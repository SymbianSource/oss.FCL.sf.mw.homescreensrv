.cproject































.project

	idlefw
	
	
	
	
		
			com.nokia.carbide.cdt.builder.carbideCPPBuilder
			
			
		
	
	
		org.eclipse.cdt.core.cnature
		org.eclipse.cdt.core.ccnature
		com.nokia.carbide.cdt.builder.carbideCPPBuilderNature
	

hs_app_aifwuU.def
EXPORTS
	?NewLC@CAiFw@@SAPAV1@XZ @ 1 NONAME ; class CAiFw * CAiFw::NewLC(void)
	?RunL@CAiFw@@QAEXXZ @ 2 NONAME ; void CAiFw::RunL(void)

hs_app_aiidleintU.def
EXPORTS
	?NewLC@CAiIdleAppRegister@@SAPAV1@XZ @ 1 NONAME ; class CAiIdleAppRegister * CAiIdleAppRegister::NewLC(void)
	?NewL@CAiWsPluginManager@@SAPAV1@AAVCCoeEnv@@@Z @ 2 NONAME ; class CAiWsPluginManager * CAiWsPluginManager::NewL(class CCoeEnv &)
	?NewL@CAiUiIdleIntegration@@SAPAV1@AAVCEikonEnv@@ABUTAiIdleKeySoundConfig@@PAVMAiFwEventHandler@@@Z @ 3 NONAME ; class CAiUiIdleIntegration * CAiUiIdleIntegration::NewL(class CEikonEnv &, struct TAiIdleKeySoundConfig const &, class MAiFwEventHandler *)

hs_app_aisettingsU.def
EXPORTS
	?NewL@CAiPluginSettings@@SAPAV1@XZ @ 1 NONAME ; class CAiPluginSettings * CAiPluginSettings::NewL(void)
	
hs_app_aiutilsU.DEF
EXPORTS
	?CreateContentItemArrayIteratorL@AiUtility@@YAPAVMAiContentItemIterator@@PBUTAiContentItem@@H@Z @ 1 NONAME ; class MAiContentItemIterator * AiUtility::CreateContentItemArrayIteratorL(struct TAiContentItem const *, int)
	?CreatePSPropertyObserverL@AiUtility@@YAPAVMAiPSPropertyObserver@@VTCallBack@@VTUid@@H@Z @ 2 NONAME ; class MAiPSPropertyObserver * AiUtility::CreatePSPropertyObserverL(class TCallBack, class TUid, int)
	?CreatePluginSettingsL@AiUtility@@YAPAVMAiPluginSettings@@XZ @ 3 NONAME ; class MAiPluginSettings * AiUtility::CreatePluginSettingsL(void)
	?CreateStrParserL@AiUtility@@YAPAVMAiStrParser@@XZ @ 4 NONAME ; class MAiStrParser * AiUtility::CreateStrParserL(void)
	?CopyToBufferL@AiUtility@@YAPAVHBufC16@@PAV2@ABVTDesC16@@@Z @ 5 NONAME ; class HBufC16 * AiUtility::CopyToBufferL(class HBufC16 *, class TDesC16 const &)
	?CopyToBufferL@AiUtility@@YAPAVHBufC16@@PAV2@ABVTDesC8@@@Z @ 6 NONAME ; class HBufC16 * AiUtility::CopyToBufferL(class HBufC16 *, class TDesC8 const &)
	?CopyToBufferL@AiUtility@@YAPAVHBufC8@@PAV2@ABVTDesC16@@@Z @ 7 NONAME ; class HBufC8 * AiUtility::CopyToBufferL(class HBufC8 *, class TDesC16 const &)
	?CopyToBufferL@AiUtility@@YAPAVHBufC8@@PAV2@ABVTDesC8@@@Z @ 8 NONAME ; class HBufC8 * AiUtility::CopyToBufferL(class HBufC8 *, class TDesC8 const &)
	?EnsureBufMaxLengthL@AiUtility@@YA?AVTPtr16@@AAPAVHBufC16@@H@Z @ 9 NONAME ; class TPtr16 AiUtility::EnsureBufMaxLengthL(class HBufC16 * &, int)
	?ParseInt@AiUtility@@YAHAAJABVTDesC8@@@Z @ 10 NONAME ; int AiUtility::ParseInt(long &, class TDesC8 const &)
	?CreatePluginToolL@AiUtility@@YAPAVMAiPluginTool@@XZ @ 11 NONAME ; class MAiPluginTool * AiUtility::CreatePluginToolL(void)
	?ClearPriority@CContentPriorityMap@AiUtility@@QAEXABVTDesC8@@@Z @ 12 NONAME ; void AiUtility::CContentPriorityMap::ClearPriority(class TDesC8 const &)
	?CurrentPriority@CContentPriorityMap@AiUtility@@QBEHABVTDesC8@@@Z @ 13 NONAME ; int AiUtility::CContentPriorityMap::CurrentPriority(class TDesC8 const &) const
	?NewL@CContentPriorityMap@AiUtility@@SAPAV12@XZ @ 14 NONAME ; class AiUtility::CContentPriorityMap * AiUtility::CContentPriorityMap::NewL(void)
	?OverrideContent@CContentPriorityMap@AiUtility@@QBEHABVTDesC8@@H@Z @ 15 NONAME ; int AiUtility::CContentPriorityMap::OverrideContent(class TDesC8 const &, int) const
	?Reset@CContentPriorityMap@AiUtility@@QAEXXZ @ 16 NONAME ; void AiUtility::CContentPriorityMap::Reset(void)
	?SetCurrentPriority@CContentPriorityMap@AiUtility@@QAEHABVTDesC8@@H@Z @ 17 NONAME ; int AiUtility::CContentPriorityMap::SetCurrentPriority(class TDesC8 const &, int)
	?ParseInt@AiUtility@@YAHAAJABVTDesC16@@@Z @ 18 NONAME ; int AiUtility::ParseInt(long &, class TDesC16 const &)

keys_activeidle2.xls
????±?>??	C????b?dÂf?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????B	

 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`ac????defghijklmnopqrstuvwxyz{|}~ÄRoot Entry???????? ?F$(?”\}???±ë”?DÄWorkbook
?????????r_VBA_PROJECT_CUR"
?+Të”???±ë”?VBA????????∞øXë”??¢ë”?	| ?…??∞??\pPulkkinen Pekka                                                                                              B∞a?=”Ω?ThisWorkbook?ùº=ZZZ_-* #,##0.00\ "¨ "_-;\-* #,##0.00\ "¨ "_-;_-* "-"??\ "¨ "_-;_-@_-{´;_-* #,##0.00\ _¨ _-;\-* #,##0.00\ _¨ _-;_-* "-"??\ _¨ _-;_-@_-¨#,##0\ "mk";\-#,##0\ "mk"#≠#,##0\ "mk";[Red]\-#,##0\ "mk"$Æ#,##0.00\ "mk";\-#,##0.00\ "mk")ù$#,##0.00\ "mk";[Red]\-#,##0.00\ "mk">∞9_-* #,##0\ "mk"_-;\-* #,##0\ "mk"_-;_-* "-"\ "mk"_-;_-@_->±9_-* #,##0\ _m_k_-;\-* #,##0\ _m_k_-;_-* "-"\ _m_k_-;_-@_-F≤A_-* #,##0.00\ "mk"_-;\-* #,##0.00\ "mk"_-;_-* "-"??\ "mk"_-;_-@_-F≥A_-* #,##0.00\ _m_k_-;\-* #,##0.00\ _m_k_-;_-* "-"??\ _m_k_-;_-@_- ¥#,##0\ "EUR";\-#,##0\ "EUR"%µ #,##0\ "EUR";[Red]\-#,##0\ "EUR"&∂!#,##0.00\ "EUR";\-#,##0.00\ "EUR"+∑&#,##0.00\ "EUR";[Red]\-#,##0.00\ "EUR"Aè<_-* #,##0\ "EUR"_-;\-* #,##0\ "EUR"_-;_-* "-"\ "EUR"_-;_-@_-Dπ?_-* #,##0\ _E_U_R_-;\-* #,##0\ _E_U_R_-;_-* "-"\ _E_U_R_-;_-@_-I?D_-* #,##0.00\ "EUR"_-;\-* #,##0.00\ "EUR"_-;_-* "-"??\ "EUR"_-;_-@_-LªG_-* #,##0.00\ _E_U_R_-;\-* #,##0.00\ _E_U_R_-;_-* "-"??\ _E_U_R_-;_-@_-º"$"#,##0_);\("$"#,##0\)!Ω"$"#,##0_);[Red]\("$"#,##0\)"æ"$"#,##0.00_);\("$"#,##0.00\)'?""$"#,##0.00_);[Red]\("$"#,##0.00\)7?2_("$"* #,##0_);_("$"* \(#,##0\);_("$"* "-"_);_(@_)??:_("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)?dd\-mm\-yyyy?0.0ƒ"Yes";"Yes";"No"≈"True";"True";"False"Ø"On";"On";"Off"?0.00_ ;[Red]\-0.00\ ?ı? ? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ? ? ?´ı? ∏? ?©ı? ∏? ??ı? ∏? ?çı? ∏? ????? ????? ?	ı? ∏? ?	 ?	 ? ? ?!‹ ?	®	 ?® ?‹ ? ?	 ?	®	 ? ?	 ?!‹	 ?	 ?	 ?	®	 ? ?	 ?	®	 ??!‹	 ?)‹	 ?(∏  ?(? ?1 ? ?(? ?(∏ ? ?? ?		!‹	 ?)∏  ?)? ?(Z∏  ? ?	 ?P!?	 ? H+ ?(X+ ?(\+ ?1 \+ ? ? ?(? ?(? ?(\? ?1 ? ?)? ?)\+ ìÄ?ìÄ?ìÄ?ìÄ?ìÄ	?ìÄ?ìÄ?ìÄ?í?8????????????ÄÄÄÄÄÄÄÄÄ???ÄÄÄôô?ô3f??????ff?ÄÄf????Ä??????ÄÄÄÄÄ???????????ôô???ô??ô???ô3f?3??ô????ô?fffôñññ3f3ôf333ô3ô3f33ô333\???`Ö,MainÖ6
Key values?Æ????!
=
#	Key_names;?? ;??"æ¸x?CommentsDateVersionTypeAuthorPurposeOwnerEntityLocationVersion HistoryYesNoTemplate version]DO NOT DELETE THIS SHEET. THE FUTURE CONVERSION SCRIPTS NEED THE TEMPLATE VERSION INFORMATIONRemovedCenRep keys RFSIntMustKey IntUid NameKey TypeBackupCust ConfigRelated FeaturesRealStrBinReadDeviceDataWriteDeviceDataNetworkServices
LocalServicesReadUserData
WriteUserDataProtServDRMSwEvent	PowerMgmtAllFiles	DiskAdminNetworkControlMultiMediaDDCommDDTCB	TrustedUIRWPlatform ReleaseKey NameRWelafapacthaijapangsmlow_costRDo not delete AN1 -> BC1, since they are used in the multichoise column validation
Read  Only	Uid ValueShared Data NameVariant Name	Def Value
Range FromRange ToSurroundingsDDSID Read
AlwaysPass	SID WriteUserEnvironment2.0AcceptedJari SukanenInitial version`Migration to version 2 of the template, modified also the default value for local variation key.Jari.Sukanen@digia.comPekka Tukiainen7Support for the local variation of the SIP fields addedDigia/PhonebookJarkko Leminen7Support for the local variation of the MDO fields addedUi controller UID'sEComment: UID namespace for internal Active Idle 2 variation settings."ActiveIdle2 Internal Variation API7Comment: key for storing the status pane layout setting
0x00000100KAiStatusPaneLayoutStatus pane layout setting
0x10275102S60 3.1KCRUidActiveIdleLV
0x00000101
0x00000200KAiMainUIControllerKeyComment: Main UI Controller UIDKAIFirstKeyLockKey
0x00000300Main UI controller UID#Comment: Keylock configuration keys)Comment: Keyspace for UI controller UID's,Scan code of 1st key in the keylock sequenceS60 3.2KAISecondKeyLockKey
0x00000301,Scan code of 2nd key in the keylock sequenceKAIKeyLockTimeout
0x00000302Keylock timeout in millisecondsKAISecondKeyLockKey2
0x00000303jScan code for optional 2nd key in the keylock sequence. Value of -1 means there is no optional second key.%Scan code for voice dial launch key. KAIVoiceDialLaunchKey
0x00000304KAIVoiceDialKeyTimeoutZVoice dial key timeout in milliseconds. This should be the same as long key press timeout.
0x00000305&Comment: Voice dial configuration keys.Comment: Operator indicator configuration keys
KAISPNAndEONS.Display PLMN and SPN indicators simultaneously
0x00000400KAIVHZInMainpane
0x00000500#Display VHZ in Mainpane or Navipane2Comment: HomeZome indicator location configuration
0x00001000
0x000001ff)Comment: NewsTicker availability in themeKAINTInTheme
0x00000800NewsTicker implemented in theme%Comment: Touch toolbar configuration KAITouchToolbarVisibleS60 5.0KAIPluginSettingsPluginNameSettings/ShortcutKAIPluginSettingsId
0x00001001
0x10001000KAIPluginSettingsValue
0x00001002
0x00001003
0x00001004
0x10001001
0x00001005 Comment: Touch toolbar shortcutslocalapp:0x101F4CD2#localapp:0x100058B3?view=0x10282D81
0x00001006
0x00001007
0x20001000
0x00001008Alocalapp:0x101F4CD2?iconmifpath=apps\\activeidle2.mif;1&toolbar=1
0x10001002localapp:0x100058F8
0x00001009
0x0000100A
0x0000100B
0x0000100C
0x0000100D
0x20001001
0x0000100EQlocalapp:0x100058B3?view=0x10282D81&iconmifpath=apps\\activeidle2.mif;3&toolbar=1
0x0000100F
0x00001010
0x20001002
0x00001011Alocalapp:0x100058F8?iconmifpath=apps\\activeidle2.mif;5&toolbar=1KIdentifier to shortcut plug-in that this is an icon override. DO NOT MODIFYGIndication that this setting belongs to shortcut plug-in. DO NOT MODIFY>ID of the first touch toolbar shortcut shortcut. DO NOT MODIFY6ID of the second touch toolbar shortcut. DO NOT MODIFY5ID of the third touch toolbar shortcut. DO NOT MODIFY
0x00000700∞Application UID and parameters of the first touch toolbar shortcut. Default value localapp:0x101F4CD2 is AppShell. If this value is modified modify also icon definition for it!?Application UID and parameters of the second touch toolbar shortcut. Default value localapp:0x100058B3?view=0x10282D81 is Dialer. If this value is modified modify also icon definition for it!∞Application UID and parameters of the third touch toolbar shortcut. Default value localapp:0x100058F8 is Profiles. If this value is modified modify also icon definition for it!¶Application UID and icon definition for it. Default value localapp:0x101F4CD2?iconmifpath=apps\\activeidle2.mif;1&toolbar=1 overrides touch toolbar icon for AppShell.¥Application UID and icon definition for it. Default value localapp:0x100058B3?view=0x10282D81&iconmifpath=apps\\activeidle2.mif;3&toolbar=1 overrides touch toolbar icon for Dialer.¶Application UID and icon definition for it. Default value localapp:0x100058F8?iconmifpath=apps\\activeidle2.mif;5&toolbar=1 overrides touch toolbar icon for Profiles.YComment: Additional URL shortcuts to be added to shortcut settings. One key per shortcut.0x000002000
0x00002FFFKAISettingsExtraURLShortcut
0x00002000eAdditional shortcut to be placed in shortcut settings. Format same as in normal shortcut definitions.
0x00002001
0x00002002%Display Touch toolbar on touch device2Comment: External Standby screen management switch
0x00000600KAIExternalStatusScreen-Display AI1 themes or external standby screen Comment: Wallpaper change typeKAIWallpaperChangeType
0x00000850<Selecting whether page specific wallpaper is enabled or not./Comment: Wallpaper path common for all HS pagesKAIWallpaperPath
0x000008515Storing wallpaper path that is used for all HS pages.???‰S??QMº?o>≠?aY?ê?	0?&ï:©e?	3¢
?]k ?!z≥!"
ô"e%?∂(%…)8?*7ccﬁ
	| ?…?b0?4
d¸©??MbP?_*+ÇÄ%?Å??ÑM¢\\trprn003\trh5c3c1‹ƒS?Ä	?
o6,,LetterPRIV?0''''ƒ\K\K
?¥???"	6,,????U}}@}@
 }`} } ]}	êColumn B,??J?!J?"?????	§?$
?Ä!??
??æ?
&
?
?
-Eæ?
æ?
ææ
?
?
 Mæ
##?
?
2J?
#%@î;¸
%??Bæ
	?
		æ	
?

?

?

?

?

Ω1?∞?@ ???
F?
G?
HΩ1`ª?@ @?
F?
K?
LΩ
1 ª?@ @?

F?

G?

IΩ1?Ω?@ @?
N?
O◊"ı6**4&?*P@@@>∂@?7è¢?…?y????Ç?K©Jari.Sukanen@digia.com?…?y????Ç?K©<mailto:Jari.Sukanen@digia.com?	Sheet1
	| ?…??T?Ufp4????ùf???v???Ü?
ñ,¶;.K∂Z>jØyNâ÷?^çø∑n?ˆ÷~øˆﬁ˛$&4ÆC6SæbFr?ÅVë? f∞??v???Ü??ñ
¶,.<∂K>[ØjNz÷â^ôøçnèˆ?~◊?ﬁˆ˛&%Æ46DæSFc?rVÇ?ëf??∞v???Üﬂ?ñ?¶.-∂<>LØ[Nk÷z^–øôn©ˆè~?®ﬁ?˜˛&Æ%65æDFT?c˛m
d¸©??MbP?_*+ÇÄ%íÅA?ÑMÇ\\hkisrv02\HKIPRN016‹§C?Ä	4dXXA4????DINU"(d@Xr-(SMTJHP LaserJet 4250 PCL 5eInputBinFORMSOURCERESDLLUniresDLLResolution600dpiOrientationPORTRAITHPOrientRotate180FalseDuplexNONEPaperSizeA4MediaTypeAUTOCollateOFFOutputBinAutoStaplingNoneEconomodeFalseTextAsBlackFalseHPEnableRAWSpoolingTrueTTAsBitmapsSettingTTModeOutlineGraphicsModeRASTERMODERETChoiceTrueHPDuplicateJobNameOverrideSWFWAlternateLetterHeadFalsePrintQualityGroupPQGroup_1HPColorModeMONOCHROME_MODEHPContentOrientationHPContentOrientation_OptionHPPDLTypePDL_PCL5HPMaxResolutionPDM_600DPIHPPJLEncodingUTF8HPJobAccountingHPJOBACCT_JOBACNTHPBornOnDateHPBODHPJobByJobOverrideJBJOHPManualDuplexDialogItemsInstructionID_01_FACEDOWN-NOROTATEHPManualFeedOrientationFACEDOWNHPOutputBinOrientationFACEDOWNHPManualDuplexDialogModelModelessHPManualDuplexPageOrderEvenPagesFirstHPMapManualFeedToTray1FalseHPCustomDUplexableRange5.83x8.27_8.5x14HPPrintOnBothSidesManuallyFalseHPStraightPaperPathFalseHPCoversFront_CoverJRConstraintsJRCHDPartialJRHDInstalledJRHDOffJRHDNotInstalledJRHDOffPSAlignmentFileHPZLS042PSServicesOptionPrnStat_SID_242_BID_497_HID_15521HPConsumerCustomPaperHPCustomHPXMLFileUsedhpc42505.xml@IUPH
dA4 [none] [none]Arial4P??????	dÄ?ANMATTIL<Automatic>0600dpid Default Print Settingsí?j.k?k?m?m?????EXCEL.EXE?"	5XX????U}@ }`}}?} }@} (} 	(}		@	*}

Ä*}?1/}?}

Ä(}(} (}Ä*}?}`,*})@}**Ä}++},,(}--Ä(}.. (}//@(}08 )}99Ä	)}::Ä};;?}<<
}=?Ä(}@@?TE@?@@?3@?7@?7@?3@??7@?7@?7@?7	@?3
@í?7@í?7@?3
@?7@?7@?3@:Ä7@í?7@:Ä7@Ü?7@WÄ7@Ü?7@Ä7@Ü?7@h?3@ì?7@í?7@??7@í?7@í?3@g?7@Ü?7?
'?
':?
'>?
'??
'0?
'?
';?
'?
+?
	'/?

'<?
.=?
'9?

+?
'?
'?
'?
'?
'?
0B?
0?
0?
0 ?
0!?
0?
0?
0?
0"?
0#?
0$?
0%?
0&?
 0'?
!0(?
"0)?
#0*?
$0+?
%0,?
&0D?
'0@?
(0A?
)0C?
*,
?
+,?
,(?
-(?
.(?
/(?
0)?
1)-?
2).?
3)1?
4)2?
5)3?
6)4?
7)5?
8)6?
9)7?
:,8?
3Qæ4455445
æ
44æ",444466666666669æ=444??
7Y?
7W?
7Ræ89988:
æ
88æ",8888;;;;;;;;;;9æ=888?8?
	7Xæ

9<
8?
8
?
89?
7W?
7-æ",8888;;;;;;;;;;9æ=888??
3bæ
44æ
5445444æ",444466666666669æ=444??
7Z?
7~?
8Pæ899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
88?
	7X?
8
?
79?
7-?
7.æ",8888;;;;;;;;;;9æ=888??
7Zæ
88?
7?

79æ",8888;;;;;;;;;;9æ=888?æ
88?
	7X
9~
<?C?@
8?
8
?
7?
9
9?
7-?
7.æ",8888;;;;;;;;;;9æ=888??
	3Sæ
	44æ	
5445444æ"	,444466666666669æ	=444??

7U?

7[?

8V
8æ


9<?

7?


8æ
889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
88?
	7X
9~
<?
8
?
8?
9
9?
7-?
7.æ",8888;;;;;;;;;;9æ=888??
3]æ
44æ
5445444æ",444466666666669æ=444??

7\?

7T?

8`
8?

7?


7
9æ"
,8888;;;;;;;;;;9æ
=888?æ
88?
	7X
9~
<?C?@
8?
8
?
7?
9
9?
7-?
7.æ",8888;;;;;;;;;;9æ=888??
3aæ
44æ
5445444æ",444466666666669æ=444??
7^?
7_?
8cæ899<?
7
?

7æ8899æ",8888;;;;;;;;;;9æ=888?æ
88?
	9d
9~
<Äd@
8?
7?
7?
9
9?
7-æ",8888;;;;;;;;;;9æ=888??
7e?
7f?
8gæ899<?
7
?

7æ8899æ",8888;;;;;;;;;;9æ=888?æ
88?
	9d
9~
< `@
8?
7?
7?
9
9?
7-æ",8888;;;;;;;;;;9æ=888??
7k?
7i?
8mæ899<?
7
?

7æ8899æ",8888;;;;;;;;;;9æ=888?æ
88?
	9d
9~
<??
8?
7?
7?
9
9?
7-æ",8888;;;;;;;;;;9æ=888??
7h?
7l?
8jæ899<?
7
?

7æ8899æ",8888;;;;;;;;;;9æ=888?æ
88?
	9d
9~
<pó@
8?
7?
7?
9
9?
7-æ",8888;;;;;;;;;;9æ=888??
3tæ
44æ
5445444æ",444466666666669æ=444??
7o?
7p?
8næ899<?
7
?

7æ8899æ",8888;;;;;;;;;;9æ=888?æ
88?
	9d
9~
< d@
8?
7?
7?
9
9?
7-æ",8888;;;;;;;;;;9æ=888??
7q?
7s?
8ræ899<?
7
?

7æ8899æ",8888;;;;;;;;;;9æ=888?æ
88?
	9d
9~
<?Ç@
8?
7?
7?
9
9?
7-æ",8888;;;;;;;;;;9æ=888??
3uæ4455=æ
44455æ",444466666666669æ=444??
7v?
7x?
8wæ899<?
7
?

8æ8899æ",8888;;;;;;;;;;9æ=888?æ
88?
	9d
9~
<
8?
8?
8?
9
9?
7-æ",8888;;;;;;;;;;9æ=888?◊DÇl:jÑçjﬁîxƒjÆ?jêƒjç∂ç∂ç∂ç∂jç∂ç∂tç Eí?3!Eg?7"Eg?7#Eg?7$Eg?7%Eí?7&Eí?7'Eí?7(Eí?7)Eí?3*Eí?7+EÜ?7,E≥?7-Eg?7.Eí?7/E≥?70Eg?71Eí?72Eí?73EÖ?74Eí?75Eﬂ?76Eí?77Ev?78Eí?79Eí?7:E:?7;Eí?7<E??7=Eí?7>EI?7?Eí?7?
 3|æ 4455=æ 
4445 5æ" ,444466666666669æ =444??
!7y?
!7z?
!8{æ!899<?
!7
?
!
8æ!889!9æ"!,8888;;;;;;;;;;9æ!=888?æ
"88?
"	9d"
9~
"<??"
8?
"8?
"8?
"9
"9?
"7-æ"",8888;;;;;;;;;;9æ"=888??
#3ΩæÑ#3333334455=3444535333333333333333333333333344446666666666333444??
$7??
$7æ?
$8?æ$899<?
$7?
$
8æ$889$9æ"$,8888;;;;;;;;;;9æ$=888?æ
%88?
%	9Ö%
9~
%<??%
8?
%8
?
%8?
%9
%9?
%7-?
%7.æ"%,8888;;;;;;;;;;9æ%=888??
&3?æ&3333334455
?
&=?æx&344453533333333333333333333333334444666666666633344433333D?
'7Ñ?
'7≠?
'8ºæ'899<?
'7
?
'
8æ'889'9æ"',8888;;;;;;;;;;9æ'=888?æ
(88?
(	9Ö(
9~
(<??(
8?
(8?
(8?
(9
(9?
(7-æ"(,8888;;;;;;;;;;9æ(=888??
)3æ)4455=æ)
4445)5æ"),444466666666669æ)=444??
*7Ä?
*7Å?
*8Çæ*899<?
*7?
*
8æ*889*9æ"*,8888;;;;;;;;;;9æ*=888?æ
+88?
+	9d+
9~
+<+
8?
+8
?
+8?
+9
+9?
+7-?
+7.æ"+,8888;;;;;;;;;;9æ+=888??
,3?æÑ,3333334455=3444535333333333333333333333333344446666666666333444??
-7??
-7ƒ?
-8≈æ-899<?
-7?
-
8æ-889-9æ"-,8888;;;;;;;;;;9æ-=888?æ
.88?
.	9Ö.
9~
.<.
8?
.8?
.8?
.9
.9?
.7-?
.7.æ".,8888;;;;;;;;;;9æ.=888??
/3ØæÑ/3333334455=3444535333333333333333333333333344446666666666333444??
07??
07??
08…æ0899<?
07?
0
8æ088909æ"0,8888;;;;;;;;;;9æ0=888?æ
188?
1	9Ö1
9~
1<1
8?
18?
18?
19
19?
17-?
17.æ"1,8888;;;;;;;;;;9æ1=888??
23ëæﬁ23333334455=344453533333333333333333333333334444666666666633344433333D?
37Ü?
37}?
38©æ3899<?
37
?
3
8æ388939æ"3,8888;;;;;;;;;;9æ3=888?æ
488?
4	9Ö4
9?
4<á4
8?
48?
48
?
49
49?
47-æ"4,8888;;;;;;;;;;9æ4=888??
57??
57â?
58?æ5899<?
57
?
5
8æ588959æ"5,8888;;;;;;;;;;9æ5=888?æ
688?
6	9Ö6
9?
6<–6
8?
68?
68
?
69
69?
67-æ"6,8888;;;;;;;;;;9æ6=888??
77ã?
77??
78Ææ7899<?
77
?
7
8æ788979æ"7,8888;;;;;;;;;;9æ7=888?æ
888?
8	9Ö8
9?
8<í8
8?
88?
88
?
89
89?
87-æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888??
:7Ü?
:7??
:8©æ:899<?
:7
?
:
8æ:889:9æ":,8888;;;;;;;;;;9æ:=888?æ
;88?
;	9Ö;
9?
;á;
8?
;8?
;8
?
;9
;9?
;7-æ";,8888;;;;;;;;;;9æ;=888??
<7??
<7ﬁ?
<8´æ<899<?
<7
?
<
8æ<889<9æ"<,8888;;;;;;;;;;9æ<=888?æ
=88?
=	9Ö=
9?
=<?=
8?
=8?
=8
?
=9
=9?
=7-æ"=,8888;;;;;;;;;;9æ==888??
>7ã?
>7ê?
>8ùæ>899<?
>7
?
>
8æ>889>9æ">,8888;;;;;;;;;;9æ>=888?æ
?88?
?	9Ö?
9?
?<ì?
8?
?8?
?8
?
?9
?9?
?7-æ"?,8888;;;;;;;;;;9æ?=888?◊DÜltç∂ñçƒ∂ç∂tçƒñçƒñçƒ ç∂ç∂ç∂fç∂ç∂ç@@I?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@+?7H@í?7I@
?7J@í?7K@¢?7L@I?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7T@í?7U@í?7V@í?7W@í?7X@í?7Y@í?7Z@í?7[@í?3\@í?7]@g?7^@í?7_@g?7?
@7Ü?
@7î?
@8©æ@899<?
@7
?
@
8æ@889@9æ"@,8888;;;;;;;;;;9æ@=888?æ
A88?
A	9ÖA
9?
A<áA
8?
A8?
A8
?
A9
A9?
A7-æ"A,8888;;;;;;;;;;9æA=888??
B7??
B7ï?
B8¨æB899<?
B7
?
B
8æB889B9æ"B,8888;;;;;;;;;;9æB=888?æ
C88?
C	9ÖC
9?
C<ôC
8?
C8?
C8
?
C9
C9?
C7-æ"C,8888;;;;;;;;;;9æC=888??
D7ã?
D7ó?
D8∞æD899<?
D7
?
D
8æD889D9æ"D,8888;;;;;;;;;;9æD=888?æ
E88?
E	9ÖE
9?
E<E
8?
E8?
E8
?
E9
E9?
E7-æ"E,8888;;;;;;;;;;9æE=888?æF88999æF
8889F9æ"F,8888;;;;;;;;;;9æF=888??
G7Ü?
G7õ?
G8©æG899<?
G7
?
G
8æG889G9æ"G,8888;;;;;;;;;;9æG=888?æ
H88?
H	9ÖH
9?
H<áH
8?
H8?
H8
?
H9
H9?
H7-æ"H,8888;;;;;;;;;;9æH=888??
I7??
I7??
I8çæI899<?
I7
?
I
8æI889I9æ"I,8888;;;;;;;;;;9æI=888?æ
J88?
J	9ÖJ
9?
J<ñJ
8?
J8?
J8
?
J9
J9?
J7-æ"J,8888;;;;;;;;;;9æJ=888??
K7ã?
K7??
K8±æK899<?
K7
?
K
8æK889K9æ"K,8888;;;;;;;;;;9æK=888?æ
L88?
L	9ÖL
9?
L<?L
8?
L8?
L8
?
L9
L9?
L7-æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888??
N7Ü?
N7˛?
N8©æN899<?
N7
?
N
8æN889N9æ"N,8888;;;;;;;;;;9æN=888?æ
O88?
O	9ÖO
9?
O<áO
8?
O8?
O8
?
O9
O9?
O7-æ"O,8888;;;;;;;;;;9æO=888??
P7??
P7??
P8çæP899<?
P7
?
P
8æP889P9æ"P,8888;;;;;;;;;;9æP=888?æ
Q88?
Q	9ÖQ
9?
Q< Q
8?
Q8?
Q8
?
Q9
Q9?
Q7-æ"Q,8888;;;;;;;;;;9æQ=888??
R7ã?
R7??
R8≤æR899<?
R7
?
R
8æR889R9æ"R,8888;;;;;;;;;;9æR=888?æ
S88?
S	9ÖS
9?
S<¢S
8?
S8?
S8
?
S9
S9?
S7-æ"S,8888;;;;;;;;;;9æS=888?æT8899<æT
8889T9æ"T,8888;;;;;;;;;;9æT=888??
U7Ü?
U7£?
U8©æU899<?
U7
?
U
8æU889U9æ"U,8888;;;;;;;;;;9æU=888?æ
V88?
V	9ÖV
9?
V<áV
8?
V8?
V8
?
V9
V9?
V7-æ"V,8888;;;;;;;;;;9æV=888??
W7??
W7§?
W8çæW899<?
W7
?
W
8æW889W9æ"W,8888;;;;;;;;;;9æW=888?æ
X88?
X	9ÖX
9?
X<?X
8?
X8?
X8
?
X9
X9?
X7-æ"X,8888;;;;;;;;;;9æX=888??
Y7ã?
Y7¶?
Y8≥æY899<?
Y7
?
Y
8æY889Y9æ"Y,8888;;;;;;;;;;9æY=888?æ
Z88?
Z	9ÖZ
9?
Z<ßZ
8?
Z8?
Z8
?
Z9
Z9?
Z7-æ"Z,8888;;;;;;;;;;9æZ=888??
[3¥æ[4455=æ[
4445[5æ"[,444466666666669æ[=444??
\7µ?
\7∂æ\8899<æ\
8889\9æ"\,8888;;;;;;;;;;9æ\=888??
]7∑?
]7è?
]8πæ]899<?
]7
?
]
8æ]889]9æ"],8888;;;;;;;;;;9æ]=888?æ
^88?
^	9dæ
^
9<^
8?
^8?
^8
?
^9
^9?
^7-æ"^,8888;;;;;;;;;;9æ^=888??
_7∑?
_7??
_8πæ_899<?
_7
?
_
8æ_889_9æ"_,8888;;;;;;;;;;9æ_=888?◊Dlç∂ç∂ç∂fç∂ç∂ç∂fç∂ç∂ç∂fç∂ç∂ç∂tÇç¨`@í?7a@g?7b@í?7c@í?7d@í?7e@í?7f@í?7g@í?7h@í?7i@í?7j@í?7k@í?7l@í?7m@í?7n@í?7o@í?7p@í?7q@í?7r@í?7s@í?7t@í?7u@í?7v@í?7w@í?7x@í?7y@í?7z@í?7{@í?7|@í?7}@í?7~@í?7@í?7æ
`88?
`	9dæ
`
9<`
8?
`8?
`8
?
`9
`9?
`7-æ"`,8888;;;;;;;;;;9æ`=888??
a7∑?
a7ª?
a8πæa899<?
a7
?
a
8æa889a9æ"a,8888;;;;;;;;;;9æa=888?æ
b88?
b	9dæ
b
9<b
8?
b8?
b8
?
b9
b9?
b7-æ"b,8888;;;;;;;;;;9æb=888?æc8899<æc
8889c9æ"c,8888;;;;;;;;;;9æc=888?æd8899<æd
8889d9æ"d,8888;;;;;;;;;;9æd=888?æe8899<æe
8889e9æ"e,8888;;;;;;;;;;9æe=888?æf8899<æf
8889f9æ"f,8888;;;;;;;;;;9æf=888?æg8899<æg
8889g9æ"g,8888;;;;;;;;;;9æg=888?æh8899<æh
8889h9æ"h,8888;;;;;;;;;;9æh=888?æi8899<æi
8889i9æ"i,8888;;;;;;;;;;9æi=888?æj8899<æj
8889j9æ"j,8888;;;;;;;;;;9æj=888?æk8899<æk
8889k9æ"k,8888;;;;;;;;;;9æk=888?æl8899<æl
8889l9æ"l,8888;;;;;;;;;;9æl=888?æm8899<æm
8889m9æ"m,8888;;;;;;;;;;9æm=888?æn8899<æn
8889n9æ"n,8888;;;;;;;;;;9æn=888?æo8899<æo
8889o9æ"o,8888;;;;;;;;;;9æo=888?æp8899<æp
8889p9æ"p,8888;;;;;;;;;;9æp=888?æq8899<æq
8889q9æ"q,8888;;;;;;;;;;9æq=888?ær8899<ær
8889r9æ"r,8888;;;;;;;;;;9ær=888?æs8899<æs
8889s9æ"s,8888;;;;;;;;;;9æs=888?æt8899<æt
8889t9æ"t,8888;;;;;;;;;;9æt=888?æu8899<æu
8889u9æ"u,8888;;;;;;;;;;9æu=888?æv8899<æv
8889v9æ"v,8888;;;;;;;;;;9æv=888?æw8899<æw
8889w9æ"w,8888;;;;;;;;;;9æw=888?æx8899<æx
8889x9æ"x,8888;;;;;;;;;;9æx=888?æy8899<æy
8889y9æ"y,8888;;;;;;;;;;9æy=888?æz8899<æz
8889z9æ"z,8888;;;;;;;;;;9æz=888?æ{8899<æ{
8889{9æ"{,8888;;;;;;;;;;9æ{=888?æ|8899<æ|
8889|9æ"|,8888;;;;;;;;;;9æ|=888?æ}8899<æ}
8889}9æ"},8888;;;;;;;;;;9æ}=888?æ~8899<æ~
8889~9æ"~,8888;;;;;;;;;;9æ~=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊Dl¨ç¨ffffffffffffffffffffffffffffÄ@í?7Å@í?7Ç@í?7?@í?7Ñ@í?7Ö@í?7Ü@í?7á@í?7?@í?7â@í?7–@í?7ã@í?7?@í?7?@í?7ﬁ@í?7?@í?7ê@í?7ë@í?7í@í?7ì@í?7î@í?7ï@í?7ñ@í?7ó@í?7?@í?7ô@í?7@í?7õ@í?7?@í?7?@í?7˛@í?7?@í?7æÄ8899<æÄ
8889Ä9æ"Ä,8888;;;;;;;;;;9æÄ=888?æÅ8899<æÅ
8889Å9æ"Å,8888;;;;;;;;;;9æÅ=888?æÇ8899<æÇ
8889Ç9æ"Ç,8888;;;;;;;;;;9æÇ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÑ8899<æÑ
8889Ñ9æ"Ñ,8888;;;;;;;;;;9æÑ=888?æÖ8899<æÖ
8889Ö9æ"Ö,8888;;;;;;;;;;9æÖ=888?æÜ8899<æÜ
8889Ü9æ"Ü,8888;;;;;;;;;;9æÜ=888?æá8899<æá
8889á9æ"á,8888;;;;;;;;;;9æá=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æâ8899<æâ
8889â9æ"â,8888;;;;;;;;;;9æâ=888?æ–8899<æ–
8889–9æ"–,8888;;;;;;;;;;9æ–=888?æã8899<æã
8889ã9æ"ã,8888;;;;;;;;;;9æã=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬁ8899<æﬁ
8889ﬁ9æ"ﬁ,8888;;;;;;;;;;9æﬁ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æê8899<æê
8889ê9æ"ê,8888;;;;;;;;;;9æê=888?æë8899<æë
8889ë9æ"ë,8888;;;;;;;;;;9æë=888?æí8899<æí
8889í9æ"í,8888;;;;;;;;;;9æí=888?æì8899<æì
8889ì9æ"ì,8888;;;;;;;;;;9æì=888?æî8899<æî
8889î9æ"î,8888;;;;;;;;;;9æî=888?æï8899<æï
8889ï9æ"ï,8888;;;;;;;;;;9æï=888?æñ8899<æñ
8889ñ9æ"ñ,8888;;;;;;;;;;9æñ=888?æó8899<æó
8889ó9æ"ó,8888;;;;;;;;;;9æó=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æô8899<æô
8889ô9æ"ô,8888;;;;;;;;;;9æô=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æõ8899<æõ
8889õ9æ"õ,8888;;;;;;;;;;9æõ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ˛8899<æ˛
8889˛9æ"˛,8888;;;;;;;;;;9æ˛=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff @í?7?@í?7¢@í?7£@í?7ÅÇ?ÑÖÜá?â–ã??ﬁ?êëíìîïñó?ôõ??˛? ?¢£§?¶ßç©?´¨≠Æù∞±≤≥¥µ∂∑èπ?ªºΩæ?????ƒ≈Ø??…?????????”?’÷◊®???‹??ﬂ???‰????Âø??È?????????Û?ıˆ˜∏???¸???§@í?7?@í?7¶@í?7ß@í?7ç@í?7©@í?7?@í?7´@í?7¨@í?7≠@í?7Æ@í?7ù@í?7∞@í?7±@í?7≤@í?7≥@í?7¥@í?7µ@í?7∂@í?7∑@í?7è@í?7π@í?7?@í?7ª@í?7º@í?7Ω@í?7æ@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¢8899<æ¢
8889¢9æ"¢,8888;;;;;;;;;;9æ¢=888?æ£8899<æ£
8889£9æ"£,8888;;;;;;;;;;9æ£=888?æ§8899<æ§
8889§9æ"§,8888;;;;;;;;;;9æ§=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¶8899<æ¶
8889¶9æ"¶,8888;;;;;;;;;;9æ¶=888?æß8899<æß
8889ß9æ"ß,8888;;;;;;;;;;9æß=888?æç8899<æç
8889ç9æ"ç,8888;;;;;;;;;;9æç=888?æ©8899<æ©
8889©9æ"©,8888;;;;;;;;;;9æ©=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ´8899<æ´
8889´9æ"´,8888;;;;;;;;;;9æ´=888?æ¨8899<æ¨
8889¨9æ"¨,8888;;;;;;;;;;9æ¨=888?æ≠8899<æ≠
8889≠9æ"≠,8888;;;;;;;;;;9æ≠=888?æÆ8899<æÆ
8889Æ9æ"Æ,8888;;;;;;;;;;9æÆ=888?æù8899<æù
8889ù9æ"ù,8888;;;;;;;;;;9æù=888?æ∞8899<æ∞
8889∞9æ"∞,8888;;;;;;;;;;9æ∞=888?æ±8899<æ±
8889±9æ"±,8888;;;;;;;;;;9æ±=888?æ≤8899<æ≤
8889≤9æ"≤,8888;;;;;;;;;;9æ≤=888?æ≥8899<æ≥
8889≥9æ"≥,8888;;;;;;;;;;9æ≥=888?æ¥8899<æ¥
8889¥9æ"¥,8888;;;;;;;;;;9æ¥=888?æµ8899<æµ
8889µ9æ"µ,8888;;;;;;;;;;9æµ=888?æ∂8899<æ∂
8889∂9æ"∂,8888;;;;;;;;;;9æ∂=888?æ∑8899<æ∑
8889∑9æ"∑,8888;;;;;;;;;;9æ∑=888?æè8899<æè
8889è9æ"è,8888;;;;;;;;;;9æè=888?æπ8899<æπ
8889π9æ"π,8888;;;;;;;;;;9æπ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æª8899<æª
8889ª9æ"ª,8888;;;;;;;;;;9æª=888?æº8899<æº
8889º9æ"º,8888;;;;;;;;;;9æº=888?æΩ8899<æΩ
8889Ω9æ"Ω,8888;;;;;;;;;;9æΩ=888?ææ8899<ææ
8889æ9æ"æ,8888;;;;;;;;;;9ææ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7ƒ@í?7≈@í?7Ø@í?7?@í?7?@í?7…@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7”@í?7?@í?7’@í?7÷@í?7◊@í?7®@í?7?@í?7?@í?7?@í?7‹@í?7?@í?7?@í?7ﬂ@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æƒ8899<æƒ
8889ƒ9æ"ƒ,8888;;;;;;;;;;9æƒ=888?æ≈8899<æ≈
8889≈9æ"≈,8888;;;;;;;;;;9æ≈=888?æØ8899<æØ
8889Ø9æ"Ø,8888;;;;;;;;;;9æØ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ…8899<æ…
8889…9æ"…,8888;;;;;;;;;;9æ…=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ”8899<æ”
8889”9æ"”,8888;;;;;;;;;;9æ”=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ’8899<æ’
8889’9æ"’,8888;;;;;;;;;;9æ’=888?æ÷8899<æ÷
8889÷9æ"÷,8888;;;;;;;;;;9æ÷=888?æ◊8899<æ◊
8889◊9æ"◊,8888;;;;;;;;;;9æ◊=888?æ®8899<æ®
8889®9æ"®,8888;;;;;;;;;;9æ®=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‹8899<æ‹
8889‹9æ"‹,8888;;;;;;;;;;9æ‹=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬂ8899<æﬂ
8889ﬂ9æ"ﬂ,8888;;;;;;;;;;9æﬂ=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7‰@í?7Â@í?7ø@í?7?@í?7?@í?7È@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7Û@í?7?@í?7ı@í?7ˆ@í?7˜@í?7∏@í?7?@í?7?@í?7?@í?7¸@í?7?@í?7?@í?7?@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‰8899<æ‰
8889‰9æ"‰,8888;;;;;;;;;;9æ‰=888?æÂ8899<æÂ
8889Â9æ"Â,8888;;;;;;;;;;9æÂ=888?æø8899<æø
8889ø9æ"ø,8888;;;;;;;;;;9æø=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÈ8899<æÈ
8889È9æ"È,8888;;;;;;;;;;9æÈ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÛ8899<æÛ
8889Û9æ"Û,8888;;;;;;;;;;9æÛ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æı8899<æı
8889ı9æ"ı,8888;;;;;;;;;;9æı=888?æˆ8899<æˆ
8889ˆ9æ"ˆ,8888;;;;;;;;;;9æˆ=888?æ˜8899<æ˜
8889˜9æ"˜,8888;;;;;;;;;;9æ˜=888?æ∏8899<æ∏
8889∏9æ"∏,8888;;;;;;;;;;9æ∏=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¸8899<æ¸
8889¸9æ"¸,8888;;;;;;;;;;9æ¸=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7	@í?7
@í?7@í?7@í?7
@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffff @í?7!@í?7"@í?7#@í?7$@í?7%@í?7&@í?7'@í?7(@í?7)@í?7*@í?7+@í?7,@í?7-@í?7.@í?7/@í?70@í?71@í?72@í?73@í?74@í?75@í?76@í?77@í?78@í?79@í?7:@í?7;@í?7<@í?7=@í?7>@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ!8899<æ!
8889!9æ"!,8888;;;;;;;;;;9æ!=888?æ"8899<æ"
8889"9æ"",8888;;;;;;;;;;9æ"=888?æ#8899<æ#
8889#9æ"#,8888;;;;;;;;;;9æ#=888?æ$8899<æ$
8889$9æ"$,8888;;;;;;;;;;9æ$=888?æ%8899<æ%
8889%9æ"%,8888;;;;;;;;;;9æ%=888?æ&8899<æ&
8889&9æ"&,8888;;;;;;;;;;9æ&=888?æ'8899<æ'
8889'9æ"',8888;;;;;;;;;;9æ'=888?æ(8899<æ(
8889(9æ"(,8888;;;;;;;;;;9æ(=888?æ)8899<æ)
8889)9æ"),8888;;;;;;;;;;9æ)=888?æ*8899<æ*
8889*9æ"*,8888;;;;;;;;;;9æ*=888?æ+8899<æ+
8889+9æ"+,8888;;;;;;;;;;9æ+=888?æ,8899<æ,
8889,9æ",,8888;;;;;;;;;;9æ,=888?æ-8899<æ-
8889-9æ"-,8888;;;;;;;;;;9æ-=888?æ.8899<æ.
8889.9æ".,8888;;;;;;;;;;9æ.=888?æ/8899<æ/
8889/9æ"/,8888;;;;;;;;;;9æ/=888?æ08899<æ0
888909æ"0,8888;;;;;;;;;;9æ0=888?æ18899<æ1
888919æ"1,8888;;;;;;;;;;9æ1=888?æ28899<æ2
888929æ"2,8888;;;;;;;;;;9æ2=888?æ38899<æ3
888939æ"3,8888;;;;;;;;;;9æ3=888?æ48899<æ4
888949æ"4,8888;;;;;;;;;;9æ4=888?æ58899<æ5
888959æ"5,8888;;;;;;;;;;9æ5=888?æ68899<æ6
888969æ"6,8888;;;;;;;;;;9æ6=888?æ78899<æ7
888979æ"7,8888;;;;;;;;;;9æ7=888?æ88899<æ8
888989æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888?æ:8899<æ:
8889:9æ":,8888;;;;;;;;;;9æ:=888?æ;8899<æ;
8889;9æ";,8888;;;;;;;;;;9æ;=888?æ<8899<æ<
8889<9æ"<,8888;;;;;;;;;;9æ<=888?æ=8899<æ=
8889=9æ"=,8888;;;;;;;;;;9æ==888?æ>8899<æ>
8889>9æ">,8888;;;;;;;;;;9æ>=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@@í?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@í?7H@í?7I@í?7J@í?7K@í?7L@í?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7T@í?7U@í?7V@í?7W@í?7X@í?7Y@í?7Z@í?7[@í?7\@í?7]@í?7^@í?7_@í?7æ@8899<æ@
8889@9æ"@,8888;;;;;;;;;;9æ@=888?æA8899<æA
8889A9æ"A,8888;;;;;;;;;;9æA=888?æB8899<æB
8889B9æ"B,8888;;;;;;;;;;9æB=888?æC8899<æC
8889C9æ"C,8888;;;;;;;;;;9æC=888?æD8899<æD
8889D9æ"D,8888;;;;;;;;;;9æD=888?æE8899<æE
8889E9æ"E,8888;;;;;;;;;;9æE=888?æF8899<æF
8889F9æ"F,8888;;;;;;;;;;9æF=888?æG8899<æG
8889G9æ"G,8888;;;;;;;;;;9æG=888?æH8899<æH
8889H9æ"H,8888;;;;;;;;;;9æH=888?æI8899<æI
8889I9æ"I,8888;;;;;;;;;;9æI=888?æJ8899<æJ
8889J9æ"J,8888;;;;;;;;;;9æJ=888?æK8899<æK
8889K9æ"K,8888;;;;;;;;;;9æK=888?æL8899<æL
8889L9æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888?æN8899<æN
8889N9æ"N,8888;;;;;;;;;;9æN=888?æO8899<æO
8889O9æ"O,8888;;;;;;;;;;9æO=888?æP8899<æP
8889P9æ"P,8888;;;;;;;;;;9æP=888?æQ8899<æQ
8889Q9æ"Q,8888;;;;;;;;;;9æQ=888?æR8899<æR
8889R9æ"R,8888;;;;;;;;;;9æR=888?æS8899<æS
8889S9æ"S,8888;;;;;;;;;;9æS=888?æT8899<æT
8889T9æ"T,8888;;;;;;;;;;9æT=888?æU8899<æU
8889U9æ"U,8888;;;;;;;;;;9æU=888?æV8899<æV
8889V9æ"V,8888;;;;;;;;;;9æV=888?æW8899<æW
8889W9æ"W,8888;;;;;;;;;;9æW=888?æX8899<æX
8889X9æ"X,8888;;;;;;;;;;9æX=888?æY8899<æY
8889Y9æ"Y,8888;;;;;;;;;;9æY=888?æZ8899<æZ
8889Z9æ"Z,8888;;;;;;;;;;9æZ=888?æ[8899<æ[
8889[9æ"[,8888;;;;;;;;;;9æ[=888?æ\8899<æ\
8889\9æ"\,8888;;;;;;;;;;9æ\=888?æ]8899<æ]
8889]9æ"],8888;;;;;;;;;;9æ]=888?æ^8899<æ^
8889^9æ"^,8888;;;;;;;;;;9æ^=888?æ_8899<æ_
8889_9æ"_,8888;;;;;;;;;;9æ_=888?◊D@lfffffffffffffffffffffffffffffff`@í?7a@í?7b@í?7c@í?7d@í?7e@í?7f@í?7g@í?7h@í?7i@í?7j@í?7k@í?7l@í?7m@í?7n@í?7o@í?7p@í?7q@í?7r@í?7s@í?7t@í?7u@í?7v@í?7w@í?7x@í?7y@í?7z@í?7{@í?7|@í?7}@í?7~@í?7@í?7æ`8899<æ`
8889`9æ"`,8888;;;;;;;;;;9æ`=888?æa8899<æa
8889a9æ"a,8888;;;;;;;;;;9æa=888?æb8899<æb
8889b9æ"b,8888;;;;;;;;;;9æb=888?æc8899<æc
8889c9æ"c,8888;;;;;;;;;;9æc=888?æd8899<æd
8889d9æ"d,8888;;;;;;;;;;9æd=888?æe8899<æe
8889e9æ"e,8888;;;;;;;;;;9æe=888?æf8899<æf
8889f9æ"f,8888;;;;;;;;;;9æf=888?æg8899<æg
8889g9æ"g,8888;;;;;;;;;;9æg=888?æh8899<æh
8889h9æ"h,8888;;;;;;;;;;9æh=888?æi8899<æi
8889i9æ"i,8888;;;;;;;;;;9æi=888?æj8899<æj
8889j9æ"j,8888;;;;;;;;;;9æj=888?æk8899<æk
8889k9æ"k,8888;;;;;;;;;;9æk=888?æl8899<æl
8889l9æ"l,8888;;;;;;;;;;9æl=888?æm8899<æm
8889m9æ"m,8888;;;;;;;;;;9æm=888?æn8899<æn
8889n9æ"n,8888;;;;;;;;;;9æn=888?æo8899<æo
8889o9æ"o,8888;;;;;;;;;;9æo=888?æp8899<æp
8889p9æ"p,8888;;;;;;;;;;9æp=888?æq8899<æq
8889q9æ"q,8888;;;;;;;;;;9æq=888?ær8899<ær
8889r9æ"r,8888;;;;;;;;;;9ær=888?æs8899<æs
8889s9æ"s,8888;;;;;;;;;;9æs=888?æt8899<æt
8889t9æ"t,8888;;;;;;;;;;9æt=888?æu8899<æu
8889u9æ"u,8888;;;;;;;;;;9æu=888?æv8899<æv
8889v9æ"v,8888;;;;;;;;;;9æv=888?æw8899<æw
8889w9æ"w,8888;;;;;;;;;;9æw=888?æx8899<æx
8889x9æ"x,8888;;;;;;;;;;9æx=888?æy8899<æy
8889y9æ"y,8888;;;;;;;;;;9æy=888?æz8899<æz
8889z9æ"z,8888;;;;;;;;;;9æz=888?æ{8899<æ{
8889{9æ"{,8888;;;;;;;;;;9æ{=888?æ|8899<æ|
8889|9æ"|,8888;;;;;;;;;;9æ|=888?æ}8899<æ}
8889}9æ"},8888;;;;;;;;;;9æ}=888?æ~8899<æ~
8889~9æ"~,8888;;;;;;;;;;9æ~=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffffÄ@í?7Å@í?7Ç@í?7?@í?7Ñ@í?7Ö@í?7Ü@í?7á@í?7?@í?7â@í?7–@í?7ã@í?7?@í?7?@í?7ﬁ@í?7?@í?7ê@í?7ë@í?7í@í?7ì@í?7î@í?7ï@í?7ñ@í?7ó@í?7?@í?7ô@í?7@í?7õ@í?7?@í?7?@í?7˛@í?7?@í?7æÄ8899<æÄ
8889Ä9æ"Ä,8888;;;;;;;;;;9æÄ=888?æÅ8899<æÅ
8889Å9æ"Å,8888;;;;;;;;;;9æÅ=888?æÇ8899<æÇ
8889Ç9æ"Ç,8888;;;;;;;;;;9æÇ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÑ8899<æÑ
8889Ñ9æ"Ñ,8888;;;;;;;;;;9æÑ=888?æÖ8899<æÖ
8889Ö9æ"Ö,8888;;;;;;;;;;9æÖ=888?æÜ8899<æÜ
8889Ü9æ"Ü,8888;;;;;;;;;;9æÜ=888?æá8899<æá
8889á9æ"á,8888;;;;;;;;;;9æá=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æâ8899<æâ
8889â9æ"â,8888;;;;;;;;;;9æâ=888?æ–8899<æ–
8889–9æ"–,8888;;;;;;;;;;9æ–=888?æã8899<æã
8889ã9æ"ã,8888;;;;;;;;;;9æã=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬁ8899<æﬁ
8889ﬁ9æ"ﬁ,8888;;;;;;;;;;9æﬁ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æê8899<æê
8889ê9æ"ê,8888;;;;;;;;;;9æê=888?æë8899<æë
8889ë9æ"ë,8888;;;;;;;;;;9æë=888?æí8899<æí
8889í9æ"í,8888;;;;;;;;;;9æí=888?æì8899<æì
8889ì9æ"ì,8888;;;;;;;;;;9æì=888?æî8899<æî
8889î9æ"î,8888;;;;;;;;;;9æî=888?æï8899<æï
8889ï9æ"ï,8888;;;;;;;;;;9æï=888?æñ8899<æñ
8889ñ9æ"ñ,8888;;;;;;;;;;9æñ=888?æó8899<æó
8889ó9æ"ó,8888;;;;;;;;;;9æó=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æô8899<æô
8889ô9æ"ô,8888;;;;;;;;;;9æô=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æõ8899<æõ
8889õ9æ"õ,8888;;;;;;;;;;9æõ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ˛8899<æ˛
8889˛9æ"˛,8888;;;;;;;;;;9æ˛=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff @í?7?@í?7¢@í?7£@í?7§@í?7?@í?7¶@í?7ß@í?7ç@í?7©@í?7?@í?7´@í?7¨@í?7≠@í?7Æ@í?7ù@í?7∞@í?7±@í?7≤@í?7≥@í?7¥@í?7µ@í?7∂@í?7∑@í?7è@í?7π@í?7?@í?7ª@í?7º@í?7Ω@í?7æ@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¢8899<æ¢
8889¢9æ"¢,8888;;;;;;;;;;9æ¢=888?æ£8899<æ£
8889£9æ"£,8888;;;;;;;;;;9æ£=888?æ§8899<æ§
8889§9æ"§,8888;;;;;;;;;;9æ§=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¶8899<æ¶
8889¶9æ"¶,8888;;;;;;;;;;9æ¶=888?æß8899<æß
8889ß9æ"ß,8888;;;;;;;;;;9æß=888?æç8899<æç
8889ç9æ"ç,8888;;;;;;;;;;9æç=888?æ©8899<æ©
8889©9æ"©,8888;;;;;;;;;;9æ©=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ´8899<æ´
8889´9æ"´,8888;;;;;;;;;;9æ´=888?æ¨8899<æ¨
8889¨9æ"¨,8888;;;;;;;;;;9æ¨=888?æ≠8899<æ≠
8889≠9æ"≠,8888;;;;;;;;;;9æ≠=888?æÆ8899<æÆ
8889Æ9æ"Æ,8888;;;;;;;;;;9æÆ=888?æù8899<æù
8889ù9æ"ù,8888;;;;;;;;;;9æù=888?æ∞8899<æ∞
8889∞9æ"∞,8888;;;;;;;;;;9æ∞=888?æ±8899<æ±
8889±9æ"±,8888;;;;;;;;;;9æ±=888?æ≤8899<æ≤
8889≤9æ"≤,8888;;;;;;;;;;9æ≤=888?æ≥8899<æ≥
8889≥9æ"≥,8888;;;;;;;;;;9æ≥=888?æ¥8899<æ¥
8889¥9æ"¥,8888;;;;;;;;;;9æ¥=888?æµ8899<æµ
8889µ9æ"µ,8888;;;;;;;;;;9æµ=888?æ∂8899<æ∂
8889∂9æ"∂,8888;;;;;;;;;;9æ∂=888?æ∑8899<æ∑
8889∑9æ"∑,8888;;;;;;;;;;9æ∑=888?æè8899<æè
8889è9æ"è,8888;;;;;;;;;;9æè=888?æπ8899<æπ
8889π9æ"π,8888;;;;;;;;;;9æπ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æª8899<æª
8889ª9æ"ª,8888;;;;;;;;;;9æª=888?æº8899<æº
8889º9æ"º,8888;;;;;;;;;;9æº=888?æΩ8899<æΩ
8889Ω9æ"Ω,8888;;;;;;;;;;9æΩ=888?ææ8899<ææ
8889æ9æ"æ,8888;;;;;;;;;;9ææ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7ƒ@í?7≈@í?7Ø@í?7?@í?7?@í?7…@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7”@í?7?@í?7’@í?7÷@í?7◊@í?7®@í?7?@í?7?@í?7?@í?7‹@í?7?@í?7?@í?7ﬂ@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æƒ8899<æƒ
8889ƒ9æ"ƒ,8888;;;;;;;;;;9æƒ=888?æ≈8899<æ≈
8889≈9æ"≈,8888;;;;;;;;;;9æ≈=888?æØ8899<æØ
8889Ø9æ"Ø,8888;;;;;;;;;;9æØ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ…8899<æ…
8889…9æ"…,8888;;;;;;;;;;9æ…=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ”8899<æ”
8889”9æ"”,8888;;;;;;;;;;9æ”=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ’8899<æ’
8889’9æ"’,8888;;;;;;;;;;9æ’=888?æ÷8899<æ÷
8889÷9æ"÷,8888;;;;;;;;;;9æ÷=888?æ◊8899<æ◊
8889◊9æ"◊,8888;;;;;;;;;;9æ◊=888?æ®8899<æ®
8889®9æ"®,8888;;;;;;;;;;9æ®=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‹8899<æ‹
8889‹9æ"‹,8888;;;;;;;;;;9æ‹=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬂ8899<æﬂ
8889ﬂ9æ"ﬂ,8888;;;;;;;;;;9æﬂ=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7‰@í?7Â@í?7ø@í?7?@í?7?@í?7È@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7Û@í?7?@í?7ı@í?7ˆ@í?7˜@í?7∏@í?7?@í?7?@í?7?@í?7¸@í?7?@í?7?@í?7?@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‰8899<æ‰
8889‰9æ"‰,8888;;;;;;;;;;9æ‰=888?æÂ8899<æÂ
8889Â9æ"Â,8888;;;;;;;;;;9æÂ=888?æø8899<æø
8889ø9æ"ø,8888;;;;;;;;;;9æø=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÈ8899<æÈ
8889È9æ"È,8888;;;;;;;;;;9æÈ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÛ8899<æÛ
8889Û9æ"Û,8888;;;;;;;;;;9æÛ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æı8899<æı
8889ı9æ"ı,8888;;;;;;;;;;9æı=888?æˆ8899<æˆ
8889ˆ9æ"ˆ,8888;;;;;;;;;;9æˆ=888?æ˜8899<æ˜
8889˜9æ"˜,8888;;;;;;;;;;9æ˜=888?æ∏8899<æ∏
8889∏9æ"∏,8888;;;;;;;;;;9æ∏=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¸8899<æ¸
8889¸9æ"¸,8888;;;;;;;;;;9æ¸=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7	@í?7
@í?7@í?7@í?7
@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffff @í?7!@í?7"@í?7#@í?7$@í?7%@í?7&@í?7'@í?7(@í?7)@í?7*@í?7+@í?7,@í?7-@í?7.@í?7/@í?70@í?71@í?72@í?73@í?74@í?75@í?76@í?77@í?78@í?79@í?7:@í?7;@í?7<@í?7=@í?7>@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ!8899<æ!
8889!9æ"!,8888;;;;;;;;;;9æ!=888?æ"8899<æ"
8889"9æ"",8888;;;;;;;;;;9æ"=888?æ#8899<æ#
8889#9æ"#,8888;;;;;;;;;;9æ#=888?æ$8899<æ$
8889$9æ"$,8888;;;;;;;;;;9æ$=888?æ%8899<æ%
8889%9æ"%,8888;;;;;;;;;;9æ%=888?æ&8899<æ&
8889&9æ"&,8888;;;;;;;;;;9æ&=888?æ'8899<æ'
8889'9æ"',8888;;;;;;;;;;9æ'=888?æ(8899<æ(
8889(9æ"(,8888;;;;;;;;;;9æ(=888?æ)8899<æ)
8889)9æ"),8888;;;;;;;;;;9æ)=888?æ*8899<æ*
8889*9æ"*,8888;;;;;;;;;;9æ*=888?æ+8899<æ+
8889+9æ"+,8888;;;;;;;;;;9æ+=888?æ,8899<æ,
8889,9æ",,8888;;;;;;;;;;9æ,=888?æ-8899<æ-
8889-9æ"-,8888;;;;;;;;;;9æ-=888?æ.8899<æ.
8889.9æ".,8888;;;;;;;;;;9æ.=888?æ/8899<æ/
8889/9æ"/,8888;;;;;;;;;;9æ/=888?æ08899<æ0
888909æ"0,8888;;;;;;;;;;9æ0=888?æ18899<æ1
888919æ"1,8888;;;;;;;;;;9æ1=888?æ28899<æ2
888929æ"2,8888;;;;;;;;;;9æ2=888?æ38899<æ3
888939æ"3,8888;;;;;;;;;;9æ3=888?æ48899<æ4
888949æ"4,8888;;;;;;;;;;9æ4=888?æ58899<æ5
888959æ"5,8888;;;;;;;;;;9æ5=888?æ68899<æ6
888969æ"6,8888;;;;;;;;;;9æ6=888?æ78899<æ7
888979æ"7,8888;;;;;;;;;;9æ7=888?æ88899<æ8
888989æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888?æ:8899<æ:
8889:9æ":,8888;;;;;;;;;;9æ:=888?æ;8899<æ;
8889;9æ";,8888;;;;;;;;;;9æ;=888?æ<8899<æ<
8889<9æ"<,8888;;;;;;;;;;9æ<=888?æ=8899<æ=
8889=9æ"=,8888;;;;;;;;;;9æ==888?æ>8899<æ>
8889>9æ">,8888;;;;;;;;;;9æ>=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@@í?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@í?7H@í?7I@í?7J@í?7K@í?7L@í?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7T@í?7U@í?7V@í?7W@í?7X@í?7Y@í?7Z@í?7[@í?7\@í?7]@í?7^@í?7_@í?7æ@8899<æ@
8889@9æ"@,8888;;;;;;;;;;9æ@=888?æA8899<æA
8889A9æ"A,8888;;;;;;;;;;9æA=888?æB8899<æB
8889B9æ"B,8888;;;;;;;;;;9æB=888?æC8899<æC
8889C9æ"C,8888;;;;;;;;;;9æC=888?æD8899<æD
8889D9æ"D,8888;;;;;;;;;;9æD=888?æE8899<æE
8889E9æ"E,8888;;;;;;;;;;9æE=888?æF8899<æF
8889F9æ"F,8888;;;;;;;;;;9æF=888?æG8899<æG
8889G9æ"G,8888;;;;;;;;;;9æG=888?æH8899<æH
8889H9æ"H,8888;;;;;;;;;;9æH=888?æI8899<æI
8889I9æ"I,8888;;;;;;;;;;9æI=888?æJ8899<æJ
8889J9æ"J,8888;;;;;;;;;;9æJ=888?æK8899<æK
8889K9æ"K,8888;;;;;;;;;;9æK=888?æL8899<æL
8889L9æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888?æN8899<æN
8889N9æ"N,8888;;;;;;;;;;9æN=888?æO8899<æO
8889O9æ"O,8888;;;;;;;;;;9æO=888?æP8899<æP
8889P9æ"P,8888;;;;;;;;;;9æP=888?æQ8899<æQ
8889Q9æ"Q,8888;;;;;;;;;;9æQ=888?æR8899<æR
8889R9æ"R,8888;;;;;;;;;;9æR=888?æS8899<æS
8889S9æ"S,8888;;;;;;;;;;9æS=888?æT8899<æT
8889T9æ"T,8888;;;;;;;;;;9æT=888?æU8899<æU
8889U9æ"U,8888;;;;;;;;;;9æU=888?æV8899<æV
8889V9æ"V,8888;;;;;;;;;;9æV=888?æW8899<æW
8889W9æ"W,8888;;;;;;;;;;9æW=888?æX8899<æX
8889X9æ"X,8888;;;;;;;;;;9æX=888?æY8899<æY
8889Y9æ"Y,8888;;;;;;;;;;9æY=888?æZ8899<æZ
8889Z9æ"Z,8888;;;;;;;;;;9æZ=888?æ[8899<æ[
8889[9æ"[,8888;;;;;;;;;;9æ[=888?æ\8899<æ\
8889\9æ"\,8888;;;;;;;;;;9æ\=888?æ]8899<æ]
8889]9æ"],8888;;;;;;;;;;9æ]=888?æ^8899<æ^
8889^9æ"^,8888;;;;;;;;;;9æ^=888?æ_8899<æ_
8889_9æ"_,8888;;;;;;;;;;9æ_=888?◊D@lfffffffffffffffffffffffffffffff`@í?7a@í?7b@í?7c@í?7d@í?7e@í?7f@í?7g@í?7h@í?7i@í?7j@í?7k@í?7l@í?7m@í?7n@í?7o@í?7p@í?7q@í?7r@í?7s@í?7t@í?7u@í?7v@í?7w@í?7x@í?7y@í?7z@í?7{@í?7|@í?7}@í?7~@í?7@í?7æ`8899<æ`
8889`9æ"`,8888;;;;;;;;;;9æ`=888?æa8899<æa
8889a9æ"a,8888;;;;;;;;;;9æa=888?æb8899<æb
8889b9æ"b,8888;;;;;;;;;;9æb=888?æc8899<æc
8889c9æ"c,8888;;;;;;;;;;9æc=888?æd8899<æd
8889d9æ"d,8888;;;;;;;;;;9æd=888?æe8899<æe
8889e9æ"e,8888;;;;;;;;;;9æe=888?æf8899<æf
8889f9æ"f,8888;;;;;;;;;;9æf=888?æg8899<æg
8889g9æ"g,8888;;;;;;;;;;9æg=888?æh8899<æh
8889h9æ"h,8888;;;;;;;;;;9æh=888?æi8899<æi
8889i9æ"i,8888;;;;;;;;;;9æi=888?æj8899<æj
8889j9æ"j,8888;;;;;;;;;;9æj=888?æk8899<æk
8889k9æ"k,8888;;;;;;;;;;9æk=888?æl8899<æl
8889l9æ"l,8888;;;;;;;;;;9æl=888?æm8899<æm
8889m9æ"m,8888;;;;;;;;;;9æm=888?æn8899<æn
8889n9æ"n,8888;;;;;;;;;;9æn=888?æo8899<æo
8889o9æ"o,8888;;;;;;;;;;9æo=888?æp8899<æp
8889p9æ"p,8888;;;;;;;;;;9æp=888?æq8899<æq
8889q9æ"q,8888;;;;;;;;;;9æq=888?ær8899<ær
8889r9æ"r,8888;;;;;;;;;;9ær=888?æs8899<æs
8889s9æ"s,8888;;;;;;;;;;9æs=888?æt8899<æt
8889t9æ"t,8888;;;;;;;;;;9æt=888?æu8899<æu
8889u9æ"u,8888;;;;;;;;;;9æu=888?æv8899<æv
8889v9æ"v,8888;;;;;;;;;;9æv=888?æw8899<æw
8889w9æ"w,8888;;;;;;;;;;9æw=888?æx8899<æx
8889x9æ"x,8888;;;;;;;;;;9æx=888?æy8899<æy
8889y9æ"y,8888;;;;;;;;;;9æy=888?æz8899<æz
8889z9æ"z,8888;;;;;;;;;;9æz=888?æ{8899<æ{
8889{9æ"{,8888;;;;;;;;;;9æ{=888?æ|8899<æ|
8889|9æ"|,8888;;;;;;;;;;9æ|=888?æ}8899<æ}
8889}9æ"},8888;;;;;;;;;;9æ}=888?æ~8899<æ~
8889~9æ"~,8888;;;;;;;;;;9æ~=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffffÄ@í?7Å@í?7Ç@í?7?@í?7Ñ@í?7Ö@í?7Ü@í?7á@í?7?@í?7â@í?7–@í?7ã@í?7?@í?7?@í?7ﬁ@í?7?@í?7ê@í?7ë@í?7í@í?7ì@í?7î@í?7ï@í?7ñ@í?7ó@í?7?@í?7ô@í?7@í?7õ@í?7?@í?7?@í?7˛@í?7?@í?7æÄ8899<æÄ
8889Ä9æ"Ä,8888;;;;;;;;;;9æÄ=888?æÅ8899<æÅ
8889Å9æ"Å,8888;;;;;;;;;;9æÅ=888?æÇ8899<æÇ
8889Ç9æ"Ç,8888;;;;;;;;;;9æÇ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÑ8899<æÑ
8889Ñ9æ"Ñ,8888;;;;;;;;;;9æÑ=888?æÖ8899<æÖ
8889Ö9æ"Ö,8888;;;;;;;;;;9æÖ=888?æÜ8899<æÜ
8889Ü9æ"Ü,8888;;;;;;;;;;9æÜ=888?æá8899<æá
8889á9æ"á,8888;;;;;;;;;;9æá=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æâ8899<æâ
8889â9æ"â,8888;;;;;;;;;;9æâ=888?æ–8899<æ–
8889–9æ"–,8888;;;;;;;;;;9æ–=888?æã8899<æã
8889ã9æ"ã,8888;;;;;;;;;;9æã=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬁ8899<æﬁ
8889ﬁ9æ"ﬁ,8888;;;;;;;;;;9æﬁ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æê8899<æê
8889ê9æ"ê,8888;;;;;;;;;;9æê=888?æë8899<æë
8889ë9æ"ë,8888;;;;;;;;;;9æë=888?æí8899<æí
8889í9æ"í,8888;;;;;;;;;;9æí=888?æì8899<æì
8889ì9æ"ì,8888;;;;;;;;;;9æì=888?æî8899<æî
8889î9æ"î,8888;;;;;;;;;;9æî=888?æï8899<æï
8889ï9æ"ï,8888;;;;;;;;;;9æï=888?æñ8899<æñ
8889ñ9æ"ñ,8888;;;;;;;;;;9æñ=888?æó8899<æó
8889ó9æ"ó,8888;;;;;;;;;;9æó=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æô8899<æô
8889ô9æ"ô,8888;;;;;;;;;;9æô=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æõ8899<æõ
8889õ9æ"õ,8888;;;;;;;;;;9æõ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ˛8899<æ˛
8889˛9æ"˛,8888;;;;;;;;;;9æ˛=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff @í?7?@í?7¢@í?7£@í?7§@í?7?@í?7¶@í?7ß@í?7ç@í?7©@í?7?@í?7´@í?7¨@í?7≠@í?7Æ@í?7ù@í?7∞@í?7±@í?7≤@í?7≥@í?7¥@í?7µ@í?7∂@í?7∑@í?7è@í?7π@í?7?@í?7ª@í?7º@í?7Ω@í?7æ@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¢8899<æ¢
8889¢9æ"¢,8888;;;;;;;;;;9æ¢=888?æ£8899<æ£
8889£9æ"£,8888;;;;;;;;;;9æ£=888?æ§8899<æ§
8889§9æ"§,8888;;;;;;;;;;9æ§=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¶8899<æ¶
8889¶9æ"¶,8888;;;;;;;;;;9æ¶=888?æß8899<æß
8889ß9æ"ß,8888;;;;;;;;;;9æß=888?æç8899<æç
8889ç9æ"ç,8888;;;;;;;;;;9æç=888?æ©8899<æ©
8889©9æ"©,8888;;;;;;;;;;9æ©=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ´8899<æ´
8889´9æ"´,8888;;;;;;;;;;9æ´=888?æ¨8899<æ¨
8889¨9æ"¨,8888;;;;;;;;;;9æ¨=888?æ≠8899<æ≠
8889	

 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abce????fghijklmnopqrstuvwxyz{|}~Ä≠9æ"≠,8888;;;;;;;;;;9æ≠=888?æÆ8899<æÆ
8889Æ9æ"Æ,8888;;;;;;;;;;9æÆ=888?æù8899<æù
8889ù9æ"ù,8888;;;;;;;;;;9æù=888?æ∞8899<æ∞
8889∞9æ"∞,8888;;;;;;;;;;9æ∞=888?æ±8899<æ±
8889±9æ"±,8888;;;;;;;;;;9æ±=888?æ≤8899<æ≤
8889≤9æ"≤,8888;;;;;;;;;;9æ≤=888?æ≥8899<æ≥
8889≥9æ"≥,8888;;;;;;;;;;9æ≥=888?æ¥8899<æ¥
8889¥9æ"¥,8888;;;;;;;;;;9æ¥=888?æµ8899<æµ
8889µ9æ"µ,8888;;;;;;;;;;9æµ=888?æ∂8899<æ∂
8889∂9æ"∂,8888;;;;;;;;;;9æ∂=888?æ∑8899<æ∑
8889∑9æ"∑,8888;;;;;;;;;;9æ∑=888?æè8899<æè
8889è9æ"è,8888;;;;;;;;;;9æè=888?æπ8899<æπ
8889π9æ"π,8888;;;;;;;;;;9æπ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æª8899<æª
8889ª9æ"ª,8888;;;;;;;;;;9æª=888?æº8899<æº
8889º9æ"º,8888;;;;;;;;;;9æº=888?æΩ8899<æΩ
8889Ω9æ"Ω,8888;;;;;;;;;;9æΩ=888?ææ8899<ææ
8889æ9æ"æ,8888;;;;;;;;;;9ææ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7ƒ@í?7≈@í?7Ø@í?7?@í?7?@í?7…@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7”@í?7?@í?7’@í?7÷@í?7◊@í?7®@í?7?@í?7?@í?7?@í?7‹@í?7?@í?7?@í?7ﬂ@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æƒ8899<æƒ
8889ƒ9æ"ƒ,8888;;;;;;;;;;9æƒ=888?æ≈8899<æ≈
8889≈9æ"≈,8888;;;;;;;;;;9æ≈=888?æØ8899<æØ
8889Ø9æ"Ø,8888;;;;;;;;;;9æØ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ…8899<æ…
8889…9æ"…,8888;;;;;;;;;;9æ…=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ”8899<æ”
8889”9æ"”,8888;;;;;;;;;;9æ”=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ’8899<æ’
8889’9æ"’,8888;;;;;;;;;;9æ’=888?æ÷8899<æ÷
8889÷9æ"÷,8888;;;;;;;;;;9æ÷=888?æ◊8899<æ◊
8889◊9æ"◊,8888;;;;;;;;;;9æ◊=888?æ®8899<æ®
8889®9æ"®,8888;;;;;;;;;;9æ®=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‹8899<æ‹
8889‹9æ"‹,8888;;;;;;;;;;9æ‹=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬂ8899<æﬂ
8889ﬂ9æ"ﬂ,8888;;;;;;;;;;9æﬂ=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7‰@í?7Â@í?7ø@í?7?@í?7?@í?7È@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7Û@í?7?@í?7ı@í?7ˆ@í?7˜@í?7∏@í?7?@í?7?@í?7?@í?7¸@í?7?@í?7?@í?7?@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‰8899<æ‰
8889‰9æ"‰,8888;;;;;;;;;;9æ‰=888?æÂ8899<æÂ
8889Â9æ"Â,8888;;;;;;;;;;9æÂ=888?æø8899<æø
8889ø9æ"ø,8888;;;;;;;;;;9æø=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÈ8899<æÈ
8889È9æ"È,8888;;;;;;;;;;9æÈ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÛ8899<æÛ
8889Û9æ"Û,8888;;;;;;;;;;9æÛ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æı8899<æı
8889ı9æ"ı,8888;;;;;;;;;;9æı=888?æˆ8899<æˆ
8889ˆ9æ"ˆ,8888;;;;;;;;;;9æˆ=888?æ˜8899<æ˜
8889˜9æ"˜,8888;;;;;;;;;;9æ˜=888?æ∏8899<æ∏
8889∏9æ"∏,8888;;;;;;;;;;9æ∏=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¸8899<æ¸
8889¸9æ"¸,8888;;;;;;;;;;9æ¸=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7	@í?7
@í?7@í?7@í?7
@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffff @í?7!@í?7"@í?7#@í?7$@í?7%@í?7&@í?7'@í?7(@í?7)@í?7*@í?7+@í?7,@í?7-@í?7.@í?7/@í?70@í?71@í?72@í?73@í?74@í?75@í?76@í?77@í?78@í?79@í?7:@í?7;@í?7<@í?7=@í?7>@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ!8899<æ!
8889!9æ"!,8888;;;;;;;;;;9æ!=888?æ"8899<æ"
8889"9æ"",8888;;;;;;;;;;9æ"=888?æ#8899<æ#
8889#9æ"#,8888;;;;;;;;;;9æ#=888?æ$8899<æ$
8889$9æ"$,8888;;;;;;;;;;9æ$=888?æ%8899<æ%
8889%9æ"%,8888;;;;;;;;;;9æ%=888?æ&8899<æ&
8889&9æ"&,8888;;;;;;;;;;9æ&=888?æ'8899<æ'
8889'9æ"',8888;;;;;;;;;;9æ'=888?æ(8899<æ(
8889(9æ"(,8888;;;;;;;;;;9æ(=888?æ)8899<æ)
8889)9æ"),8888;;;;;;;;;;9æ)=888?æ*8899<æ*
8889*9æ"*,8888;;;;;;;;;;9æ*=888?æ+8899<æ+
8889+9æ"+,8888;;;;;;;;;;9æ+=888?æ,8899<æ,
8889,9æ",,8888;;;;;;;;;;9æ,=888?æ-8899<æ-
8889-9æ"-,8888;;;;;;;;;;9æ-=888?æ.8899<æ.
8889.9æ".,8888;;;;;;;;;;9æ.=888?æ/8899<æ/
8889/9æ"/,8888;;;;;;;;;;9æ/=888?æ08899<æ0
888909æ"0,8888;;;;;;;;;;9æ0=888?æ18899<æ1
888919æ"1,8888;;;;;;;;;;9æ1=888?æ28899<æ2
888929æ"2,8888;;;;;;;;;;9æ2=888?æ38899<æ3
888939æ"3,8888;;;;;;;;;;9æ3=888?æ48899<æ4
888949æ"4,8888;;;;;;;;;;9æ4=888?æ58899<æ5
888959æ"5,8888;;;;;;;;;;9æ5=888?æ68899<æ6
888969æ"6,8888;;;;;;;;;;9æ6=888?æ78899<æ7
888979æ"7,8888;;;;;;;;;;9æ7=888?æ88899<æ8
888989æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888?æ:8899<æ:
8889:9æ":,8888;;;;;;;;;;9æ:=888?æ;8899<æ;
8889;9æ";,8888;;;;;;;;;;9æ;=888?æ<8899<æ<
8889<9æ"<,8888;;;;;;;;;;9æ<=888?æ=8899<æ=
8889=9æ"=,8888;;;;;;;;;;9æ==888?æ>8899<æ>
8889>9æ">,8888;;;;;;;;;;9æ>=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@@í?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@í?7H@í?7I@í?7J@í?7K@í?7L@í?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7T@í?7U@í?7V@í?7W@í?7X@í?7Y@í?7Z@í?7[@í?7\@í?7]@í?7^@í?7_@í?7æ@8899<æ@
8889@9æ"@,8888;;;;;;;;;;9æ@=888?æA8899<æA
8889A9æ"A,8888;;;;;;;;;;9æA=888?æB8899<æB
8889B9æ"B,8888;;;;;;;;;;9æB=888?æC8899<æC
8889C9æ"C,8888;;;;;;;;;;9æC=888?æD8899<æD
8889D9æ"D,8888;;;;;;;;;;9æD=888?æE8899<æE
8889E9æ"E,8888;;;;;;;;;;9æE=888?æF8899<æF
8889F9æ"F,8888;;;;;;;;;;9æF=888?æG8899<æG
8889G9æ"G,8888;;;;;;;;;;9æG=888?æH8899<æH
8889H9æ"H,8888;;;;;;;;;;9æH=888?æI8899<æI
8889I9æ"I,8888;;;;;;;;;;9æI=888?æJ8899<æJ
8889J9æ"J,8888;;;;;;;;;;9æJ=888?æK8899<æK
8889K9æ"K,8888;;;;;;;;;;9æK=888?æL8899<æL
8889L9æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888?æN8899<æN
8889N9æ"N,8888;;;;;;;;;;9æN=888?æO8899<æO
8889O9æ"O,8888;;;;;;;;;;9æO=888?æP8899<æP
8889P9æ"P,8888;;;;;;;;;;9æP=888?æQ8899<æQ
8889Q9æ"Q,8888;;;;;;;;;;9æQ=888?æR8899<æR
8889R9æ"R,8888;;;;;;;;;;9æR=888?æS8899<æS
8889S9æ"S,8888;;;;;;;;;;9æS=888?æT8899<æT
8889T9æ"T,8888;;;;;;;;;;9æT=888?æU8899<æU
8889U9æ"U,8888;;;;;;;;;;9æU=888?æV8899<æV
8889V9æ"V,8888;;;;;;;;;;9æV=888?æW8899<æW
8889W9æ"W,8888;;;;;;;;;;9æW=888?æX8899<æX
8889X9æ"X,8888;;;;;;;;;;9æX=888?æY8899<æY
8889Y9æ"Y,8888;;;;;;;;;;9æY=888?æZ8899<æZ
8889Z9æ"Z,8888;;;;;;;;;;9æZ=888?æ[8899<æ[
8889[9æ"[,8888;;;;;;;;;;9æ[=888?æ\8899<æ\
8889\9æ"\,8888;;;;;;;;;;9æ\=888?æ]8899<æ]
8889]9æ"],8888;;;;;;;;;;9æ]=888?æ^8899<æ^
8889^9æ"^,8888;;;;;;;;;;9æ^=888?æ_8899<æ_
8889_9æ"_,8888;;;;;;;;;;9æ_=888?◊D@lfffffffffffffffffffffffffffffff`@í?7a@í?7b@í?7c@í?7d@í?7e@í?7f@í?7g@í?7h@í?7i@í?7j@í?7k@í?7l@í?7m@í?7n@í?7o@í?7p@í?7q@í?7r@í?7s@í?7t@í?7u@í?7v@í?7w@í?7x@í?7y@í?7z@í?7{@í?7|@í?7}@í?7~@í?7@í?7æ`8899<æ`
8889`9æ"`,8888;;;;;;;;;;9æ`=888?æa8899<æa
8889a9æ"a,8888;;;;;;;;;;9æa=888?æb8899<æb
8889b9æ"b,8888;;;;;;;;;;9æb=888?æc8899<æc
8889c9æ"c,8888;;;;;;;;;;9æc=888?æd8899<æd
8889d9æ"d,8888;;;;;;;;;;9æd=888?æe8899<æe
8889e9æ"e,8888;;;;;;;;;;9æe=888?æf8899<æf
8889f9æ"f,8888;;;;;;;;;;9æf=888?æg8899<æg
8889g9æ"g,8888;;;;;;;;;;9æg=888?æh8899<æh
8889h9æ"h,8888;;;;;;;;;;9æh=888?æi8899<æi
8889i9æ"i,8888;;;;;;;;;;9æi=888?æj8899<æj
8889j9æ"j,8888;;;;;;;;;;9æj=888?æk8899<æk
8889k9æ"k,8888;;;;;;;;;;9æk=888?æl8899<æl
8889l9æ"l,8888;;;;;;;;;;9æl=888?æm8899<æm
8889m9æ"m,8888;;;;;;;;;;9æm=888?æn8899<æn
8889n9æ"n,8888;;;;;;;;;;9æn=888?æo8899<æo
8889o9æ"o,8888;;;;;;;;;;9æo=888?æp8899<æp
8889p9æ"p,8888;;;;;;;;;;9æp=888?æq8899<æq
8889q9æ"q,8888;;;;;;;;;;9æq=888?ær8899<ær
8889r9æ"r,8888;;;;;;;;;;9ær=888?æs8899<æs
8889s9æ"s,8888;;;;;;;;;;9æs=888?æt8899<æt
8889t9æ"t,8888;;;;;;;;;;9æt=888?æu8899<æu
8889u9æ"u,8888;;;;;;;;;;9æu=888?æv8899<æv
8889v9æ"v,8888;;;;;;;;;;9æv=888?æw8899<æw
8889w9æ"w,8888;;;;;;;;;;9æw=888?æx8899<æx
8889x9æ"x,8888;;;;;;;;;;9æx=888?æy8899<æy
8889y9æ"y,8888;;;;;;;;;;9æy=888?æz8899<æz
8889z9æ"z,8888;;;;;;;;;;9æz=888?æ{8899<æ{
8889{9æ"{,8888;;;;;;;;;;9æ{=888?æ|8899<æ|
8889|9æ"|,8888;;;;;;;;;;9æ|=888?æ}8899<æ}
8889}9æ"},8888;;;;;;;;;;9æ}=888?æ~8899<æ~
8889~9æ"~,8888;;;;;;;;;;9æ~=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffffÄ@í?7Å@í?7Ç@í?7?@í?7Ñ@í?7Ö@í?7Ü@í?7á@í?7?@í?7â@í?7–@í?7ã@í?7?@í?7?@í?7ﬁ@í?7?@í?7ê@í?7ë@í?7í@í?7ì@í?7î@í?7ï@í?7ñ@í?7ó@í?7?@í?7ô@í?7@í?7õ@í?7?@í?7?@í?7˛@í?7?@í?7æÄ8899<æÄ
8889Ä9æ"Ä,8888;;;;;;;;;;9æÄ=888?æÅ8899<æÅ
8889Å9æ"Å,8888;;;;;;;;;;9æÅ=888?æÇ8899<æÇ
8889Ç9æ"Ç,8888;;;;;;;;;;9æÇ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÑ8899<æÑ
8889Ñ9æ"Ñ,8888;;;;;;;;;;9æÑ=888?æÖ8899<æÖ
8889Ö9æ"Ö,8888;;;;;;;;;;9æÖ=888?æÜ8899<æÜ
8889Ü9æ"Ü,8888;;;;;;;;;;9æÜ=888?æá8899<æá
8889á9æ"á,8888;;;;;;;;;;9æá=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æâ8899<æâ
8889â9æ"â,8888;;;;;;;;;;9æâ=888?æ–8899<æ–
8889–9æ"–,8888;;;;;;;;;;9æ–=888?æã8899<æã
8889ã9æ"ã,8888;;;;;;;;;;9æã=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬁ8899<æﬁ
8889ﬁ9æ"ﬁ,8888;;;;;;;;;;9æﬁ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æê8899<æê
8889ê9æ"ê,8888;;;;;;;;;;9æê=888?æë8899<æë
8889ë9æ"ë,8888;;;;;;;;;;9æë=888?æí8899<æí
8889í9æ"í,8888;;;;;;;;;;9æí=888?æì8899<æì
8889ì9æ"ì,8888;;;;;;;;;;9æì=888?æî8899<æî
8889î9æ"î,8888;;;;;;;;;;9æî=888?æï8899<æï
8889ï9æ"ï,8888;;;;;;;;;;9æï=888?æñ8899<æñ
8889ñ9æ"ñ,8888;;;;;;;;;;9æñ=888?æó8899<æó
8889ó9æ"ó,8888;;;;;;;;;;9æó=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æô8899<æô
8889ô9æ"ô,8888;;;;;;;;;;9æô=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æõ8899<æõ
8889õ9æ"õ,8888;;;;;;;;;;9æõ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ˛8899<æ˛
8889˛9æ"˛,8888;;;;;;;;;;9æ˛=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff @í?7?@í?7¢@í?7£@í?7§@í?7?@í?7¶@í?7ß@í?7ç@í?7©@í?7?@í?7´@í?7¨@í?7≠@í?7Æ@í?7ù@í?7∞@í?7±@í?7≤@í?7≥@í?7¥@í?7µ@í?7∂@í?7∑@í?7è@í?7π@í?7?@í?7ª@í?7º@í?7Ω@í?7æ@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¢8899<æ¢
8889¢9æ"¢,8888;;;;;;;;;;9æ¢=888?æ£8899<æ£
8889£9æ"£,8888;;;;;;;;;;9æ£=888?æ§8899<æ§
8889§9æ"§,8888;;;;;;;;;;9æ§=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¶8899<æ¶
8889¶9æ"¶,8888;;;;;;;;;;9æ¶=888?æß8899<æß
8889ß9æ"ß,8888;;;;;;;;;;9æß=888?æç8899<æç
8889ç9æ"ç,8888;;;;;;;;;;9æç=888?æ©8899<æ©
8889©9æ"©,8888;;;;;;;;;;9æ©=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ´8899<æ´
8889´9æ"´,8888;;;;;;;;;;9æ´=888?æ¨8899<æ¨
8889¨9æ"¨,8888;;;;;;;;;;9æ¨=888?æ≠8899<æ≠
8889≠9æ"≠,8888;;;;;;;;;;9æ≠=888?æÆ8899<æÆ
8889Æ9æ"Æ,8888;;;;;;;;;;9æÆ=888?æù8899<æù
8889ù9æ"ù,8888;;;;;;;;;;9æù=888?æ∞8899<æ∞
8889∞9æ"∞,8888;;;;;;;;;;9æ∞=888?æ±8899<æ±
8889±9æ"±,8888;;;;;;;;;;9æ±=888?æ≤8899<æ≤
8889≤9æ"≤,8888;;;;;;;;;;9æ≤=888?æ≥8899<æ≥
8889≥9æ"≥,8888;;;;;;;;;;9æ≥=888?æ¥8899<æ¥
8889¥9æ"¥,8888;;;;;;;;;;9æ¥=888?æµ8899<æµ
8889µ9æ"µ,8888;;;;;;;;;;9æµ=888?æ∂8899<æ∂
8889∂9æ"∂,8888;;;;;;;;;;9æ∂=888?æ∑8899<æ∑
8889∑9æ"∑,8888;;;;;;;;;;9æ∑=888?æè8899<æè
8889è9æ"è,8888;;;;;;;;;;9æè=888?æπ8899<æπ
8889π9æ"π,8888;;;;;;;;;;9æπ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æª8899<æª
8889ª9æ"ª,8888;;;;;;;;;;9æª=888?æº8899<æº
8889º9æ"º,8888;;;;;;;;;;9æº=888?æΩ8899<æΩ
8889Ω9æ"Ω,8888;;;;;;;;;;9æΩ=888?ææ8899<ææ
8889æ9æ"æ,8888;;;;;;;;;;9ææ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7ƒ@í?7≈@í?7Ø@í?7?@í?7?@í?7…@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7”@í?7?@í?7’@í?7÷@í?7◊@í?7®@í?7?@í?7?@í?7?@í?7‹@í?7?@í?7?@í?7ﬂ@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æƒ8899<æƒ
8889ƒ9æ"ƒ,8888;;;;;;;;;;9æƒ=888?æ≈8899<æ≈
8889≈9æ"≈,8888;;;;;;;;;;9æ≈=888?æØ8899<æØ
8889Ø9æ"Ø,8888;;;;;;;;;;9æØ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ…8899<æ…
8889…9æ"…,8888;;;;;;;;;;9æ…=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ”8899<æ”
8889”9æ"”,8888;;;;;;;;;;9æ”=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ’8899<æ’
8889’9æ"’,8888;;;;;;;;;;9æ’=888?æ÷8899<æ÷
8889÷9æ"÷,8888;;;;;;;;;;9æ÷=888?æ◊8899<æ◊
8889◊9æ"◊,8888;;;;;;;;;;9æ◊=888?æ®8899<æ®
8889®9æ"®,8888;;;;;;;;;;9æ®=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‹8899<æ‹
8889‹9æ"‹,8888;;;;;;;;;;9æ‹=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬂ8899<æﬂ
8889ﬂ9æ"ﬂ,8888;;;;;;;;;;9æﬂ=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7‰@í?7Â@í?7ø@í?7?@í?7?@í?7È@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7Û@í?7?@í?7ı@í?7ˆ@í?7˜@í?7∏@í?7?@í?7?@í?7?@í?7¸@í?7?@í?7?@í?7?@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‰8899<æ‰
8889‰9æ"‰,8888;;;;;;;;;;9æ‰=888?æÂ8899<æÂ
8889Â9æ"Â,8888;;;;;;;;;;9æÂ=888?æø8899<æø
8889ø9æ"ø,8888;;;;;;;;;;9æø=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÈ8899<æÈ
8889È9æ"È,8888;;;;;;;;;;9æÈ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÛ8899<æÛ
8889Û9æ"Û,8888;;;;;;;;;;9æÛ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æı8899<æı
8889ı9æ"ı,8888;;;;;;;;;;9æı=888?æˆ8899<æˆ
8889ˆ9æ"ˆ,8888;;;;;;;;;;9æˆ=888?æ˜8899<æ˜
8889˜9æ"˜,8888;;;;;;;;;;9æ˜=888?æ∏8899<æ∏
8889∏9æ"∏,8888;;;;;;;;;;9æ∏=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¸8899<æ¸
8889¸9æ"¸,8888;;;;;;;;;;9æ¸=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7	@í?7
@í?7@í?7@í?7
@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffff @í?7!@í?7"@í?7#@í?7$@í?7%@í?7&@í?7'@í?7(@í?7)@í?7*@í?7+@í?7,@í?7-@í?7.@í?7/@í?70@í?71@í?72@í?73@í?74@í?75@í?76@í?77@í?78@í?79@í?7:@í?7;@í?7<@í?7=@í?7>@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ!8899<æ!
8889!9æ"!,8888;;;;;;;;;;9æ!=888?æ"8899<æ"
8889"9æ"",8888;;;;;;;;;;9æ"=888?æ#8899<æ#
8889#9æ"#,8888;;;;;;;;;;9æ#=888?æ$8899<æ$
8889$9æ"$,8888;;;;;;;;;;9æ$=888?æ%8899<æ%
8889%9æ"%,8888;;;;;;;;;;9æ%=888?æ&8899<æ&
8889&9æ"&,8888;;;;;;;;;;9æ&=888?æ'8899<æ'
8889'9æ"',8888;;;;;;;;;;9æ'=888?æ(8899<æ(
8889(9æ"(,8888;;;;;;;;;;9æ(=888?æ)8899<æ)
8889)9æ"),8888;;;;;;;;;;9æ)=888?æ*8899<æ*
8889*9æ"*,8888;;;;;;;;;;9æ*=888?æ+8899<æ+
8889+9æ"+,8888;;;;;;;;;;9æ+=888?æ,8899<æ,
8889,9æ",,8888;;;;;;;;;;9æ,=888?æ-8899<æ-
8889-9æ"-,8888;;;;;;;;;;9æ-=888?æ.8899<æ.
8889.9æ".,8888;;;;;;;;;;9æ.=888?æ/8899<æ/
8889/9æ"/,8888;;;;;;;;;;9æ/=888?æ08899<æ0
888909æ"0,8888;;;;;;;;;;9æ0=888?æ18899<æ1
888919æ"1,8888;;;;;;;;;;9æ1=888?æ28899<æ2
888929æ"2,8888;;;;;;;;;;9æ2=888?æ38899<æ3
888939æ"3,8888;;;;;;;;;;9æ3=888?æ48899<æ4
888949æ"4,8888;;;;;;;;;;9æ4=888?æ58899<æ5
888959æ"5,8888;;;;;;;;;;9æ5=888?æ68899<æ6
888969æ"6,8888;;;;;;;;;;9æ6=888?æ78899<æ7
888979æ"7,8888;;;;;;;;;;9æ7=888?æ88899<æ8
888989æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888?æ:8899<æ:
8889:9æ":,8888;;;;;;;;;;9æ:=888?æ;8899<æ;
8889;9æ";,8888;;;;;;;;;;9æ;=888?æ<8899<æ<
8889<9æ"<,8888;;;;;;;;;;9æ<=888?æ=8899<æ=
8889=9æ"=,8888;;;;;;;;;;9æ==888?æ>8899<æ>
8889>9æ">,8888;;;;;;;;;;9æ>=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@@í?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@í?7H@í?7I@í?7J@í?7K@í?7L@í?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7T@í?7U@í?7V@í?7W@í?7X@í?7Y@í?7Z@í?7[@í?7\@í?7]@í?7^@í?7_@í?7æ@8899<æ@
8889@9æ"@,8888;;;;;;;;;;9æ@=888?æA8899<æA
8889A9æ"A,8888;;;;;;;;;;9æA=888?æB8899<æB
8889B9æ"B,8888;;;;;;;;;;9æB=888?æC8899<æC
8889C9æ"C,8888;;;;;;;;;;9æC=888?æD8899<æD
8889D9æ"D,8888;;;;;;;;;;9æD=888?æE8899<æE
8889E9æ"E,8888;;;;;;;;;;9æE=888?æF8899<æF
8889F9æ"F,8888;;;;;;;;;;9æF=888?æG8899<æG
8889G9æ"G,8888;;;;;;;;;;9æG=888?æH8899<æH
8889H9æ"H,8888;;;;;;;;;;9æH=888?æI8899<æI
8889I9æ"I,8888;;;;;;;;;;9æI=888?æJ8899<æJ
8889J9æ"J,8888;;;;;;;;;;9æJ=888?æK8899<æK
8889K9æ"K,8888;;;;;;;;;;9æK=888?æL8899<æL
8889L9æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888?æN8899<æN
8889N9æ"N,8888;;;;;;;;;;9æN=888?æO8899<æO
8889O9æ"O,8888;;;;;;;;;;9æO=888?æP8899<æP
8889P9æ"P,8888;;;;;;;;;;9æP=888?æQ8899<æQ
8889Q9æ"Q,8888;;;;;;;;;;9æQ=888?æR8899<æR
8889R9æ"R,8888;;;;;;;;;;9æR=888?æS8899<æS
8889S9æ"S,8888;;;;;;;;;;9æS=888?æT8899<æT
8889T9æ"T,8888;;;;;;;;;;9æT=888?æU8899<æU
8889U9æ"U,8888;;;;;;;;;;9æU=888?æV8899<æV
8889V9æ"V,8888;;;;;;;;;;9æV=888?æW8899<æW
8889W9æ"W,8888;;;;;;;;;;9æW=888?æX8899<æX
8889X9æ"X,8888;;;;;;;;;;9æX=888?æY8899<æY
8889Y9æ"Y,8888;;;;;;;;;;9æY=888?æZ8899<æZ
8889Z9æ"Z,8888;;;;;;;;;;9æZ=888?æ[8899<æ[
8889[9æ"[,8888;;;;;;;;;;9æ[=888?æ\8899<æ\
8889\9æ"\,8888;;;;;;;;;;9æ\=888?æ]8899<æ]
8889]9æ"],8888;;;;;;;;;;9æ]=888?æ^8899<æ^
8889^9æ"^,8888;;;;;;;;;;9æ^=888?æ_8899<æ_
8889_9æ"_,8888;;;;;;;;;;9æ_=888?◊D@lfffffffffffffffffffffffffffffff`@í?7a@í?7b@í?7c@í?7d@í?7e@í?7f@í?7g@í?7h@í?7i@í?7j@í?7k@í?7l@í?7m@í?7n@í?7o@í?7p@í?7q@í?7r@í?7s@í?7t@í?7u@í?7v@í?7w@í?7x@í?7y@í?7z@í?7{@í?7|@í?7}@í?7~@í?7@í?7æ`8899<æ`
8889`9æ"`,8888;;;;;;;;;;9æ`=888?æa8899<æa
8889a9æ"a,8888;;;;;;;;;;9æa=888?æb8899<æb
8889b9æ"b,8888;;;;;;;;;;9æb=888?æc8899<æc
8889c9æ"c,8888;;;;;;;;;;9æc=888?æd8899<æd
8889d9æ"d,8888;;;;;;;;;;9æd=888?æe8899<æe
8889e9æ"e,8888;;;;;;;;;;9æe=888?æf8899<æf
8889f9æ"f,8888;;;;;;;;;;9æf=888?æg8899<æg
8889g9æ"g,8888;;;;;;;;;;9æg=888?æh8899<æh
8889h9æ"h,8888;;;;;;;;;;9æh=888?æi8899<æi
8889i9æ"i,8888;;;;;;;;;;9æi=888?æj8899<æj
8889j9æ"j,8888;;;;;;;;;;9æj=888?æk8899<æk
8889k9æ"k,8888;;;;;;;;;;9æk=888?æl8899<æl
8889l9æ"l,8888;;;;;;;;;;9æl=888?æm8899<æm
8889m9æ"m,8888;;;;;;;;;;9æm=888?æn8899<æn
8889n9æ"n,8888;;;;;;;;;;9æn=888?æo8899<æo
8889o9æ"o,8888;;;;;;;;;;9æo=888?æp8899<æp
8889p9æ"p,8888;;;;;;;;;;9æp=888?æq8899<æq
8889q9æ"q,8888;;;;;;;;;;9æq=888?ær8899<ær
8889r9æ"r,8888;;;;;;;;;;9ær=888?æs8899<æs
8889s9æ"s,8888;;;;;;;;;;9æs=888?æt8899<æt
8889t9æ"t,8888;;;;;;;;;;9æt=888?æu8899<æu
8889u9æ"u,8888;;;;;;;;;;9æu=888?æv8899<æv
8889v9æ"v,8888;;;;;;;;;;9æv=888?æw8899<æw
8889w9æ"w,8888;;;;;;;;;;9æw=888?æx8899<æx
8889x9æ"x,8888;;;;;;;;;;9æx=888?æy8899<æy
8889y9æ"y,8888;;;;;;;;;;9æy=888?æz8899<æz
8889z9æ"z,8888;;;;;;;;;;9æz=888?æ{8899<æ{
8889{9æ"{,8888;;;;;;;;;;9æ{=888?æ|8899<æ|
8889|9æ"|,8888;;;;;;;;;;9æ|=888?æ}8899<æ}
8889}9æ"},8888;;;;;;;;;;9æ}=888?æ~8899<æ~
8889~9æ"~,8888;;;;;;;;;;9æ~=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffffÄ@í?7Å@í?7Ç@í?7?@í?7Ñ@í?7Ö@í?7Ü@í?7á@í?7?@í?7â@í?7–@í?7ã@í?7?@í?7?@í?7ﬁ@í?7?@í?7ê@í?7ë@í?7í@í?7ì@í?7î@í?7ï@í?7ñ@í?7ó@í?7?@í?7ô@í?7@í?7õ@í?7?@í?7?@í?7˛@í?7?@í?7æÄ8899<æÄ
8889Ä9æ"Ä,8888;;;;;;;;;;9æÄ=888?æÅ8899<æÅ
8889Å9æ"Å,8888;;;;;;;;;;9æÅ=888?æÇ8899<æÇ
8889Ç9æ"Ç,8888;;;;;;;;;;9æÇ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÑ8899<æÑ
8889Ñ9æ"Ñ,8888;;;;;;;;;;9æÑ=888?æÖ8899<æÖ
8889Ö9æ"Ö,8888;;;;;;;;;;9æÖ=888?æÜ8899<æÜ
8889Ü9æ"Ü,8888;;;;;;;;;;9æÜ=888?æá8899<æá
8889á9æ"á,8888;;;;;;;;;;9æá=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æâ8899<æâ
8889â9æ"â,8888;;;;;;;;;;9æâ=888?æ–8899<æ–
8889–9æ"–,8888;;;;;;;;;;9æ–=888?æã8899<æã
8889ã9æ"ã,8888;;;;;;;;;;9æã=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬁ8899<æﬁ
8889ﬁ9æ"ﬁ,8888;;;;;;;;;;9æﬁ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æê8899<æê
8889ê9æ"ê,8888;;;;;;;;;;9æê=888?æë8899<æë
8889ë9æ"ë,8888;;;;;;;;;;9æë=888?æí8899<æí
8889í9æ"í,8888;;;;;;;;;;9æí=888?æì8899<æì
8889ì9æ"ì,8888;;;;;;;;;;9æì=888?æî8899<æî
8889î9æ"î,8888;;;;;;;;;;9æî=888?æï8899<æï
8889ï9æ"ï,8888;;;;;;;;;;9æï=888?æñ8899<æñ
8889ñ9æ"ñ,8888;;;;;;;;;;9æñ=888?æó8899<æó
8889ó9æ"ó,8888;;;;;;;;;;9æó=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æô8899<æô
8889ô9æ"ô,8888;;;;;;;;;;9æô=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æõ8899<æõ
8889õ9æ"õ,8888;;;;;;;;;;9æõ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ˛8899<æ˛
8889˛9æ"˛,8888;;;;;;;;;;9æ˛=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff @í?7?@í?7¢@í?7£@í?7§@í?7?@í?7¶@í?7ß@í?7ç@í?7©@í?7?@í?7´@í?7¨@í?7≠@í?7Æ@í?7ù@í?7∞@í?7±@í?7≤@í?7≥@í?7¥@í?7µ@í?7∂@í?7∑@í?7è@í?7π@í?7?@í?7ª@í?7º@í?7Ω@í?7æ@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¢8899<æ¢
8889¢9æ"¢,8888;;;;;;;;;;9æ¢=888?æ£8899<æ£
8889£9æ"£,8888;;;;;;;;;;9æ£=888?æ§8899<æ§
8889§9æ"§,8888;;;;;;;;;;9æ§=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¶8899<æ¶
8889¶9æ"¶,8888;;;;;;;;;;9æ¶=888?æß8899<æß
8889ß9æ"ß,8888;;;;;;;;;;9æß=888?æç8899<æç
8889ç9æ"ç,8888;;;;;;;;;;9æç=888?æ©8899<æ©
8889©9æ"©,8888;;;;;;;;;;9æ©=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ´8899<æ´
8889´9æ"´,8888;;;;;;;;;;9æ´=888?æ¨8899<æ¨
8889¨9æ"¨,8888;;;;;;;;;;9æ¨=888?æ≠8899<æ≠
8889≠9æ"≠,8888;;;;;;;;;;9æ≠=888?æÆ8899<æÆ
8889Æ9æ"Æ,8888;;;;;;;;;;9æÆ=888?æù8899<æù
8889ù9æ"ù,8888;;;;;;;;;;9æù=888?æ∞8899<æ∞
8889∞9æ"∞,8888;;;;;;;;;;9æ∞=888?æ±8899<æ±
8889±9æ"±,8888;;;;;;;;;;9æ±=888?æ≤8899<æ≤
8889≤9æ"≤,8888;;;;;;;;;;9æ≤=888?æ≥8899<æ≥
8889≥9æ"≥,8888;;;;;;;;;;9æ≥=888?æ¥8899<æ¥
8889¥9æ"¥,8888;;;;;;;;;;9æ¥=888?æµ8899<æµ
8889µ9æ"µ,8888;;;;;;;;;;9æµ=888?æ∂8899<æ∂
8889∂9æ"∂,8888;;;;;;;;;;9æ∂=888?æ∑8899<æ∑
8889∑9æ"∑,8888;;;;;;;;;;9æ∑=888?æè8899<æè
8889è9æ"è,8888;;;;;;;;;;9æè=888?æπ8899<æπ
8889π9æ"π,8888;;;;;;;;;;9æπ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æª8899<æª
8889ª9æ"ª,8888;;;;;;;;;;9æª=888?æº8899<æº
8889º9æ"º,8888;;;;;;;;;;9æº=888?æΩ8899<æΩ
8889Ω9æ"Ω,8888;;;;;;;;;;9æΩ=888?ææ8899<ææ
8889æ9æ"æ,8888;;;;;;;;;;9ææ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lffffÅÇ?ÑÖÜá?â–ã??ﬁ?êëíìîïñó?ôõ??˛? ?¢£§?¶ßç©?´¨≠Æù∞±≤≥¥µ∂∑èπ?ªºΩæ?????ƒ≈Ø??…?????????”?’÷◊®???‹??ﬂ????‰ø??????È?????????Û?ıˆ˜∏???¸???fffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7ƒ@í?7≈@í?7Ø@í?7?@í?7?@í?7…@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7”@í?7?@í?7’@í?7÷@í?7◊@í?7®@í?7?@í?7?@í?7?@í?7‹@í?7?@í?7?@í?7ﬂ@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æƒ8899<æƒ
8889ƒ9æ"ƒ,8888;;;;;;;;;;9æƒ=888?æ≈8899<æ≈
8889≈9æ"≈,8888;;;;;;;;;;9æ≈=888?æØ8899<æØ
8889Ø9æ"Ø,8888;;;;;;;;;;9æØ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ…8899<æ…
8889…9æ"…,8888;;;;;;;;;;9æ…=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ”8899<æ”
8889”9æ"”,8888;;;;;;;;;;9æ”=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ’8899<æ’
8889’9æ"’,8888;;;;;;;;;;9æ’=888?æ÷8899<æ÷
8889÷9æ"÷,8888;;;;;;;;;;9æ÷=888?æ◊8899<æ◊
8889◊9æ"◊,8888;;;;;;;;;;9æ◊=888?æ®8899<æ®
8889®9æ"®,8888;;;;;;;;;;9æ®=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‹8899<æ‹
8889‹9æ"‹,8888;;;;;;;;;;9æ‹=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬂ8899<æﬂ
8889ﬂ9æ"ﬂ,8888;;;;;;;;;;9æﬂ=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7‰@í?7Â@í?7ø@í?7?@í?7?@í?7È@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7Û@í?7?@í?7ı@í?7ˆ@í?7˜@í?7∏@í?7?@í?7?@í?7?@í?7¸@í?7?@í?7?@í?7?@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‰8899<æ‰
8889‰9æ"‰,8888;;;;;;;;;;9æ‰=888?æÂ8899<æÂ
8889Â9æ"Â,8888;;;;;;;;;;9æÂ=888?æø8899<æø
8889ø9æ"ø,8888;;;;;;;;;;9æø=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÈ8899<æÈ
8889È9æ"È,8888;;;;;;;;;;9æÈ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÛ8899<æÛ
8889Û9æ"Û,8888;;;;;;;;;;9æÛ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æı8899<æı
8889ı9æ"ı,8888;;;;;;;;;;9æı=888?æˆ8899<æˆ
8889ˆ9æ"ˆ,8888;;;;;;;;;;9æˆ=888?æ˜8899<æ˜
8889˜9æ"˜,8888;;;;;;;;;;9æ˜=888?æ∏8899<æ∏
8889∏9æ"∏,8888;;;;;;;;;;9æ∏=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¸8899<æ¸
8889¸9æ"¸,8888;;;;;;;;;;9æ¸=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7	@í?7
@í?7@í?7@í?7
@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffff @í?7!@í?7"@í?7#@í?7$@í?7%@í?7&@í?7'@í?7(@í?7)@í?7*@í?7+@í?7,@í?7-@í?7.@í?7/@í?70@í?71@í?72@í?73@í?74@í?75@í?76@í?77@í?78@í?79@í?7:@í?7;@í?7<@í?7=@í?7>@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ!8899<æ!
8889!9æ"!,8888;;;;;;;;;;9æ!=888?æ"8899<æ"
8889"9æ"",8888;;;;;;;;;;9æ"=888?æ#8899<æ#
8889#9æ"#,8888;;;;;;;;;;9æ#=888?æ$8899<æ$
8889$9æ"$,8888;;;;;;;;;;9æ$=888?æ%8899<æ%
8889%9æ"%,8888;;;;;;;;;;9æ%=888?æ&8899<æ&
8889&9æ"&,8888;;;;;;;;;;9æ&=888?æ'8899<æ'
8889'9æ"',8888;;;;;;;;;;9æ'=888?æ(8899<æ(
8889(9æ"(,8888;;;;;;;;;;9æ(=888?æ)8899<æ)
8889)9æ"),8888;;;;;;;;;;9æ)=888?æ*8899<æ*
8889*9æ"*,8888;;;;;;;;;;9æ*=888?æ+8899<æ+
8889+9æ"+,8888;;;;;;;;;;9æ+=888?æ,8899<æ,
8889,9æ",,8888;;;;;;;;;;9æ,=888?æ-8899<æ-
8889-9æ"-,8888;;;;;;;;;;9æ-=888?æ.8899<æ.
8889.9æ".,8888;;;;;;;;;;9æ.=888?æ/8899<æ/
8889/9æ"/,8888;;;;;;;;;;9æ/=888?æ08899<æ0
888909æ"0,8888;;;;;;;;;;9æ0=888?æ18899<æ1
888919æ"1,8888;;;;;;;;;;9æ1=888?æ28899<æ2
888929æ"2,8888;;;;;;;;;;9æ2=888?æ38899<æ3
888939æ"3,8888;;;;;;;;;;9æ3=888?æ48899<æ4
888949æ"4,8888;;;;;;;;;;9æ4=888?æ58899<æ5
888959æ"5,8888;;;;;;;;;;9æ5=888?æ68899<æ6
888969æ"6,8888;;;;;;;;;;9æ6=888?æ78899<æ7
888979æ"7,8888;;;;;;;;;;9æ7=888?æ88899<æ8
888989æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888?æ:8899<æ:
8889:9æ":,8888;;;;;;;;;;9æ:=888?æ;8899<æ;
8889;9æ";,8888;;;;;;;;;;9æ;=888?æ<8899<æ<
8889<9æ"<,8888;;;;;;;;;;9æ<=888?æ=8899<æ=
8889=9æ"=,8888;;;;;;;;;;9æ==888?æ>8899<æ>
8889>9æ">,8888;;;;;;;;;;9æ>=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@@í?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@í?7H@í?7I@í?7J@í?7K@í?7L@í?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7T@í?7U@í?7V@í?7W@í?7X@í?7Y@í?7Z@í?7[@í?7\@í?7]@í?7^@í?7_@í?7æ@8899<æ@
8889@9æ"@,8888;;;;;;;;;;9æ@=888?æA8899<æA
8889A9æ"A,8888;;;;;;;;;;9æA=888?æB8899<æB
8889B9æ"B,8888;;;;;;;;;;9æB=888?æC8899<æC
8889C9æ"C,8888;;;;;;;;;;9æC=888?æD8899<æD
8889D9æ"D,8888;;;;;;;;;;9æD=888?æE8899<æE
8889E9æ"E,8888;;;;;;;;;;9æE=888?æF8899<æF
8889F9æ"F,8888;;;;;;;;;;9æF=888?æG8899<æG
8889G9æ"G,8888;;;;;;;;;;9æG=888?æH8899<æH
8889H9æ"H,8888;;;;;;;;;;9æH=888?æI8899<æI
8889I9æ"I,8888;;;;;;;;;;9æI=888?æJ8899<æJ
8889J9æ"J,8888;;;;;;;;;;9æJ=888?æK8899<æK
8889K9æ"K,8888;;;;;;;;;;9æK=888?æL8899<æL
8889L9æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888?æN8899<æN
8889N9æ"N,8888;;;;;;;;;;9æN=888?æO8899<æO
8889O9æ"O,8888;;;;;;;;;;9æO=888?æP8899<æP
8889P9æ"P,8888;;;;;;;;;;9æP=888?æQ8899<æQ
8889Q9æ"Q,8888;;;;;;;;;;9æQ=888?æR8899<æR
8889R9æ"R,8888;;;;;;;;;;9æR=888?æS8899<æS
8889S9æ"S,8888;;;;;;;;;;9æS=888?æT8899<æT
8889T9æ"T,8888;;;;;;;;;;9æT=888?æU8899<æU
8889U9æ"U,8888;;;;;;;;;;9æU=888?æV8899<æV
8889V9æ"V,8888;;;;;;;;;;9æV=888?æW8899<æW
8889W9æ"W,8888;;;;;;;;;;9æW=888?æX8899<æX
8889X9æ"X,8888;;;;;;;;;;9æX=888?æY8899<æY
8889Y9æ"Y,8888;;;;;;;;;;9æY=888?æZ8899<æZ
8889Z9æ"Z,8888;;;;;;;;;;9æZ=888?æ[8899<æ[
8889[9æ"[,8888;;;;;;;;;;9æ[=888?æ\8899<æ\
8889\9æ"\,8888;;;;;;;;;;9æ\=888?æ]8899<æ]
8889]9æ"],8888;;;;;;;;;;9æ]=888?æ^8899<æ^
8889^9æ"^,8888;;;;;;;;;;9æ^=888?æ_8899<æ_
8889_9æ"_,8888;;;;;;;;;;9æ_=888?◊D@lfffffffffffffffffffffffffffffff`@í?7a@í?7b@í?7c@í?7d@í?7e@í?7f@í?7g@í?7h@í?7i@í?7j@í?7k@í?7l@í?7m@í?7n@í?7o@í?7p@í?7q@í?7r@í?7s@í?7t@í?7u@í?7v@í?7w@í?7x@í?7y@í?7z@í?7{@í?7|@í?7}@í?7~@í?7@í?7æ`8899<æ`
8889`9æ"`,8888;;;;;;;;;;9æ`=888?æa8899<æa
8889a9æ"a,8888;;;;;;;;;;9æa=888?æb8899<æb
8889b9æ"b,8888;;;;;;;;;;9æb=888?æc8899<æc
8889c9æ"c,8888;;;;;;;;;;9æc=888?æd8899<æd
8889d9æ"d,8888;;;;;;;;;;9æd=888?æe8899<æe
8889e9æ"e,8888;;;;;;;;;;9æe=888?æf8899<æf
8889f9æ"f,8888;;;;;;;;;;9æf=888?æg8899<æg
8889g9æ"g,8888;;;;;;;;;;9æg=888?æh8899<æh
8889h9æ"h,8888;;;;;;;;;;9æh=888?æi8899<æi
8889i9æ"i,8888;;;;;;;;;;9æi=888?æj8899<æj
8889j9æ"j,8888;;;;;;;;;;9æj=888?æk8899<æk
8889k9æ"k,8888;;;;;;;;;;9æk=888?æl8899<æl
8889l9æ"l,8888;;;;;;;;;;9æl=888?æm8899<æm
8889m9æ"m,8888;;;;;;;;;;9æm=888?æn8899<æn
8889n9æ"n,8888;;;;;;;;;;9æn=888?æo8899<æo
8889o9æ"o,8888;;;;;;;;;;9æo=888?æp8899<æp
8889p9æ"p,8888;;;;;;;;;;9æp=888?æq8899<æq
8889q9æ"q,8888;;;;;;;;;;9æq=888?ær8899<ær
8889r9æ"r,8888;;;;;;;;;;9ær=888?æs8899<æs
8889s9æ"s,8888;;;;;;;;;;9æs=888?æt8899<æt
8889t9æ"t,8888;;;;;;;;;;9æt=888?æu8899<æu
8889u9æ"u,8888;;;;;;;;;;9æu=888?æv8899<æv
8889v9æ"v,8888;;;;;;;;;;9æv=888?æw8899<æw
8889w9æ"w,8888;;;;;;;;;;9æw=888?æx8899<æx
8889x9æ"x,8888;;;;;;;;;;9æx=888?æy8899<æy
8889y9æ"y,8888;;;;;;;;;;9æy=888?æz8899<æz
8889z9æ"z,8888;;;;;;;;;;9æz=888?æ{8899<æ{
8889{9æ"{,8888;;;;;;;;;;9æ{=888?æ|8899<æ|
8889|9æ"|,8888;;;;;;;;;;9æ|=888?æ}8899<æ}
8889}9æ"},8888;;;;;;;;;;9æ}=888?æ~8899<æ~
8889~9æ"~,8888;;;;;;;;;;9æ~=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffffÄ@í?7Å@í?7Ç@í?7?@í?7Ñ@í?7Ö@í?7Ü@í?7á@í?7?@í?7â@í?7–@í?7ã@í?7?@í?7?@í?7ﬁ@í?7?@í?7ê@í?7ë@í?7í@í?7ì@í?7î@í?7ï@í?7ñ@í?7ó@í?7?@í?7ô@í?7@í?7õ@í?7?@í?7?@í?7˛@í?7?@í?7æÄ8899<æÄ
8889Ä9æ"Ä,8888;;;;;;;;;;9æÄ=888?æÅ8899<æÅ
8889Å9æ"Å,8888;;;;;;;;;;9æÅ=888?æÇ8899<æÇ
8889Ç9æ"Ç,8888;;;;;;;;;;9æÇ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÑ8899<æÑ
8889Ñ9æ"Ñ,8888;;;;;;;;;;9æÑ=888?æÖ8899<æÖ
8889Ö9æ"Ö,8888;;;;;;;;;;9æÖ=888?æÜ8899<æÜ
8889Ü9æ"Ü,8888;;;;;;;;;;9æÜ=888?æá8899<æá
8889á9æ"á,8888;;;;;;;;;;9æá=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æâ8899<æâ
8889â9æ"â,8888;;;;;;;;;;9æâ=888?æ–8899<æ–
8889–9æ"–,8888;;;;;;;;;;9æ–=888?æã8899<æã
8889ã9æ"ã,8888;;;;;;;;;;9æã=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬁ8899<æﬁ
8889ﬁ9æ"ﬁ,8888;;;;;;;;;;9æﬁ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æê8899<æê
8889ê9æ"ê,8888;;;;;;;;;;9æê=888?æë8899<æë
8889ë9æ"ë,8888;;;;;;;;;;9æë=888?æí8899<æí
8889í9æ"í,8888;;;;;;;;;;9æí=888?æì8899<æì
8889ì9æ"ì,8888;;;;;;;;;;9æì=888?æî8899<æî
8889î9æ"î,8888;;;;;;;;;;9æî=888?æï8899<æï
8889ï9æ"ï,8888;;;;;;;;;;9æï=888?æñ8899<æñ
8889ñ9æ"ñ,8888;;;;;;;;;;9æñ=888?æó8899<æó
8889ó9æ"ó,8888;;;;;;;;;;9æó=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æô8899<æô
8889ô9æ"ô,8888;;;;;;;;;;9æô=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æõ8899<æõ
8889õ9æ"õ,8888;;;;;;;;;;9æõ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ˛8899<æ˛
8889˛9æ"˛,8888;;;;;;;;;;9æ˛=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff @í?7?@í?7¢@í?7£@í?7§@í?7?@í?7¶@í?7ß@í?7ç@í?7©@í?7?@í?7´@í?7¨@í?7≠@í?7Æ@í?7ù@í?7∞@í?7±@í?7≤@í?7≥@í?7¥@í?7µ@í?7∂@í?7∑@í?7è@í?7π@í?7?@í?7ª@í?7º@í?7Ω@í?7æ@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¢8899<æ¢
8889¢9æ"¢,8888;;;;;;;;;;9æ¢=888?æ£8899<æ£
8889£9æ"£,8888;;;;;;;;;;9æ£=888?æ§8899<æ§
8889§9æ"§,8888;;;;;;;;;;9æ§=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¶8899<æ¶
8889¶9æ"¶,8888;;;;;;;;;;9æ¶=888?æß8899<æß
8889ß9æ"ß,8888;;;;;;;;;;9æß=888?æç8899<æç
8889ç9æ"ç,8888;;;;;;;;;;9æç=888?æ©8899<æ©
8889©9æ"©,8888;;;;;;;;;;9æ©=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ´8899<æ´
8889´9æ"´,8888;;;;;;;;;;9æ´=888?æ¨8899<æ¨
8889¨9æ"¨,8888;;;;;;;;;;9æ¨=888?æ≠8899<æ≠
8889≠9æ"≠,8888;;;;;;;;;;9æ≠=888?æÆ8899<æÆ
8889Æ9æ"Æ,8888;;;;;;;;;;9æÆ=888?æù8899<æù
8889ù9æ"ù,8888;;;;;;;;;;9æù=888?æ∞8899<æ∞
8889∞9æ"∞,8888;;;;;;;;;;9æ∞=888?æ±8899<æ±
8889±9æ"±,8888;;;;;;;;;;9æ±=888?æ≤8899<æ≤
8889≤9æ"≤,8888;;;;;;;;;;9æ≤=888?æ≥8899<æ≥
8889≥9æ"≥,8888;;;;;;;;;;9æ≥=888?æ¥8899<æ¥
8889¥9æ"¥,8888;;;;;;;;;;9æ¥=888?æµ8899<æµ
8889µ9æ"µ,8888;;;;;;;;;;9æµ=888?æ∂8899<æ∂
8889∂9æ"∂,8888;;;;;;;;;;9æ∂=888?æ∑8899<æ∑
8889∑9æ"∑,8888;;;;;;;;;;9æ∑=888?æè8899<æè
8889è9æ"è,8888;;;;;;;;;;9æè=888?æπ8899<æπ
8889π9æ"π,8888;;;;;;;;;;9æπ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æª8899<æª
8889ª9æ"ª,8888;;;;;;;;;;9æª=888?æº8899<æº
8889º9æ"º,8888;;;;;;;;;;9æº=888?æΩ8899<æΩ
8889Ω9æ"Ω,8888;;;;;;;;;;9æΩ=888?ææ8899<ææ
8889æ9æ"æ,8888;;;;;;;;;;9ææ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7ƒ@í?7≈@í?7Ø@í?7?@í?7?@í?7…@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7”@í?7?@í?7’@í?7÷@í?7◊@í?7®@í?7?@í?7?@í?7?@í?7‹@í?7?@í?7?@í?7ﬂ@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æƒ8899<æƒ
8889ƒ9æ"ƒ,8888;;;;;;;;;;9æƒ=888?æ≈8899<æ≈
8889≈9æ"≈,8888;;;;;;;;;;9æ≈=888?æØ8899<æØ
8889Ø9æ"Ø,8888;;;;;;;;;;9æØ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ…8899<æ…
8889…9æ"…,8888;;;;;;;;;;9æ…=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ”8899<æ”
8889”9æ"”,8888;;;;;;;;;;9æ”=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ’8899<æ’
8889’9æ"’,8888;;;;;;;;;;9æ’=888?æ÷8899<æ÷
8889÷9æ"÷,8888;;;;;;;;;;9æ÷=888?æ◊8899<æ◊
8889◊9æ"◊,8888;;;;;;;;;;9æ◊=888?æ®8899<æ®
8889®9æ"®,8888;;;;;;;;;;9æ®=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‹8899<æ‹
8889‹9æ"‹,8888;;;;;;;;;;9æ‹=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬂ8899<æﬂ
8889ﬂ9æ"ﬂ,8888;;;;;;;;;;9æﬂ=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7‰@í?7Â@í?7ø@í?7?@í?7?@í?7È@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7Û@í?7?@í?7ı@í?7ˆ@í?7˜@í?7∏@í?7?@í?7?@í?7?@í?7¸@í?7?@í?7?@í?7?@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‰8899<æ‰
8889‰9æ"‰,8888;;;;;;;;;;9æ‰=888?æÂ8899<æÂ
8889Â9æ"Â,8888;;;;;;;;;;9æÂ=888?æø8899<æø
8889ø9æ"ø,8888;;;;;;;;;;9æø=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÈ8899<æÈ
8889È9æ"È,8888;;;;;;;;;;9æÈ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÛ8899<æÛ
8889Û9æ"Û,8888;;;;;;;;;;9æÛ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æı8899<æı
8889ı9æ"ı,8888;;;;;;;;;;9æı=888?æˆ8899<æˆ
8889ˆ9æ"ˆ,8888;;;;;;;;;;9æˆ=888?æ˜8899<æ˜
8889˜9æ"˜,8888;;;;;;;;;;9æ˜=888?æ∏8899<æ∏
8889∏9æ"∏,8888;;;;;;;;;;9æ∏=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¸8899<æ¸
8889¸9æ"¸,8888;;;;;;;;;;9æ¸=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7	@í?7
@í?7@í?7@í?7
@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffff @í?7!@í?7"@í?7#@í?7$@í?7%@í?7&@í?7'@í?7(@í?7)@í?7*@í?7+@í?7,@í?7-@í?7.@í?7/@í?70@í?71@í?72@í?73@í?74@í?75@í?76@í?77@í?78@í?79@í?7:@í?7;@í?7<@í?7=@í?7>@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ!8899<æ!
8889!9æ"!,8888;;;;;;;;;;9æ!=888?æ"8899<æ"
8889"9æ"",8888;;;;;;;;;;9æ"=888?æ#8899<æ#
8889#9æ"#,8888;;;;;;;;;;9æ#=888?æ$8899<æ$
8889$9æ"$,8888;;;;;;;;;;9æ$=888?æ%8899<æ%
8889%9æ"%,8888;;;;;;;;;;9æ%=888?æ&8899<æ&
8889&9æ"&,8888;;;;;;;;;;9æ&=888?æ'8899<æ'
8889'9æ"',8888;;;;;;;;;;9æ'=888?æ(8899<æ(
8889(9æ"(,8888;;;;;;;;;;9æ(=888?æ)8899<æ)
8889)9æ"),8888;;;;;;;;;;9æ)=888?æ*8899<æ*
8889*9æ"*,8888;;;;;;;;;;9æ*=888?æ+8899<æ+
8889+9æ"+,8888;;;;;;;;;;9æ+=888?æ,8899<æ,
8889,9æ",,8888;;;;;;;;;;9æ,=888?æ-8899<æ-
8889-9æ"-,8888;;;;;;;;;;9æ-=888?æ.8899<æ.
8889.9æ".,8888;;;;;;;;;;9æ.=888?æ/8899<æ/
8889/9æ"/,8888;;;;;;;;;;9æ/=888?æ08899<æ0
888909æ"0,8888;;;;;;;;;;9æ0=888?æ18899<æ1
888919æ"1,8888;;;;;;;;;;9æ1=888?æ28899<æ2
888929æ"2,8888;;;;;;;;;;9æ2=888?æ38899<æ3
888939æ"3,8888;;;;;;;;;;9æ3=888?æ48899<æ4
888949æ"4,8888;;;;;;;;;;9æ4=888?æ58899<æ5
888959æ"5,8888;;;;;;;;;;9æ5=888?æ68899<æ6
888969æ"6,8888;;;;;;;;;;9æ6=888?æ78899<æ7
888979æ"7,8888;;;;;;;;;;9æ7=888?æ88899<æ8
888989æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888?æ:8899<æ:
8889:9æ":,8888;;;;;;;;;;9æ:=888?æ;8899<æ;
8889;9æ";,8888;;;;;;;;;;9æ;=888?æ<8899<æ<
8889<9æ"<,8888;;;;;;;;;;9æ<=888?æ=8899<æ=
8889=9æ"=,8888;;;;;;;;;;9æ==888?æ>8899<æ>
8889>9æ">,8888;;;;;;;;;;9æ>=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@@í?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@í?7H@í?7I@í?7J@í?7K@í?7L@í?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7T@í?7U@í?7V@í?7W@í?7X@í?7Y@í?7Z@í?7[@í?7\@í?7]@í?7^@í?7_@í?7æ@8899<æ@
8889@9æ"@,8888;;;;;;;;;;9æ@=888?æA8899<æA
8889A9æ"A,8888;;;;;;;;;;9æA=888?æB8899<æB
8889B9æ"B,8888;;;;;;;;;;9æB=888?æC8899<æC
8889C9æ"C,8888;;;;;;;;;;9æC=888?æD8899<æD
8889D9æ"D,8888;;;;;;;;;;9æD=888?æE8899<æE
8889E9æ"E,8888;;;;;;;;;;9æE=888?æF8899<æF
8889F9æ"F,8888;;;;;;;;;;9æF=888?æG8899<æG
8889G9æ"G,8888;;;;;;;;;;9æG=888?æH8899<æH
8889H9æ"H,8888;;;;;;;;;;9æH=888?æI8899<æI
8889I9æ"I,8888;;;;;;;;;;9æI=888?æJ8899<æJ
8889J9æ"J,8888;;;;;;;;;;9æJ=888?æK8899<æK
8889K9æ"K,8888;;;;;;;;;;9æK=888?æL8899<æL
8889L9æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888?æN8899<æN
8889N9æ"N,8888;;;;;;;;;;9æN=888?æO8899<æO
8889O9æ"O,8888;;;;;;;;;;9æO=888?æP8899<æP
8889P9æ"P,8888;;;;;;;;;;9æP=888?æQ8899<æQ
8889Q9æ"Q,8888;;;;;;;;;;9æQ=888?æR8899<æR
8889R9æ"R,8888;;;;;;;;;;9æR=888?æS8899<æS
8889S9æ"S,8888;;;;;;;;;;9æS=888?æT8899<æT
8889T9æ"T,8888;;;;;;;;;;9æT=888?æU8899<æU
8889U9æ"U,8888;;;;;;;;;;9æU=888?æV8899<æV
8889V9æ"V,8888;;;;;;;;;;9æV=888?æW8899<æW
8889W9æ"W,8888;;;;;;;;;;9æW=888?æX8899<æX
8889X9æ"X,8888;;;;;;;;;;9æX=888?æY8899<æY
8889Y9æ"Y,8888;;;;;;;;;;9æY=888?æZ8899<æZ
8889Z9æ"Z,8888;;;;;;;;;;9æZ=888?æ[8899<æ[
8889[9æ"[,8888;;;;;;;;;;9æ[=888?æ\8899<æ\
8889\9æ"\,8888;;;;;;;;;;9æ\=888?æ]8899<æ]
8889]9æ"],8888;;;;;;;;;;9æ]=888?æ^8899<æ^
8889^9æ"^,8888;;;;;;;;;;9æ^=888?æ_8899<æ_
8889_9æ"_,8888;;;;;;;;;;9æ_=888?◊D@lfffffffffffffffffffffffffffffff`@í?7a@í?7b@í?7c@í?7d@í?7e@í?7f@í?7g@í?7h@í?7i@í?7j@í?7k@í?7l@í?7m@í?7n@í?7o@í?7p@í?7q@í?7r@í?7s@í?7t@í?7u@í?7v@í?7w@í?7x@í?7y@í?7z@í?7{@í?7|@í?7}@í?7~@í?7@í?7æ`8899<æ`
8889`9æ"`,8888;;;;;;;;;;9æ`=888?æa8899<æa
8889a9æ"a,8888;;;;;;;;;;9æa=888?æb8899<æb
8889b9æ"b,8888;;;;;;;;;;9æb=888?æc8899<æc
8889c9æ"c,8888;;;;;;;;;;9æc=888?æd8899<æd
8889d9æ"d,8888;;;;;;;;;;9æd=888?æe8899<æe
8889e9æ"e,8888;;;;;;;;;;9æe=888?æf8899<æf
8889f9æ"f,8888;;;;;;;;;;9æf=888?æg8899<æg
8889g9æ"g,8888;;;;;;;;;;9æg=888?æh8899<æh
8889h9æ"h,8888;;;;;;;;;;9æh=888?æi8899<æi
8889i9æ"i,8888;;;;;;;;;;9æi=888?æj8899<æj
8889j9æ"j,8888;;;;;;;;;;9æj=888?æk8899<æk
8889k9æ"k,8888;;;;;;;;;;9æk=888?æl8899<æl
8889l9æ"l,8888;;;;;;;;;;9æl=888?æm8899<æm
8889m9æ"m,8888;;;;;;;;;;9æm=888?æn8899<æn
8889n9æ"n,8888;;;;;;;;;;9æn=888?æo8899<æo
8889o9æ"o,8888;;;;;;;;;;9æo=888?æp8899<æp
8889p9æ"p,8888;;;;;;;;;;9æp=888?æq8899<æq
8889q9æ"q,8888;;;;;;;;;;9æq=888?ær8899<ær
8889r9æ"r,8888;;;;;;;;;;9ær=888?æs8899<æs
8889s9æ"s,8888;;;;;;;;;;9æs=888?æt8899<æt
8889t9æ"t,8888;;;;;;;;;;9æt=888?æu8899<æu
8889u9æ"u,8888;;;;;;;;;;9æu=888?æv8899<æv
8889v9æ"v,8888;;;;;;;;;;9æv=888?æw8899<æw
8889w9æ"w,8888;;;;;;;;;;9æw=888?æx8899<æx
8889x9æ"x,8888;;;;;;;;;;9æx=888?æy8899<æy
8889y9æ"y,8888;;;;;;;;;;9æy=888?æz8899<æz
8889z9æ"z,8888;;;;;;;;;;9æz=888?æ{8899<æ{
8889{9æ"{,8888;;;;;;;;;;9æ{=888?æ|8899<æ|
8889|9æ"|,8888;;;;;;;;;;9æ|=888?æ}8899<æ}
8889}9æ"},8888;;;;;;;;;;9æ}=888?æ~8899<æ~
8889~9æ"~,8888;;;;;;;;;;9æ~=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffffÄ@í?7Å@í?7Ç@í?7?@í?7Ñ@í?7Ö@í?7Ü@í?7á@í?7?@í?7â@í?7–@í?7ã@í?7?@í?7?@í?7ﬁ@í?7?@í?7ê@í?7ë@í?7í@í?7ì@í?7î@í?7ï@í?7ñ@í?7ó@í?7?@í?7ô@í?7@í?7õ@í?7?@í?7?@í?7˛@í?7?@í?7æÄ8899<æÄ
8889Ä9æ"Ä,8888;;;;;;;;;;9æÄ=888?æÅ8899<æÅ
8889Å9æ"Å,8888;;;;;;;;;;9æÅ=888?æÇ8899<æÇ
8889Ç9æ"Ç,8888;;;;;;;;;;9æÇ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÑ8899<æÑ
8889Ñ9æ"Ñ,8888;;;;;;;;;;9æÑ=888?æÖ8899<æÖ
8889Ö9æ"Ö,8888;;;;;;;;;;9æÖ=888?æÜ8899<æÜ
8889Ü9æ"Ü,8888;;;;;;;;;;9æÜ=888?æá8899<æá
8889á9æ"á,8888;;;;;;;;;;9æá=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æâ8899<æâ
8889â9æ"â,8888;;;;;;;;;;9æâ=888?æ–8899<æ–
8889–9æ"–,8888;;;;;;;;;;9æ–=888?æã8899<æã
8889ã9æ"ã,8888;;;;;;;;;;9æã=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬁ8899<æﬁ
8889ﬁ9æ"ﬁ,8888;;;;;;;;;;9æﬁ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æê8899<æê
8889ê9æ"ê,8888;;;;;;;;;;9æê=888?æë8899<æë
8889ë9æ"ë,8888;;;;;;;;;;9æë=888?æí8899<æí
8889í9æ"í,8888;;;;;;;;;;9æí=888?æì8899<æì
8889ì9æ"ì,8888;;;;;;;;;;9æì=888?æî8899<æî
8889î9æ"î,8888;;;;;;;;;;9æî=888?æï8899<æï
8889ï9æ"ï,8888;;;;;;;;;;9æï=888?æñ8899<æñ
8889ñ9æ"ñ,8888;;;;;;;;;;9æñ=888?æó8899<æó
8889ó9æ"ó,8888;;;;;;;;;;9æó=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æô8899<æô
8889ô9æ"ô,8888;;;;;;;;;;9æô=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æõ8899<æõ
8889õ9æ"õ,8888;;;;;;;;;;9æõ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ˛8899<æ˛
8889˛9æ"˛,8888;;;;;;;;;;9æ˛=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff @í?7?@í?7¢@í?7£@í?7§@í?7?@í?7¶@í?7ß@í?7ç@í?7©@í?7?@í?7´@í?7¨@í?7≠@í?7Æ@í?7ù@í?7∞@í?7±@í?7≤@í?7≥@í?7¥@í?7µ@í?7∂@í?7∑@í?7è@í?7π@í?7?@í?7ª@í?7º@í?7Ω@í?7æ@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¢8899<æ¢
8889¢9æ"¢,8888;;;;;;;;;;9æ¢=888?æ£8899<æ£
8889£9æ"£,8888;;;;;;;;;;9æ£=888?æ§8899<æ§
8889§9æ"§,8888;;;;;;;;;;9æ§=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¶8899<æ¶
8889¶9æ"¶,8888;;;;;;;;;;9æ¶=888?æß8899<æß
8889ß9æ"ß,8888;;;;;;;;;;9æß=888?æç8899<æç
8889ç9æ"ç,8888;;;;;;;;;;9æç=888?æ©8899<æ©
8889©9æ"©,8888;;;;;;;;;;9æ©=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ´8899<æ´
8889´9æ"´,8888;;;;;;;;;;9æ´=888?æ¨8899<æ¨
8889¨9æ"¨,8888;;;;;;;;;;9æ¨=888?æ≠8899<æ≠
8889≠9æ"≠,8888;;;;;;;;;;9æ≠=888?æÆ8899<æÆ
8889Æ9æ"Æ,8888;;;;;;;;;;9æÆ=888?æù8899<æù
8889ù9æ"ù,8888;;;;;;;;;;9æù=888?æ∞8899<æ∞
8889∞9æ"∞,8888;;;;;;;;;;9æ∞=888?æ±8899<æ±
8889±9æ"±,8888;;;;;;;;;;9æ±=888?æ≤8899<æ≤
8889≤9æ"≤,8888;;;;;;;;;;9æ≤=888?æ≥8899<æ≥
8889≥9æ"≥,8888;;;;;;;;;;9æ≥=888?æ¥8899<æ¥
8889¥9æ"¥,8888;;;;;;;;;;9æ¥=888?æµ8899<æµ
8889µ9æ"µ,8888;;;;;;;;;;9æµ=888?æ∂8899<æ∂
8889∂9æ"∂,8888;;;;;;;;;;9æ∂=888?æ∑8899<æ∑
8889∑9æ"∑,8888;;;;;;;;;;9æ∑=888?æè8899<æè
8889è9æ"è,8888;;;;;;;;;;9æè=888?æπ8899<æπ
8889π9æ"π,8888;;;;;;;;;;9æπ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æª8899<æª
8889ª9æ"ª,8888;;;;;;;;;;9æª=888?æº8899<æº
8889º9æ"º,8888;;;;;;;;;;9æº=888?æΩ8899<æΩ
8889Ω9æ"Ω,8888;;;;;;;;;;9æΩ=888?ææ8899<ææ
8889æ9æ"æ,8888;;;;;;;;;;9ææ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7ƒ@í?7≈@í?7Ø@í?7?@í?7?@í?7…@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7”@í?7?@í?7’@í?7÷@í?7◊@í?7®@í?7?@í?7?@í?7?@í?7‹@í?7?@í?7?@í?7ﬂ@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æƒ8899<æƒ
8889ƒ9æ"ƒ,8888;;;;;;;;;;9æƒ=888?æ≈8899<æ≈
8889≈9æ"≈,8888;;;;;;;;;;9æ≈=888?æØ8899<æØ
8889Ø9æ"Ø,8888;;;;;;;;;;9æØ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ…8899<æ…
8889…9æ"…,8888;;;;;;;;;;9æ…=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ	

 !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdeg????hijklmnopqrstuvwxyz{|}~Ä?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ”8899<æ”
8889”9æ"”,8888;;;;;;;;;;9æ”=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ’8899<æ’
8889’9æ"’,8888;;;;;;;;;;9æ’=888?æ÷8899<æ÷
8889÷9æ"÷,8888;;;;;;;;;;9æ÷=888?æ◊8899<æ◊
8889◊9æ"◊,8888;;;;;;;;;;9æ◊=888?æ®8899<æ®
8889®9æ"®,8888;;;;;;;;;;9æ®=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‹8899<æ‹
8889‹9æ"‹,8888;;;;;;;;;;9æ‹=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬂ8899<æﬂ
8889ﬂ9æ"ﬂ,8888;;;;;;;;;;9æﬂ=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7‰@í?7Â@í?7ø@í?7?@í?7?@í?7È@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7Û@í?7?@í?7ı@í?7ˆ@í?7˜@í?7∏@í?7?@í?7?@í?7?@í?7¸@í?7?@í?7?@í?7?@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‰8899<æ‰
8889‰9æ"‰,8888;;;;;;;;;;9æ‰=888?æÂ8899<æÂ
8889Â9æ"Â,8888;;;;;;;;;;9æÂ=888?æø8899<æø
8889ø9æ"ø,8888;;;;;;;;;;9æø=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÈ8899<æÈ
8889È9æ"È,8888;;;;;;;;;;9æÈ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÛ8899<æÛ
8889Û9æ"Û,8888;;;;;;;;;;9æÛ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æı8899<æı
8889ı9æ"ı,8888;;;;;;;;;;9æı=888?æˆ8899<æˆ
8889ˆ9æ"ˆ,8888;;;;;;;;;;9æˆ=888?æ˜8899<æ˜
8889˜9æ"˜,8888;;;;;;;;;;9æ˜=888?æ∏8899<æ∏
8889∏9æ"∏,8888;;;;;;;;;;9æ∏=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¸8899<æ¸
8889¸9æ"¸,8888;;;;;;;;;;9æ¸=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7	@í?7
@í?7@í?7@í?7
@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffff @í?7!@í?7"@í?7#@í?7$@í?7%@í?7&@í?7'@í?7(@í?7)@í?7*@í?7+@í?7,@í?7-@í?7.@í?7/@í?70@í?71@í?72@í?73@í?74@í?75@í?76@í?77@í?78@í?79@í?7:@í?7;@í?7<@í?7=@í?7>@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ!8899<æ!
8889!9æ"!,8888;;;;;;;;;;9æ!=888?æ"8899<æ"
8889"9æ"",8888;;;;;;;;;;9æ"=888?æ#8899<æ#
8889#9æ"#,8888;;;;;;;;;;9æ#=888?æ$8899<æ$
8889$9æ"$,8888;;;;;;;;;;9æ$=888?æ%8899<æ%
8889%9æ"%,8888;;;;;;;;;;9æ%=888?æ&8899<æ&
8889&9æ"&,8888;;;;;;;;;;9æ&=888?æ'8899<æ'
8889'9æ"',8888;;;;;;;;;;9æ'=888?æ(8899<æ(
8889(9æ"(,8888;;;;;;;;;;9æ(=888?æ)8899<æ)
8889)9æ"),8888;;;;;;;;;;9æ)=888?æ*8899<æ*
8889*9æ"*,8888;;;;;;;;;;9æ*=888?æ+8899<æ+
8889+9æ"+,8888;;;;;;;;;;9æ+=888?æ,8899<æ,
8889,9æ",,8888;;;;;;;;;;9æ,=888?æ-8899<æ-
8889-9æ"-,8888;;;;;;;;;;9æ-=888?æ.8899<æ.
8889.9æ".,8888;;;;;;;;;;9æ.=888?æ/8899<æ/
8889/9æ"/,8888;;;;;;;;;;9æ/=888?æ08899<æ0
888909æ"0,8888;;;;;;;;;;9æ0=888?æ18899<æ1
888919æ"1,8888;;;;;;;;;;9æ1=888?æ28899<æ2
888929æ"2,8888;;;;;;;;;;9æ2=888?æ38899<æ3
888939æ"3,8888;;;;;;;;;;9æ3=888?æ48899<æ4
888949æ"4,8888;;;;;;;;;;9æ4=888?æ58899<æ5
888959æ"5,8888;;;;;;;;;;9æ5=888?æ68899<æ6
888969æ"6,8888;;;;;;;;;;9æ6=888?æ78899<æ7
888979æ"7,8888;;;;;;;;;;9æ7=888?æ88899<æ8
888989æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888?æ:8899<æ:
8889:9æ":,8888;;;;;;;;;;9æ:=888?æ;8899<æ;
8889;9æ";,8888;;;;;;;;;;9æ;=888?æ<8899<æ<
8889<9æ"<,8888;;;;;;;;;;9æ<=888?æ=8899<æ=
8889=9æ"=,8888;;;;;;;;;;9æ==888?æ>8899<æ>
8889>9æ">,8888;;;;;;;;;;9æ>=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@@í?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@í?7H@í?7I@í?7J@í?7K@í?7L@í?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7T@í?7U@í?7V@í?7W@í?7X@í?7Y@í?7Z@í?7[@í?7\@í?7]@í?7^@í?7_@í?7æ@8899<æ@
8889@9æ"@,8888;;;;;;;;;;9æ@=888?æA8899<æA
8889A9æ"A,8888;;;;;;;;;;9æA=888?æB8899<æB
8889B9æ"B,8888;;;;;;;;;;9æB=888?æC8899<æC
8889C9æ"C,8888;;;;;;;;;;9æC=888?æD8899<æD
8889D9æ"D,8888;;;;;;;;;;9æD=888?æE8899<æE
8889E9æ"E,8888;;;;;;;;;;9æE=888?æF8899<æF
8889F9æ"F,8888;;;;;;;;;;9æF=888?æG8899<æG
8889G9æ"G,8888;;;;;;;;;;9æG=888?æH8899<æH
8889H9æ"H,8888;;;;;;;;;;9æH=888?æI8899<æI
8889I9æ"I,8888;;;;;;;;;;9æI=888?æJ8899<æJ
8889J9æ"J,8888;;;;;;;;;;9æJ=888?æK8899<æK
8889K9æ"K,8888;;;;;;;;;;9æK=888?æL8899<æL
8889L9æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888?æN8899<æN
8889N9æ"N,8888;;;;;;;;;;9æN=888?æO8899<æO
8889O9æ"O,8888;;;;;;;;;;9æO=888?æP8899<æP
8889P9æ"P,8888;;;;;;;;;;9æP=888?æQ8899<æQ
8889Q9æ"Q,8888;;;;;;;;;;9æQ=888?æR8899<æR
8889R9æ"R,8888;;;;;;;;;;9æR=888?æS8899<æS
8889S9æ"S,8888;;;;;;;;;;9æS=888?æT8899<æT
8889T9æ"T,8888;;;;;;;;;;9æT=888?æU8899<æU
8889U9æ"U,8888;;;;;;;;;;9æU=888?æV8899<æV
8889V9æ"V,8888;;;;;;;;;;9æV=888?æW8899<æW
8889W9æ"W,8888;;;;;;;;;;9æW=888?æX8899<æX
8889X9æ"X,8888;;;;;;;;;;9æX=888?æY8899<æY
8889Y9æ"Y,8888;;;;;;;;;;9æY=888?æZ8899<æZ
8889Z9æ"Z,8888;;;;;;;;;;9æZ=888?æ[8899<æ[
8889[9æ"[,8888;;;;;;;;;;9æ[=888?æ\8899<æ\
8889\9æ"\,8888;;;;;;;;;;9æ\=888?æ]8899<æ]
8889]9æ"],8888;;;;;;;;;;9æ]=888?æ^8899<æ^
8889^9æ"^,8888;;;;;;;;;;9æ^=888?æ_8899<æ_
8889_9æ"_,8888;;;;;;;;;;9æ_=888?◊D@lfffffffffffffffffffffffffffffff`@í?7a@í?7b@í?7c@í?7d@í?7e@í?7f@í?7g@í?7h@í?7i@í?7j@í?7k@í?7l@í?7m@í?7n@í?7o@í?7p@í?7q@í?7r@í?7s@í?7t@í?7u@í?7v@í?7w@í?7x@í?7y@í?7z@í?7{@í?7|@í?7}@í?7~@í?7@í?7æ`8899<æ`
8889`9æ"`,8888;;;;;;;;;;9æ`=888?æa8899<æa
8889a9æ"a,8888;;;;;;;;;;9æa=888?æb8899<æb
8889b9æ"b,8888;;;;;;;;;;9æb=888?æc8899<æc
8889c9æ"c,8888;;;;;;;;;;9æc=888?æd8899<æd
8889d9æ"d,8888;;;;;;;;;;9æd=888?æe8899<æe
8889e9æ"e,8888;;;;;;;;;;9æe=888?æf8899<æf
8889f9æ"f,8888;;;;;;;;;;9æf=888?æg8899<æg
8889g9æ"g,8888;;;;;;;;;;9æg=888?æh8899<æh
8889h9æ"h,8888;;;;;;;;;;9æh=888?æi8899<æi
8889i9æ"i,8888;;;;;;;;;;9æi=888?æj8899<æj
8889j9æ"j,8888;;;;;;;;;;9æj=888?æk8899<æk
8889k9æ"k,8888;;;;;;;;;;9æk=888?æl8899<æl
8889l9æ"l,8888;;;;;;;;;;9æl=888?æm8899<æm
8889m9æ"m,8888;;;;;;;;;;9æm=888?æn8899<æn
8889n9æ"n,8888;;;;;;;;;;9æn=888?æo8899<æo
8889o9æ"o,8888;;;;;;;;;;9æo=888?æp8899<æp
8889p9æ"p,8888;;;;;;;;;;9æp=888?æq8899<æq
8889q9æ"q,8888;;;;;;;;;;9æq=888?ær8899<ær
8889r9æ"r,8888;;;;;;;;;;9ær=888?æs8899<æs
8889s9æ"s,8888;;;;;;;;;;9æs=888?æt8899<æt
8889t9æ"t,8888;;;;;;;;;;9æt=888?æu8899<æu
8889u9æ"u,8888;;;;;;;;;;9æu=888?æv8899<æv
8889v9æ"v,8888;;;;;;;;;;9æv=888?æw8899<æw
8889w9æ"w,8888;;;;;;;;;;9æw=888?æx8899<æx
8889x9æ"x,8888;;;;;;;;;;9æx=888?æy8899<æy
8889y9æ"y,8888;;;;;;;;;;9æy=888?æz8899<æz
8889z9æ"z,8888;;;;;;;;;;9æz=888?æ{8899<æ{
8889{9æ"{,8888;;;;;;;;;;9æ{=888?æ|8899<æ|
8889|9æ"|,8888;;;;;;;;;;9æ|=888?æ}8899<æ}
8889}9æ"},8888;;;;;;;;;;9æ}=888?æ~8899<æ~
8889~9æ"~,8888;;;;;;;;;;9æ~=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffffÄ@í?7Å@í?7Ç@í?7?@í?7Ñ@í?7Ö@í?7Ü@í?7á@í?7?@í?7â@í?7–@í?7ã@í?7?@í?7?@í?7ﬁ@í?7?@í?7ê@í?7ë@í?7í@í?7ì@í?7î@í?7ï@í?7ñ@í?7ó@í?7?@í?7ô@í?7@í?7õ@í?7?@í?7?@í?7˛@í?7?@í?7æÄ8899<æÄ
8889Ä9æ"Ä,8888;;;;;;;;;;9æÄ=888?æÅ8899<æÅ
8889Å9æ"Å,8888;;;;;;;;;;9æÅ=888?æÇ8899<æÇ
8889Ç9æ"Ç,8888;;;;;;;;;;9æÇ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÑ8899<æÑ
8889Ñ9æ"Ñ,8888;;;;;;;;;;9æÑ=888?æÖ8899<æÖ
8889Ö9æ"Ö,8888;;;;;;;;;;9æÖ=888?æÜ8899<æÜ
8889Ü9æ"Ü,8888;;;;;;;;;;9æÜ=888?æá8899<æá
8889á9æ"á,8888;;;;;;;;;;9æá=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æâ8899<æâ
8889â9æ"â,8888;;;;;;;;;;9æâ=888?æ–8899<æ–
8889–9æ"–,8888;;;;;;;;;;9æ–=888?æã8899<æã
8889ã9æ"ã,8888;;;;;;;;;;9æã=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬁ8899<æﬁ
8889ﬁ9æ"ﬁ,8888;;;;;;;;;;9æﬁ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æê8899<æê
8889ê9æ"ê,8888;;;;;;;;;;9æê=888?æë8899<æë
8889ë9æ"ë,8888;;;;;;;;;;9æë=888?æí8899<æí
8889í9æ"í,8888;;;;;;;;;;9æí=888?æì8899<æì
8889ì9æ"ì,8888;;;;;;;;;;9æì=888?æî8899<æî
8889î9æ"î,8888;;;;;;;;;;9æî=888?æï8899<æï
8889ï9æ"ï,8888;;;;;;;;;;9æï=888?æñ8899<æñ
8889ñ9æ"ñ,8888;;;;;;;;;;9æñ=888?æó8899<æó
8889ó9æ"ó,8888;;;;;;;;;;9æó=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æô8899<æô
8889ô9æ"ô,8888;;;;;;;;;;9æô=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æõ8899<æõ
8889õ9æ"õ,8888;;;;;;;;;;9æõ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ˛8899<æ˛
8889˛9æ"˛,8888;;;;;;;;;;9æ˛=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff @í?7?@í?7¢@í?7£@í?7§@í?7?@í?7¶@í?7ß@í?7ç@í?7©@í?7?@í?7´@í?7¨@í?7≠@í?7Æ@í?7ù@í?7∞@í?7±@í?7≤@í?7≥@í?7¥@í?7µ@í?7∂@í?7∑@í?7è@í?7π@í?7?@í?7ª@í?7º@í?7Ω@í?7æ@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¢8899<æ¢
8889¢9æ"¢,8888;;;;;;;;;;9æ¢=888?æ£8899<æ£
8889£9æ"£,8888;;;;;;;;;;9æ£=888?æ§8899<æ§
8889§9æ"§,8888;;;;;;;;;;9æ§=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¶8899<æ¶
8889¶9æ"¶,8888;;;;;;;;;;9æ¶=888?æß8899<æß
8889ß9æ"ß,8888;;;;;;;;;;9æß=888?æç8899<æç
8889ç9æ"ç,8888;;;;;;;;;;9æç=888?æ©8899<æ©
8889©9æ"©,8888;;;;;;;;;;9æ©=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ´8899<æ´
8889´9æ"´,8888;;;;;;;;;;9æ´=888?æ¨8899<æ¨
8889¨9æ"¨,8888;;;;;;;;;;9æ¨=888?æ≠8899<æ≠
8889≠9æ"≠,8888;;;;;;;;;;9æ≠=888?æÆ8899<æÆ
8889Æ9æ"Æ,8888;;;;;;;;;;9æÆ=888?æù8899<æù
8889ù9æ"ù,8888;;;;;;;;;;9æù=888?æ∞8899<æ∞
8889∞9æ"∞,8888;;;;;;;;;;9æ∞=888?æ±8899<æ±
8889±9æ"±,8888;;;;;;;;;;9æ±=888?æ≤8899<æ≤
8889≤9æ"≤,8888;;;;;;;;;;9æ≤=888?æ≥8899<æ≥
8889≥9æ"≥,8888;;;;;;;;;;9æ≥=888?æ¥8899<æ¥
8889¥9æ"¥,8888;;;;;;;;;;9æ¥=888?æµ8899<æµ
8889µ9æ"µ,8888;;;;;;;;;;9æµ=888?æ∂8899<æ∂
8889∂9æ"∂,8888;;;;;;;;;;9æ∂=888?æ∑8899<æ∑
8889∑9æ"∑,8888;;;;;;;;;;9æ∑=888?æè8899<æè
8889è9æ"è,8888;;;;;;;;;;9æè=888?æπ8899<æπ
8889π9æ"π,8888;;;;;;;;;;9æπ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æª8899<æª
8889ª9æ"ª,8888;;;;;;;;;;9æª=888?æº8899<æº
8889º9æ"º,8888;;;;;;;;;;9æº=888?æΩ8899<æΩ
8889Ω9æ"Ω,8888;;;;;;;;;;9æΩ=888?ææ8899<ææ
8889æ9æ"æ,8888;;;;;;;;;;9ææ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7ƒ@í?7≈@í?7Ø@í?7?@í?7?@í?7…@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7”@í?7?@í?7’@í?7÷@í?7◊@í?7®@í?7?@í?7?@í?7?@í?7‹@í?7?@í?7?@í?7ﬂ@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æƒ8899<æƒ
8889ƒ9æ"ƒ,8888;;;;;;;;;;9æƒ=888?æ≈8899<æ≈
8889≈9æ"≈,8888;;;;;;;;;;9æ≈=888?æØ8899<æØ
8889Ø9æ"Ø,8888;;;;;;;;;;9æØ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ…8899<æ…
8889…9æ"…,8888;;;;;;;;;;9æ…=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ”8899<æ”
8889”9æ"”,8888;;;;;;;;;;9æ”=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ’8899<æ’
8889’9æ"’,8888;;;;;;;;;;9æ’=888?æ÷8899<æ÷
8889÷9æ"÷,8888;;;;;;;;;;9æ÷=888?æ◊8899<æ◊
8889◊9æ"◊,8888;;;;;;;;;;9æ◊=888?æ®8899<æ®
8889®9æ"®,8888;;;;;;;;;;9æ®=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‹8899<æ‹
8889‹9æ"‹,8888;;;;;;;;;;9æ‹=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬂ8899<æﬂ
8889ﬂ9æ"ﬂ,8888;;;;;;;;;;9æﬂ=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7‰@í?7Â@í?7ø@í?7?@í?7?@í?7È@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7Û@í?7?@í?7ı@í?7ˆ@í?7˜@í?7∏@í?7?@í?7?@í?7?@í?7¸@í?7?@í?7?@í?7?@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‰8899<æ‰
8889‰9æ"‰,8888;;;;;;;;;;9æ‰=888?æÂ8899<æÂ
8889Â9æ"Â,8888;;;;;;;;;;9æÂ=888?æø8899<æø
8889ø9æ"ø,8888;;;;;;;;;;9æø=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÈ8899<æÈ
8889È9æ"È,8888;;;;;;;;;;9æÈ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÛ8899<æÛ
8889Û9æ"Û,8888;;;;;;;;;;9æÛ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æı8899<æı
8889ı9æ"ı,8888;;;;;;;;;;9æı=888?æˆ8899<æˆ
8889ˆ9æ"ˆ,8888;;;;;;;;;;9æˆ=888?æ˜8899<æ˜
8889˜9æ"˜,8888;;;;;;;;;;9æ˜=888?æ∏8899<æ∏
8889∏9æ"∏,8888;;;;;;;;;;9æ∏=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¸8899<æ¸
8889¸9æ"¸,8888;;;;;;;;;;9æ¸=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7	@í?7
@í?7@í?7@í?7
@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffff @í?7!@í?7"@í?7#@í?7$@í?7%@í?7&@í?7'@í?7(@í?7)@í?7*@í?7+@í?7,@í?7-@í?7.@í?7/@í?70@í?71@í?72@í?73@í?74@í?75@í?76@í?77@í?78@í?79@í?7:@í?7;@í?7<@í?7=@í?7>@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ!8899<æ!
8889!9æ"!,8888;;;;;;;;;;9æ!=888?æ"8899<æ"
8889"9æ"",8888;;;;;;;;;;9æ"=888?æ#8899<æ#
8889#9æ"#,8888;;;;;;;;;;9æ#=888?æ$8899<æ$
8889$9æ"$,8888;;;;;;;;;;9æ$=888?æ%8899<æ%
8889%9æ"%,8888;;;;;;;;;;9æ%=888?æ&8899<æ&
8889&9æ"&,8888;;;;;;;;;;9æ&=888?æ'8899<æ'
8889'9æ"',8888;;;;;;;;;;9æ'=888?æ(8899<æ(
8889(9æ"(,8888;;;;;;;;;;9æ(=888?æ)8899<æ)
8889)9æ"),8888;;;;;;;;;;9æ)=888?æ*8899<æ*
8889*9æ"*,8888;;;;;;;;;;9æ*=888?æ+8899<æ+
8889+9æ"+,8888;;;;;;;;;;9æ+=888?æ,8899<æ,
8889,9æ",,8888;;;;;;;;;;9æ,=888?æ-8899<æ-
8889-9æ"-,8888;;;;;;;;;;9æ-=888?æ.8899<æ.
8889.9æ".,8888;;;;;;;;;;9æ.=888?æ/8899<æ/
8889/9æ"/,8888;;;;;;;;;;9æ/=888?æ08899<æ0
888909æ"0,8888;;;;;;;;;;9æ0=888?æ18899<æ1
888919æ"1,8888;;;;;;;;;;9æ1=888?æ28899<æ2
888929æ"2,8888;;;;;;;;;;9æ2=888?æ38899<æ3
888939æ"3,8888;;;;;;;;;;9æ3=888?æ48899<æ4
888949æ"4,8888;;;;;;;;;;9æ4=888?æ58899<æ5
888959æ"5,8888;;;;;;;;;;9æ5=888?æ68899<æ6
888969æ"6,8888;;;;;;;;;;9æ6=888?æ78899<æ7
888979æ"7,8888;;;;;;;;;;9æ7=888?æ88899<æ8
888989æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888?æ:8899<æ:
8889:9æ":,8888;;;;;;;;;;9æ:=888?æ;8899<æ;
8889;9æ";,8888;;;;;;;;;;9æ;=888?æ<8899<æ<
8889<9æ"<,8888;;;;;;;;;;9æ<=888?æ=8899<æ=
8889=9æ"=,8888;;;;;;;;;;9æ==888?æ>8899<æ>
8889>9æ">,8888;;;;;;;;;;9æ>=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@@í?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@í?7H@í?7I@í?7J@í?7K@í?7L@í?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7T@í?7U@í?7V@í?7W@í?7X@í?7Y@í?7Z@í?7[@í?7\@í?7]@í?7^@í?7_@í?7æ@8899<æ@
8889@9æ"@,8888;;;;;;;;;;9æ@=888?æA8899<æA
8889A9æ"A,8888;;;;;;;;;;9æA=888?æB8899<æB
8889B9æ"B,8888;;;;;;;;;;9æB=888?æC8899<æC
8889C9æ"C,8888;;;;;;;;;;9æC=888?æD8899<æD
8889D9æ"D,8888;;;;;;;;;;9æD=888?æE8899<æE
8889E9æ"E,8888;;;;;;;;;;9æE=888?æF8899<æF
8889F9æ"F,8888;;;;;;;;;;9æF=888?æG8899<æG
8889G9æ"G,8888;;;;;;;;;;9æG=888?æH8899<æH
8889H9æ"H,8888;;;;;;;;;;9æH=888?æI8899<æI
8889I9æ"I,8888;;;;;;;;;;9æI=888?æJ8899<æJ
8889J9æ"J,8888;;;;;;;;;;9æJ=888?æK8899<æK
8889K9æ"K,8888;;;;;;;;;;9æK=888?æL8899<æL
8889L9æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888?æN8899<æN
8889N9æ"N,8888;;;;;;;;;;9æN=888?æO8899<æO
8889O9æ"O,8888;;;;;;;;;;9æO=888?æP8899<æP
8889P9æ"P,8888;;;;;;;;;;9æP=888?æQ8899<æQ
8889Q9æ"Q,8888;;;;;;;;;;9æQ=888?æR8899<æR
8889R9æ"R,8888;;;;;;;;;;9æR=888?æS8899<æS
8889S9æ"S,8888;;;;;;;;;;9æS=888?æT8899<æT
8889T9æ"T,8888;;;;;;;;;;9æT=888?æU8899<æU
8889U9æ"U,8888;;;;;;;;;;9æU=888?æV8899<æV
8889V9æ"V,8888;;;;;;;;;;9æV=888?æW8899<æW
8889W9æ"W,8888;;;;;;;;;;9æW=888?æX8899<æX
8889X9æ"X,8888;;;;;;;;;;9æX=888?æY8899<æY
8889Y9æ"Y,8888;;;;;;;;;;9æY=888?æZ8899<æZ
8889Z9æ"Z,8888;;;;;;;;;;9æZ=888?æ[8899<æ[
8889[9æ"[,8888;;;;;;;;;;9æ[=888?æ\8899<æ\
8889\9æ"\,8888;;;;;;;;;;9æ\=888?æ]8899<æ]
8889]9æ"],8888;;;;;;;;;;9æ]=888?æ^8899<æ^
8889^9æ"^,8888;;;;;;;;;;9æ^=888?æ_8899<æ_
8889_9æ"_,8888;;;;;;;;;;9æ_=888?◊D@lfffffffffffffffffffffffffffffff`@í?7a@í?7b@í?7c@í?7d@í?7e@í?7f@í?7g@í?7h@í?7i@í?7j@í?7k@í?7l@í?7m@í?7n@í?7o@í?7p@í?7q@í?7r@í?7s@í?7t@í?7u@í?7v@í?7w@í?7x@í?7y@í?7z@í?7{@í?7|@í?7}@í?7~@í?7@í?7æ`8899<æ`
8889`9æ"`,8888;;;;;;;;;;9æ`=888?æa8899<æa
8889a9æ"a,8888;;;;;;;;;;9æa=888?æb8899<æb
8889b9æ"b,8888;;;;;;;;;;9æb=888?æc8899<æc
8889c9æ"c,8888;;;;;;;;;;9æc=888?æd8899<æd
8889d9æ"d,8888;;;;;;;;;;9æd=888?æe8899<æe
8889e9æ"e,8888;;;;;;;;;;9æe=888?æf8899<æf
8889f9æ"f,8888;;;;;;;;;;9æf=888?æg8899<æg
8889g9æ"g,8888;;;;;;;;;;9æg=888?æh8899<æh
8889h9æ"h,8888;;;;;;;;;;9æh=888?æi8899<æi
8889i9æ"i,8888;;;;;;;;;;9æi=888?æj8899<æj
8889j9æ"j,8888;;;;;;;;;;9æj=888?æk8899<æk
8889k9æ"k,8888;;;;;;;;;;9æk=888?æl8899<æl
8889l9æ"l,8888;;;;;;;;;;9æl=888?æm8899<æm
8889m9æ"m,8888;;;;;;;;;;9æm=888?æn8899<æn
8889n9æ"n,8888;;;;;;;;;;9æn=888?æo8899<æo
8889o9æ"o,8888;;;;;;;;;;9æo=888?æp8899<æp
8889p9æ"p,8888;;;;;;;;;;9æp=888?æq8899<æq
8889q9æ"q,8888;;;;;;;;;;9æq=888?ær8899<ær
8889r9æ"r,8888;;;;;;;;;;9ær=888?æs8899<æs
8889s9æ"s,8888;;;;;;;;;;9æs=888?æt8899<æt
8889t9æ"t,8888;;;;;;;;;;9æt=888?æu8899<æu
8889u9æ"u,8888;;;;;;;;;;9æu=888?æv8899<æv
8889v9æ"v,8888;;;;;;;;;;9æv=888?æw8899<æw
8889w9æ"w,8888;;;;;;;;;;9æw=888?æx8899<æx
8889x9æ"x,8888;;;;;;;;;;9æx=888?æy8899<æy
8889y9æ"y,8888;;;;;;;;;;9æy=888?æz8899<æz
8889z9æ"z,8888;;;;;;;;;;9æz=888?æ{8899<æ{
8889{9æ"{,8888;;;;;;;;;;9æ{=888?æ|8899<æ|
8889|9æ"|,8888;;;;;;;;;;9æ|=888?æ}8899<æ}
8889}9æ"},8888;;;;;;;;;;9æ}=888?æ~8899<æ~
8889~9æ"~,8888;;;;;;;;;;9æ~=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffffÄ@í?7Å@í?7Ç@í?7?@í?7Ñ@í?7Ö@í?7Ü@í?7á@í?7?@í?7â@í?7–@í?7ã@í?7?@í?7?@í?7ﬁ@í?7?@í?7ê@í?7ë@í?7í@í?7ì@í?7î@í?7ï@í?7ñ@í?7ó@í?7?@í?7ô@í?7@í?7õ@í?7?@í?7?@í?7˛@í?7?@í?7æÄ8899<æÄ
8889Ä9æ"Ä,8888;;;;;;;;;;9æÄ=888?æÅ8899<æÅ
8889Å9æ"Å,8888;;;;;;;;;;9æÅ=888?æÇ8899<æÇ
8889Ç9æ"Ç,8888;;;;;;;;;;9æÇ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÑ8899<æÑ
8889Ñ9æ"Ñ,8888;;;;;;;;;;9æÑ=888?æÖ8899<æÖ
8889Ö9æ"Ö,8888;;;;;;;;;;9æÖ=888?æÜ8899<æÜ
8889Ü9æ"Ü,8888;;;;;;;;;;9æÜ=888?æá8899<æá
8889á9æ"á,8888;;;;;;;;;;9æá=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æâ8899<æâ
8889â9æ"â,8888;;;;;;;;;;9æâ=888?æ–8899<æ–
8889–9æ"–,8888;;;;;;;;;;9æ–=888?æã8899<æã
8889ã9æ"ã,8888;;;;;;;;;;9æã=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬁ8899<æﬁ
8889ﬁ9æ"ﬁ,8888;;;;;;;;;;9æﬁ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æê8899<æê
8889ê9æ"ê,8888;;;;;;;;;;9æê=888?æë8899<æë
8889ë9æ"ë,8888;;;;;;;;;;9æë=888?æí8899<æí
8889í9æ"í,8888;;;;;;;;;;9æí=888?æì8899<æì
8889ì9æ"ì,8888;;;;;;;;;;9æì=888?æî8899<æî
8889î9æ"î,8888;;;;;;;;;;9æî=888?æï8899<æï
8889ï9æ"ï,8888;;;;;;;;;;9æï=888?æñ8899<æñ
8889ñ9æ"ñ,8888;;;;;;;;;;9æñ=888?æó8899<æó
8889ó9æ"ó,8888;;;;;;;;;;9æó=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æô8899<æô
8889ô9æ"ô,8888;;;;;;;;;;9æô=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æõ8899<æõ
8889õ9æ"õ,8888;;;;;;;;;;9æõ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ˛8899<æ˛
8889˛9æ"˛,8888;;;;;;;;;;9æ˛=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff @í?7?@í?7¢@í?7£@í?7§@í?7?@í?7¶@í?7ß@í?7ç@í?7©@í?7?@í?7´@í?7¨@í?7≠@í?7Æ@í?7ù@í?7∞@í?7±@í?7≤@í?7≥@í?7¥@í?7µ@í?7∂@í?7∑@í?7è@í?7π@í?7?@í?7ª@í?7º@í?7Ω@í?7æ@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¢8899<æ¢
8889¢9æ"¢,8888;;;;;;;;;;9æ¢=888?æ£8899<æ£
8889£9æ"£,8888;;;;;;;;;;9æ£=888?æ§8899<æ§
8889§9æ"§,8888;;;;;;;;;;9æ§=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¶8899<æ¶
8889¶9æ"¶,8888;;;;;;;;;;9æ¶=888?æß8899<æß
8889ß9æ"ß,8888;;;;;;;;;;9æß=888?æç8899<æç
8889ç9æ"ç,8888;;;;;;;;;;9æç=888?æ©8899<æ©
8889©9æ"©,8888;;;;;;;;;;9æ©=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ´8899<æ´
8889´9æ"´,8888;;;;;;;;;;9æ´=888?æ¨8899<æ¨
8889¨9æ"¨,8888;;;;;;;;;;9æ¨=888?æ≠8899<æ≠
8889≠9æ"≠,8888;;;;;;;;;;9æ≠=888?æÆ8899<æÆ
8889Æ9æ"Æ,8888;;;;;;;;;;9æÆ=888?æù8899<æù
8889ù9æ"ù,8888;;;;;;;;;;9æù=888?æ∞8899<æ∞
8889∞9æ"∞,8888;;;;;;;;;;9æ∞=888?æ±8899<æ±
8889±9æ"±,8888;;;;;;;;;;9æ±=888?æ≤8899<æ≤
8889≤9æ"≤,8888;;;;;;;;;;9æ≤=888?æ≥8899<æ≥
8889≥9æ"≥,8888;;;;;;;;;;9æ≥=888?æ¥8899<æ¥
8889¥9æ"¥,8888;;;;;;;;;;9æ¥=888?æµ8899<æµ
8889µ9æ"µ,8888;;;;;;;;;;9æµ=888?æ∂8899<æ∂
8889∂9æ"∂,8888;;;;;;;;;;9æ∂=888?æ∑8899<æ∑
8889∑9æ"∑,8888;;;;;;;;;;9æ∑=888?æè8899<æè
8889è9æ"è,8888;;;;;;;;;;9æè=888?æπ8899<æπ
8889π9æ"π,8888;;;;;;;;;;9æπ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æª8899<æª
8889ª9æ"ª,8888;;;;;;;;;;9æª=888?æº8899<æº
8889º9æ"º,8888;;;;;;;;;;9æº=888?æΩ8899<æΩ
8889Ω9æ"Ω,8888;;;;;;;;;;9æΩ=888?ææ8899<ææ
8889æ9æ"æ,8888;;;;;;;;;;9ææ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7ƒ@í?7≈@í?7Ø@í?7?@í?7?@í?7…@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7”@í?7?@í?7’@í?7÷@í?7◊@í?7®@í?7?@í?7?@í?7?@í?7‹@í?7?@í?7?@í?7ﬂ@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æƒ8899<æƒ
8889ƒ9æ"ƒ,8888;;;;;;;;;;9æƒ=888?æ≈8899<æ≈
8889≈9æ"≈,8888;;;;;;;;;;9æ≈=888?æØ8899<æØ
8889Ø9æ"Ø,8888;;;;;;;;;;9æØ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ…8899<æ…
8889…9æ"…,8888;;;;;;;;;;9æ…=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ”8899<æ”
8889”9æ"”,8888;;;;;;;;;;9æ”=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ’8899<æ’
8889’9æ"’,8888;;;;;;;;;;9æ’=888?æ÷8899<æ÷
8889÷9æ"÷,8888;;;;;;;;;;9æ÷=888?æ◊8899<æ◊
8889◊9æ"◊,8888;;;;;;;;;;9æ◊=888?æ®8899<æ®
8889®9æ"®,8888;;;;;;;;;;9æ®=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‹8899<æ‹
8889‹9æ"‹,8888;;;;;;;;;;9æ‹=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9ÅÇ?ÑÖÜá?â–ã??ﬁ?êëíìîïñó?ôõ??˛? ?¢£§?¶ßç©?´¨≠Æù∞±≤≥¥µ∂∑èπ?ªºΩæ?????ƒ≈Ø??…?????????”?’÷◊®???‹??ﬂ????‰Âø?????È?????????Û?ıˆ˜∏???¸???æ?=888?æﬂ8899<æﬂ
8889ﬂ9æ"ﬂ,8888;;;;;;;;;;9æﬂ=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7‰@í?7Â@í?7ø@í?7?@í?7?@í?7È@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7Û@í?7?@í?7ı@í?7ˆ@í?7˜@í?7∏@í?7?@í?7?@í?7?@í?7¸@í?7?@í?7?@í?7?@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‰8899<æ‰
8889‰9æ"‰,8888;;;;;;;;;;9æ‰=888?æÂ8899<æÂ
8889Â9æ"Â,8888;;;;;;;;;;9æÂ=888?æø8899<æø
8889ø9æ"ø,8888;;;;;;;;;;9æø=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÈ8899<æÈ
8889È9æ"È,8888;;;;;;;;;;9æÈ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÛ8899<æÛ
8889Û9æ"Û,8888;;;;;;;;;;9æÛ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æı8899<æı
8889ı9æ"ı,8888;;;;;;;;;;9æı=888?æˆ8899<æˆ
8889ˆ9æ"ˆ,8888;;;;;;;;;;9æˆ=888?æ˜8899<æ˜
8889˜9æ"˜,8888;;;;;;;;;;9æ˜=888?æ∏8899<æ∏
8889∏9æ"∏,8888;;;;;;;;;;9æ∏=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¸8899<æ¸
8889¸9æ"¸,8888;;;;;;;;;;9æ¸=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7		@í?7
	@í?7	@í?7	@í?7
	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7	@í?7æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ		8899<æ		
8889		9æ"		,8888;;;;;;;;;;9æ		=888?æ
	8899<æ
	
8889
	9æ"
	,8888;;;;;;;;;;9æ
	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
	8899<æ
	
8889
	9æ"
	,8888;;;;;;;;;;9æ
	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?◊D@lfffffffffffffffffffffffffffffff 	@í?7!	@í?7"	@í?7#	@í?7$	@í?7%	@í?7&	@í?7'	@í?7(	@í?7)	@í?7*	@í?7+	@í?7,	@í?7-	@í?7.	@í?7/	@í?70	@í?71	@í?72	@í?73	@í?74	@í?75	@í?76	@í?77	@í?78	@í?79	@í?7:	@í?7;	@í?7<	@í?7=	@í?7>	@í?7?	@í?7æ 	8899<æ 	
8889 	9æ" 	,8888;;;;;;;;;;9æ 	=888?æ!	8899<æ!	
8889!	9æ"!	,8888;;;;;;;;;;9æ!	=888?æ"	8899<æ"	
8889"	9æ""	,8888;;;;;;;;;;9æ"	=888?æ#	8899<æ#	
8889#	9æ"#	,8888;;;;;;;;;;9æ#	=888?æ$	8899<æ$	
8889$	9æ"$	,8888;;;;;;;;;;9æ$	=888?æ%	8899<æ%	
8889%	9æ"%	,8888;;;;;;;;;;9æ%	=888?æ&	8899<æ&	
8889&	9æ"&	,8888;;;;;;;;;;9æ&	=888?æ'	8899<æ'	
8889'	9æ"'	,8888;;;;;;;;;;9æ'	=888?æ(	8899<æ(	
8889(	9æ"(	,8888;;;;;;;;;;9æ(	=888?æ)	8899<æ)	
8889)	9æ")	,8888;;;;;;;;;;9æ)	=888?æ*	8899<æ*	
8889*	9æ"*	,8888;;;;;;;;;;9æ*	=888?æ+	8899<æ+	
8889+	9æ"+	,8888;;;;;;;;;;9æ+	=888?æ,	8899<æ,	
8889,	9æ",	,8888;;;;;;;;;;9æ,	=888?æ-	8899<æ-	
8889-	9æ"-	,8888;;;;;;;;;;9æ-	=888?æ.	8899<æ.	
8889.	9æ".	,8888;;;;;;;;;;9æ.	=888?æ/	8899<æ/	
8889/	9æ"/	,8888;;;;;;;;;;9æ/	=888?æ0	8899<æ0	
88890	9æ"0	,8888;;;;;;;;;;9æ0	=888?æ1	8899<æ1	
88891	9æ"1	,8888;;;;;;;;;;9æ1	=888?æ2	8899<æ2	
88892	9æ"2	,8888;;;;;;;;;;9æ2	=888?æ3	8899<æ3	
88893	9æ"3	,8888;;;;;;;;;;9æ3	=888?æ4	8899<æ4	
88894	9æ"4	,8888;;;;;;;;;;9æ4	=888?æ5	8899<æ5	
88895	9æ"5	,8888;;;;;;;;;;9æ5	=888?æ6	8899<æ6	
88896	9æ"6	,8888;;;;;;;;;;9æ6	=888?æ7	8899<æ7	
88897	9æ"7	,8888;;;;;;;;;;9æ7	=888?æ8	8899<æ8	
88898	9æ"8	,8888;;;;;;;;;;9æ8	=888?æ9	8899<æ9	
88899	9æ"9	,8888;;;;;;;;;;9æ9	=888?æ:	8899<æ:	
8889:	9æ":	,8888;;;;;;;;;;9æ:	=888?æ;	8899<æ;	
8889;	9æ";	,8888;;;;;;;;;;9æ;	=888?æ<	8899<æ<	
8889<	9æ"<	,8888;;;;;;;;;;9æ<	=888?æ=	8899<æ=	
8889=	9æ"=	,8888;;;;;;;;;;9æ=	=888?æ>	8899<æ>	
8889>	9æ">	,8888;;;;;;;;;;9æ>	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?◊D@lfffffffffffffffffffffffffffffff@	@í?7A	@í?7B	@í?7C	@í?7D	@í?7E	@í?7F	@í?7G	@í?7H	@í?7I	@í?7J	@í?7K	@í?7L	@í?7M	@í?7N	@í?7O	@í?7P	@í?7Q	@í?7R	@í?7S	@í?7T	@í?7U	@í?7V	@í?7W	@í?7X	@í?7Y	@í?7Z	@í?7[	@í?7\	@í?7]	@í?7^	@í?7_	@í?7æ@	8899<æ@	
8889@	9æ"@	,8888;;;;;;;;;;9æ@	=888?æA	8899<æA	
8889A	9æ"A	,8888;;;;;;;;;;9æA	=888?æB	8899<æB	
8889B	9æ"B	,8888;;;;;;;;;;9æB	=888?æC	8899<æC	
8889C	9æ"C	,8888;;;;;;;;;;9æC	=888?æD	8899<æD	
8889D	9æ"D	,8888;;;;;;;;;;9æD	=888?æE	8899<æE	
8889E	9æ"E	,8888;;;;;;;;;;9æE	=888?æF	8899<æF	
8889F	9æ"F	,8888;;;;;;;;;;9æF	=888?æG	8899<æG	
8889G	9æ"G	,8888;;;;;;;;;;9æG	=888?æH	8899<æH	
8889H	9æ"H	,8888;;;;;;;;;;9æH	=888?æI	8899<æI	
8889I	9æ"I	,8888;;;;;;;;;;9æI	=888?æJ	8899<æJ	
8889J	9æ"J	,8888;;;;;;;;;;9æJ	=888?æK	8899<æK	
8889K	9æ"K	,8888;;;;;;;;;;9æK	=888?æL	8899<æL	
8889L	9æ"L	,8888;;;;;;;;;;9æL	=888?æM	8899<æM	
8889M	9æ"M	,8888;;;;;;;;;;9æM	=888?æN	8899<æN	
8889N	9æ"N	,8888;;;;;;;;;;9æN	=888?æO	8899<æO	
8889O	9æ"O	,8888;;;;;;;;;;9æO	=888?æP	8899<æP	
8889P	9æ"P	,8888;;;;;;;;;;9æP	=888?æQ	8899<æQ	
8889Q	9æ"Q	,8888;;;;;;;;;;9æQ	=888?æR	8899<æR	
8889R	9æ"R	,8888;;;;;;;;;;9æR	=888?æS	8899<æS	
8889S	9æ"S	,8888;;;;;;;;;;9æS	=888?æT	8899<æT	
8889T	9æ"T	,8888;;;;;;;;;;9æT	=888?æU	8899<æU	
8889U	9æ"U	,8888;;;;;;;;;;9æU	=888?æV	8899<æV	
8889V	9æ"V	,8888;;;;;;;;;;9æV	=888?æW	8899<æW	
8889W	9æ"W	,8888;;;;;;;;;;9æW	=888?æX	8899<æX	
8889X	9æ"X	,8888;;;;;;;;;;9æX	=888?æY	8899<æY	
8889Y	9æ"Y	,8888;;;;;;;;;;9æY	=888?æZ	8899<æZ	
8889Z	9æ"Z	,8888;;;;;;;;;;9æZ	=888?æ[	8899<æ[	
8889[	9æ"[	,8888;;;;;;;;;;9æ[	=888?æ\	8899<æ\	
8889\	9æ"\	,8888;;;;;;;;;;9æ\	=888?æ]	8899<æ]	
8889]	9æ"]	,8888;;;;;;;;;;9æ]	=888?æ^	8899<æ^	
8889^	9æ"^	,8888;;;;;;;;;;9æ^	=888?æ_	8899<æ_	
8889_	9æ"_	,8888;;;;;;;;;;9æ_	=888?◊D@lfffffffffffffffffffffffffffffff`	@í?7a	@í?7b	@í?7c	@í?7d	@í?7e	@í?7f	@í?7g	@í?7h	@í?7i	@í?7j	@í?7k	@í?7l	@í?7m	@í?7n	@í?7o	@í?7p	@í?7q	@í?7r	@í?7s	@í?7t	@í?7u	@í?7v	@í?7w	@í?7x	@í?7y	@í?7z	@í?7{	@í?7|	@í?7}	@í?7~	@í?7	@í?7æ`	8899<æ`	
8889`	9æ"`	,8888;;;;;;;;;;9æ`	=888?æa	8899<æa	
8889a	9æ"a	,8888;;;;;;;;;;9æa	=888?æb	8899<æb	
8889b	9æ"b	,8888;;;;;;;;;;9æb	=888?æc	8899<æc	
8889c	9æ"c	,8888;;;;;;;;;;9æc	=888?æd	8899<æd	
8889d	9æ"d	,8888;;;;;;;;;;9æd	=888?æe	8899<æe	
8889e	9æ"e	,8888;;;;;;;;;;9æe	=888?æf	8899<æf	
8889f	9æ"f	,8888;;;;;;;;;;9æf	=888?æg	8899<æg	
8889g	9æ"g	,8888;;;;;;;;;;9æg	=888?æh	8899<æh	
8889h	9æ"h	,8888;;;;;;;;;;9æh	=888?æi	8899<æi	
8889i	9æ"i	,8888;;;;;;;;;;9æi	=888?æj	8899<æj	
8889j	9æ"j	,8888;;;;;;;;;;9æj	=888?æk	8899<æk	
8889k	9æ"k	,8888;;;;;;;;;;9æk	=888?æl	8899<æl	
8889l	9æ"l	,8888;;;;;;;;;;9æl	=888?æm	8899<æm	
8889m	9æ"m	,8888;;;;;;;;;;9æm	=888?æn	8899<æn	
8889n	9æ"n	,8888;;;;;;;;;;9æn	=888?æo	8899<æo	
8889o	9æ"o	,8888;;;;;;;;;;9æo	=888?æp	8899<æp	
8889p	9æ"p	,8888;;;;;;;;;;9æp	=888?æq	8899<æq	
8889q	9æ"q	,8888;;;;;;;;;;9æq	=888?ær	8899<ær	
8889r	9æ"r	,8888;;;;;;;;;;9ær	=888?æs	8899<æs	
8889s	9æ"s	,8888;;;;;;;;;;9æs	=888?æt	8899<æt	
8889t	9æ"t	,8888;;;;;;;;;;9æt	=888?æu	8899<æu	
8889u	9æ"u	,8888;;;;;;;;;;9æu	=888?æv	8899<æv	
8889v	9æ"v	,8888;;;;;;;;;;9æv	=888?æw	8899<æw	
8889w	9æ"w	,8888;;;;;;;;;;9æw	=888?æx	8899<æx	
8889x	9æ"x	,8888;;;;;;;;;;9æx	=888?æy	8899<æy	
8889y	9æ"y	,8888;;;;;;;;;;9æy	=888?æz	8899<æz	
8889z	9æ"z	,8888;;;;;;;;;;9æz	=888?æ{	8899<æ{	
8889{	9æ"{	,8888;;;;;;;;;;9æ{	=888?æ|	8899<æ|	
8889|	9æ"|	,8888;;;;;;;;;;9æ|	=888?æ}	8899<æ}	
8889}	9æ"}	,8888;;;;;;;;;;9æ}	=888?æ~	8899<æ~	
8889~	9æ"~	,8888;;;;;;;;;;9æ~	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?◊D@lfffffffffffffffffffffffffffffffÄ	@í?7Å	@í?7Ç	@í?7?	@í?7Ñ	@í?7Ö	@í?7Ü	@í?7á	@í?7?	@í?7â	@í?7–	@í?7ã	@í?7?	@í?7?	@í?7ﬁ	@í?7?	@í?7ê	@í?7ë	@í?7í	@í?7ì	@í?7î	@í?7ï	@í?7ñ	@í?7ó	@í?7?	@í?7ô	@í?7	@í?7õ	@í?7?	@í?7?	@í?7˛	@í?7?	@í?7æÄ	8899<æÄ	
8889Ä	9æ"Ä	,8888;;;;;;;;;;9æÄ	=888?æÅ	8899<æÅ	
8889Å	9æ"Å	,8888;;;;;;;;;;9æÅ	=888?æÇ	8899<æÇ	
8889Ç	9æ"Ç	,8888;;;;;;;;;;9æÇ	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æÑ	8899<æÑ	
8889Ñ	9æ"Ñ	,8888;;;;;;;;;;9æÑ	=888?æÖ	8899<æÖ	
8889Ö	9æ"Ö	,8888;;;;;;;;;;9æÖ	=888?æÜ	8899<æÜ	
8889Ü	9æ"Ü	,8888;;;;;;;;;;9æÜ	=888?æá	8899<æá	
8889á	9æ"á	,8888;;;;;;;;;;9æá	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æâ	8899<æâ	
8889â	9æ"â	,8888;;;;;;;;;;9æâ	=888?æ–	8899<æ–	
8889–	9æ"–	,8888;;;;;;;;;;9æ–	=888?æã	8899<æã	
8889ã	9æ"ã	,8888;;;;;;;;;;9æã	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æﬁ	8899<æﬁ	
8889ﬁ	9æ"ﬁ	,8888;;;;;;;;;;9æﬁ	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æê	8899<æê	
8889ê	9æ"ê	,8888;;;;;;;;;;9æê	=888?æë	8899<æë	
8889ë	9æ"ë	,8888;;;;;;;;;;9æë	=888?æí	8899<æí	
8889í	9æ"í	,8888;;;;;;;;;;9æí	=888?æì	8899<æì	
8889ì	9æ"ì	,8888;;;;;;;;;;9æì	=888?æî	8899<æî	
8889î	9æ"î	,8888;;;;;;;;;;9æî	=888?æï	8899<æï	
8889ï	9æ"ï	,8888;;;;;;;;;;9æï	=888?æñ	8899<æñ	
8889ñ	9æ"ñ	,8888;;;;;;;;;;9æñ	=888?æó	8899<æó	
8889ó	9æ"ó	,8888;;;;;;;;;;9æó	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æô	8899<æô	
8889ô	9æ"ô	,8888;;;;;;;;;;9æô	=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æõ	8899<æõ	
8889õ	9æ"õ	,8888;;;;;;;;;;9æõ	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ˛	8899<æ˛	
8889˛	9æ"˛	,8888;;;;;;;;;;9æ˛	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?◊D@lfffffffffffffffffffffffffffffff 	@í?7?	@í?7¢	@í?7£	@í?7§	@í?7?	@í?7¶	@í?7ß	@í?7ç	@í?7©	@í?7?	@í?7´	@í?7¨	@í?7≠	@í?7Æ	@í?7ù	@í?7∞	@í?7±	@í?7≤	@í?7≥	@í?7¥	@í?7µ	@í?7∂	@í?7∑	@í?7è	@í?7π	@í?7?	@í?7ª	@í?7º	@í?7Ω	@í?7æ	@í?7?	@í?7æ 	8899<æ 	
8889 	9æ" 	,8888;;;;;;;;;;9æ 	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ¢	8899<æ¢	
8889¢	9æ"¢	,8888;;;;;;;;;;9æ¢	=888?æ£	8899<æ£	
8889£	9æ"£	,8888;;;;;;;;;;9æ£	=888?æ§	8899<æ§	
8889§	9æ"§	,8888;;;;;;;;;;9æ§	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ¶	8899<æ¶	
8889¶	9æ"¶	,8888;;;;;;;;;;9æ¶	=888?æß	8899<æß	
8889ß	9æ"ß	,8888;;;;;;;;;;9æß	=888?æç	8899<æç	
8889ç	9æ"ç	,8888;;;;;;;;;;9æç	=888?æ©	8899<æ©	
8889©	9æ"©	,8888;;;;;;;;;;9æ©	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ´	8899<æ´	
8889´	9æ"´	,8888;;;;;;;;;;9æ´	=888?æ¨	8899<æ¨	
8889¨	9æ"¨	,8888;;;;;;;;;;9æ¨	=888?æ≠	8899<æ≠	
8889≠	9æ"≠	,8888;;;;;;;;;;9æ≠	=888?æÆ	8899<æÆ	
8889Æ	9æ"Æ	,8888;;;;;;;;;;9æÆ	=888?æù	8899<æù	
8889ù	9æ"ù	,8888;;;;;;;;;;9æù	=888?æ∞	8899<æ∞	
8889∞	9æ"∞	,8888;;;;;;;;;;9æ∞	=888?æ±	8899<æ±	
8889±	9æ"±	,8888;;;;;;;;;;9æ±	=888?æ≤	8899<æ≤	
8889≤	9æ"≤	,8888;;;;;;;;;;9æ≤	=888?æ≥	8899<æ≥	
8889≥	9æ"≥	,8888;;;;;;;;;;9æ≥	=888?æ¥	8899<æ¥	
8889¥	9æ"¥	,8888;;;;;;;;;;9æ¥	=888?æµ	8899<æµ	
8889µ	9æ"µ	,8888;;;;;;;;;;9æµ	=888?æ∂	8899<æ∂	
8889∂	9æ"∂	,8888;;;;;;;;;;9æ∂	=888?æ∑	8899<æ∑	
8889∑	9æ"∑	,8888;;;;;;;;;;9æ∑	=888?æè	8899<æè	
8889è	9æ"è	,8888;;;;;;;;;;9æè	=888?æπ	8899<æπ	
8889π	9æ"π	,8888;;;;;;;;;;9æπ	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æª	8899<æª	
8889ª	9æ"ª	,8888;;;;;;;;;;9æª	=888?æº	8899<æº	
8889º	9æ"º	,8888;;;;;;;;;;9æº	=888?æΩ	8899<æΩ	
8889Ω	9æ"Ω	,8888;;;;;;;;;;9æΩ	=888?ææ	8899<ææ	
8889æ	9æ"æ	,8888;;;;;;;;;;9ææ	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?◊D@lfffffffffffffffffffffffffffffff?	@í?7?	@í?7?	@í?7?	@í?7ƒ	@í?7≈	@í?7Ø	@í?7?	@í?7?	@í?7…	@í?7?	@í?7?	@í?7?	@í?7?	@í?7?	@í?7?	@í?7?	@í?7?	@í?7?	@í?7”	@í?7?	@í?7’	@í?7÷	@í?7◊	@í?7®	@í?7?	@í?7?	@í?7?	@í?7‹	@í?7?	@í?7?	@í?7ﬂ	@í?7æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æƒ	8899<æƒ	
8889ƒ	9æ"ƒ	,8888;;;;;;;;;;9æƒ	=888?æ≈	8899<æ≈	
8889≈	9æ"≈	,8888;;;;;;;;;;9æ≈	=888?æØ	8899<æØ	
8889Ø	9æ"Ø	,8888;;;;;;;;;;9æØ	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ…	8899<æ…	
8889…	9æ"…	,8888;;;;;;;;;;9æ…	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ”	8899<æ”	
8889”	9æ"”	,8888;;;;;;;;;;9æ”	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ’	8899<æ’	
8889’	9æ"’	,8888;;;;;;;;;;9æ’	=888?æ÷	8899<æ÷	
8889÷	9æ"÷	,8888;;;;;;;;;;9æ÷	=888?æ◊	8899<æ◊	
8889◊	9æ"◊	,8888;;;;;;;;;;9æ◊	=888?æ®	8899<æ®	
8889®	9æ"®	,8888;;;;;;;;;;9æ®	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ‹	8899<æ‹	
8889‹	9æ"‹	,8888;;;;;;;;;;9æ‹	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æﬂ	8899<æﬂ	
8889ﬂ	9æ"ﬂ	,8888;;;;;;;;;;9æﬂ	=888?◊D@lfffffffffffffffffffffffffffffff?	@í?7?	@í?7?	@í?7?	@í?7‰	@í?7Â	@í?7ø	@í?7?	@í?7?	@í?7È	@í?7?	@í?7?	@í?7?	@í?7?	@í?7?	@í?7?	@í?7?	@í?7?	@í?7?	@í?7Û	@í?7?	@í?7ı	@í?7ˆ	@í?7˜	@í?7∏	@í?7?	@í?7?	@í?7?	@í?7¸	@í?7?	@í?7?	@í?7?	@í?7æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ‰	8899<æ‰	
8889‰	9æ"‰	,8888;;;;;;;;;;9æ‰	=888?æÂ	8899<æÂ	
8889Â	9æ"Â	,8888;;;;;;;;;;9æÂ	=888?æø	8899<æø	
8889ø	9æ"ø	,8888;;;;;;;;;;9æø	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æÈ	8899<æÈ	
8889È	9æ"È	,8888;;;;;;;;;;9æÈ	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æÛ	8899<æÛ	
8889Û	9æ"Û	,8888;;;;;;;;;;9æÛ	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æı	8899<æı	
8889ı	9æ"ı	,8888;;;;;;;;;;9æı	=888?æˆ	8899<æˆ	
8889ˆ	9æ"ˆ	,8888;;;;;;;;;;9æˆ	=888?æ˜	8899<æ˜	
8889˜	9æ"˜	,8888;;;;;;;;;;9æ˜	=888?æ∏	8899<æ∏	
8889∏	9æ"∏	,8888;;;;;;;;;;9æ∏	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ¸	8899<æ¸	
8889¸	9æ"¸	,8888;;;;;;;;;;9æ¸	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?æ?	8899<æ?	
8889?	9æ"?	,8888;;;;;;;;;;9æ?	=888?◊D@lfffffffffffffffffffffffffffffff
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7	
@í?7

@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7
@í?7æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ	
8899<æ	

8889	
9æ"	
,8888;;;;;;;;;;9æ	
=888?æ

8899<æ


8889

9æ"

,8888;;;;;;;;;;9æ

=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?◊D@lfffffffffffffffffffffffffffffff 
@í?7!
@í?7"
@í?7#
@í?7$
@í?7%
@í?7&
@í?7'
@í?7(
@í?7)
@í?7*
@í?7+
@í?7,
@í?7-
@í?7.
@í?7/
@í?70
@í?71
@í?72
@í?73
@í?74
@í?75
@í?76
@í?77
@í?78
@í?79
@í?7:
@í?7;
@í?7<
@í?7=
@í?7>
@í?7?
@í?7æ 
8899<æ 

8889 
9æ" 
,8888;;;;;;;;;;9æ 
=888?æ!
8899<æ!

8889!
9æ"!
,8888;;;;;;;;;;9æ!
=888?æ"
8899<æ"

8889"
9æ""
,8888;;;;;;;;;;9æ"
=888?æ#
8899<æ#

8889#
9æ"#
,8888;;;;;;;;;;9æ#
=888?æ$
8899<æ$

8889$
9æ"$
,8888;;;;;;;;;;9æ$
=888?æ%
8899<æ%

8889%
9æ"%
,8888;;;;;;;;;;9æ%
=888?æ&
8899<æ&

8889&
9æ"&
,8888;;;;;;;;;;9æ&
=888?æ'
8899<æ'

8889'
9æ"'
,8888;;;;;;;;;;9æ'
=888?æ(
8899<æ(

8889(
9æ"(
,8888;;;;;;;;;;9æ(
=888?æ)
8899<æ)

8889)
9æ")
,8888;;;;;;;;;;9æ)
=888?æ*
8899<æ*

8889*
9æ"*
,8888;;;;;;;;;;9æ*
=888?æ+
8899<æ+

8889+
9æ"+
,8888;;;;;;;;;;9æ+
=888?æ,
8899<æ,

8889,
9æ",
,8888;;;;;;;;;;9æ,
=888?æ-
8899<æ-

8889-
9æ"-
,8888;;;;;;;;;;9æ-
=888?æ.
8899<æ.

8889.
9æ".
,8888;;;;;;;;;;9æ.
=888?æ/
8899<æ/

8889/
9æ"/
,8888;;;;;;;;;;9æ/
=888?æ0
8899<æ0

88890
9æ"0
,8888;;;;;;;;;;9æ0
=888?æ1
8899<æ1

88891
9æ"1
,8888;;;;;;;;;;9æ1
=888?æ2
8899<æ2

88892
9æ"2
,8888;;;;;;;;;;9æ2
=888?æ3
8899<æ3

88893
9æ"3
,8888;;;;;;;;;;9æ3
=888?æ4
8899<æ4

88894
9æ"4
,8888;;;;;;;;;;9æ4
=888?æ5
8899<æ5

88895
9æ"5
,8888;;;;;;;;;;9æ5
=888?æ6
8899<æ6

88896
9æ"6
,8888;;;;;;;;;;9æ6
=888?æ7
8899<æ7

88897
9æ"7
,8888;;;;;;;;;;9æ7
=888?æ8
8899<æ8

88898
9æ"8
,8888;;;;;;;;;;9æ8
=888?æ9
8899<æ9

88899
9æ"9
,8888;;;;;;;;;;9æ9
=888?æ:
8899<æ:

8889:
9æ":
,8888;;;;;;;;;;9æ:
=888?æ;
8899<æ;

8889;
9æ";
,8888;;;;;;;;;;9æ;
=888?æ<
8899<æ<

8889<
9æ"<
,8888;;;;;;;;;;9æ<
=888?æ=
8899<æ=

8889=
9æ"=
,8888;;;;;;;;;;9æ=
=888?æ>
8899<æ>

8889>
9æ">
,8888;;;;;;;;;;9æ>
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?◊D@lfffffffffffffffffffffffffffffff@
@í?7A
@í?7B
@í?7C
@í?7D
@í?7E
@í?7F
@í?7G
@í?7H
@í?7I
@í?7J
@í?7K
@í?7L
@í?7M
@í?7N
@í?7O
@í?7P
@í?7Q
@í?7R
@í?7S
@í?7T
@í?7U
@í?7V
@í?7W
@í?7X
@í?7Y
@í?7Z
@í?7[
@í?7\
@í?7]
@í?7^
@í?7_
@í?7æ@
8899<æ@

8889@
9æ"@
,8888;;;;;;;;;;9æ@
=888?æA
8899<æA

8889A
9æ"A
,8888;;;;;;;;;;9æA
=888?æB
8899<æB

8889B
9æ"B
,8888;;;;;;;;;;9æB
=888?æC
8899<æC

8889C
9æ"C
,8888;;;;;;;;;;9æC
=888?æD
8899<æD

8889D
9æ"D
,8888;;;;;;;;;;9æD
=888?æE
8899<æE

8889E
9æ"E
,8888;;;;;;;;;;9æE
=888?æF
8899<æF

8889F
9æ"F
,8888;;;;;;;;;;9æF
=888?æG
8899<æG

8889G
9æ"G
,8888;;;;;;;;;;9æG
=888?æH
8899<æH

8889H
9æ"H
,8888;;;;;;;;;;9æH
=888?æI
8899<æI

8889I
9æ"I
,8888;;;;;;;;;;9æI
=888?æJ
8899<æJ

8889J
9æ"J
,8888;;;;;;;;;;9æJ
=888?æK
8899<æK

8889K
9æ"K
,8888;;;;;;;;;;9æK
=888?æL
8899<æL

8889L
9æ"L
,8888;;;;;;;;;;9æL
=888?æM
8899<æM

8889M
9æ"M
,8888;;;;;;;;;;9æM
=888?æN
8899<æN

8889N
9æ"N
,8888;;;;;;;;;;9æN
=888?æO
8899<æO

8889O
9æ"O
,8888;;;;;;;;;;9æO
=888?æP
8899<æP

8889P
9æ"P
,8888;;;;;;;;;;9æP
=888?æQ
8899<æQ

8889Q
9æ"Q
,8888;;;;;;;;;;9æQ
=888?æR
8899<æR

8889R
9æ"R
,8888;;;;;;;;;;9æR
=888?æS
8899<æS

8889S
9æ"S
,8888;;;;;;;;;;9æS
=888?æT
8899<æT

8889T
9æ"T
,8888;;;;;;;;;;9æT
=888?æU
8899<æU

8889U
9æ"U
,8888;;;;;;;;;;9æU
=888?æV
8899<æV

8889V
9æ"V
,8888;;;;;;;;;;9æV
=888?æW
8899<æW

8889W
9æ"W
,8888;;;;;;;;;;9æW
=888?æX
8899<æX

8889X
9æ"X
,8888;;;;;;;;;;9æX
=888?æY
8899<æY

8889Y
9æ"Y
,8888;;;;;;;;;;9æY
=888?æZ
8899<æZ

8889Z
9æ"Z
,8888;;;;;;;;;;9æZ
=888?æ[
8899<æ[

8889[
9æ"[
,8888;;;;;;;;;;9æ[
=888?æ\
8899<æ\

8889\
9æ"\
,8888;;;;;;;;;;9æ\
=888?æ]
8899<æ]

8889]
9æ"]
,8888;;;;;;;;;;9æ]
=888?æ^
8899<æ^

8889^
9æ"^
,8888;;;;;;;;;;9æ^
=888?æ_
8899<æ_

8889_
9æ"_
,8888;;;;;;;;;;9æ_
=888?◊D@lfffffffffffffffffffffffffffffff`
@í?7a
@í?7b
@í?7c
@í?7d
@í?7e
@í?7f
@í?7g
@í?7h
@í?7i
@í?7j
@í?7k
@í?7l
@í?7m
@í?7n
@í?7o
@í?7p
@í?7q
@í?7r
@í?7s
@í?7t
@í?7u
@í?7v
@í?7w
@í?7x
@í?7y
@í?7z
@í?7{
@í?7|
@í?7}
@í?7~
@í?7
@í?7æ`
8899<æ`

8889`
9æ"`
,8888;;;;;;;;;;9æ`
=888?æa
8899<æa

8889a
9æ"a
,8888;;;;;;;;;;9æa
=888?æb
8899<æb

8889b
9æ"b
,8888;;;;;;;;;;9æb
=888?æc
8899<æc

8889c
9æ"c
,8888;;;;;;;;;;9æc
=888?æd
8899<æd

8889d
9æ"d
,8888;;;;;;;;;;9æd
=888?æe
8899<æe

8889e
9æ"e
,8888;;;;;;;;;;9æe
=888?æf
8899<æf

8889f
9æ"f
,8888;;;;;;;;;;9æf
=888?æg
8899<æg

8889g
9æ"g
,8888;;;;;;;;;;9æg
=888?æh
8899<æh

8889h
9æ"h
,8888;;;;;;;;;;9æh
=888?æi
8899<æi

8889i
9æ"i
,8888;;;;;;;;;;9æi
=888?æj
8899<æj

8889j
9æ"j
,8888;;;;;;;;;;9æj
=888?æk
8899<æk

8889k
9æ"k
,8888;;;;;;;;;;9æk
=888?æl
8899<æl

8889l
9æ"l
,8888;;;;;;;;;;9æl
=888?æm
8899<æm

8889m
9æ"m
,8888;;;;;;;;;;9æm
=888?æn
8899<æn

8889n
9æ"n
,8888;;;;;;;;;;9æn
=888?æo
8899<æo

8889o
9æ"o
,8888;;;;;;;;;;9æo
=888?æp
8899<æp

8889p
9æ"p
,8888;;;;;;;;;;9æp
=888?æq
8899<æq

8889q
9æ"q
,8888;;;;;;;;;;9æq
=888?ær
8899<ær

8889r
9æ"r
,8888;;;;;;;;;;9ær
=888?æs
8899<æs

8889s
9æ"s
,8888;;;;;;;;;;9æs
=888?æt
8899<æt

8889t
9æ"t
,8888;;;;;;;;;;9æt
=888?æu
8899<æu

8889u
9æ"u
,8888;;;;;;;;;;9æu
=888?æv
8899<æv

8889v
9æ"v
,8888;;;;;;;;;;9æv
=888?æw
8899<æw

8889w
9æ"w
,8888;;;;;;;;;;9æw
=888?æx
8899<æx

8889x
9æ"x
,8888;;;;;;;;;;9æx
=888?æy
8899<æy

8889y
9æ"y
,8888;;;;;;;;;;9æy
=888?æz
8899<æz

8889z
9æ"z
,8888;;;;;;;;;;9æz
=888?æ{
8899<æ{

8889{
9æ"{
,8888;;;;;;;;;;9æ{
=888?æ|
8899<æ|

8889|
9æ"|
,8888;;;;;;;;;;9æ|
=888?æ}
8899<æ}

8889}
9æ"}
,8888;;;;;;;;;;9æ}
=888?æ~
8899<æ~

8889~
9æ"~
,8888;;;;;;;;;;9æ~
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?◊D@lfffffffffffffffffffffffffffffffÄ
@í?7Å
@í?7Ç
@í?7?
@í?7Ñ
@í?7Ö
@í?7Ü
@í?7á
@í?7?
@í?7â
@í?7–
@í?7ã
@í?7?
@í?7?
@í?7ﬁ
@í?7?
@í?7ê
@í?7ë
@í?7í
@í?7ì
@í?7î
@í?7ï
@í?7ñ
@í?7ó
@í?7?
@í?7ô
@í?7
@í?7õ
@í?7?
@í?7?
@í?7˛
@í?7?
@í?7æÄ
8899<æÄ

8889Ä
9æ"Ä
,8888;;;;;;;;;;9æÄ
=888?æÅ
8899<æÅ

8889Å
9æ"Å
,8888;;;;;;;;;;9æÅ
=888?æÇ
8899<æÇ

8889Ç
9æ"Ç
,8888;;;;;;;;;;9æÇ
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æÑ
8899<æÑ

8889Ñ
9æ"Ñ
,8888;;;;;;;;;;9æÑ
=888?æÖ
8899<æÖ

8889Ö
9æ"Ö
,8888;;;;;;;;;;9æÖ
=888?æÜ
8899<æÜ

8889Ü
9æ"Ü
,8888;;;;;;;;;;9æÜ
=888?æá
8899<æá

8889á
9æ"á
,8888;;;;;;;;;;9æá
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æâ
8899<æâ

8889â
9æ"â
,8888;;;;;;;;;;9æâ
=888?æ–
8899<æ–

8889–
9æ"–
,8888;;;;;;;;;;9æ–
=888?æã
8899<æã

8889ã
9æ"ã
,8888;;;;;;;;;;9æã
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æﬁ
8899<æﬁ

8889ﬁ
9æ"ﬁ
,8888;;;;;;;;;;9æﬁ
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æê
8899<æê

8889ê
9æ"ê
,8888;;;;;;;;;;9æê
=888?æë
8899<æë

8889ë
9æ"ë
,8888;;;;;;;;;;9æë
=888?æí
8899<æí

8889í
9æ"í
,8888;;;;;;;;;;9æí
=888?æì
8899<æì

8889ì
9æ"ì
,8888;;;;;;;;;;9æì
=888?æî
8899<æî

8889î
9æ"î
,8888;;;;;;;;;;9æî
=888?æï
8899<æï

8889ï
9æ"ï
,8888;;;;;;;;;;9æï
=888?æñ
8899<æñ

8889ñ
9æ"ñ
,8888;;;;;;;;;;9æñ
=888?æó
8899<æó

8889ó
9æ"ó
,8888;;;;;;;;;;9æó
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æô
8899<æô

8889ô
9æ"ô
,8888;;;;;;;;;;9æô
=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æõ
8899<æõ

8889õ
9æ"õ
,8888;;;;;;;;;;9æõ
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ˛
8899<æ˛

8889˛
9æ"˛
,8888;;;;;;;;;;9æ˛
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?◊D@lfffffffffffffffffffffffffffffff 
@í?7?
@í?7¢
@í?7£
@í?7§
@í?7?
@í?7¶
@í?7ß
@í?7ç
@í?7©
@í?7?
@í?7´
@í?7¨
@í?7≠
@í?7Æ
@í?7ù
@í?7∞
@í?7±
@í?7≤
@í?7≥
@í?7¥
@í?7µ
@í?7∂
@í?7∑
@í?7è
@í?7π
@í?7?
@í?7ª
@í?7º
@í?7Ω
@í?7æ
@í?7?
@í?7æ 
8899<æ 

8889 
9æ" 
,8888;;;;;;;;;;9æ 
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ¢
8899<æ¢

8889¢
9æ"¢
,8888;;;;;;;;;;9æ¢
=888?æ£
8899<æ£

8889£
9æ"£
,8888;;;;;;;;;;9æ£
=888?æ§
8899<æ§

8889§
9æ"§
,8888;;;;;;;;;;9æ§
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ¶
8899<æ¶

8889¶
9æ"¶
,8888;;;;;;;;;;9æ¶
=888?æß
8899<æß

8889ß
9æ"ß
,8888;;;;;;;;;;9æß
=888?æç
8899<æç

8889ç
9æ"ç
,8888;;;;;;;;;;9æç
=888?æ©
8899<æ©

8889©
9æ"©
,8888;;;;;;;;;;9æ©
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ´
8899<æ´

8889´
9æ"´
,8888;;;;;;;;;;9æ´
=888?æ¨
8899<æ¨

8889¨
9æ"¨
,8888;;;;;;;;;;9æ¨
=888?æ≠
8899<æ≠

8889≠
9æ"≠
,8888;;;;;;;;;;9æ≠
=888?æÆ
8899<æÆ

8889Æ
9æ"Æ
,8888;;;;;;;;;;9æÆ
=888?æù
8899<æù

8889ù
9æ"ù
,8888;;;;;;;;;;9æù
=888?æ∞
8899<æ∞

8889∞
9æ"∞
,8888;;;;;;;;;;9æ∞
=888?æ±
8899<æ±

8889±
9æ"±
,8888;;;;;;;;;;9æ±
=888?æ≤
8899<æ≤

8889≤
9æ"≤
,8888;;;;;;;;;;9æ≤
=888?æ≥
8899<æ≥

8889≥
9æ"≥
,8888;;;;;;;;;;9æ≥
=888?æ¥
8899<æ¥

8889¥
9æ"¥
,8888;;;;;;;;;;9æ¥
=888?æµ
8899<æµ

8889µ
9æ"µ
,8888;;;;;;;;;;9æµ
=888?æ∂
8899<æ∂

8889∂
9æ"∂
,8888;;;;;;;;;;9æ∂
=888?æ∑
8899<æ∑

8889∑
9æ"∑
,8888;;;;;;;;;;9æ∑
=888?æè
8899<æè

8889è
9æ"è
,8888;;;;;;;;;;9æè
=888?æπ
8899<æπ

8889π
9æ"π
,8888;;;;;;;;;;9æπ
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æª
8899<æª

8889ª
9æ"ª
,8888;;;;;;;;;;9æª
=888?æº
8899<æº

8889º
9æ"º
,8888;;;;;;;;;;9æº
=888?æΩ
8899<æΩ

8889Ω
9æ"Ω
,8888;;;;;;;;;;9æΩ
=888?ææ
8899<ææ

8889æ
9æ"æ
,8888;;;;;;;;;;9ææ
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?◊D@lfffffffffffffffffffffffffffffff?
@í?7?
@í?7?
@í?7?
@í?7ƒ
@í?7≈
@í?7Ø
@í?7?
@í?7?
@í?7…
@í?7?
@í?7?
@í?7?
@í?7?
@í?7?
@í?7?
@í?7?
@í?7?
@í?7?
@í?7”
@í?7?
@í?7’
@í?7÷
@í?7◊
@í?7®
@í?7?
@í?7?
@í?7?
@í?7‹
@í?7?
@í?7?
@í?7ﬂ
@í?7æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æƒ
8899<æƒ

8889ƒ
9æ"ƒ
,8888;;;;;;;;;;9æƒ
=888?æ≈
8899<æ≈

8889≈
9æ"≈
,8888;;;;;;;;;;9æ≈
=888?æØ
8899<æØ

8889Ø
9æ"Ø
,8888;;;;;;;;;;9æØ
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ…
8899<æ…

8889…
9æ"…
,8888;;;;;;;;;;9æ…
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ”
8899<æ”

8889”
9æ"”
,8888;;;;;;;;;;9æ”
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ’
8899<æ’

8889’
9æ"’
,8888;;;;;;;;;;9æ’
=888?æ÷
8899<æ÷

8889÷
9æ"÷
,8888;;;;;;;;;;9æ÷
=888?æ◊
8899<æ◊

8889◊
9æ"◊
,8888;;;;;;;;;;9æ◊
=888?æ®
8899<æ®

8889®
9æ"®
,8888;;;;;;;;;;9æ®
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ‹
8899<æ‹

8889‹
9æ"‹
,8888;;;;;;;;;;9æ‹
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æﬂ
8899<æﬂ

8889ﬂ
9æ"ﬂ
,8888;;;;;;;;;;9æﬂ
=888?◊D@lfffffffffffffffffffffffffffffff?
@í?7?
@í?7?
@í?7?
@í?7‰
@í?7Â
@í?7ø
@í?7?
@í?7?
@í?7È
@í?7?
@í?7?
@í?7?
@í?7?
@í?7?
@í?7?
@í?7?
@í?7?
@í?7?
@í?7Û
@í?7?
@í?7ı
@í?7ˆ
@í?7˜
@í?7∏
@í?7?
@í?7?
@í?7?
@í?7¸
@í?7?
@í?7?
@í?7?
@í?7æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ‰
8899<æ‰

8889‰
9æ"‰
,8888;;;;;;;;;;9æ‰
=888?æÂ
8899<æÂ

8889Â
9æ"Â
,8888;;;;;;;;;;9æÂ
=888?æø
8899<æø

8889ø
9æ"ø
,8888;;;;;;;;;;9æø
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æÈ
8899<æÈ

8889È
9æ"È
,8888;;;;;;;;;;9æÈ
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;	

 !"#$%&'()*+,-./0123456789:;<=>?@A????O????EFGHIJKLMNPSQRT????U????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æÛ
8899<æÛ

8889Û
9æ"Û
,8888;;;;;;;;;;9æÛ
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æı
8899<æı

8889ı
9æ"ı
,8888;;;;;;;;;;9æı
=888?æˆ
8899<æˆ

8889ˆ
9æ"ˆ
,8888;;;;;;;;;;9æˆ
=888?æ˜
8899<æ˜

8889˜
9æ"˜
,8888;;;;;;;;;;9æ˜
=888?æ∏
8899<æ∏

8889∏
9æ"∏
,8888;;;;;;;;;;9æ∏
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ¸
8899<æ¸

8889¸
9æ"¸
,8888;;;;;;;;;;9æ¸
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?æ?
8899<æ?

8889?
9æ"?
,8888;;;;;;;;;;9æ?
=888?◊D@lfffffffffffffffffffffffffffffff@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7	@í?7
@í?7@í?7@í?7
@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffff @í?7!@í?7"@í?7#@í?7$@í?7%@í?7&@í?7'@í?7(@í?7)@í?7*@í?7+@í?7,@í?7-@í?7.@í?7/@í?70@í?71@í?72@í?73@í?74@í?75@í?76@í?77@í?78@í?79@í?7:@í?7;@í?7<@í?7=@í?7>@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ!8899<æ!
8889!9æ"!,8888;;;;;;;;;;9æ!=888?æ"8899<æ"
8889"9æ"",8888;;;;;;;;;;9æ"=888?æ#8899<æ#
8889#9æ"#,8888;;;;;;;;;;9æ#=888?æ$8899<æ$
8889$9æ"$,8888;;;;;;;;;;9æ$=888?æ%8899<æ%
8889%9æ"%,8888;;;;;;;;;;9æ%=888?æ&8899<æ&
8889&9æ"&,8888;;;;;;;;;;9æ&=888?æ'8899<æ'
8889'9æ"',8888;;;;;;;;;;9æ'=888?æ(8899<æ(
8889(9æ"(,8888;;;;;;;;;;9æ(=888?æ)8899<æ)
8889)9æ"),8888;;;;;;;;;;9æ)=888?æ*8899<æ*
8889*9æ"*,8888;;;;;;;;;;9æ*=888?æ+8899<æ+
8889+9æ"+,8888;;;;;;;;;;9æ+=888?æ,8899<æ,
8889,9æ",,8888;;;;;;;;;;9æ,=888?æ-8899<æ-
8889-9æ"-,8888;;;;;;;;;;9æ-=888?æ.8899<æ.
8889.9æ".,8888;;;;;;;;;;9æ.=888?æ/8899<æ/
8889/9æ"/,8888;;;;;;;;;;9æ/=888?æ08899<æ0
888909æ"0,8888;;;;;;;;;;9æ0=888?æ18899<æ1
888919æ"1,8888;;;;;;;;;;9æ1=888?æ28899<æ2
888929æ"2,8888;;;;;;;;;;9æ2=888?æ38899<æ3
888939æ"3,8888;;;;;;;;;;9æ3=888?æ48899<æ4
888949æ"4,8888;;;;;;;;;;9æ4=888?æ58899<æ5
888959æ"5,8888;;;;;;;;;;9æ5=888?æ68899<æ6
888969æ"6,8888;;;;;;;;;;9æ6=888?æ78899<æ7
888979æ"7,8888;;;;;;;;;;9æ7=888?æ88899<æ8
888989æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888?æ:8899<æ:
8889:9æ":,8888;;;;;;;;;;9æ:=888?æ;8899<æ;
8889;9æ";,8888;;;;;;;;;;9æ;=888?æ<8899<æ<
8889<9æ"<,8888;;;;;;;;;;9æ<=888?æ=8899<æ=
8889=9æ"=,8888;;;;;;;;;;9æ==888?æ>8899<æ>
8889>9æ">,8888;;;;;;;;;;9æ>=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@@í?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@í?7H@í?7I@í?7J@í?7K@í?7L@í?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7T@í?7U@í?7V@í?7W@í?7X@í?7Y@í?7Z@í?7[@í?7\@í?7]@í?7^@í?7_@í?7æ@8899<æ@
8889@9æ"@,8888;;;;;;;;;;9æ@=888?æA8899<æA
8889A9æ"A,8888;;;;;;;;;;9æA=888?æB8899<æB
8889B9æ"B,8888;;;;;;;;;;9æB=888?æC8899<æC
8889C9æ"C,8888;;;;;;;;;;9æC=888?æD8899<æD
8889D9æ"D,8888;;;;;;;;;;9æD=888?æE8899<æE
8889E9æ"E,8888;;;;;;;;;;9æE=888?æF8899<æF
8889F9æ"F,8888;;;;;;;;;;9æF=888?æG8899<æG
8889G9æ"G,8888;;;;;;;;;;9æG=888?æH8899<æH
8889H9æ"H,8888;;;;;;;;;;9æH=888?æI8899<æI
8889I9æ"I,8888;;;;;;;;;;9æI=888?æJ8899<æJ
8889J9æ"J,8888;;;;;;;;;;9æJ=888?æK8899<æK
8889K9æ"K,8888;;;;;;;;;;9æK=888?æL8899<æL
8889L9æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888?æN8899<æN
8889N9æ"N,8888;;;;;;;;;;9æN=888?æO8899<æO
8889O9æ"O,8888;;;;;;;;;;9æO=888?æP8899<æP
8889P9æ"P,8888;;;;;;;;;;9æP=888?æQ8899<æQ
8889Q9æ"Q,8888;;;;;;;;;;9æQ=888?æR8899<æR
8889R9æ"R,8888;;;;;;;;;;9æR=888?æS8899<æS
8889S9æ"S,8888;;;;;;;;;;9æS=888?æT8899<æT
8889T9æ"T,8888;;;;;;;;;;9æT=888?æU8899<æU
8889U9æ"U,8888;;;;;;;;;;9æU=888?æV8899<æV
8889V9æ"V,8888;;;;;;;;;;9æV=888?æW8899<æW
8889W9æ"W,8888;;;;;;;;;;9æW=888?æX8899<æX
8889X9æ"X,8888;;;;;;;;;;9æX=888?æY8899<æY
8889Y9æ"Y,8888;;;;;;;;;;9æY=888?æZ8899<æZ
8889Z9æ"Z,8888;;;;;;;;;;9æZ=888?æ[8899<æ[
8889[9æ"[,8888;;;;;;;;;;9æ[=888?æ\8899<æ\
8889\9æ"\,8888;;;;;;;;;;9æ\=888?æ]8899<æ]
8889]9æ"],8888;;;;;;;;;;9æ]=888?æ^8899<æ^
8889^9æ"^,8888;;;;;;;;;;9æ^=888?æ_8899<æ_
8889_9æ"_,8888;;;;;;;;;;9æ_=888?◊D@lfffffffffffffffffffffffffffffff`@í?7a@í?7b@í?7c@í?7d@í?7e@í?7f@í?7g@í?7h@í?7i@í?7j@í?7k@í?7l@í?7m@í?7n@í?7o@í?7p@í?7q@í?7r@í?7s@í?7t@í?7u@í?7v@í?7w@í?7x@í?7y@í?7z@í?7{@í?7|@í?7}@í?7~@í?7@í?7æ`8899<æ`
8889`9æ"`,8888;;;;;;;;;;9æ`=888?æa8899<æa
8889a9æ"a,8888;;;;;;;;;;9æa=888?æb8899<æb
8889b9æ"b,8888;;;;;;;;;;9æb=888?æc8899<æc
8889c9æ"c,8888;;;;;;;;;;9æc=888?æd8899<æd
8889d9æ"d,8888;;;;;;;;;;9æd=888?æe8899<æe
8889e9æ"e,8888;;;;;;;;;;9æe=888?æf8899<æf
8889f9æ"f,8888;;;;;;;;;;9æf=888?æg8899<æg
8889g9æ"g,8888;;;;;;;;;;9æg=888?æh8899<æh
8889h9æ"h,8888;;;;;;;;;;9æh=888?æi8899<æi
8889i9æ"i,8888;;;;;;;;;;9æi=888?æj8899<æj
8889j9æ"j,8888;;;;;;;;;;9æj=888?æk8899<æk
8889k9æ"k,8888;;;;;;;;;;9æk=888?æl8899<æl
8889l9æ"l,8888;;;;;;;;;;9æl=888?æm8899<æm
8889m9æ"m,8888;;;;;;;;;;9æm=888?æn8899<æn
8889n9æ"n,8888;;;;;;;;;;9æn=888?æo8899<æo
8889o9æ"o,8888;;;;;;;;;;9æo=888?æp8899<æp
8889p9æ"p,8888;;;;;;;;;;9æp=888?æq8899<æq
8889q9æ"q,8888;;;;;;;;;;9æq=888?ær8899<ær
8889r9æ"r,8888;;;;;;;;;;9ær=888?æs8899<æs
8889s9æ"s,8888;;;;;;;;;;9æs=888?æt8899<æt
8889t9æ"t,8888;;;;;;;;;;9æt=888?æu8899<æu
8889u9æ"u,8888;;;;;;;;;;9æu=888?æv8899<æv
8889v9æ"v,8888;;;;;;;;;;9æv=888?æw8899<æw
8889w9æ"w,8888;;;;;;;;;;9æw=888?æx8899<æx
8889x9æ"x,8888;;;;;;;;;;9æx=888?æy8899<æy
8889y9æ"y,8888;;;;;;;;;;9æy=888?æz8899<æz
8889z9æ"z,8888;;;;;;;;;;9æz=888?æ{8899<æ{
8889{9æ"{,8888;;;;;;;;;;9æ{=888?æ|8899<æ|
8889|9æ"|,8888;;;;;;;;;;9æ|=888?æ}8899<æ}
8889}9æ"},8888;;;;;;;;;;9æ}=888?æ~8899<æ~
8889~9æ"~,8888;;;;;;;;;;9æ~=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffffÄ@í?7Å@í?7Ç@í?7?@í?7Ñ@í?7Ö@í?7Ü@í?7á@í?7?@í?7â@í?7–@í?7ã@í?7?@í?7?@í?7ﬁ@í?7?@í?7ê@í?7ë@í?7í@í?7ì@í?7î@í?7ï@í?7ñ@í?7ó@í?7?@í?7ô@í?7@í?7õ@í?7?@í?7?@í?7˛@í?7?@í?7æÄ8899<æÄ
8889Ä9æ"Ä,8888;;;;;;;;;;9æÄ=888?æÅ8899<æÅ
8889Å9æ"Å,8888;;;;;;;;;;9æÅ=888?æÇ8899<æÇ
8889Ç9æ"Ç,8888;;;;;;;;;;9æÇ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÑ8899<æÑ
8889Ñ9æ"Ñ,8888;;;;;;;;;;9æÑ=888?æÖ8899<æÖ
8889Ö9æ"Ö,8888;;;;;;;;;;9æÖ=888?æÜ8899<æÜ
8889Ü9æ"Ü,8888;;;;;;;;;;9æÜ=888?æá8899<æá
8889á9æ"á,8888;;;;;;;;;;9æá=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æâ8899<æâ
8889â9æ"â,8888;;;;;;;;;;9æâ=888?æ–8899<æ–
8889–9æ"–,8888;;;;;;;;;;9æ–=888?æã8899<æã
8889ã9æ"ã,8888;;;;;;;;;;9æã=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬁ8899<æﬁ
8889ﬁ9æ"ﬁ,8888;;;;;;;;;;9æﬁ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æê8899<æê
8889ê9æ"ê,8888;;;;;;;;;;9æê=888?æë8899<æë
8889ë9æ"ë,8888;;;;;;;;;;9æë=888?æí8899<æí
8889í9æ"í,8888;;;;;;;;;;9æí=888?æì8899<æì
8889ì9æ"ì,8888;;;;;;;;;;9æì=888?æî8899<æî
8889î9æ"î,8888;;;;;;;;;;9æî=888?æï8899<æï
8889ï9æ"ï,8888;;;;;;;;;;9æï=888?æñ8899<æñ
8889ñ9æ"ñ,8888;;;;;;;;;;9æñ=888?æó8899<æó
8889ó9æ"ó,8888;;;;;;;;;;9æó=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æô8899<æô
8889ô9æ"ô,8888;;;;;;;;;;9æô=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æõ8899<æõ
8889õ9æ"õ,8888;;;;;;;;;;9æõ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ˛8899<æ˛
8889˛9æ"˛,8888;;;;;;;;;;9æ˛=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff @í?7?@í?7¢@í?7£@í?7§@í?7?@í?7¶@í?7ß@í?7ç@í?7©@í?7?@í?7´@í?7¨@í?7≠@í?7Æ@í?7ù@í?7∞@í?7±@í?7≤@í?7≥@í?7¥@í?7µ@í?7∂@í?7∑@í?7è@í?7π@í?7?@í?7ª@í?7º@í?7Ω@í?7æ@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¢8899<æ¢
8889¢9æ"¢,8888;;;;;;;;;;9æ¢=888?æ£8899<æ£
8889£9æ"£,8888;;;;;;;;;;9æ£=888?æ§8899<æ§
8889§9æ"§,8888;;;;;;;;;;9æ§=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¶8899<æ¶
8889¶9æ"¶,8888;;;;;;;;;;9æ¶=888?æß8899<æß
8889ß9æ"ß,8888;;;;;;;;;;9æß=888?æç8899<æç
8889ç9æ"ç,8888;;;;;;;;;;9æç=888?æ©8899<æ©
8889©9æ"©,8888;;;;;;;;;;9æ©=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ´8899<æ´
8889´9æ"´,8888;;;;;;;;;;9æ´=888?æ¨8899<æ¨
8889¨9æ"¨,8888;;;;;;;;;;9æ¨=888?æ≠8899<æ≠
8889≠9æ"≠,8888;;;;;;;;;;9æ≠=888?æÆ8899<æÆ
8889Æ9æ"Æ,8888;;;;;;;;;;9æÆ=888?æù8899<æù
8889ù9æ"ù,8888;;;;;;;;;;9æù=888?æ∞8899<æ∞
8889∞9æ"∞,8888;;;;;;;;;;9æ∞=888?æ±8899<æ±
8889±9æ"±,8888;;;;;;;;;;9æ±=888?æ≤8899<æ≤
8889≤9æ"≤,8888;;;;;;;;;;9æ≤=888?æ≥8899<æ≥
8889≥9æ"≥,8888;;;;;;;;;;9æ≥=888?æ¥8899<æ¥
8889¥9æ"¥,8888;;;;;;;;;;9æ¥=888?æµ8899<æµ
8889µ9æ"µ,8888;;;;;;;;;;9æµ=888?æ∂8899<æ∂
8889∂9æ"∂,8888;;;;;;;;;;9æ∂=888?æ∑8899<æ∑
8889∑9æ"∑,8888;;;;;;;;;;9æ∑=888?æè8899<æè
8889è9æ"è,8888;;;;;;;;;;9æè=888?æπ8899<æπ
8889π9æ"π,8888;;;;;;;;;;9æπ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æª8899<æª
8889ª9æ"ª,8888;;;;;;;;;;9æª=888?æº8899<æº
8889º9æ"º,8888;;;;;;;;;;9æº=888?æΩ8899<æΩ
8889Ω9æ"Ω,8888;;;;;;;;;;9æΩ=888?ææ8899<ææ
8889æ9æ"æ,8888;;;;;;;;;;9ææ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7ƒ@í?7≈@í?7Ø@í?7?@í?7?@í?7…@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7”@í?7?@í?7’@í?7÷@í?7◊@í?7®@í?7?@í?7?@í?7?@í?7‹@í?7?@í?7?@í?7ﬂ@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æƒ8899<æƒ
8889ƒ9æ"ƒ,8888;;;;;;;;;;9æƒ=888?æ≈8899<æ≈
8889≈9æ"≈,8888;;;;;;;;;;9æ≈=888?æØ8899<æØ
8889Ø9æ"Ø,8888;;;;;;;;;;9æØ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ…8899<æ…
8889…9æ"…,8888;;;;;;;;;;9æ…=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ”8899<æ”
8889”9æ"”,8888;;;;;;;;;;9æ”=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ’8899<æ’
8889’9æ"’,8888;;;;;;;;;;9æ’=888?æ÷8899<æ÷
8889÷9æ"÷,8888;;;;;;;;;;9æ÷=888?æ◊8899<æ◊
8889◊9æ"◊,8888;;;;;;;;;;9æ◊=888?æ®8899<æ®
8889®9æ"®,8888;;;;;;;;;;9æ®=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‹8899<æ‹
8889‹9æ"‹,8888;;;;;;;;;;9æ‹=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æﬂ8899<æﬂ
8889ﬂ9æ"ﬂ,8888;;;;;;;;;;9æﬂ=888?◊D@lfffffffffffffffffffffffffffffff?@í?7?@í?7?@í?7?@í?7‰@í?7Â@í?7ø@í?7?@í?7?@í?7È@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7?@í?7Û@í?7?@í?7ı@í?7ˆ@í?7˜@í?7∏@í?7?@í?7?@í?7?@í?7¸@í?7?@í?7?@í?7?@í?7æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ‰8899<æ‰
8889‰9æ"‰,8888;;;;;;;;;;9æ‰=888?æÂ8899<æÂ
8889Â9æ"Â,8888;;;;;;;;;;9æÂ=888?æø8899<æø
8889ø9æ"ø,8888;;;;;;;;;;9æø=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÈ8899<æÈ
8889È9æ"È,8888;;;;;;;;;;9æÈ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æÛ8899<æÛ
8889Û9æ"Û,8888;;;;;;;;;;9æÛ=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æı8899<æı
8889ı9æ"ı,8888;;;;;;;;;;9æı=888?æˆ8899<æˆ
8889ˆ9æ"ˆ,8888;;;;;;;;;;9æˆ=888?æ˜8899<æ˜
8889˜9æ"˜,8888;;;;;;;;;;9æ˜=888?æ∏8899<æ∏
8889∏9æ"∏,8888;;;;;;;;;;9æ∏=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ¸8899<æ¸
8889¸9æ"¸,8888;;;;;;;;;;9æ¸=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7	@í?7
@í?7@í?7@í?7
@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7@í?7æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ	8899<æ	
8889	9æ"	,8888;;;;;;;;;;9æ	=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ
8899<æ

8889
9æ"
,8888;;;;;;;;;;9æ
=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?æ8899<æ
88899æ",8888;;;;;;;;;;9æ=888?◊D@lfffffffffffffffffffffffffffffff @í?7!@í?7"@í?7#@í?7$@í?7%@í?7&@í?7'@í?7(@í?7)@í?7*@í?7+@í?7,@í?7-@í?7.@í?7/@í?70@í?71@í?72@í?73@í?74@í?75@í?76@í?77@í?78@í?79@í?7:@í?7;@í?7<@í?7=@í?7>@í?7?@í?7æ 8899<æ 
8889 9æ" ,8888;;;;;;;;;;9æ =888?æ!8899<æ!
8889!9æ"!,8888;;;;;;;;;;9æ!=888?æ"8899<æ"
8889"9æ"",8888;;;;;;;;;;9æ"=888?æ#8899<æ#
8889#9æ"#,8888;;;;;;;;;;9æ#=888?æ$8899<æ$
8889$9æ"$,8888;;;;;;;;;;9æ$=888?æ%8899<æ%
8889%9æ"%,8888;;;;;;;;;;9æ%=888?æ&8899<æ&
8889&9æ"&,8888;;;;;;;;;;9æ&=888?æ'8899<æ'
8889'9æ"',8888;;;;;;;;;;9æ'=888?æ(8899<æ(
8889(9æ"(,8888;;;;;;;;;;9æ(=888?æ)8899<æ)
8889)9æ"),8888;;;;;;;;;;9æ)=888?æ*8899<æ*
8889*9æ"*,8888;;;;;;;;;;9æ*=888?æ+8899<æ+
8889+9æ"+,8888;;;;;;;;;;9æ+=888?æ,8899<æ,
8889,9æ",,8888;;;;;;;;;;9æ,=888?æ-8899<æ-
8889-9æ"-,8888;;;;;;;;;;9æ-=888?æ.8899<æ.
8889.9æ".,8888;;;;;;;;;;9æ.=888?æ/8899<æ/
8889/9æ"/,8888;;;;;;;;;;9æ/=888?æ08899<æ0
888909æ"0,8888;;;;;;;;;;9æ0=888?æ18899<æ1
888919æ"1,8888;;;;;;;;;;9æ1=888?æ28899<æ2
888929æ"2,8888;;;;;;;;;;9æ2=888?æ38899<æ3
888939æ"3,8888;;;;;;;;;;9æ3=888?æ48899<æ4
888949æ"4,8888;;;;;;;;;;9æ4=888?æ58899<æ5
888959æ"5,8888;;;;;;;;;;9æ5=888?æ68899<æ6
888969æ"6,8888;;;;;;;;;;9æ6=888?æ78899<æ7
888979æ"7,8888;;;;;;;;;;9æ7=888?æ88899<æ8
888989æ"8,8888;;;;;;;;;;9æ8=888?æ98899<æ9
888999æ"9,8888;;;;;;;;;;9æ9=888?æ:8899<æ:
8889:9æ":,8888;;;;;;;;;;9æ:=888?æ;8899<æ;
8889;9æ";,8888;;;;;;;;;;9æ;=888?æ<8899<æ<
8889<9æ"<,8888;;;;;;;;;;9æ<=888?æ=8899<æ=
8889=9æ"=,8888;;;;;;;;;;9æ==888?æ>8899<æ>
8889>9æ">,8888;;;;;;;;;;9æ>=888?æ?8899<æ?
8889?9æ"?,8888;;;;;;;;;;9æ?=888?◊D@lfffffffffffffffffffffffffffffff@@í?7A@í?7B@í?7C@í?7D@í?7E@í?7F@í?7G@í?7H@í?7I@í?7J@í?7K@í?7L@í?7M@í?7N@í?7O@í?7P@í?7Q@í?7R@í?7S@í?7æ@8899<æ@
8889@9æ"@,8888;;;;;;;;;;9æ@=888?æA8899<æA
8889A9æ"A,8888;;;;;;;;;;9æA=888?æB8899<æB
8889B9æ"B,8888;;;;;;;;;;9æB=888?æC8899<æC
8889C9æ"C,8888;;;;;;;;;;9æC=888?æD8899<æD
8889D9æ"D,8888;;;;;;;;;;9æD=888?æE8899<æE
8889E9æ"E,8888;;;;;;;;;;9æE=888?æF8899<æF
8889F9æ"F,8888;;;;;;;;;;9æF=888?æG8899<æG
8889G9æ"G,8888;;;;;;;;;;9æG=888?æH8899<æH
8889H9æ"H,8888;;;;;;;;;;9æH=888?æI8899<æI
8889I9æ"I,8888;;;;;;;;;;9æI=888?æJ8899<æJ
8889J9æ"J,8888;;;;;;;;;;9æJ=888?æK8899<æK
8889K9æ"K,8888;;;;;;;;;;9æK=888?æL8899<æL
8889L9æ"L,8888;;;;;;;;;;9æL=888?æM8899<æM
8889M9æ"M,8888;;;;;;;;;;9æM=888?æN8899<æN
8889N9æ"N,8888;;;;;;;;;;9æN=888?æO8899<æO
8889O9æ"O,8888;;;;;;;;;;9æO=888?æP8899<æP
8889P9æ"P,8888;;;;;;;;;;9æP=888?æQ8899<æQ
8889Q9æ"Q,8888;;;;;;;;;;9æQ=888?æR8899<æR
8889R9æ"R,8888;;;;;;;;;;9æR=888?æS8899<æS
8889S9æ"S,8888;;;;;;;;;;9æS=888?◊,?	|fffffffffffffffffffP>∂@ 333?7≤=J????	æ?	;%*+S


µµæg	;%*,S
d?bæ	;%-0S





















∂

æ?	;%49S



µ

æ?	;%13S'
''''


''''''		'µ'æg	;%.0S		æá	;%'(S				æW	;%')S		æW	;%*-S		











?	Sheet4
ThisWorkbook?????????Sheet1?????????Sheet4???? ?_VBA_PROJECT????????????0ô		

????????!"#$%&'()*+,-./????123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUV????XYZ[\]^_????a????cdefghij????lmn????pqrstuvw????y?????????????????????????????ƒ??????=&?[??#?∂????????????????????????x??ME??????????ﬂ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????(SL????S????Sî????<??????N0{00020819-0000-0000-C000-000000000046}????8Ä????????(??????????%????H????????????????????????????????????????????????????????????????????????????????????????????ﬂ??????????x????∞∞Attribute VB_Name = "ThisWorkbook"

?Bas?0{00020P819-0C$0046}Å
|Global?SpacíFalsedCreatablPredêeclaId±Tru
BExposeTemplateDerivíBustomizD2?ƒ??????=&vK??#?∂????????????????????????x??ME??????????ﬂ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????(SL????S????Sî????<??????N0{00020820-0000-0000-C000-000000000046}????8Ä????????(??????????%????H????????????????????????????????????????????????????????????????????????????????????????????ﬂ??????????x????ç∞Attribute VB_Name = "She@et1"

?Bast0{000?20820- C$0046}
|Global!ƒSpacíFalsedCreatablPre declaId´Tru
BExposeTemplateDeriv$íBustomizD2?ƒ??????=&?:??#?∂????????????????????????x??ME??????????ﬂ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????(SL????S????Sî????<??????N0{00020820-0000-0000-C000-000000000046}????8Ä????????(??????????%????H????????????????????????????????????????????????????????????????????????????????????????????ﬂ??????????x????ç∞Attribute VB_Name = "She@et4"

?Bast0{000?20820- C$0046}
|Global!ƒSpacíFalsedCreatablPre declaId´Tru
BExposeTemplateDeriv$íBustomizD2?ay?		‰?*\G{000204EF-0000-0000-C000-000000000046}#4.0#9#C:\PROGRA~1\COMMON~1\MICROS~1\VBA\VBA6\VBE6.DLL#Visual Basic For Applications*\G{00020813-0000-0000-C000-000000000046}#1.5#0#C:\Program Files\Microsoft Office\OFFICE11\EXCEL.EXE#Microsoft Excel 11.0 Object Libraryè*\G{00020430-0000-0000-C000-000000000046}#2.0#0#C:\WINNT\system32\stdole2.tlb#OLE Automation&*\G{2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}#2.3#0#C:\Program Files\Common Files\Microsoft Shared\OFFICE11\MSO.DLL#Microsoft Office 9.0 Object Library
????????pˆïB	??????????????????????????????????????????????????????????=&ThisWorkbook014cb9a55d??ThisWorkbook???[%??Sheet1024cb9a55d??Sheet1??vK%??Sheet4034cb9a55d??Sheet4???:0%??????P????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????0????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????0w^?peFª?º??”Æ?????v?GiôHêâo∞MX????®?¢∂¸?K?§?≈8a?¶????????0Ä??%ExcelÄ+VBA˜?Win16?~Win32Mac≥≤VBA6≠#
VBAProjectæ?stdoleì`OfficeuThisWorkbook|?	Ä?_Evaluate?Sheet1?Sheet4?Workbookk	Worksheet????`??????????????????????????????????????????	??????????????????6
≤Ä0*ê	pHÇd‰
VBAProje?ct4@j
=
dir????????????WPROJECTwm????????????`SPROJECT	????bSummaryInformation(????????k?r	pˆïB	îJ<
rÄstdole>stdoÄle
f%\*\G{00Ä020430-C
0046}#2.0#0#C:\WINNT\system32\c2.tlb#OLE Automation^?DOfficÑDOÄ>fic5ÇD?ÄìÄÅD2DF8D04C-5BFA-101B -BDE5ÄDAA5ÄB4Ä2?DÄógram FilesÄ\CommonMicrosoft Shared\OFFICE11\MSO.DLL#á?M 9.0 Ob? Lib∞raryÄJ”?Ç=&ßThisWorkÄbookGÄ?ThjsW≤ rkbÄo?*?2??
HB1Çw%B,?!?["B+BÇ{ShePet1G?S@#eAXt1H2SN?vK?4?4%…4?4??:…B9ThisWorkbookThisWorkbookSheet1Sheet1Sheet4Sheet4ID="{1B5B3A46-2CB4-4D7D-8C5B-E71D5E0D7526}"
Document=ThisWorkbook/&H00000000
Document=Sheet1/&H00000000
Document=Sheet4/&H00000000
Name="VBAProject"
HelpContextID="0"
VersionCompatible32="393222000"
CMG="9391641BF31FF31FF31FF31F"
DPB="2624D188F7888B898B898B"
GC="B9BB4EB34FB34F4C"

[Host Extender Info]
&H00000001={3832D640-CF90-11CF-8E43-00A0C911005A};VBE;&H00000000

[Workspace]
ThisWorkbook=132, 132, 936, 748, C
Sheet1=154, 154, 958, 770, C
Sheet4=198, 198, 1002, 814, C
Sheet2=176, 176, 980, 792, C
???Ö???Oh´ë+'≥?0ƒHPhÄ?§
∞º‰Jukka RantakariPulkkinen PekkaMicrosoft Excel@ºWDaÄƒ@Ä&§óq?@ÄEâë”???’?’?.ìó+,?ÆD’?’?.ìó+,?ÆDocumentSummaryInformation8????????????oCompObj????????????xm????????????????????????P	PXhpxÄ?
ê?‰Nokia'MainKey values'Key values'!Print_AreaWorksheets
Named Rangesº 8@_PID_HLINKS‰At[$mailto:Jari.Sukanen@digia.com??
???? ?F!Microsoft Office Excel WorksheetBiff8Excel.Sheet.8?9≤q
activeidle2.confml
??<?xml version="1.0" encoding="UTF-16"?>

<configuration xmlns="http://www.s60.com/xml/confml/1" name="activeidle2">

  <feature ref="KCRUidActiveIdle2" name="AI settings2">

    <desc>ActiveIdle2 Internal Variation API</desc>

    <setting ref="KAIMainUIControllerKey" name="Main UI Controller Key" type="int">

      <desc>Main UI controller UID. Possible values area valid main ui controller implementation in the phone. ie UID of the implementation.</desc>

    </setting>

    <setting ref="KAISecondaryUIControllerKey" name="Secondary UI Controller Key" type="int">

      <desc> Main UI controller UID. Possible values area valid secondary ui controller implementation in the phone.</desc>

    </setting>

    <setting id="" ref="KAIActiveUIControllerRange" name="Active UI Controllers" type="sequence">

      <desc> Active UI controller range. Valid values are existing AI2 ui controller implementation uids. First key in range defines first &quot;secondary&quot; ui controller. Main UI controler is defined in its own key.</desc>

    </setting>

    <setting ref="KAIStatusPaneLayout" name="Status Pane Layout" type="selection">

      <desc>Status pane layout setting. 0 = normal, 1 = flat, 2 = hidden</desc>

      <option name="normal" value="0"/>

      <option name="flat" value="1"/>

      <option name="hidden" value="2"/>

    </setting>

    <setting ref="KAIFirstKeyLockKey" name="First Keylock Key" type="int">

      <desc>Scan code of 1st key in the keylock sequence.</desc>

    </setting>

    <setting ref="KAISecondKeyLockKey" name="Second Keylock Key" type="int">

      <desc>Scan code of 2nd key in the keylock sequence.</desc>

    </setting>

    <setting ref="KAISecondKeyLockKey2" name="Second Keylock Key2" type="int">

      <desc>Scan code for optional 2nd key in the keylock sequence. Value of -1 means there is no optional second key.</desc>

    </setting>

    <setting ref="KAIKeyLockTimeout" name="Key Lock Timeout" type="int">

      <desc>Keylock timeout in milliseconds.</desc>

    </setting>

    <setting ref="KAIVoiceDialLaunchKey" name="Voice Dial Launch Key" type="int">

      <desc>Scan code for voice dial launch key.</desc>

    </setting>

    <setting ref="KAIVoiceDialKeyTimeout" name="Voice Dial Key Timeout" type="int">

      <desc>Voice dial key timeout in milliseconds. This should be the same as long key press timeout.</desc>

    </setting>

    <setting ref="KAISPNAndEONS" name="SPN And EONS" type="int">

      <desc>Display PLMN and SPN indicators simultaneously. 0 = do not display simultaneously, 1 = display simultaneously.</desc>

      <option name="no simultaneous" value="0"/>

      <option name="simultaneous" value="1"/>

    </setting>

    <setting ref="KAIVHZInMainpane" name="Homezome Indicator in main pane" type="selection">

      <desc>Display VHZ in Mainpane or Navipane. 0 = not in main pane, 1 = in main pane.</desc>

      <option name="in status pane" value="0"/>

      <option name="in main pane" value="1"/>

    </setting>

    <setting ref="KAIExternalStatusScreen" name="Display Ext HS themes in listing" type="selection">

      <desc>Display AI1 themes or external standby screen.</desc>

      <option name="no dot display" value="0"/>

      <option name="display" value="1"/>

    </setting>

    <setting ref="KAITouchToolbarVisible" name="Touch toolbar visible" type="int">

      <desc>Display Touch toolbar on touch device. Visible by default. Controlled in themes. Not user modifiable.</desc>

    </setting>

    <setting ref="KAINTInTheme" name="NT In Theme" type="int" readOnly="true">

      <desc>NewsTicker implemented in theme. DO NOT MODIFY.</desc>

    </setting>

    <setting ref="KAIBlacklistedPlugins" name="Blacklisted plugin list" type="string">

      <desc>Blacklisted plugin list.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName1" name="Plugin Settings - PluginName1" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId1" name="Plugin Settings - Id1" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue1" name="First shortcut" type="string">

      <desc>Shortcut definition for shortcut 1. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName2" name="Plugin Settings - PluginName2" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId2" name="Plugin Settings - Id2" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue2" name="Second shortcut" type="string">

      <desc>Shortcut definition for shortcut 2. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName3" name="Plugin Settings - PluginName3" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId3" name="Plugin Settings - Id3" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue3" name="Third shortcut" type="string">

      <desc>Shortcut definition for shortcut 3. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName4" name="Plugin Settings - PluginName4" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId4" name="Plugin Settings - Id4" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue4" name="Fourth shortcut" type="string">

      <desc>Shortcut definition for shortcut 4. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName5" name="Plugin Settings - PluginName5" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId5" name="Plugin Settings - Id5" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue5" name="Fifth shortcut" type="string">

      <desc>Shortcut definition for shortcut 5. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName6" name="Plugin Settings - PluginName6" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId6" name="Plugin Settings - Id6" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue6" name="Sixth shortcut" type="string">

      <desc>Shortcut definition for shortcut 6. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName7" name="Plugin Settings - PluginName7" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId7" name="Plugin Settings - Id7" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue7" name="Seventh shortcut" type="string">

      <desc>Shortcut definition for shortcut 7. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName8" name="Plugin Settings - PluginName8" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId8" name="Plugin Settings - Id8" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue8" name="Eight shortcut" type="string">

      <desc>Shortcut definition for shortcut 8. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName9" name="Plugin Settings - PluginName9" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId9" name="Plugin Settings - Id9" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue9" name="Navigation key Left" type="string">

      <desc>Shortcut definition for navigation key left shortcut. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName10" name="Plugin Settings - PluginName10" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId10" name="Plugin Settings - Id10" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue10" name="Navigation key Right" type="string">

      <desc>Shortcut definition for navigation key right shortcut. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName11" name="Plugin Settings - PluginName11" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId11" name="Plugin Settings - Id11" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue11" name="Navigation key Up" type="string">

      <desc>Shortcut definition for navigation key up shortcut . Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName12" name="Plugin Settings - PluginName12" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId12" name="Plugin Settings - Id12" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue12" name="Navigation key Down" type="string">

      <desc>Shortcut definition for navigation key down shortcut. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName13" name="Plugin Settings - PluginName13" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId13" name="Plugin Settings - Id13" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue13" name="Middle Softkey / Navigation key Selection" type="string">

      <desc>Application UID for MSK / navigation key shortcut. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName14" name="Plugin Settings - PluginName14" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId14" name="Plugin Settings - Id14" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue14" name="Left Softkey" type="string">

      <desc>Shortcut definition for LSK / left softkey shortcut. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName15" name="Plugin Settings - PluginName15" type="string" readOnly="true">

      <desc>Name of the plugin to receive the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId15" name="Plugin Settings - Id15" type="string" readOnly="true">

      <desc>Index of the setting. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue15" name="Right Softkey" type="string">

      <desc>Shortcut definition for RSK / right softkey shortcut. Default (empty string) means that platform values are used.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName16" name="Plugin Settings - PluginName16" type="string" readOnly="true">

      <desc>Indication that this setting belongs to shortcut plug-in. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId16" name="Plugin Settings - Id16" type="string" readOnly="true">

      <desc>ID of the first touch toolbar shortcut shortcut. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue16" name="First Touch Toolbar shortcut" type="string">

      <desc>Application UID and parameters of the first touch toolbar shortcut. Default value localapp:0x101F4CD2 is AppShell. If this value is modified modify also icon definition for it!</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName17" name="Plugin Settings - PluginName17" type="string" readOnly="true">

      <desc>Indication that this setting belongs to shortcut plug-in. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId17" name="Plugin Settings - Id17" type="string" readOnly="true">

      <desc>ID of the second touch toolbar shortcut. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue17" name="Second Touch Toolbar shortcut" type="string">

      <desc>Application UID and parameters of the second touch toolbar shortcut. Default value localapp:0x100058B3?view=0x10282D81 is Dialer. If this value is modified modify also icon definition for it!</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName18" name="Plugin Settings - PluginName18" type="string" readOnly="true">

      <desc>Indication that this setting belongs to shortcut plug-in. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId18" name="Plugin Settings - Id18" type="string" readOnly="true">

      <desc>ID of the third touch toolbar shortcut. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue18" name="Third Touch Toolbar shortcut" type="string">

      <desc>Application UID and parameters of the third touch toolbar shortcut. Default value localapp:0x100058F8 is Profiles. If this value is modified modify also icon definition for it!</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName19" name="Plugin Settings - PluginName19" type="string" readOnly="true">

      <desc>Indication that this setting belongs to shortcut plug-in. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId19" name="Plugin Settings - Id19" type="string" readOnly="true">

      <desc>Identifier to shortcut plug-in that this is an icon override. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue19" name="First Touch Toolbar icon" type="string">

      <desc>Application UID and icon definition for it. Default value localapp:0x101F4CD2?iconmifpath=apps\\activeidle2.mif;1&amp;toolbar=1 overrides touch toolbar icon for AppShell.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName20" name="Plugin Settings - PluginName20" type="string" readOnly="true">

      <desc>Indication that this setting belongs to shortcut plug-in. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId20" name="Plugin Settings - Id20" type="string" readOnly="true">

      <desc>Identifier to shortcut plug-in that this is an icon override. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue20" name="Second Touch Toolbar icon" type="string">

      <desc>Application UID and icon definition for it. Default value localapp:0x100058B3?view=0x10282D81&amp;iconmifpath=apps\\activeidle2.mif;3&amp;toolbar=1 overrides touch toolbar icon for Dialer.</desc>

    </setting>

    <setting ref="KAIPluginSettingsPluginName21" name="Plugin Settings - PluginName21" type="string" readOnly="true">

      <desc>Indication that this setting belongs to shortcut plug-in. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsId21" name="Plugin Settings - Id21" type="string" readOnly="true">

      <desc>Identifier to shortcut plug-in that this is an icon override. DO NOT MODIFY</desc>

    </setting>

    <setting ref="KAIPluginSettingsValue21" name="Third Touch Toolbar icon" type="string">

      <desc>Application UID and icon definition for it. Default value localapp:0x100058F8?iconmifpath=apps\\activeidle2.mif;5&amp;toolbar=1 overrides touch toolbar icon for Profiles.</desc>

    </setting>

    <setting ref="KAISettingsExtraURLShortcut1" name="First extra URL Shortcut" type="string">

      <desc>Additional shortcut to be placed in shortcut settings. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAISettingsExtraURLShortcut2" name="Second extra URL Shortcut" type="string">

      <desc>Additional shortcut to be placed in shortcut settings. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAISettingsExtraURLShortcut3" name="Third extra URL Shortcut" type="string">

      <desc>Additional shortcut to be placed in shortcut settings. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackup1" name="First shortcut backup application" type="string">

      <desc>Backup application definition for shortcut 1. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackup2" name="Second shortcut backup application" type="string">

      <desc>Backup application definition for shortcut 2. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackup3" name="Third shortcut backup application" type="string">

      <desc>Backup application definition for shortcut 3. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackup4" name="Fourth shortcut backup application" type="string">

      <desc>Backup application definition for shortcut 4. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackup5" name="Fifth shortcut backup application" type="string">

      <desc>Backup application definition for shortcut 5. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackup6" name="Sixth shortcut backup application" type="string">

      <desc>Backup application definition for shortcut 6. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackup7" name="Seventh shortcut backup application" type="string">

      <desc>Backup application definition for shortcut 7. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackup8" name="Eighth shortcut backup application" type="string">

      <desc>Backup application definition for shortcut 8. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackupNaviLeft" name="Navi key left shortcut backup application" type="string">

      <desc>Backup application definition for shortcut navigation key left. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackupNaviRight" name="Navi key right shortcut backup application" type="string">

      <desc>Backup application definition for shortcut navigation key right. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackupNaviUp" name="Navi key up shortcut backup application" type="string">

      <desc>Backup application definition for shortcut navigation key up. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackupNaviDown" name="Navi key down shortcut backup application" type="string">

      <desc>Backup application definition for shortcut navigation key down. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackupNaviKey" name="MSK shortcut backup application" type="string">

      <desc>Backup application definition for shortcut navigation key / selection key / MSK. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackupLSK" name="LSK shortcut backup application" type="string">

      <desc>Backup application definition for shortcut LSK. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIShortcutBackupRSK" name="RSK shortcut backup application" type="string">

      <desc>Backup application definition for shortcut RSK. Format same as in normal shortcut definitions.</desc>

    </setting>

    <setting ref="KAIWebStatus" name="HomeScreen status" type="int">

      <desc>This indicates wheather the widget in homescreen can go online or offline</desc>

      <option name="HomeScreen Offline" value="0"/>

      <option name="HomeScreen Online" value="1"/>

    </setting>

    <setting ref="KAICCPluginUID" name="HomeScreen Content Control Plugin UI UID" type="string"/>

    <setting ref="KAIWallpaperChangeType" name="Wallpaper change type" type="int">

      <desc>Indicates whether page specific wallpaper is used or not</desc>

      <option name="Disable" value="0"/>

      <option name="Enable" value="1"/>

    </setting>    

    <setting ref="KAIWallpaperPath" name="Common wallpaper path" type="string">

      <desc>Stores wallpaper path that is common for all Homescreen pages</desc>

    </setting>    

  </feature>

  <data>

    <KCRUidActiveIdle2>

      <KAIMainUIControllerKey>536974636</KAIMainUIControllerKey>

      <KAISecondaryUIControllerKey>271012084</KAISecondaryUIControllerKey>

      <KAIActiveUIControllerRange template="true"></KAIActiveUIControllerRange>

      <KAIStatusPaneLayout>0</KAIStatusPaneLayout>

      <KAIFirstKeyLockKey>164</KAIFirstKeyLockKey>

      <KAISecondKeyLockKey>133</KAISecondKeyLockKey>

      <KAISecondKeyLockKey2>-1</KAISecondKeyLockKey2>

      <KAIKeyLockTimeout>1500</KAIKeyLockTimeout>

      <KAIVoiceDialLaunchKey>165</KAIVoiceDialLaunchKey>

      <KAIVoiceDialKeyTimeout>600</KAIVoiceDialKeyTimeout>

      <KAISPNAndEONS>0</KAISPNAndEONS>

      <KAIVHZInMainpane>1</KAIVHZInMainpane>

      <KAIExternalStatusScreen>1</KAIExternalStatusScreen>

      <KAITouchToolbarVisible>1</KAITouchToolbarVisible>

      <KAINTInTheme>0</KAINTInTheme>

      <KAIBlacklistedPlugins></KAIBlacklistedPlugins>

      <KAIPluginSettingsPluginName1>Settings/Shortcut</KAIPluginSettingsPluginName1>

      <KAIPluginSettingsId1>0x00000001</KAIPluginSettingsId1>

      <KAIPluginSettingsValue1></KAIPluginSettingsValue1>

      <KAIPluginSettingsPluginName2>Settings/Shortcut</KAIPluginSettingsPluginName2>

      <KAIPluginSettingsId2>0x00000002</KAIPluginSettingsId2>

      <KAIPluginSettingsValue2></KAIPluginSettingsValue2>

      <KAIPluginSettingsPluginName3>Settings/Shortcut</KAIPluginSettingsPluginName3>

      <KAIPluginSettingsId3>0x00000003</KAIPluginSettingsId3>

      <KAIPluginSettingsValue3></KAIPluginSettingsValue3>

      <KAIPluginSettingsPluginName4>Settings/Shortcut</KAIPluginSettingsPluginName4>

      <KAIPluginSettingsId4>0x00000004</KAIPluginSettingsId4>

      <KAIPluginSettingsValue4></KAIPluginSettingsValue4>

      <KAIPluginSettingsPluginName5>Settings/Shortcut</KAIPluginSettingsPluginName5>

      <KAIPluginSettingsId5>0x00000005</KAIPluginSettingsId5>

      <KAIPluginSettingsValue5></KAIPluginSettingsValue5>

      <KAIPluginSettingsPluginName6>Settings/Shortcut</KAIPluginSettingsPluginName6>

      <KAIPluginSettingsId6>0x00000006</KAIPluginSettingsId6>

      <KAIPluginSettingsValue6></KAIPluginSettingsValue6>

      <KAIPluginSettingsPluginName7>Settings/Shortcut</KAIPluginSettingsPluginName7>

      <KAIPluginSettingsId7>0x00000007</KAIPluginSettingsId7>

      <KAIPluginSettingsValue7></KAIPluginSettingsValue7>

      <KAIPluginSettingsPluginName8>Settings/Shortcut</KAIPluginSettingsPluginName8>

      <KAIPluginSettingsId8>0x00000008</KAIPluginSettingsId8>

      <KAIPluginSettingsValue8></KAIPluginSettingsValue8>

      <KAIPluginSettingsPluginName9>Settings/Shortcut</KAIPluginSettingsPluginName9>

      <KAIPluginSettingsId9>0x01000000</KAIPluginSettingsId9>

      <KAIPluginSettingsValue9></KAIPluginSettingsValue9>

      <KAIPluginSettingsPluginName10>Settings/Shortcut</KAIPluginSettingsPluginName10>

      <KAIPluginSettingsId10>0x01000001</KAIPluginSettingsId10>

      <KAIPluginSettingsValue10></KAIPluginSettingsValue10>

      <KAIPluginSettingsPluginName11>Settings/Shortcut</KAIPluginSettingsPluginName11>

      <KAIPluginSettingsId11>0x01000002</KAIPluginSettingsId11>

      <KAIPluginSettingsValue11></KAIPluginSettingsValue11>

      <KAIPluginSettingsPluginName12>Settings/Shortcut</KAIPluginSettingsPluginName12>

      <KAIPluginSettingsId12>0x01000003</KAIPluginSettingsId12>

      <KAIPluginSettingsValue12></KAIPluginSettingsValue12>

      <KAIPluginSettingsPluginName13>Settings/Shortcut</KAIPluginSettingsPluginName13>

      <KAIPluginSettingsId13>0x01000004</KAIPluginSettingsId13>

      <KAIPluginSettingsValue13></KAIPluginSettingsValue13>

      <KAIPluginSettingsPluginName14>Settings/Shortcut</KAIPluginSettingsPluginName14>

      <KAIPluginSettingsId14>0x01000100</KAIPluginSettingsId14>

      <KAIPluginSettingsValue14></KAIPluginSettingsValue14>

      <KAIPluginSettingsPluginName15>Settings/Shortcut</KAIPluginSettingsPluginName15>

      <KAIPluginSettingsId15>0x01000101</KAIPluginSettingsId15>

      <KAIPluginSettingsValue15></KAIPluginSettingsValue15>

      <KAIPluginSettingsPluginName16>Settings/Shortcut</KAIPluginSettingsPluginName16>

      <KAIPluginSettingsId16>0x10001000</KAIPluginSettingsId16>

      <KAIPluginSettingsValue16>localapp:0x101F4CD2</KAIPluginSettingsValue16>

      <KAIPluginSettingsPluginName17>Settings/Shortcut</KAIPluginSettingsPluginName17>

      <KAIPluginSettingsId17>0x10001001</KAIPluginSettingsId17>

      <KAIPluginSettingsValue17>localapp:0x100058B3?view=0x10282D81</KAIPluginSettingsValue17>

      <KAIPluginSettingsPluginName18>Settings/Shortcut</KAIPluginSettingsPluginName18>

      <KAIPluginSettingsId18>0x10001002</KAIPluginSettingsId18>

      <KAIPluginSettingsValue18>localapp:0x100058F8</KAIPluginSettingsValue18>

      <KAIPluginSettingsPluginName19>Settings/Shortcut</KAIPluginSettingsPluginName19>

      <KAIPluginSettingsId19>0x20001000</KAIPluginSettingsId19>

      <KAIPluginSettingsValue19>localapp:0x101F4CD2?iconid=270501603;7110&amp;toolbar=1</KAIPluginSettingsValue19>

      <KAIPluginSettingsPluginName20>Settings/Shortcut</KAIPluginSettingsPluginName20>

      <KAIPluginSettingsId20>0x20001001</KAIPluginSettingsId20>

      <KAIPluginSettingsValue20>localapp:0x100058B3?view=0x10282D81&amp;iconid=270501603;7111&amp;toolbar=1</KAIPluginSettingsValue20>

      <KAIPluginSettingsPluginName21>Settings/Shortcut</KAIPluginSettingsPluginName21>

      <KAIPluginSettingsId21>0x20001002</KAIPluginSettingsId21>

      <KAIPluginSettingsValue21>localapp:0x100058F8?iconid=270501603;7116&amp;toolbar=1</KAIPluginSettingsValue21>

      <KAISettingsExtraURLShortcut1></KAISettingsExtraURLShortcut1>

      <KAISettingsExtraURLShortcut2></KAISettingsExtraURLShortcut2>

      <KAISettingsExtraURLShortcut3></KAISettingsExtraURLShortcut3>

      <KAIShortcutBackup1></KAIShortcutBackup1>

      <KAIShortcutBackup2></KAIShortcutBackup2>

      <KAIShortcutBackup3></KAIShortcutBackup3>

      <KAIShortcutBackup4></KAIShortcutBackup4>

      <KAIShortcutBackup5></KAIShortcutBackup5>

      <KAIShortcutBackup6></KAIShortcutBackup6>

      <KAIShortcutBackup7></KAIShortcutBackup7>

      <KAIShortcutBackup8></KAIShortcutBackup8>

      <KAIShortcutBackupNaviLeft></KAIShortcutBackupNaviLeft>

      <KAIShortcutBackupNaviRight></KAIShortcutBackupNaviRight>

      <KAIShortcutBackupNaviUp></KAIShortcutBackupNaviUp>

      <KAIShortcutBackupNaviDown></KAIShortcutBackupNaviDown>

      <KAIShortcutBackupNaviKey></KAIShortcutBackupNaviKey>

      <KAIShortcutBackupLSK></KAIShortcutBackupLSK>

      <KAIShortcutBackupRSK></KAIShortcutBackupRSK>

      <KAIWebStatus>0</KAIWebStatus>

      <KAICCPluginUID>0x20026F53</KAICCPluginUID>

      <KAIWallpaperChangeType>1</KAIWallpaperChangeType>

      <KAIWallpaperPath></KAIWallpaperPath>

    </KCRUidActiveIdle2>

  </data>

  <rfs>

    <KCRUidActiveIdle2>

      <KAIMainUIControllerKey>true</KAIMainUIControllerKey>

      <KAISecondaryUIControllerKey>true</KAISecondaryUIControllerKey>

      <KAIActiveUIControllerRange>true</KAIActiveUIControllerRange>

      <KAIStatusPaneLayout>true</KAIStatusPaneLayout>

      <KAIFirstKeyLockKey>false</KAIFirstKeyLockKey>

      <KAISecondKeyLockKey>false</KAISecondKeyLockKey>

      <KAISecondKeyLockKey2>false</KAISecondKeyLockKey2>

      <KAIKeyLockTimeout>false</KAIKeyLockTimeout>

      <KAIVoiceDialLaunchKey>false</KAIVoiceDialLaunchKey>

      <KAIVoiceDialKeyTimeout>false</KAIVoiceDialKeyTimeout>

      <KAISPNAndEONS>false</KAISPNAndEONS>

      <KAIVHZInMainpane>false</KAIVHZInMainpane>

      <KAIExternalStatusScreen>true</KAIExternalStatusScreen>

      <KAITouchToolbarVisible>false</KAITouchToolbarVisible>

      <KAINTInTheme>true</KAINTInTheme>

      <KAIBlacklistedPlugins>true</KAIBlacklistedPlugins>

      <KAIPluginSettingsPluginName1>false</KAIPluginSettingsPluginName1>

      <KAIPluginSettingsId1>false</KAIPluginSettingsId1>

      <KAIPluginSettingsValue1>false</KAIPluginSettingsValue1>

      <KAIPluginSettingsPluginName2>false</KAIPluginSettingsPluginName2>

      <KAIPluginSettingsId2>false</KAIPluginSettingsId2>

      <KAIPluginSettingsValue2>false</KAIPluginSettingsValue2>

      <KAIPluginSettingsPluginName3>false</KAIPluginSettingsPluginName3>

      <KAIPluginSettingsId3>false</KAIPluginSettingsId3>

      <KAIPluginSettingsValue3>false</KAIPluginSettingsValue3>

      <KAIPluginSettingsPluginName4>false</KAIPluginSettingsPluginName4>

      <KAIPluginSettingsId4>false</KAIPluginSettingsId4>

      <KAIPluginSettingsValue4>false</KAIPluginSettingsValue4>

      <KAIPluginSettingsPluginName5>false</KAIPluginSettingsPluginName5>

      <KAIPluginSettingsId5>false</KAIPluginSettingsId5>

      <KAIPluginSettingsValue5>false</KAIPluginSettingsValue5>

      <KAIPluginSettingsPluginName6>false</KAIPluginSettingsPluginName6>

      <KAIPluginSettingsId6>false</KAIPluginSettingsId6>

      <KAIPluginSettingsValue6>false</KAIPluginSettingsValue6>

      <KAIPluginSettingsPluginName7>false</KAIPluginSettingsPluginName7>

      <KAIPluginSettingsId7>false</KAIPluginSettingsId7>

      <KAIPluginSettingsValue7>false</KAIPluginSettingsValue7>

      <KAIPluginSettingsPluginName8>false</KAIPluginSettingsPluginName8>

      <KAIPluginSettingsId8>false</KAIPluginSettingsId8>

      <KAIPluginSettingsValue8>false</KAIPluginSettingsValue8>

      <KAIPluginSettingsPluginName9>false</KAIPluginSettingsPluginName9>

      <KAIPluginSettingsId9>false</KAIPluginSettingsId9>

      <KAIPluginSettingsValue9>false</KAIPluginSettingsValue9>

      <KAIPluginSettingsPluginName10>false</KAIPluginSettingsPluginName10>

      <KAIPluginSettingsId10>false</KAIPluginSettingsId10>

      <KAIPluginSettingsValue10>false</KAIPluginSettingsValue10>

      <KAIPluginSettingsPluginName11>false</KAIPluginSettingsPluginName11>

      <KAIPluginSettingsId11>false</KAIPluginSettingsId11>

      <KAIPluginSettingsValue11>false</KAIPluginSettingsValue11>

      <KAIPluginSettingsPluginName12>false</KAIPluginSettingsPluginName12>

      <KAIPluginSettingsId12>false</KAIPluginSettingsId12>

      <KAIPluginSettingsValue12>false</KAIPluginSettingsValue12>

      <KAIPluginSettingsPluginName13>false</KAIPluginSettingsPluginName13>

      <KAIPluginSettingsId13>false</KAIPluginSettingsId13>

      <KAIPluginSettingsValue13>false</KAIPluginSettingsValue13>

      <KAIPluginSettingsPluginName14>false</KAIPluginSettingsPluginName14>

      <KAIPluginSettingsId14>false</KAIPluginSettingsId14>

      <KAIPluginSettingsValue14>false</KAIPluginSettingsValue14>

      <KAIPluginSettingsPluginName15>false</KAIPluginSettingsPluginName15>

      <KAIPluginSettingsId15>false</KAIPluginSettingsId15>

      <KAIPluginSettingsValue15>false</KAIPluginSettingsValue15>

      <KAIPluginSettingsPluginName16>false</KAIPluginSettingsPluginName16>

      <KAIPluginSettingsId16>false</KAIPluginSettingsId16>

      <KAIPluginSettingsValue16>false</KAIPluginSettingsValue16>

      <KAIPluginSettingsPluginName17>false</KAIPluginSettingsPluginName17>

      <KAIPluginSettingsId17>false</KAIPluginSettingsId17>

      <KAIPluginSettingsValue17>false</KAIPluginSettingsValue17>

      <KAIPluginSettingsPluginName18>false</KAIPluginSettingsPluginName18>

      <KAIPluginSettingsId18>false</KAIPluginSettingsId18>

      <KAIPluginSettingsValue18>false</KAIPluginSettingsValue18>

      <KAIPluginSettingsPluginName19>false</KAIPluginSettingsPluginName19>

      <KAIPluginSettingsId19>false</KAIPluginSettingsId19>

      <KAIPluginSettingsValue19>false</KAIPluginSettingsValue19>

      <KAIPluginSettingsPluginName20>false</KAIPluginSettingsPluginName20>

      <KAIPluginSettingsId20>false</KAIPluginSettingsId20>

      <KAIPluginSettingsValue20>false</KAIPluginSettingsValue20>

      <KAIPluginSettingsPluginName21>false</KAIPluginSettingsPluginName21>

      <KAIPluginSettingsId21>false</KAIPluginSettingsId21>

      <KAIPluginSettingsValue21>false</KAIPluginSettingsValue21>

      <KAISettingsExtraURLShortcut1>false</KAISettingsExtraURLShortcut1>

      <KAISettingsExtraURLShortcut2>false</KAISettingsExtraURLShortcut2>

      <KAISettingsExtraURLShortcut3>false</KAISettingsExtraURLShortcut3>

      <KAIShortcutBackup1>false</KAIShortcutBackup1>

      <KAIShortcutBackup2>false</KAIShortcutBackup2>

      <KAIShortcutBackup3>false</KAIShortcutBackup3>

      <KAIShortcutBackup4>false</KAIShortcutBackup4>

      <KAIShortcutBackup5>false</KAIShortcutBackup5>

      <KAIShortcutBackup6>false</KAIShortcutBackup6>

      <KAIShortcutBackup7>false</KAIShortcutBackup7>

      <KAIShortcutBackup8>false</KAIShortcutBackup8>

      <KAIShortcutBackupNaviLeft>false</KAIShortcutBackupNaviLeft>

      <KAIShortcutBackupNaviRight>false</KAIShortcutBackupNaviRight>

      <KAIShortcutBackupNaviUp>false</KAIShortcutBackupNaviUp>

      <KAIShortcutBackupNaviDown>false</KAIShortcutBackupNaviDown>

      <KAIShortcutBackupNaviKey>false</KAIShortcutBackupNaviKey>

      <KAIShortcutBackupLSK>false</KAIShortcutBackupLSK>

      <KAIShortcutBackupRSK>false</KAIShortcutBackupRSK>

      <KAIWebStatus>false</KAIWebStatus>

      <KAIWallpaperChangeType>false</KAIWallpaperChangeType>      

      <KAIWallpaperPath>false</KAIWallpaperPath>      

    </KCRUidActiveIdle2>

  </rfs>

</configuration>

activeidle2_10275102.crml
??<?xml version="1.0" encoding="UTF-16"?>

<repository xmlns="http://www.s60.com/xml/cenrep/1" backup="true" uidName="KCRUidActiveIdle" uidValue="0x10275102" owner="0x10275102" rfs="true">

  <access type="R" capabilities="AlwaysPass"/>

  <key ref="KCRUidActiveIdle2/KAIMainUIControllerKey" backup="true" name="Main UI Controller Key" int="0x00000100" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAISecondaryUIControllerKey" backup="true" name="Secondary UI Controller Key" int="0x00000101" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIStatusPaneLayout" backup="true" name="Status Pane Layout" int="0x00000200" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIFirstKeyLockKey" name="First Keylock Key" int="0x00000300" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAISecondKeyLockKey" name="Second Keylock Key" int="0x00000301" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAISecondKeyLockKey2" name="Second Keylock Key2" int="0x00000302" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIKeyLockTimeout" name="Key Lock Timeout" int="0x00000303" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIVoiceDialLaunchKey" name="Voice Dial Launch Key" int="0x00000304" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIVoiceDialKeyTimeout" name="Voice Dial Key Timeout" int="0x00000305" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAISPNAndEONS" name="SPN And EONS" int="0x00000400" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIVHZInMainpane" name="HomeZone In Mainpane" int="0x00000500" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIExternalStatusScreen" backup="true" name="Display Ext HS themes in listing" int="0x00000600" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAITouchToolbarVisible" name="Touch Toolbar Visible" int="0x00000700" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAINTInTheme" backup="true" name="NewsTicker In Theme" int="0x00000800" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIBlacklistedPlugins" name="KAIBlacklistedPlugins" int="0x00000900" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName1" name="Plugin Settings - PluginName1" int="0x00001000" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId1" name="Plugin Settings - Id1" int="0x00001001" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue1" name="First shortcut" int="0x00001002" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName2" name="Plugin Settings - PluginName2" int="0x00001003" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId2" name="Plugin Settings - Id2" int="0x00001004" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue2" name="Second shortcut" int="0x00001005" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName3" name="Plugin Settings - PluginName3" int="0x00001006" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId3" name="Plugin Settings - Id3" int="0x00001007" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue3" name="Third shortcut" int="0x00001008" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName4" name="Plugin Settings - PluginName4" int="0x00001009" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId4" name="Plugin Settings - Id4" int="0x0000100A" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue4" name="Fourth shortcut" int="0x0000100B" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName5" name="Plugin Settings - PluginName5" int="0x0000100C" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId5" name="Plugin Settings - Id5" int="0x0000100D" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue5" name="Fifth shortcut" int="0x0000100E" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName6" name="Plugin Settings - PluginName6" int="0x0000100F" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId6" name="Plugin Settings - Id6" int="0x00001010" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue6" name="Sixth shortcut" int="0x00001011" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName7" name="Plugin Settings - PluginName7" int="0x00001012" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId7" name="Plugin Settings - Id7" int="0x00001013" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue7" name="Seventh shortcut" int="0x00001014" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName8" name="Plugin Settings - PluginName8" int="0x00001015" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId8" name="Plugin Settings - Id8" int="0x00001016" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue8" name="Eigth shortcut" int="0x00001017" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName9" name="Plugin Settings - PluginName9" int="0x00001018" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId9" name="Plugin Settings - Id9" int="0x00001019" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue9" name="Navigation key Left" int="0x0000101A" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName10" name="Plugin Settings - PluginName10" int="0x0000101B" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId10" name="Plugin Settings - Id10" int="0x0000101C" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue10" name="Navigation key Right" int="0x0000101D" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName11" name="Plugin Settings - PluginName11" int="0x0000101E" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId11" name="Plugin Settings - Id11" int="0x0000101F" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue11" name="Navigation key Up" int="0x00001020" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName12" name="Plugin Settings - PluginName12" int="0x00001021" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId12" name="Plugin Settings - Id12" int="0x00001022" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue12" name="Navigation key Down" int="0x00001023" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName13" name="Plugin Settings - PluginName13" int="0x00001024" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId13" name="Plugin Settings - Id13" int="0x00001025" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue13" name="Middle Softkey / Navigation key Selection" int="0x00001026" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName14" name="Plugin Settings - PluginName14" int="0x00001027" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId14" name="Plugin Settings - Id14" int="0x00001028" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue14" name="Left Softkey" int="0x00001029" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName15" name="Plugin Settings - PluginName15" int="0x0000102A" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId15" name="Plugin Settings - Id15" int="0x0000102B" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue15" name="Right Softkey" int="0x0000102C" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName16" name="Plugin Settings - PluginName16" int="0x0000102D" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId16" name="Plugin Settings - Id16" int="0x0000102E" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue16" name="First Touch Toolbar shortcut" int="0x0000102F" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName17" name="Plugin Settings - PluginName17" int="0x00001030" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId17" name="Plugin Settings - Id17" int="0x00001031" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue17" name="Second Touch Toolbar shortcut" int="0x00001032" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName18" name="Plugin Settings - PluginName18" int="0x00001033" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId18" name="Plugin Settings - Id18" int="0x00001034" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue18" name="Third Touch Toolbar shortcut" int="0x00001035" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName19" name="Plugin Settings - PluginName19" int="0x00001036" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId19" name="Plugin Settings - Id19" int="0x00001037" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue19" name="First Touch Toolbar icon" int="0x00001038" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName20" name="Plugin Settings - PluginName20" int="0x00001039" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId20" name="Plugin Settings - Id20" int="0x0000103A" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue20" name="Second Touch Toolbar icon" int="0x0000103B" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsPluginName21" name="Plugin Settings - PluginName21" int="0x0000103C" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsId21" name="Plugin Settings - Id21" int="0x0000103D" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIPluginSettingsValue21" name="Third Touch Toolbar icon" int="0x0000103E" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAISettingsExtraURLShortcut1" name="First extra URL Shortcut" int="0x00002000" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAISettingsExtraURLShortcut2" name="Second extra URL Shortcut" int="0x00002001" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAISettingsExtraURLShortcut3" name="Third extra URL Shortcut" int="0x00002002" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackup1" name="Backup application definition for shortcut 1." int="0x00003000" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackup2" name="Backup application definition for shortcut 2." int="0x00003001" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackup3" name="Backup application definition for shortcut 3." int="0x00003002" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackup4" name="Backup application definition for shortcut 4." int="0x00003003" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackup5" name="Backup application definition for shortcut 5." int="0x00003004" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackup6" name="Backup application definition for shortcut 6." int="0x00003005" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackup7" name="Backup application definition for shortcut 7." int="0x00003006" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackup8" name="Backup application definition for shortcut 8." int="0x00003007" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackupNaviLeft" name="Backup application definition for shortcut navigation key left." int="0x00003008" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackupNaviRight" name="Backup application definition for shortcut navigation key right." int="0x00003009" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackupNaviUp" name="Backup application definition for shortcut navigation key up." int="0x0000300A" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackupNaviDown" name="Backup application definition for shortcut navigation key down." int="0x0000300B" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackupNaviKey" name="Backup application definition for shortcut navigation key / selection key / MSK." int="0x0000300C" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackupLSK" name="Backup application definition for shortcut LSK." int="0x0000300D" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAIShortcutBackupRSK" name="Backup application definition for shortcut RSK." int="0x0000300E" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

  <keyRange id="" ref="KCRUidActiveIdle2/KAIActiveUIControllerRange" backup="true" name="Active UI Controllers" firstInt="0x00000101" lastInt="0x000001ff">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </keyRange>

 <key ref="KCRUidActiveIdle2/KAIWebStatus" name="HomeScreen status." int="0x0000300F" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </key>

  <key ref="KCRUidActiveIdle2/KAICCPluginUID" readOnly="true" name="HomeScreen Content Control Plugin UI UID" int="0x3010" type="string8">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="alwaysfail"/>

  </key>

 <key ref="KCRUidActiveIdle2/KAIWallpaperChangeType" name="Wallpaper change type" int="0x00000850" type="int">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </key>  

 <key ref="KCRUidActiveIdle2/KAIWallpaperPath" name="Wallpaper path common for all HS pages" int="0x00000851" type="string">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </key>

</repository>

  
hs_app_aifwuU.def
EXPORTS
	_ZN5CAiFw5NewLCEv @ 1 NONAME
	_ZN5CAiFw4RunLEv @ 2 NONAME

hs_app_aiidleintU.def
EXPORTS
	_ZN18CAiWsPluginManager4NewLER7CCoeEnv @ 1 NONAME
	_ZN18CAiIdleAppRegister5NewLCEv @ 2 NONAME
	_ZN20CAiUiIdleIntegration4NewLER9CEikonEnvRK21TAiIdleKeySoundConfigP17MAiFwEventHandler @ 3 NONAME

hs_app_aisettingsU.def
EXPORTS
	_ZN17CAiPluginSettings4NewLEv @ 1 NONAME

hs_app_aiutilsU.DEF
EXPORTS
	_ZN9AiUtility16CreateStrParserLEv @ 1 NONAME
	_ZN9AiUtility21CreatePluginSettingsLEv @ 2 NONAME
	_ZN9AiUtility25CreatePSPropertyObserverLE9TCallBack4TUidi @ 3 NONAME
	_ZN9AiUtility31CreateContentItemArrayIteratorLEPK14TAiContentItemi @ 4 NONAME
	_ZN9AiUtility13CopyToBufferLEP6HBufC8RK6TDesC8 @ 5 NONAME
	_ZN9AiUtility13CopyToBufferLEP6HBufC8RK7TDesC16 @ 6 NONAME
	_ZN9AiUtility13CopyToBufferLEP7HBufC16RK6TDesC8 @ 7 NONAME
	_ZN9AiUtility13CopyToBufferLEP7HBufC16RK7TDesC16 @ 8 NONAME
	_ZN9AiUtility19EnsureBufMaxLengthLERP7HBufC16i @ 9 NONAME
	_ZN9AiUtility8ParseIntERlRK6TDesC8 @ 10 NONAME
	_ZN9AiUtility17CreatePluginToolLEv @ 11 NONAME
	_ZN9AiUtility19CContentPriorityMap13ClearPriorityERK6TDesC8 @ 12 NONAME
	_ZN9AiUtility19CContentPriorityMap18SetCurrentPriorityERK6TDesC8i @ 13 NONAME
	_ZN9AiUtility19CContentPriorityMap4NewLEv @ 14 NONAME
	_ZN9AiUtility19CContentPriorityMap5ResetEv @ 15 NONAME
	_ZNK9AiUtility19CContentPriorityMap15CurrentPriorityERK6TDesC8 @ 16 NONAME
	_ZNK9AiUtility19CContentPriorityMap15OverrideContentERK6TDesC8i @ 17 NONAME
	_ZTIN9AiUtility19CContentPriorityMapE @ 18 NONAME ; ##
	_ZTVN9AiUtility19CContentPriorityMapE @ 19 NONAME ; ##
	_ZN9AiUtility8ParseIntERlRK7TDesC16 @ 20 NONAME

ABLD.BAT
@ECHO OFF

REM Bldmake-generated batch file - ABLD.BAT
REM ** DO NOT EDIT **

perl -S ABLD.PL "\S60\devices\S60_5th_Edition_SDK_v1.0\homescreensrv\idlefw\group\\" %1 %2 %3 %4 %5 %6 %7 %8 %9
if errorlevel==1 goto CheckPerl
goto End

:CheckPerl
perl -v >NUL
if errorlevel==1 echo Is Perl, version 5.003_07 or later, installed?
goto End

:End
aifw.mmp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project definition file for project AI framework
*
*/

#include        
#include        
#include        

TARGET          hs_app_aifw.dll
TARGETTYPE      dll
UID             0x1000008D AI_UID3_AIFW_DLL
VENDORID        VID_DEFAULT
CAPABILITY      CAP_GENERAL_DLL

// Framework sources
SOURCEPATH      ../src/framework
SOURCE          hs_app_aifw.cpp
SOURCE          hs_app_aicontentpluginmanager.cpp
SOURCE          hs_app_aiuicontrollermanager.cpp
SOURCE          hs_app_aicallstatusobserver.cpp
SOURCE          hs_app_ailightstatusobserver.cpp
SOURCE          hs_app_aibackuprestorestatusobserver.cpp
SOURCE          hs_app_aienvironmentchangeobserver.cpp
SOURCE          hs_app_aifocusobserver.cpp
SOURCE          hs_app_aikeylockobserver.cpp
SOURCE          hs_app_aipsstatusobserver.cpp
SOURCE          hs_app_aipluginstatemanager.cpp
SOURCE          hs_app_aipluginstatemachineimpl.cpp
SOURCE          hs_app_aistatealive.cpp
SOURCE          hs_app_aistatesuspended.cpp
SOURCE          hs_app_aistateidle.cpp
SOURCE          hs_app_aipluginfactory.cpp
SOURCE          hs_app_aiuiframeworkobserverimpl.cpp
SOURCE          hs_app_ainetworklistener.cpp

// Active Idle Framework shared sources
SOURCEPATH      ../src/common
SOURCE          hs_app_aifwpanic.cpp

USERINCLUDE     .
USERINCLUDE     ../inc/framework
USERINCLUDE     ../inc/common
USERINCLUDE     ../inc/idleint
USERINCLUDE     ../cenrep

MW_LAYER_SYSTEMINCLUDE

// Symbian OS dependencies
LIBRARY         euser.lib bafl.lib ecom.lib
LIBRARY         centralrepository.lib
LIBRARY         apparc.lib apgrfx.lib
LIBRARY         ws32.lib cone.lib commonengine.lib
LIBRARY         cenrepnotifhandler.lib

// S60 Dependencies
LIBRARY         avkon.lib
LIBRARY         aknnotify.lib
LIBRARY         featmgr.lib
LIBRARY         eikcore.lib
LIBRARY         hwrmlightclient.lib
LIBRARY         networkhandling.lib

// Active Idle internal dependencies
LIBRARY     hs_app_aiutils.lib hs_app_aiidleint.lib

// Debugging dependencies
LIBRARY    flogger.lib

//++HV
LIBRARY akntransitionutils.lib
//--HV

DEFFILE         aifwu.def

aiidleint.mmp
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project definition file for Active Idle Idle integration
*                library.
*
*/

#include        
#include        
#include        

TARGET          hs_app_aiidleint.dll
TARGETTYPE      dll
UID             0x1000008D AI_UID3_AIFW_DLL
VENDORID        VID_DEFAULT
CAPABILITY      CAP_GENERAL_DLL

SOURCEPATH      ../src/idleint
SOURCE          hs_app_aiidleappregister.cpp
SOURCE          hs_app_aiwspluginmanager.cpp
SOURCE          hs_app_aiuiidleintegration.cpp
SOURCE          hs_app_aistate.cpp

SOURCEPATH      ../src/common
SOURCE          hs_app_aifwpanic.cpp

USERINCLUDE     .
USERINCLUDE     ../inc/common
USERINCLUDE     ../inc/idleint
USERINCLUDE     ../inc/framework

APP_LAYER_SYSTEMINCLUDE

LIBRARY         euser.lib flogger.lib
LIBRARY         apgrfx.lib
LIBRARY         ws32.lib
LIBRARY         cone.lib eikcore.lib
LIBRARY         avkon.lib aknnotify.lib

LIBRARY         hs_app_aiutils.lib
aiutils.mmp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  AI Utilities Factory
*
*/

#include        
#include        
//#include        

TARGET          hs_app_aiutils.dll
TARGETTYPE      dll
UID             0x1000008D 0x10281865
VENDORID        VID_DEFAULT
CAPABILITY      CAP_GENERAL_DLL

SOURCEPATH      ../src/utility
SOURCE			hs_app_aiutility.cpp
SOURCE			hs_app_caipspropertyobserver.cpp
SOURCE			hs_app_caistrparser.cpp
SOURCE			hs_app_caiplugintool.cpp
SOURCE			hs_app_caicontentitemarrayiterator.cpp
SOURCE          hs_app_contentprioritymap.cpp
SOURCE          hs_app_aipluginsettingsimpl.cpp

USERINCLUDE     .
USERINCLUDE     ../inc/utility

MW_LAYER_SYSTEMINCLUDE

LIBRARY         euser.lib
LIBRARY			charconv.lib

backup_registration.xml

    
    

bld.inf
/*
* Copyright (c) 2002-2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: 
*
*/


// #ifdef RD_CUSTOMIZABLE_AI

#include 

PRJ_PLATFORMS
DEFAULT


PRJ_EXPORTS
../plugins/devicestatus/loc/hs_app_aidevstaplgres.loc          MW_LAYER_LOC_EXPORT_PATH(hs_app_aidevstaplgres.loc)
../loc/hs_app_aifw.loc                                       MW_LAYER_LOC_EXPORT_PATH(hs_app_aifw.loc)

// Generic configuration interface for component cenrep settings
../conf/activeidle2.confml                  APP_LAYER_CONFML(activeidle2.confml)
../conf/activeidle2_10275102.crml           APP_LAYER_CRML(activeidle2_10275102.crml)

../rom/hs_app_idlefw.iby                                  CORE_MW_LAYER_IBY_EXPORT_PATH(hs_app_idlefw.iby)
../rom/hs_app_idlefw_resources.iby                        LANGUAGE_MW_LAYER_IBY_EXPORT_PATH(hs_app_idlefw_resources.iby)

PRJ_MMPFILES
aiutils.mmp
aiidleint.mmp
aifw.mmp
homescreen.mmp


PRJ_TESTMMPFILES

PRJ_TESTEXPORTS

//
// Include subprojects
//

// hslaunch
#include "../hslaunch/group/bld.inf"

// Plug-ins
#include "../plugins/group/bld.inf"

// #endif // RD_CUSTOMIZABLE_AI
homescreen.mmp
/*
* Copyright (c) 2002-2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: 
*
*/

#include        
#include        
#include        

TARGET          hs_app_homescreen.exe
TARGETTYPE      exe
UID             0x100039CE AI_UID3_AIFW_EXE
SECUREID        AI_SID_AIFW_EXE
VENDORID        VID_DEFAULT

CAPABILITY      CAP_APPLICATION PowerMgmt NetworkControl TrustedUI

EPOCSTACKSIZE   0x5000
EPOCHEAPSIZE    0x300000 0xC00000

SOURCEPATH      ../src/framework
SOURCE          hs_app_main.cpp

START RESOURCE  hs_app_homescreen.rss
HEADER
TARGETPATH      APP_RESOURCE_DIR
LANGUAGE_IDS
END

START RESOURCE  hs_app_homescreen_reg.rss
TARGETPATH      /private/10003a3f/apps
END

USERINCLUDE     .
USERINCLUDE     ../inc/common
USERINCLUDE     ../inc/framework

MW_LAYER_SYSTEMINCLUDE

LIBRARY         euser.lib
LIBRARY         apparc.lib
LIBRARY         hs_app_aifw.lib
LIBRARY         eikcore.lib
LIBRARY         ecom.lib
LIBRARY         flogger.lib

bld.inf
/*
* Copyright (c) 2003 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  This file provides the information required for building the
*  		hslaunch component.
*
*/

#include 

PRJ_PLATFORMS
ARMV5 WINSCW

PRJ_EXPORTS

PRJ_MMPFILES
hslaunch.mmp

hslaunch.mmp
/*
* Copyright (c) 2008 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Makefile of hslaunch
*
*/

#include 

TARGET hs_app_ailaunch.exe

targettype exe

UID             0x1000008d 0x200286E3
CAPABILITY      ReadDeviceData WriteDeviceData
VENDORID        VID_DEFAULT
SECUREID        0x200286E3

EPOCHEAPSIZE	0x1000 0x100000   // 4KB - 1 MB
EPOCSTACKSIZE	0x5000

SOURCEPATH		../src
SOURCE			hs_app_hslaunch.cpp
SOURCE			hs_app_hsprocessmonitor.cpp
SOURCE			hs_app_hsshutdownmonitor.cpp

USERINCLUDE		. 
USERINCLUDE		../inc

MW_LAYER_SYSTEMINCLUDE

LIBRARY			euser.lib  // CBase etc
LIBRARY			bafl.lib   // descriptors
LIBRARY			ssmcmn.lib // state manager

LANG			SC


hs_app_hslaunch.h
/*
* Copyright (c) 1020 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: application class.
*/

#ifndef __HS_LAUNCH_
#define __HS_LAUNCH_

#include 
#include "hs_app_hsprocessmonitor.h"
#include "hs_app_hsshutdownmonitor.h"

/**
 * CHsLaunch
 * 
 * application class.
 * 
 * @since S60 5.2  
 */
class CHsLaunch : public CActive,
                         MHsProcessMonitorObserver,
                         MHsShutdownMonitorObserver
    {
    public:
        /**
         * Create new launcher
         *
         * @since S60 5.2     
         */    
        static CHsLaunch* NewL();
        
        /**
         * Destructor.
         *
         * @since S60 5.2     
         */
        virtual ~CHsLaunch();

        /**
         * Set active object to be ran
         * 
         * @since S60 5.2
         */        
        void Activate();        

        /**
         * Get application return value
         * 
         * @return TInt     Application return value
         * @since S60 5.2
         */        
        TInt ApplicationReturnValue();      
        
    protected:
        /**
         * C++ constructor.
         *
         * @since S60 5.2      
         */        
        CHsLaunch();    
        
        /**
         * Symbian 2nd phase constructor
         * 
         * @since S60 5.2
         */        
        void ConstructL();
    
    private: // From CActive.
        /**
         * From CActive
         */        
        void RunL();

        /**
         * From CActive
         * 
         * @since S60 5.2
         */        
        void DoCancel(); 

        /**
         * From CActive
         * 
         * @since S60 5.2
         */        
        TInt RunError( TInt aError );

    private: // From MHsProcessMonitorObserver
        /**
         * From MHsProcessMonitorObserver
         */
        void ProcessEnded( const TExitType& aExitType,
                           const TInt aExitReason,
                           const TExitCategoryName& aExitCategory );

        /**
         * From MHsProcessMonitorObserver
         */
        void ProcessMonitoringError( TInt aError );

    private: // From MHsShutdownMonitorObserver
        /**
         * From MHsShutdownMonitorObserver
         */
        void SystemShutdownEvent();

    private:
        /**
         * Initialize process monitor
         * 
         * @param aProcessId    Id of process to monitor 
         */
        void InitProcessMonitorL( const TInt aProcessId );
        
        /**
         * Shut down application 
         * 
         * @param aApplicationReturnValue   Application return value.
         */
        void ShutdownApp( const TInt aApplicationReturnValue );         
        
    private: // data.
        // Process monitor. Owned.
        CHsProcessMonitor* iProcessMonitor;
        
        // Shutdown monitor. Owned.
        CHsShutdownMonitor* iShutdownMonitor;
        
        // Application return value
        TInt iApplicationReturnValue;
    };

#endif // __HS_LAUNCH_
hs_app_hsprocessmonitor.h
/*
* Copyright (c) 1020 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: process monitor.
*/


#ifndef __HS_PROCESS_MONITOR__
#define __HS_PROCESS_MONITOR__

#include 

/**
 * MHsProcessMonitorObserver
 * 
 * Monitor component observer.
 * 
 * @since S60 5.2
 */
class MHsProcessMonitorObserver
    {    
    public:
        /**
         * Called when monitored process is ended.
         * 
         * @param aExitType         Exit type
         * @param aExitReason       Exit reason
         * @param aExitCategory     Exit category
         */
        virtual void ProcessEnded( const TExitType& aExitType,
                                   const TInt aExitReason,
                                   const TExitCategoryName& aExitCategory ) = 0;

        /**
         * Called when error occured during monitoring.
         * 
         * @param aError System wide error code.
         */        
        virtual void ProcessMonitoringError( TInt aError ) = 0;											
    };

/**
 * HsProcessMonitor
 * 
 * Component for monitoring process states.
 * 
 * @since S60 5.2
 */  
class CHsProcessMonitor : public CActive
    {
    public:
        /**
         * Create new monitor
         * 
         * @param aProcessName	process id
         * @param aObserver monitor observer
         * @since S60 5.2     
         */    
        static CHsProcessMonitor* NewL( const TInt aProcessId,
                                        MHsProcessMonitorObserver& aObserver );   
        
        /**
         * Destructor
         * 
         * @since S60 5.2     
         */    
        ~CHsProcessMonitor();
    
        /**
         * Attach monitor
         * 
         * @return TInt     System wide error code.       
         * @since S60 5.2
         */        
        TInt AttachMonitor();
        
        /**
         * Start monitor
         * 
         * @return TInt     System wide error code.
         * @since S60 5.2
         */        
        TInt StartMonitor();        

    protected:
        /** 
         * C++ constructor
         *
         * @param aProcessName  process id
         * @param aObserver     watchdog observer.   
         * @since S60 5.2      
         */        
        CHsProcessMonitor( const TInt aProcessId,
                           MHsProcessMonitorObserver& aObserver );    

        /**
         * Symbian 2nd phase constructor
         * 
         * @since S60 5.2
         */        
        void ConstructL();

    private: // From CActive
        /**
         * From CActive
         */        
        void RunL();

        /**
         * From CActive
         * 
         * @since S60 5.2
         */        
        void DoCancel(); 

        /**
         * From CActive
         * 
         * @since S60 5.2
         */        
        TInt RunError( TInt aError );

    private: // New methods
        /**
         * Close process handle if open
         * 
         * @since S60 5.2
         */        
        void SecureProcessHandleAsClosed();     

    private:	
        // process id
        TInt iProcessId;        
        
        // watchdog observer
        MHsProcessMonitorObserver& iObserver;
        
        // Process handle
        RProcess iProcess;
        
        // boolean to represent whether process handle is open
        TBool iProcessHandleOpen;        
    };

#endif // __HS_PROCESS_MONITOR__
hs_app_hsshutdownmonitor.h
/*
* Copyright (c) 1020 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: shutdown monitor.
*/


#ifndef __HS_SHUTDOWN_MONITOR__
#define __HS_SHUTDOWN_MONITOR__

#include 
#include 

/**
 * MHsShutdownMonitorObserver
 * 
 * Monitor component observer.
 * 
 * @since S60 5.2
 */
class MHsShutdownMonitorObserver
    {    
    public:
        /**
         * Called when shutdown occurs 
         */
        virtual void SystemShutdownEvent() = 0;
    };

/**
 * HsShutdownMonitor
 * 
 * Component for monitoring shutdown
 * 
 * @since S60 5.2
 */  
class CHsShutdownMonitor : public CActive
    {
    public:
        /**
         * Create new monitor
         * 
         * @param aObserver monitor observer
         * @since S60 5.2     
         */    
        static CHsShutdownMonitor* NewL(
                MHsShutdownMonitorObserver& aObserver );   
        
        /**
         * Destructor
         * 
         * @since S60 5.2     
         */    
        ~CHsShutdownMonitor();
    
        /**
         * Start monitor
         * 
         * @since S60 5.2
         */        
        void StartMonitor();        

    protected:
        /** 
         * C++ constructor
         *
         * @param aObserver     monitor observer.   
         * @since S60 5.2      
         */        
        CHsShutdownMonitor( MHsShutdownMonitorObserver& aObserver );    

        /**
         * Symbian 2nd phase constructor
         * 
         * @since S60 5.2
         */        
        void ConstructL();

    private: // From CActive
        /**
         * From CActive
         */        
        void RunL();

        /**
         * From CActive
         * 
         * @since S60 5.2
         */        
        void DoCancel(); 

        /**
         * From CActive
         * 
         * @since S60 5.2
         */        
        TInt RunError( TInt aError );

    private:	
        // watchdog observer
        MHsShutdownMonitorObserver& iObserver;

        // State aware session.
        RSsmStateAwareSession iSAS;
    };

#endif // __HS_PROCESS_MONITOR__
hs_app_hslaunch.cpp
/*
 * Copyright (c) 2008 Nokia Corporation and/or its subsidiary(-ies).
 * All rights reserved.
 * This component and the accompanying materials are made available
 * under the terms of "Eclipse Public License v1.0"
 * which accompanies this distribution, and is available
 * at the URL "http://www.eclipse.org/legal/epl-v10.html".
 *
 * Initial Contributors:
 * Nokia Corporation - initial contribution.
 *
 * Contributors:
 *
 * Description: application class.                 
 *
 */

#include 
#include "hs_app_hslaunch.h"

// ========================= DECLARATIONS ==================================
_LIT( KHsExeName, "hs_app_homescreen.exe" );
_LIT( KHsProcessName, "Home screen" );
const TInt KSleepOnRetry = 250000; // 250ms
const TUid KPSCategoryUid = TUid::Uid( 0x200286E3 );
const TInt KPSCrashCountKey = 1;
_LIT_SECURITY_POLICY_C1( KPSReadPolicy, ECapabilityReadDeviceData );
_LIT_SECURITY_POLICY_C1( KPSWritePolicy, ECapabilityWriteDeviceData );

// ========================= LOCAL FUNCTIONS ==================================

void RunAppL()
    {
    // Construct active scheduler.
    CActiveScheduler* activeScheduler = new ( ELeave )CActiveScheduler();
    CleanupStack::PushL( activeScheduler );
    CActiveScheduler::Install( activeScheduler );        
    
    // Construct app.
    CHsLaunch* app = CHsLaunch::NewL();
    CleanupStack::PushL( app );        
    
    app->Activate();
    
    // Signal startup.
    RProcess::Rendezvous(KErrNone);
    
    // Start active scheduler.
    CActiveScheduler::Start();
    
    User::LeaveIfError( app->ApplicationReturnValue() );
    
    // Cleanup.
    CleanupStack::PopAndDestroy( app );
    CleanupStack::PopAndDestroy( activeScheduler );
    }

// -----------------------------------------------------------------------------
// E32Main
// entry-point
// -----------------------------------------------------------------------------
//
TInt E32Main()
    {            
    TInt error = KErrNone;
    
    __UHEAP_MARK;    
    
    // Construct cleanup stack.
    CTrapCleanup* cleanupstack = CTrapCleanup::New();
    if( !cleanupstack )
        {
        error  = KErrNoMemory;
        }
    
    // Call next phase of startup.
    if( !error )
        {
        TRAP( error, RunAppL() );
        }
    
    // Cleanup.
    delete cleanupstack;
    cleanupstack = NULL;
    
    __UHEAP_MARKEND;
    
    return error;
    }

// ========================= MEMBER FUNCTIONS ==================================

// -----------------------------------------------------------------------------
// CHsLaunch::NewL()
// Two-phased constructor.
// -----------------------------------------------------------------------------
CHsLaunch* CHsLaunch::NewL()
    {
    CHsLaunch* self = new ( ELeave ) CHsLaunch();
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }

// -----------------------------------------------------------------------------
// CHsLaunch::ConstructL()
// Symbian 2nd phase constructor can leave.
// -----------------------------------------------------------------------------
//
void CHsLaunch::ConstructL()
    {
    iShutdownMonitor = CHsShutdownMonitor::NewL( *this );
    iShutdownMonitor->StartMonitor();
    
    // Create property to pub/sub.    
    TInt error = RProperty::Define( KPSCrashCountKey,
                                    RProperty::EInt,
                                    KPSReadPolicy,
                                    KPSWritePolicy );    
    if( error == KErrNone )
        {
        // Init it to zero.
        error = RProperty::Set( KPSCategoryUid, KPSCrashCountKey, 0 );
        }                
    else if( error == KErrAlreadyExists )
        {
        error = KErrNone;        
        }        
    
    User::LeaveIfError( error );
    }

// -----------------------------------------------------------------------------
// CHsLaunch::CHsLaunch()
// C++ default constructor can NOT contain any code, that might leave.
// -----------------------------------------------------------------------------
CHsLaunch::CHsLaunch() :
        CActive( EPriorityStandard ),
        iApplicationReturnValue( KErrNone )
    {
    CActiveScheduler::Add( this );
    }

// -----------------------------------------------------------------------------
// CHsLaunch::~CHsLaunch()
// Destructor.
// -----------------------------------------------------------------------------
//
CHsLaunch::~CHsLaunch()
    {
    Cancel();
    
    delete iProcessMonitor;
    iProcessMonitor = NULL;
    
    delete iShutdownMonitor;
    iShutdownMonitor = NULL;
    }

// -----------------------------------------------------------------------------
// CHsLaunch::Activate()
// Set active object to be ran
// -----------------------------------------------------------------------------
//
void CHsLaunch::Activate()
    {   
    SetActive();
    TRequestStatus* tmp = &iStatus;
    User::RequestComplete( tmp, KErrNone );
    }

// -----------------------------------------------------------------------------
// CHsLaunch::ApplicationReturnValue()
// Get application return value
// -----------------------------------------------------------------------------
//
TInt CHsLaunch::ApplicationReturnValue()
    {
    return iApplicationReturnValue;
    }

// -----------------------------------------------------------------------------
// CHsLaunch::RunL
// -----------------------------------------------------------------------------
//
void CHsLaunch::RunL()
    {    
    // Create app or connect to existing.
    TInt processExisted = EFalse;
    
    RProcess process;
    TInt processError = process.Create( KHsExeName, KNullDesC );
    if( processError == KErrAlreadyExists )
        {        
        processError = process.Open( KHsProcessName, EOwnerProcess );
        processExisted = ETrue;
        }
    
    TInt monitorError = KErrNone;
    if( processError == KErrNone )
        {
        TRAP( monitorError, InitProcessMonitorL( process.Id() ) );
        }
    
    if( processError == KErrNone &&
        !processExisted )
        {
        // Make sure process is started even if monitor startup
        // fails. This will assure that process is not left in
        // suspended state. Resume can not be called for
        // already running process (will cause KERN-EXEC 46).
        process.Resume();
        }
                     
    process.Close();
    
    if( processError != KErrNone ||
        monitorError != KErrNone )
        {
        /* Error in this method is critical and it might cause
         * endless active scheduler loop if no active objects are
         * not triggered. Therefore shutdown. This application
         * will be restarted by startup sw. */
        ShutdownApp( KErrGeneral );
        }
    }

// -----------------------------------------------------------------------------
// CHsLaunch::DoCancel()
// From CActive.
// -----------------------------------------------------------------------------
//
void CHsLaunch::DoCancel()
    {
    if( iProcessMonitor )
        {
        iProcessMonitor->Cancel();
        }
    
    if( iShutdownMonitor )
        {
        iShutdownMonitor->Cancel();
        }
    }      

// -----------------------------------------------------------------------------
// CHsLaunch::RunError()
// From CActive.
// -----------------------------------------------------------------------------
//
TInt CHsLaunch::RunError( TInt aError )
    {
    return aError;
    } 

// -----------------------------------------------------------------------------
// CHsLaunch::ProcessEndedL()
// From MHsProcessMonitorObserver
// -----------------------------------------------------------------------------
//
void CHsLaunch::ProcessEnded( const TExitType& aExitType,
                              const TInt /*aExitReason*/,
                              const TExitCategoryName& /*aExitCategory*/ )
    {    
    // Only respond to panic. EExitTerminate and EExitKill are ignored.
    if( aExitType != EExitPanic )
        {
        return;
        }
    
    TInt crashCount = 0;
    TInt error = RProperty::Get( KPSCategoryUid,
                                 KPSCrashCountKey,
                                 crashCount );
    
    if( error == KErrNone )
        {
        crashCount++;
        error = RProperty::Set( KPSCategoryUid,
                                KPSCrashCountKey,
                                crashCount );
        }
    
    if( error == KErrNone )
        {
        User::After( KSleepOnRetry ); 
        Activate();
        }
    else
        {    
        ShutdownApp( error );
        }
    }

// -----------------------------------------------------------------------------
// CHsLaunch::ProcessMonitoringErrorL()
// From MHsProcessMonitorObserver
// -----------------------------------------------------------------------------
//
void CHsLaunch::ProcessMonitoringError( TInt aError )
    {
    /* Error in this method is critical and it might cause
     * endless active scheduler loop if no active objects are
     * not triggered. Therefore shutdown. This application
     * will be restarted by startup sw. */
    ShutdownApp( aError );
    }

// -----------------------------------------------------------------------------
// CHsLaunch::SystemShutdownEvent()
// From MHsShutdownMonitorObserver
// -----------------------------------------------------------------------------
//
void CHsLaunch::SystemShutdownEvent()
    {
    // Do not shut down app. Startup app would try to restart this app.
    // Just deactivate all active objects and wait for power off.
    if( IsActive() )
        {
        Cancel();
        }
    else
        {
        DoCancel();
        }    
    }

// -----------------------------------------------------------------------------
// CHsLaunch::InitProcessMonitorL()
// Initialize process monitor
// -----------------------------------------------------------------------------
//
void CHsLaunch::InitProcessMonitorL( const TInt aProcessId )
    {
    if( iProcessMonitor )
        {
        delete iProcessMonitor;
        iProcessMonitor = NULL;
        }
    iProcessMonitor = CHsProcessMonitor::NewL( aProcessId, *this );    
    User::LeaveIfError( iProcessMonitor->StartMonitor() );
    }

// -----------------------------------------------------------------------------
// CHsLaunch::ShutdownApp()
// Shut down application
// -----------------------------------------------------------------------------
//
void CHsLaunch::ShutdownApp( const TInt aApplicationReturnValue )
    {
    if( IsActive() )
        {
        Cancel();
        }
    else
        {
        DoCancel();
        }
    
    iApplicationReturnValue = aApplicationReturnValue;    
    CActiveScheduler::Stop();
    }

// End of File
hs_app_hsprocessmonitor.cpp
/* 
 * Copyright (c) 2008 Nokia Corporation and/or its subsidiary(-ies).
 * All rights reserved.
 * This component and the accompanying materials are made available
 * under the terms of "Eclipse Public License v1.0"
 * which accompanies this distribution, and is available
 * at the URL "http://www.eclipse.org/legal/epl-v10.html".
 *
 * Initial Contributors:
 * Nokia Corporation - initial contribution.
 *
 * Contributors:
 *
 * Description: process monitor.                 
 *
 */

#include "hs_app_hsprocessmonitor.h"

// ========================= MEMBER FUNCTIONS ==================================

// -----------------------------------------------------------------------------
// CHsProcessMonitor::NewL()
// Two-phased constructor
// -----------------------------------------------------------------------------
CHsProcessMonitor* CHsProcessMonitor::NewL( const TInt iProcessId,
                                            MHsProcessMonitorObserver& aObserver )
    {
    CHsProcessMonitor* self = new ( ELeave ) CHsProcessMonitor( iProcessId,
                                                                aObserver );
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }

// -----------------------------------------------------------------------------
// CHsProcessMonitor::~CHsProcessMonitor()
// Destructor.
// -----------------------------------------------------------------------------
//
CHsProcessMonitor::~CHsProcessMonitor()
    {
    Cancel();
    SecureProcessHandleAsClosed();    	
    iProcessId = KErrNotFound;
    }

// -----------------------------------------------------------------------------
// CHsProcessMonitor::AttachMonitor()
// Attach monitor
// -----------------------------------------------------------------------------
//
TInt CHsProcessMonitor::AttachMonitor()
    {   
    SecureProcessHandleAsClosed();
    
    TInt error = iProcess.Open( iProcessId, EOwnerProcess );
    
    if( error == KErrNone )
        {
        iProcessHandleOpen = ETrue;
        }
    
    return error;
    }   

// -----------------------------------------------------------------------------
// CHsProcessMonitor::StartMonitor()
// Start monitor
// -----------------------------------------------------------------------------
//
TInt CHsProcessMonitor::StartMonitor()
    {
    TInt error = KErrNone;
    
    if( !iProcessHandleOpen )
        {
        error = AttachMonitor();
        }
    
    if( error == KErrNone )
        {
        iProcess.Logon( iStatus );
        SetActive();                
        }
    
    return error;
    }   

// -----------------------------------------------------------------------------
// CHsProcessMonitor::CHsProcessMonitor()
// C++ default constructor can NOT contain any code, that might leave.
// -----------------------------------------------------------------------------
CHsProcessMonitor::CHsProcessMonitor( const TInt aProcessId,
                                      MHsProcessMonitorObserver& aObserver ) :
        CActive( EPriorityStandard ),
        iProcessId( aProcessId ),
        iObserver( aObserver ),
        iProcessHandleOpen( EFalse )
    {
    CActiveScheduler::Add( this );
    }

// -----------------------------------------------------------------------------
// CHsProcessMonitor::ConstructL()
// Symbian 2nd phase constructor can leave.
// -----------------------------------------------------------------------------
//
void CHsProcessMonitor::ConstructL()
    {    
    }

// -----------------------------------------------------------------------------
// CHsProcessMonitor::RunL
// -----------------------------------------------------------------------------
//
void CHsProcessMonitor::RunL()
    {
    iProcess.LogonCancel( iStatus );    	
    
    const TInt error = iStatus.Int();        
    
    if( error == KErrCancel )
        {
        }
    else if( error == KErrNoMemory )
        {
        User::Leave( KErrNoMemory );
        }
    else
        {
        const TExitType exitType = iProcess.ExitType();									
        if( exitType == EExitPending )
            {
            User::LeaveIfError( StartMonitor() );
            }
        else
            {
            iObserver.ProcessEnded( exitType,
                                    iProcess.ExitReason(),
                                    iProcess.ExitCategory() );
            }
        }
    }

// -----------------------------------------------------------------------------
// CHsProcessMonitor::DoCancel()
// From CActive.
// -----------------------------------------------------------------------------
//
void CHsProcessMonitor::DoCancel()
    {
    iProcess.LogonCancel( iStatus );
    }      

// -----------------------------------------------------------------------------
// CHsProcessMonitor::RunError()
// From CActive.
// -----------------------------------------------------------------------------
//
TInt CHsProcessMonitor::RunError( TInt aError )
    {    
    iObserver.ProcessMonitoringError( aError );

    // Observer will handle error. Return green light.
    return KErrNone;    
    }  

// -----------------------------------------------------------------------------
// CHsProcessMonitor::SecureProcessHandleAsClosed()
// Close process handle if open
// -----------------------------------------------------------------------------
//
void CHsProcessMonitor::SecureProcessHandleAsClosed()
    {
    if( iProcessHandleOpen )
        {
        iProcess.Close();
        iProcessHandleOpen = EFalse;
        }
    } 

// End of File
hs_app_hsshutdownmonitor.cpp
/* 
 * Copyright (c) 2008 Nokia Corporation and/or its subsidiary(-ies).
 * All rights reserved.
 * This component and the accompanying materials are made available
 * under the terms of "Eclipse Public License v1.0"
 * which accompanies this distribution, and is available
 * at the URL "http://www.eclipse.org/legal/epl-v10.html".
 *
 * Initial Contributors:
 * Nokia Corporation - initial contribution.
 *
 * Contributors:
 *
 * Description: shutdown monitor.                 
 *
 */

#include 
#include 

#include "hs_app_hsshutdownmonitor.h"

// ========================= MEMBER FUNCTIONS ==================================

// -----------------------------------------------------------------------------
// CHsShutdownMonitor::NewL()
// Two-phased constructor
// -----------------------------------------------------------------------------
CHsShutdownMonitor* CHsShutdownMonitor::NewL(
        MHsShutdownMonitorObserver& aObserver )
    {
    CHsShutdownMonitor* self = new ( ELeave ) CHsShutdownMonitor( aObserver );
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }

// -----------------------------------------------------------------------------
// CHsShutdownMonitor::~CHsShutdownMonitor()
// Destructor.
// -----------------------------------------------------------------------------
//
CHsShutdownMonitor::~CHsShutdownMonitor()
    {
    Cancel();
    iSAS.Close();
    }

// -----------------------------------------------------------------------------
// CHsShutdownMonitor::StartMonitor()
// Start monitor
// -----------------------------------------------------------------------------
//
void CHsShutdownMonitor::StartMonitor()
    {
    iSAS.RequestStateNotification( iStatus );
    SetActive();    
    }   

// -----------------------------------------------------------------------------
// CHsShutdownMonitor::CHsShutdownMonitor()
// C++ default constructor can NOT contain any code, that might leave.
// -----------------------------------------------------------------------------
CHsShutdownMonitor::CHsShutdownMonitor( MHsShutdownMonitorObserver& aObserver ) :
        CActive( EPriorityStandard ),
        iObserver( aObserver )
    {
    CActiveScheduler::Add( this );
    }

// -----------------------------------------------------------------------------
// CHsShutdownMonitor::ConstructL()
// Symbian 2nd phase constructor can leave.
// -----------------------------------------------------------------------------
//
void CHsShutdownMonitor::ConstructL()
    {
    User::LeaveIfError( iSAS.Connect( KSM2GenMiddlewareDomain3 ) );
    }

// -----------------------------------------------------------------------------
// CHsShutdownMonitor::RunL
// -----------------------------------------------------------------------------
//
void CHsShutdownMonitor::RunL()
    {
    User::LeaveIfError( iStatus.Int() );
    
    TBool registerForMoreEvents = ETrue;
    
    TSsmState state = iSAS.State();
    if( state.MainState() == ESsmShutdown )
        {
        iObserver.SystemShutdownEvent();
        registerForMoreEvents = EFalse;
        }
    
    if( registerForMoreEvents )
        {
        iSAS.AcknowledgeAndRequestStateNotification( KErrNone, iStatus );
        SetActive();
        }
    else
        {
        iSAS.AcknowledgeStateNotification( KErrNone );
        }        
    }

// -----------------------------------------------------------------------------
// CHsShutdownMonitor::DoCancel()
// From CActive.
// -----------------------------------------------------------------------------
//
void CHsShutdownMonitor::DoCancel()
    {
    iSAS.RequestStateNotificationCancel();
    }      

// -----------------------------------------------------------------------------
// CHsShutdownMonitor::RunError()
// From CActive.
// -----------------------------------------------------------------------------
//
TInt CHsShutdownMonitor::RunError( TInt aError )
    {
    return aError;
    }

// End of File
hs_app_aifwpanic.h
/*
* Copyright (c) 2005-2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  AI2 debug panic helper
*
*/


#ifndef AIFWPANIC_H
#define AIFWPANIC_H

#ifdef _DEBUG

namespace AiFwPanic
    {
    
    enum TAiPanicCodes
        {
        EAiFwPanic_FwCreationFailed,
        EAiFwPanic_UnsupportedContentType,
        EAiFwPanic_NullPointerReference,
        EAiFwPanic_IllegalPluginStateChange
        };
        
    void Panic(TAiPanicCodes aPanicCode);
    
    }

#endif // _DEBUG

#endif // AIFWPANIC_H

hs_app_aiwspluginanimdef.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Defines constants shared between this subsystem and 
*                clients of this subsystem.
*
*/


#ifndef AIWSPLUGINANIMDEF_H
#define AIWSPLUGINANIMDEF_H

// INCLUDES
#include 
#include 

// CONSTANTS

_LIT( KAiWsPluginAnimDllName, "hs_app_aiwsplugin.dll" );

// DATA TYPES

/** 
* Animation services
*
* EAnimKeyForward - Key forwarding to call handling application
*/
enum TAiWsPluginAnimType
    {
    EAnimKeyForward
    };

/**
* Active Idle anim plugin initialisation data.
*/
struct TAiWsPluginAnimInitData
    {
    // Idle window group id
    TInt iAiWgId;
    // Window group to activate 
    TInt iTargetWgId;
    };

#endif // AIWSPLUGINANIMDEF_H

hs_app_aibackuprestorestatusobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Backup / Restore status observer
*
*/


#ifndef C_AIBACKUPRESTORESTATUSOBSERVER_H
#define C_AIBACKUPRESTORESTATUSOBSERVER_H

#include 
#include 
#include "hs_app_aipsstatusobserver.h"

class MAiPSPropertyObserver;

/**
 * @ingroup group_aifw
 * 
 *  Publish and subscribe key observer
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
 
NONSHARABLE_CLASS( CAiBackupRestoreStatusObserver ) : public CAiPSStatusObserver
    {
public:

// Construction

    static CAiBackupRestoreStatusObserver* NewL( MAiStateManager* aStateManager );

    virtual ~CAiBackupRestoreStatusObserver();

// functions from base class CAiPSStatusObserver

    TAiStateChanges Status();

private:

// Construction
    
    CAiBackupRestoreStatusObserver();
    
    void ConstructL( MAiStateManager* aStateManager );
    
// new functions

    static TInt HandleBackupOperationEvent( TAny* aPtr );
    
    };

#endif // C_AIBACKUPRESTORESTATUSOBSERVER_H

// End of File.
hs_app_aicallstatusobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Call status observer
*
*/


#ifndef C_AICALLSTATUSOBSERVER_H
#define C_AICALLSTATUSOBSERVER_H

#include 
#include 
#include "hs_app_aipsstatusobserver.h"

class MAiPSPropertyObserver;

/**
 * @ingroup group_aifw
 * 
 *  Publish and subscribe key observer
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
 
NONSHARABLE_CLASS( CAiCallStatusObserver ) : public CAiPSStatusObserver
    {
public:

// Construction

    static CAiCallStatusObserver* NewL( MAiStateManager* aStateManager );

    virtual ~CAiCallStatusObserver();

// functions from base class CAiPSStatusObserver

    TAiStateChanges Status();

private:

// Construction
    
    CAiCallStatusObserver();
    
    void ConstructL( MAiStateManager* aStateManager );
    
// new functions

    static TInt HandleCallStateChange( TAny* aPtr );

    };

#endif // C_AICALLSTATUSOBSERVER_H

// End of File.
hs_app_aicontentpluginmanager.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Content plugin manager class for Active idle framework.
*
*/



#ifndef C_AICONTENTPLUGINMANAGER_H
#define C_AICONTENTPLUGINMANAGER_H

#include 
#include "aicontentmodel.h"
#include "aicontentpublisher.h"
#include "aifwdefs.h"
#include "aipluginsettings.h"
#include "hs_app_aipluginfactory.h"

class MAiContentObserver;
class MAiEventHandlerExtension;
class MAiPluginTool;
class CAiContentPublisher;
class CAiPluginStateManager;
class CAiUiController;
class CImplementationInformation;

/**
 * @ingroup group_aifw
 * 
 *  Content plugin manager class for Active idle framework.
 *
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( CAiContentPluginManager ) : public CBase
                                               
	{
public: // Constructor and destructor	        	
		
    static CAiContentPluginManager* NewL();
                                              
    virtual ~CAiContentPluginManager();
		    
public: // New functions
    
    /**
     * Forward plugin event to plugins.
     *
     * @since S60 3.2
     * @param aParam event string.
     */
    void HandlePluginEvent( const TDesC& aParam );

    /**
     * Forward plugin event to plugins.
     *
     * @since S60 5.0
     * @param aPublisherInfo publisher info.
     * @param aParam event string.
     */
    void HandlePluginEventL( const TAiPublisherInfo& aPublisherInfo, const TDesC& aParam ); 
            
    /**
     * Queries wheter a plugin has settigns or not.
     */
    TBool HasMenuItemL( const TAiPublisherInfo& aPublisherInfo, const TDesC& aMenuItem );

    /**
     * Requests a Content publisher plug-in to refresh a content item.
     */
    TBool RefreshContent( const TDesC& aContentCid );

    /**
     * Sets plugins to online/offline
     * 
     * @since S60 5.0
     * @param aOnline ETrue to set plugins online, EFalse to offline
     * @paran aPublishers List of publishers
     */    
    void ProcessOnlineState( TBool aOnline );
            
    /**
     * Gets plugin state manager.     
     *
     * @since S60 5.0
     * @return plugin state manager.
     */        
    CAiPluginStateManager& StateManager() const;

    /**
     * Gets plugin factory.     
     *
     * @since S60 5.0
     * @return plugin factory.
     */        
    CAiPluginFactory& PluginFactory() const;
    
    
private: // Constructors

    CAiContentPluginManager();
                             
    void ConstructL();

private: // New functions
                                        
    void GetIdL( CAiContentPublisher& aContentPublisher,
                 TAiPublisherProperty aProperty,            
                 const TDesC& aName, TInt& aId ); 
            
    TInt RefreshContentL( const TDesC& aContentCid );

private: // Data

    /**
     * Plugins array.
     * Owned. 
     */
    RPointerArray< CAiContentPublisher > iPlugins;

    /**
     * Plugin factory.
     * Owned.
     */
    CAiPluginFactory* iPluginFactory;
    
    /**
     * System state observer.
     * Owned.
     */    
    CAiPluginStateManager* iStateManager;
    
    /**
     * Plugin tool from utility lib.
     * Owned.
     */
    MAiPluginTool* iPluginTool;     
    };

#endif // C_AICONTENTPLUGINMANAGER_H

// End of File.
hs_app_aidevicestatusobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Device status observer
*
*/


#ifndef M_AIDEVICESTATUSOBSERVER_H
#define M_AIDEVICESTATUSOBSERVER_H

#include "hs_app_aipluginstatemachine.h"

/**
 *  description
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
class MAiDeviceStatusObserver
    {

public:

    virtual ~MAiDeviceStatusObserver(){}

    virtual TAiStateChanges Status() = 0;

    };

#endif // M_AIDEVICESTATUSOBSERVER_H

// End of File.
hs_app_aienvironmentchangeobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Environment observer
*
*/


#ifndef C_AIENVIROMENTCHANGEOBSERVER_H
#define C_AIENVIROMENTCHANGEOBSERVER_H

#include 
#include "hs_app_aidevicestatusobserver.h"
#include "aiuiframeworkobserver.h"

class MAiStateManager;
class CEnvironmentChangeNotifier;

/**
 * @ingroup group_aifw
 * 
 *  System enviroment change observer.
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( CAiEnvironmentChangeObserver ) : public CBase,
                                                   public MAiDeviceStatusObserver
    {
public:

// Construction

    static CAiEnvironmentChangeObserver* NewL( MAiStateManager* aStateManager );

    virtual ~CAiEnvironmentChangeObserver();

// functions from base class CAiEnvironmentChangeObserver

    TAiStateChanges Status();

// new functions

    static TInt EnvironmentChangeCallBack(TAny* aPtr);
    
private:

// Construction
    
    CAiEnvironmentChangeObserver();
    
    void ConstructL( MAiStateManager* aStateManager );

protected: // Data

    /**
     * State manager.
     * Not own.
     */
    MAiStateManager*   iStateManager;

    /**
     * Enviroment change notifier: time, locale and midnight crossover
     * Own.
     */
    CEnvironmentChangeNotifier*                 iEnvironmentChangeNotifier;
    };

#endif // C_AIENVIROMENTCHANGEOBSERVER_H

hs_app_aifocusobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  AI2 focus observer.
*
*/


#ifndef C_AIFOCUSOBSERVER_H
#define C_AIFOCUSOBSERVER_H

#include 
#include 
//++HV 
#include 
//--HV 
#include "hs_app_aipsstatusobserver.h"

class MAiPSPropertyObserver;

/**
 * @ingroup group_aifw
 * 
 *  Focus change observer. Using telephony idle visiblity PS.
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
 
NONSHARABLE_CLASS( CAiFocusObserver ) : public CAiPSStatusObserver
										//++HV    
    									,public MAknTransitionUtilsObserver
										//--HV    
    {
public:

// Construction

    static CAiFocusObserver* NewL( MAiStateManager* aStateManager );

    virtual ~CAiFocusObserver();

// functions from base class CAiPSStatusObserver

    TAiStateChanges Status();

private:

// Construction
    
    CAiFocusObserver();
    
    void ConstructL( MAiStateManager* aStateManager );
    
// new functions

    //++HV
    
    static TInt StaticHandleFocusChangeEvent( TAny* aPtr );
    TInt HandleFocusChangeEvent();

    
	// From MAknTransitionUtilsObserver
	TInt AknTransitionCallback(TInt aEvent, TInt aState = 0, const TDesC8* aParams = NULL);
		
        
private:
	TBool iTfxEffectActive;


	//--HV 
    };

#endif // C_AIFOCUSOBSERVER_H

// End of File.
hs_app_aifw.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  AI2 main class
*
*/


#ifndef C_AIFW_H
#define C_AIFW_H

#include 
#include 
#include 
#include 

#include "aifwdefs.h"
#include "aicontentmodel.h"
#include "aifweventhandler.h"

class CAiUiControllerManager;
class CAiContentPluginManager;
class CAiWsPluginManager;
class CAiPluginStateManager;
class RConeResourceLoader;
class CAiContentPublisher;
class MAiPSPropertyObserver;
class CAiNetworkListener;

/**
 * @ingroup group_aifw
 * 
 * Active Idle Framework main class.
 */
NONSHARABLE_CLASS( CAiFw ) : 
        public CBase,
        public MAiFwEventHandler,
        public MCenRepNotifyHandlerCallback        
    {
public: // Constructors and destructors    

    /**
     * Creates and returns a new Active Idle Framework object.
     *
     * @return  new Active Idle Framework object. The object is also left
     *          on the cleanup stack.
     * @exception Any of the system-wide error codes if framework creation
     *            fails due to an unrecoverable error.
     */
    IMPORT_C static CAiFw* NewLC();
  
    ~CAiFw();
  
public: // New functions
      
    /**
     * Runs the Active Idle Framework. This function returns when the
     * framework is shut down.
     *
     * @exception Any of the system-wide error codes if the framework 
     *            encounters a fatal initialization or run-time error.
     */
    IMPORT_C void RunL();
        
private: // Constructors      
    CAiFw();
    void ConstructL();
  
private: // From MAiFwEventHandler    
        
    /**
     * @see MAiFwEventHandler
     */
    void AppEnvReadyL();

    /**
     * @see MAiFwEventHandler
     */    
    void HandleUiReadyEventL( CAiUiController& aUiController );

    /**
     * @see MAiFwEventHandler
     */    
    void HandleActivateUI();
    
    /**
     * @see MAiFwEventHandler
     */    
    void HandleUiShutdown( CAiUiController& aUiController );
    
    /**
     * @see MAiFwEventHandler
     */        
    void HandleLoadPluginL( const TAiPublisherInfo& aPublisherInfo );
    
    /**
     * @see MAiFwEventHandler
     */        
    void HandleDestroyPluginL( const TAiPublisherInfo& aPublisherInfo );            
    
    /**
     * @see MAiFwEventHandler
     */        
    void HandlePluginEvent( const TDesC& aParam );
    
    /**
     * @see MAiFwEventHandler
     */        
    void HandlePluginEventL( const TAiPublisherInfo& aPublisherInfo, const TDesC& aParam );

    /**
     * @see MAiFwEventHandler
     */    
    TBool HasMenuItemL( const TAiPublisherInfo& aPublisherInfo, const TDesC& aMenuItem );        

    /**
     * @see MAiFwEventHandler
     */        
    TBool RefreshContent( const TDesC& aContentCid );
    
    /**
     * @see MAiFwEventHandler
     */        
    TBool QueryIsMenuOpen();

    /**
     * @see MAiFwEventHandler
     */            
    void ProcessStateChange( TAifwStates aState );    
        
private: // From MCenRepNotifyHandlerCallback

    /**
     * @see MCenRepNotifyHandlerCallback
     */
    void HandleNotifyInt( TUint32 aId, TInt aNewValue );
    
private: // New functions        
                 
    static TInt HandleFocusChangeEvent( TAny* aSelf );
    static TInt HandleRestartEvent( TAny* aSelf );
    void SwapUiControllerL( TBool aToExtHS );

private: // Data     
    
    /**
     * UI Controller manager, Owned.     
     */
    CAiUiControllerManager* iUiControllerManager;

    /**
     * Content plugin manager, Owned.     
     */
    CAiContentPluginManager* iPluginManager;

    /**
     * Window server plug-in manager, Owned.
     */
    CAiWsPluginManager* iWsPluginManager;

    /**
     * Notify handler for cenrep, Owned.     
     */
    CCenRepNotifyHandler* iNotifyHandler;
    
    /**
     * Notify handler for cenrep, Owned.     
     */    
    CCenRepNotifyHandler* iNotifyHandlerESS;

    /**
     * Idle repository, Owned.
     */
    CRepository* iAIRepository;
    
    /**
     * Idle restart PS observer, Owned.
     */
    MAiPSPropertyObserver* iIdleRestartObserver;
    
    TBool iLibrariesLoaded;
    
    RLibrary iLibrary1;
    RLibrary iLibrary2;
    RLibrary iLibrary3;       
    };

#endif // C_AIFW_H

hs_app_aifwstartupscheduler.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Custom active scheduler for Active Idle Framework startup.
*
*/


#ifndef C_AIFWSTARTUPSCHEDULER_H
#define C_AIFWSTARTUPSCHEDULER_H


#include 

/**
 *  Custom active scheduler for Active Idle Framework startup.
 */
NONSHARABLE_CLASS( CAiFwStartupScheduler ) : public CActiveScheduler
    {
public:
    static CAiFwStartupScheduler* NewLC();

    ~CAiFwStartupScheduler();

    /**
     * Returns result code from this scheduler's execution.
     *
     * @return - KErrNone if the scheduler loop executed succesfully
     *         - Any of the system-wide error codes in case of an error.
     */
    TInt Result();

private:    
// from base class CActiveScheduler
    void Error(TInt aError) const;

// Construction
    CAiFwStartupScheduler();
private: // data

    /**
     * Result code returned by Result().
     */
    mutable TInt iResult;
    };


#endif // ? C_AIFWSTARTUPSCHEDULER_H

hs_app_aikeylockobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  AI2 keylock status observer.
*
*/


#ifndef C_AIKEYLOCKOBSERVER_H
#define C_AIKEYLOCKOBSERVER_H

#include 
#include 
#include "hs_app_aipsstatusobserver.h"

class MAiPSPropertyObserver;

/**
 * @ingroup group_aifw
 * 
 *  Keylock status change observer.
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
 
NONSHARABLE_CLASS( CAiKeylockObserver ) : public CAiPSStatusObserver
    {
public:

// Construction

    static CAiKeylockObserver* NewL( MAiStateManager* aStateManager );

    virtual ~CAiKeylockObserver();

// functions from base class CAiPSStatusObserver

    TAiStateChanges Status();

private:

// Construction
    
    CAiKeylockObserver();
    
    void ConstructL( MAiStateManager* aStateManager );
    
// new functions

    static TInt HandleKeylockStatusEvent( TAny* aPtr );

    };

#endif // C_AIKEYLOCKOBSERVER_H

// End of File.
hs_app_ailightstatusobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Light status observer
*
*/


#ifndef C_AILIGHTSTATUSOBSERVER_H
#define C_AILIGHTSTATUSOBSERVER_H

#include 
#include 
#include 
#include "hs_app_aidevicestatusobserver.h"

class MAiStateManager;

/**
 * @ingroup group_aifw
 * 
 *  Publish and subscribe key observer
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
 
NONSHARABLE_CLASS( CAiLightStatusObserver ) : public CBase,
                                              public MHWRMLightObserver,
                                              public MAiDeviceStatusObserver
    {
public:

// Construction

    static CAiLightStatusObserver* NewL( MAiStateManager* aStateManager );

    ~CAiLightStatusObserver();

// functions from base class MAiDeviceStatusObserver

    TAiStateChanges Status();

private:

// Construction
    
    CAiLightStatusObserver();
    
    void ConstructL( MAiStateManager* aStateManager );
    
// from MHWRMLightObserver

    void LightStatusChanged( TInt aTarget, CHWRMLight::TLightStatus aStatus );
    
protected: // Data

    /**
     * Light client.
     * Own.
     */
    CHWRMLight* iLight;

    /**
     * State manager.
     * Not own.
     */
    MAiStateManager* iStateManager;

    };

#endif // C_AILIGHTSTATUSOBSERVER_H

// End of File.
hs_app_ainetworklistener.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network info listener
*
*/

#ifndef C_NETWORKLISTENER_H
#define C_NETWORKLISTENER_H

#include 
#include 
#include "hs_app_ainetworkobserver.h"

class MAiNetworkObserver;
class CNWSession;

/**
 *  @ingroup group_xmluicontroller
 *
 *  Network info listener.
 *
 *  Client can use this object to listen network state changes. Client must implement
 *  MAiNetworkObserver interface to retrieve network state changes
 *
 *  @since S60 5.0
 */
NONSHARABLE_CLASS(CAiNetworkListener) : public CBase, 
                           public MNWMessageObserver
    {
public:

    static CAiNetworkListener* CAiNetworkListener::NewL(MAiNetworkObserver& aNetworkObserver);
 
    virtual ~CAiNetworkListener();
    
    /**
     * Get current network status
     * @return TNetworkState
     */
    MAiNetworkObserver::TNetworkState NetworkState();

// from base class MNWMessageObserver

    /**
     * From MNWMessageObserver.
     * Called by network handling engine when network info changes.
     *
     * @since S60 5.0
     * @param aMessage is type of the change.
     */
    void HandleNetworkMessage( const TNWMessages aMessage );

    /**
     * From MNWMessageObserver.
     * Called if network handling engine fails.
     *
     * @since S60 5.0
     * @param aOperation is failed operation.
     * @param aErrorCode is fail reason.
     */
    void HandleNetworkError( const TNWOperation aOperation, TInt aErrorCode );

private:
    TBool HasNetworkInfoChanged( const TNWMessages aMessage );

    MAiNetworkObserver::TNetworkState InterpretNWMessage(const TNWMessages aMessage, const TNWInfo);

    CAiNetworkListener(MAiNetworkObserver& aNetworkObserver);

    void ConstructL();

 
private: // data

     /**
     * Session to network handling engine.
     * Own.
     */
    CNWSession* iSession;

    /**
     * Cached network info structure.
     */
    TNWInfo iInfo;
    
    /**
     * Previous network information.
     */
    TNWInfo iOldInfo;

    /**
      * Reference to client observing
      */
      MAiNetworkObserver& iObserver;


    /**
     * Network related message flags
     */
     
    enum TNetInfoFlags 
        {
        ENetworkProviderNameReceived      = 0x00000001,
        ENetworkProviderNameOk            = 0x00000002,
        EServiceProviderNameReceived      = 0x00000004,
        EServiceProviderNameOk            = 0x00000008,
        ERegistrationStatusReceived       = 0x00000010,
        ENetworkInfoChangeReceived        = 0x00000020,
        EProgrammableOperatorInfoReceived = 0x00000040,
        EProgrammableOperatorInfoReceivedOk = 0x00000080
        };
        
    /**
     * Subset of sum of TNetInfoFlags.
     */    
    TUint iReceivedMessageFlags;
    
    /**
     * Subset of sum of old TNetInfoFlags.
     */    
    TUint iOldReceivedMessageFlags;
    
    /**
     * current state of network
     */    
    MAiNetworkObserver::TNetworkState iCurrentNwState;
     };
//}    

#endif // C_AINETWORKINFOLISTENER_H
hs_app_ainetworkobserver.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network info observer
*
*/

#ifndef M_NETWORKOBSERVER_H
#define M_NETWORKOBSERVER_H

#include 
#include 

/**
 *  @ingroup group_xmluicontroller
 *
 *  Network info observer.
 *
 *  Client gets network state changes through this interface.
 *
 *  @since S60 5.0
 */
class MAiNetworkObserver
        {
    
public:
    enum TNetworkState
        {
        ENone = 0,
        EHomeNetwork,
        ERoaming
        };

protected:

    /**
     * Virtual destructor.
     * Cannot be used to destruct the object.
     */
    virtual ~MAiNetworkObserver() {};

public:

    /**
     * Called when network info changes.
     *
     * @since S60 5.0
     * @param aNewState new network state
      */
    virtual void HandleNetworkStateChange( TNetworkState aNewState ) = 0;
    
    };

#endif // M_AINETWORKINFOOBSERVER_H
hs_app_ainwsdlgcontroller.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network selection dialog controller
*
*/


#ifndef C_AINWSDLGCONTROLLER_H
#define C_AINWSDLGCONTROLLER_H

#include 
#include 
#include 

class CNWSession;

/**
 * Network Selection Dialog controller.
 */
NONSHARABLE_CLASS( CAiNwSDlgController ) : 
        public CBase,
        public MNWMessageObserver
	{
public:

// Constructors and destructors

    /**
     * Creates a new instance of the class.
     *
     * @return    A new instance of the class.
	 * @exception Any of the system-wide error codes if instance creation
	 *            fails due to an unrecoverable error.
     */
    static CAiNwSDlgController* NewL();

    ~CAiNwSDlgController();
	
// from MNWMessageObserver

	void HandleNetworkMessage( const TNWMessages aMessage );
    void HandleNetworkError( const TNWOperation aOperation, TInt aErrorCode );
		
private:

// Constructors
	
    CAiNwSDlgController();
	
	void ConstructL();
	
private:
    
// New functions
    
    /**
     * Take action according to current state change.
     */
    void HandleStateChange();

    /**
     * 
     */
    void HandleNetworkFound();

    /**
     * 
     */
    void HandleNetworkLost();

    /**
     * Opens the network selection dialog.
     */
    void LaunchDialog();

    /**
     * Cancels the network selection dialog.
     */
    void CancelDialog();

    /**
     * Tests if offline mode is engaged.
     *
     * @return ETrue if offline mode is currently active
     */
    TBool IsOffLineMode() const;

    /**
     * Tests if Bluetooth SAP is in connected mode.
     *
     * @return ETrue if Bluetooth SAP is active.
     */
    TBool IsBluetoothSAPConnected() const;

    static TInt DelayCallBack(TAny* aParam);

private:
    
// Data

    /**
     * Notifier service
     * Own
     */
    CAknSoftNotifier* iSoftNotifier;
    
    /**
     * Session to network handling engine.
     * Own.
     */
    CNWSession* iSession;

    /**
     * Cached network info structure.
     */
    TNWInfo iInfo;

    /**
     * A true value if registered to network.
     */
    TBool iRegistered;

    /**
     * Profile API.
     */
    CRepository* iProfileApi;

    /**
     * Timer object for 1-minute delay
     */
    CPeriodic* iPeriodic;
    };

#endif // C_AINWSDLGCONTROLLER_H

// End of file.
hs_app_aipluginactivitypstool.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plugin activity PS tool
*
*/


#ifndef AIPLUGINACTIVITYPSTOOL_H
#define AIPLUGINACTIVITYPSTOOL_H

#include  // TUid
#include  // RProperty

struct TAiPublisherInfo;

NONSHARABLE_CLASS(CAiPluginActivityRegistry) : public CBase
    {
    public:
    
        static CAiPluginActivityRegistry* NewL();
    
        TInt SetPluginActive( const TAiPublisherInfo& aPubInfo );
                               
        void CleanRegistry(); 
                              
        ~CAiPluginActivityRegistry();
        
    private:
    
    // construction
    
        void ConstructL();
    
        CAiPluginActivityRegistry();
        
    // new methods
    
        /**
         * Update PS registry count register.
         */
        TInt UpdateCountRegister();
        
        /**
         * Update PS registry ordinal register.
         */
        TInt UpdateOrdinalRegister( TInt aPluginUid );

        /**
         * Update plugins name register.
         */
        TInt UpdateNameRegister( TInt aPluginUid,
                                 const TDesC& aName );
        
        /**
         * Clean last added entry. In case of failure.
         */
        void CleanLastEntry( TInt aPluginUid,
                             TInt aOrdinal,
                             TInt aLastCount );
    
    private: // Members
    
        /**
         * Ordinal in registry. Ascending.
         */
        TInt iRegistryOrdinal;

        /**
         * Plugin count in registry.
         */
        TInt iPluginCount;
        
        /**
         * PS property that is updated.
         */
        RProperty iProperty;
        
    };

#endif // AIPLUGINACTIVITYPSTOOL_H

hs_app_aipluginfactory.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Content plugin manager class for Active idle framework.
*
*/



#ifndef C_AIPLUGINASYNCFACTORY_H
#define C_AIPLUGINASYNCFACTORY_H

#include "aicontentpublisher.h"
#include "aipropertyextension.h"
#include "aifwdefs.h"
#include 

class MAiContentObserver;
class MAiEventHandlerExtension;
class MAiContentItemIterator;
class CAiContentPublisher;
class CAiUiController;
class CAiPluginActivityRegistry;
class CImplementationInformation;
class CAiContentPluginManager;
class MAiPluginTool;
class MAiPluginLifecycleObserver;

/**
 * @ingroup group_aifw
 * 
 *  Content plugin factory class for Active idle framework.
 *
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( CAiPluginFactory ) : public CBase
	{
	public:
	
// Constructor and destructor
		
		static CAiPluginFactory* NewL( RPointerArray& aPlugins,
		                                    CAiContentPluginManager& aManager );
		
		virtual ~CAiPluginFactory();

// New functions
		
        /**
         * Create plugin
         *
         * @since S60 5.0
         * @param aPublisherInfo plugin to load.
         * @param aControllerArray array of active UI controllers.
         */
		void CreatePluginL( const TAiPublisherInfo& aPublisherInfo,						
						     RPointerArray& aControllerArray );						

        /**
         * Destroy plugin
         *
         * @since S60 5.0
         * @param aPublisherInfo plugin to destroy.
         * @param aControllerArray array of active UI controllers.
         */
		void DestroyPluginL( const TAiPublisherInfo& aPublisherInfo,		    
                             RPointerArray& aControllerArray );

        /**
         * Destroys all plugins
         * 
         * @since S60 5.0         
         */
		void DestroyPlugins();
		
		
        void AddLifecycleObserverL( MAiPluginLifecycleObserver& aObserver );

        /**
         * Finds plugin by publisher info.
         *
         * @since S60 5.0
         * @param aInfo publisher info.
         * @return Pointer to plugin, NULL if not found.
         */        
        CAiContentPublisher* PluginByInfoL( const TAiPublisherInfo& aInfo ) const;

        /**
         * Finds plugin by name.
         *
         * @since S60 5.0
         * @param aInfo publisher info.
         * @return Pointer to plugin, NULL if not found.
         */                
        CAiContentPublisher* PluginByNameL( const TDesC& aName ) const;
						
	private:	

// Constructors
		
		CAiPluginFactory( RPointerArray& aPlugins,
		                       CAiContentPluginManager& aManager );
		
		void ConstructL();
										
// New functions
		
		CAiContentPublisher* CreatePluginLC( const TAiPublisherInfo& aPluginInfo );
								
		void SubscribeContentObserversL( CAiContentPublisher& aContentPublisher,		    
            const TAiPublisherInfo& aPublisherInfo,
		    RPointerArray& aControllerArray );
		                              
        void ConfigurePluginL( RPointerArray& aControllerArray,
                               CAiContentPublisher& aContentPublisher,
                               const TAiPublisherInfo& aPubInfo );		                           
        
	private:     // Data	
	    // Array of loaded data plugins, Not owned
	    RPointerArray& iPlugins;
	    // Content plugin manager, Not owned	    		
        CAiContentPluginManager& iManager;
        // Ecom implementation info, Owned
		RImplInfoPtrArray iEComPlugins;		
		// Plugin tool from utility lib, Owned
		MAiPluginTool* iPluginTool;      
        // Life cycle observers, Owned
		RPointerArray iLifecycleObservers;		
    };

#endif // C_AIPLUGINASYNCFACTORY_H

// End of File.
hs_app_aipluginlifecycleobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plugin lifecycle observer
*
*/



#ifndef M_AIPLUGINLIFECYCLEOBSERVER_H
#define M_AIPLUGINLIFECYCLEOBSERVER_H

#include "aipropertyextension.h"
#include 

class CAiContentPublisher;

// Unnamed namespace for local definitions
namespace
    {       
    const TInt KAIUidDevStaPlugin = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DEVSTAPLUGIN;
    
    const TInt KAIUidShortCutPlugin = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_SHORTCUTPLUGIN;
    
    const TInt KAIUidProfilePlugin = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_PROFILEPLUGIN;
    
    const TInt KAIUidSATPlugin = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_SATPLUGIN;
    }

/**
 *  Plugin lifecycle observer base class.
 *
 *  @lib aifw
 *  @since S60 3.2
 */
class MAiPluginLifecycleObserver
    {
public:
    
    /**
     * Report plugin created.
     * @param aPlugin reference to the created plugin.
     */
    virtual void PluginCreatedL( CAiContentPublisher& aPlugin ) = 0;

    /**
     * Report plugin destroyed.
     * @param aPlugin reference to the dtored plugin.
     */
    virtual void PluginDestroyed( CAiContentPublisher& aPlugin ) = 0;

    /**
     * Report all plugins created.
     */
    virtual void AllPluginsCreated() = 0;

    /**
     * Report all plugins destroyed.
     */
    virtual void AllPluginsDestroyed() = 0;
    	
protected:

    /**
     * Protected destructor prevents deletion through this interface.
     */
    ~MAiPluginLifecycleObserver() { };               
    };

#endif // M_AIPLUGINSTATEMANAGER_H

// End of File.
hs_app_aipluginstate.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plugin state main class
*
*/


#ifndef M_AIPLUGINSTATE_H
#define M_AIPLUGINSTATE_H

#include "hs_app_aipluginstatemachine.h"

/**
 * Plugin state interface.
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
class MAiPluginState
    {
public:
    
    /**
     * This method is called when state is entered.
     * 
     * @param aStateMachine reference to the owning state machine.
     * @param aStateChange the system state variable change that caused this 
     *        state change.
     */
    virtual void Enter( MAiPluginStateMachine& aStateMachine,
                        TAiStateChanges aStateChange ) = 0;
    
    /**
     * This method handles system state variable state changes
     * handles events in the current state.
     * 
     * @param aStateMachine reference to the owning state machine.
     * @param aStateChange the system state variable change that is the cause
     *        of this event.
     * @return TBool did the state handle the event.
     */
    virtual TBool HandleEvent( MAiPluginStateMachine& aStateMachine,
                              TAiStateChanges aStateChange ) = 0;
    
    /**
     * This method is called when state is exited.
     * 
     * @param aStateMachine reference to the owning state machine.
     * @param aStateChange the system state variable change that caused this 
     *        state change.
     */
    virtual void Exit( MAiPluginStateMachine& aStateMachine,
                       TAiStateChanges aStateChange ) = 0;

protected:

    ~MAiPluginState()
        {
        };
    
    };

#endif // M_AIPLUGINSTATE_H
hs_app_aipluginstatemachine.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plugin state mmchine base class
*
*/


#ifndef M_AIPLUGINSTATEMACHINE_H
#define M_AIPLUGINSTATEMACHINE_H

#include 

class MAiPluginState;

/**
 * TAiStateChanges state change enumeration for each separate monitored state.
 */
enum TAiStateChanges
	{
	ESMAIInCall,
	ESMAINoCall,
    ESMAIBacklightOn,
    ESMAIBacklightOff,
    ESMAIBackupOn,
    ESMAIBackupOff,
    ESMAIIdleForeground,
    ESMAIIdleBackground,
    ESMAISystemBoot,
    ESMAISystemShutdown,
    ESMAILocaleChanged,
    ESMAITimeChanged,
    ESMAIMidnightCrossover,
    ESMAIReportThemeChangeStarted,
    ESMAIReportThemeChangeReady,
    ESMAIRelayoutScreen,
    ESMAIGeneralThemeChanged,
    ESMAIT1Timeout,
    ESMAIKeylockEnabled,
    ESMAIKeylockDisabled,
    ESMAIUnknownState,
    ESMAIEnterEditMode,
    ESMAIExitEditMode,
    ESMAIOffLine,
    ESMAIOnLine,
    ESMAIPageSwitch
	};
	
/**
 * Sate variable enumeration for querying the status of the monitored item.
 */
enum TAiStateVariable
	{
	ESMAICallStatus,
	ESMAILightStatus,
    ESMAIBackupRestoreStatus,
    ESMAIIdleFocusStatus
	};
	
/**
 * Possible states of the state machine (and plugin).
 */
enum TAiState
	{
	EAiIdle = 1,
	EAiSuspended,
	EAiAlive,
	EAiAliveActive,
	EAiAliveIncall,
	EAiAliveInactive
	};

/**
 * Sub states of idle state.
 */
enum TAiIdleSubState
    {
	EAiIdleCreatingPlugins = EAiAliveInactive + 1,
	EAiIdleBackupRestore
    };
	
/**
 * @ingroup group_aifw
 * 
 * Plugin state resource interface.
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
class MAiPluginStateResources
    {
public:
    
    /*
     * Check whether the specified state variable is active or not.
     *
     * @param aStateVariable system variable state change that is to be checked.
     */
    virtual TBool StateVariable( TAiStateVariable aStateVariable ) = 0;
    
    /**
     * Translates system state change reason to plugin state state reason.
     *
     * @param aStateChange the system state variable change to be translated.
     * @return TAiTransitionReason plugin state transition reason.
     */    
    virtual TAiTransitionReason TranslateReason( TAiStateChanges aStateChange ) = 0;
    
    /**
     * Restart plugin suspend timer.
     */    
    virtual void RestartSuspendTimer() = 0;

protected:
    ~MAiPluginStateResources() {}    
    };
    
/**
 * Plugin state machine interface.
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
class MAiPluginStateMachine : public MAiPluginStateResources
    {
public:
    
    /*
     * Method that changes this state machine to a state.
     *
     * @param aState state to change to.
     * @param aStateChange system variable state change that is the cause for this call.
     */
    virtual void SwitchToState( TAiState aState,
                                TAiStateChanges aStateChange ) = 0;
    
    /*
     * Reference to the plugin that is managed by this state machine.
     *
     * @return CAiContentPublisher reference to the plugin.
     */
    virtual CAiContentPublisher& Plugin() const = 0;

    /**
     * Change plugin states.
     *
     * @param aReason for transition
     * @param aStateChangeMethod state change method to call
     * @param aLogOpCode operation code for logging
     */
    virtual void ChangePluginState(
                TAiTransitionReason aReason, 
                void (CAiContentPublisher::*aStateChangeMethod)(TAiTransitionReason) ) = 0;
    
protected:
    ~MAiPluginStateMachine() {}
    };

#endif // M_AIPLUGINSTATEMACHINE_H
hs_app_aipluginstatemachineimpl.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plugin state machine implementation
*
*/


#ifndef C_AIPLUGINSTATEMACHINEIMPL_H
#define C_AIPLUGINSTATEMACHINEIMPL_H

#include 
#include 
#include "hs_app_aipluginstatemachine.h"
#include "hs_app_aistatealive.h"
#include "hs_app_aistatesuspended.h"
#include "hs_app_aistateidle.h"

class MAiPluginStateControl;
class MAiPluginState;

/**
 * Plugin state machine implementation.
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( CAiPluginStateMachine ) : public CBase,
                                             public MAiPluginStateMachine
    {
public: // Constructor 
       
    CAiPluginStateMachine( MAiPluginStateResources& aPluginStateResource,                           
                           CAiContentPublisher& aPlugin );
    
public: // from MAiPluginStateMachine
                                  
    TBool StateVariable( TAiStateVariable aStateVariable );
    
    TAiTransitionReason TranslateReason( TAiStateChanges aStateChange );
    
    void RestartSuspendTimer();
    
    void SwitchToState( TAiState aState, TAiStateChanges aStateChange );
    
    CAiContentPublisher& Plugin() const;
              
    void ChangePluginState( TAiTransitionReason aReason,                
                            void (CAiContentPublisher::*aStateChangeMethod)(TAiTransitionReason) );
                
public: // new methods

    TBool HandleEvent( TAiStateChanges aStateChange );
        
private: // data

    /**
     * Alive master state.
     */
    TAiStateAlive iAlive;

    /**
     * Suspended state.
     */
    TAiStateSuspended iSuspended;

    /**
     * Idle master state.
     */
    TAiStateIdle iIdle;

    /**
     * Pointer to current state.
     * Not owned.
     */
    MAiPluginState* iCurrentState;

    /**
     * Pointer to parent state machine.
     * Not owned.
     */
    MAiPluginStateResources& iPluginStateResource;
    
    /**
     * Pointer to managed plugin.
     * Not owned.
     */
    CAiContentPublisher& iPlugin;    

    /**
     * Online sub-state     
     */    
    TBool iOnline;
    };

#endif // C_AIPLUGINSTATEMACHINEIMPL_H
hs_app_aipluginstatemanager.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plugin state manager
*
*/


#ifndef C_AIPLUGINSTATEMANAGER_H
#define C_AIPLUGINSTATEMANAGER_H

#include 
#include "hs_app_aistatemanager.h"
#include "hs_app_aipluginstatemachine.h"
#include "hs_app_aipluginlifecycleobserver.h"

#include "hs_app_aistatealive.h"
#include "hs_app_aistatesuspended.h"
#include "hs_app_aistateidle.h"
#include "aifwdefs.h"

class MAiPSPropertyObserver;
class MAiDeviceStatusObserver;
class CAiPluginStateManager;
class CAiContentPluginManager;
class CAiPluginStateMachine;
class CAiUiFrameworkObserverImpl;
class MAiUiFrameworkObserver;

/**
 *  Plugin state manager implementation.
 *
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( CAiPluginStateManager ) : public CBase,
                                             public MAiStateManager,
                                             public MAiPluginStateResources,
                                             public MAiPluginLifecycleObserver
    {
    
public: // Constructor and destructor

    static CAiPluginStateManager* NewL();

    virtual ~CAiPluginStateManager();

public: // From MAiStateManager

    void ReportStateChange( TAiStateChanges aState );

public: // From MAiPluginStateMachine

    TBool StateVariable( TAiStateVariable aStateVariable );

    TAiTransitionReason TranslateReason( TAiStateChanges aStateChange );

    void RestartSuspendTimer();

public: // From MAiPluginLifecycleObserver

    void PluginCreatedL( CAiContentPublisher& aPlugin );

    void PluginDestroyed( CAiContentPublisher& aPlugin );
    
    void AllPluginsCreated();

    void AllPluginsDestroyed();
              
public: // new methods

    /**
     * Create system status observers (lights/backup/restore etc.).
     */
    void CreateSystemStateObserversL();

    /**
     * Destroy system status observers.
     */
    void DestroySystemStateObservers();

    /**
     * Provide accessor for fw observer.
     * @return MAiUiFrameworkObserver pointer to fw observer.
     */
    MAiUiFrameworkObserver* UiFwObserver() const;
    
    /**
     * Process online state change for a plugin
     * @param aPlugin plugin     
     */
    void ProcessOnlineState( CAiContentPublisher& aPlugin ); 

    /**
     * Process offline state change for a plugin
     * @param aPlugin plugin     
     */    
    void ProcessOfflineState( CAiContentPublisher& aPlugin );
    
private: // Constructors

    CAiPluginStateManager();

    void ConstructL();

private: // New functions
    
    /**
     * Handles Statemachine event event and error array update.
     * @param aState new state.
     * @param aMachine reference to single state machine.
     */
    void ProcessStateChange( TAiStateChanges aState,
                             CAiPluginStateMachine& aMachine );

    /**
     * Handles Statemachine event event and error array update
     * for all state machines.
     * @param aState new state.
     */
    void ProcessStateChangeForAll( TAiStateChanges aState );

    /**
     * Helper to check idle focus status.
     * @return ETrue if idle is focused / foreground app.
     */
    TBool IdleFocused() const;

    /**
     * Helper to check backup (or restore) status.
     * @return ETrue if backup (or restore) is ongoing.
     */
    TBool BackupOngoing() const;

    /**
     * Helper to check phone lights status.
     * @return ETrue if lights are on.
     */
    TBool LightsOn() const;

    /**
     * Helper to check phone call status.
     * @return ETrue if call is ongoing.
     */
    TBool CallOngoing() const;

    /**
     * Standard callback for CPeriodic ie. T1 timer.
     */
    static TInt T1TimerCallback( TAny* aPtr );
        
private:     // Data

    /**
     * Backup operation state observer.
     * Own.
     */
    MAiDeviceStatusObserver* iBackupOperationObserver;

    /**
     * Call state observer.
     * Own.
     */
    MAiDeviceStatusObserver* iCallStateObserver;

    /**
     * Light state observer.
     * Own.
     */
    MAiDeviceStatusObserver* iLightStateObserver;

    /**
     * Enviroment change observer.
     * Own.
     */
    MAiDeviceStatusObserver* iEnvironmentObserver;

    /**
     * Focus change observer. Using telephony idle visiblity PS.
     * Own.
     */
    MAiDeviceStatusObserver* iFocusObserver;

    /**
     * Keylock observer.
     * Own.
     */
    MAiDeviceStatusObserver* iKeylockObserver;

    /**
     * Enviroment change observer. Full class type is used because
     * we need to provide accessor for implemented type MAiUiFrameworkObserver.
     * Own.
     */
    CAiUiFrameworkObserverImpl* iFrameworkObserver;

    /**
     * Timer for suspend, screensaver timout + light fadeout.
     * Own.
     */
    CPeriodic* iT1Timer;

    /**
     * Timer for suspend, screensaver timout + light fadeout.
     */
    TInt iT1Delay;

    /**
     * New state to be timed.
     */
    TAiState iTimedState;

    /**
     * Reason for timers activity.
     */
    TAiTransitionReason iTimedReason;

    /**
     * Indicates whether the device has been properly started.
     */
    TBool iIsDeviceStarted;

    /**
     * State machines for plugins.
     * Own.
     */
    RPointerArray iStateMachines;
    };

#endif // C_AIPLUGINSTATEMANAGER_H

// End of File.
hs_app_aipsstatusobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  PS status observer
*
*/


#ifndef C_AIPSSTATUSOBSERVER_H
#define C_AIPSSTATUSOBSERVER_H

#include 
#include 
#include "hs_app_aidevicestatusobserver.h"

class MAiPSPropertyObserver;
class MAiStateManager;

/**
 *  description
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
 
NONSHARABLE_CLASS( CAiPSStatusObserver ) : public CBase,
                                           public MAiDeviceStatusObserver
    {

public:

// Construction

    virtual ~CAiPSStatusObserver();

// New functions

    virtual TAiStateChanges Status();

protected:

// Construction
    
    CAiPSStatusObserver();
    
    void BaseConstructL( TCallBack aCallBack,
                         TUid aCategory,
                         TInt aKey, 
                         MAiStateManager* aStateManager );
    
protected: // Data

    MAiPSPropertyObserver* iObserver;
    
    MAiStateManager* iStateManager;
    
    };

#endif // C_AIPSSTATUSOBSERVER_H

// End of File.
hs_app_aissaverstatusobserver.h
/*
* Copyright (c) 2005-2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#ifndef C_AISSAVERSTATUSOBSERVER_H
#define C_AISSAVERSTATUSOBSERVER_H

#include 
#include 
#include "hs_app_aipsstatusobserver.h"

class MAiPSPropertyObserver;

/**
 *  Publish and subscribe key observer
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
 
NONSHARABLE_CLASS( CAiSSaverStatusObserver ) : public CAiPSStatusObserver
    {
public:

// Construction

    static CAiSSaverStatusObserver* NewL( MAiStateManager* aStateManager );

    virtual ~CAiSSaverStatusObserver();

// functions from base class CAiSSaverStatusObserver

    TAiStateChanges Status();

private:

// Construction
    
    CAiSSaverStatusObserver();
    
    void ConstructL( MAiStateManager* aStateManager );
    
// new functions

    static TInt HandleScreenSaverStateChanged( TAny* aPtr );

    };

#endif // C_AISSAVERSTATUSOBSERVER_H

// End of File.
hs_app_aistatealive.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  State alive
*
*/


#ifndef T_AISTATEALIVE_H
#define T_AISTATEALIVE_H

#include "hs_app_aipluginstate.h"
#include "hs_app_aipluginstatemachine.h"

/**
 * @ingroup group_aifw
 * 
 * Alive active state
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( TAiStateAliveActive ) : public MAiPluginState
    {
public: // Constructor
    
    TAiStateAliveActive();
    
public: // from MAiPluginState
    
    void Enter( MAiPluginStateMachine& aStateMachine,
                TAiStateChanges aStateChange );
    
    TBool HandleEvent( MAiPluginStateMachine& aStateMachine,
                      TAiStateChanges aStateChange );
    
    void Exit( MAiPluginStateMachine& aStateMachine,
               TAiStateChanges aStateChange );
    
    };

/**
 * Alive inactive state
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( TAiStateAliveInactive ) : public MAiPluginState
    {
public: // Constructor    
    
    TAiStateAliveInactive();
    
public: // from MAiPluginState
    
    void Enter( MAiPluginStateMachine& aStateMachine,
                TAiStateChanges aStateChange );
    
    TBool HandleEvent( MAiPluginStateMachine& aStateMachine,
                      TAiStateChanges aStateChange );
    
    void Exit( MAiPluginStateMachine& aStateMachine,
               TAiStateChanges aStateChange );    
    };

/**
 * Alive incall state
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( TAiStateAliveIncall ) : public MAiPluginState
    {
public: // Constructor
    
    TAiStateAliveIncall();
    
public: // from MAiPluginState
    
    void Enter( MAiPluginStateMachine& aStateMachine,
                TAiStateChanges aStateChange );
    
    TBool HandleEvent( MAiPluginStateMachine& aStateMachine,
                      TAiStateChanges aStateChange );
    
    void Exit( MAiPluginStateMachine& aStateMachine,
               TAiStateChanges aStateChange );    
    };

/**
 * Alive switch state
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( TAiStateAlive ) : public MAiPluginState,
                                     public MAiPluginStateMachine
    {
public: // Constructor
        
    TAiStateAlive( MAiPluginStateMachine& aParentStateMachine );
    
public: // from MAiPluginStateMachine
    
    TBool StateVariable( TAiStateVariable aStateVariable );
    
    TAiTransitionReason TranslateReason( TAiStateChanges aStateChange );
    
    void RestartSuspendTimer();
    
    void SwitchToState( TAiState aState, TAiStateChanges aStateChange );
                                  
    CAiContentPublisher& Plugin() const;
                 
    void ChangePluginState( TAiTransitionReason aReason,                
                            void (CAiContentPublisher::*aStateChangeMethod)(TAiTransitionReason) );

public: // from MAiPluginState
    
    void Enter( MAiPluginStateMachine& aStateMachine,
                TAiStateChanges aStateChange );
    
    TBool HandleEvent( MAiPluginStateMachine& aStateMachine,
                       TAiStateChanges aStateChange );
    
    void Exit( MAiPluginStateMachine& aStateMachine,
               TAiStateChanges aStateChange );
               
private: // data

    /**
     * Pointer to current state.
     * Not owned.
     */
    MAiPluginState* iCurrentState;

    /**
     * Pointer to parent state machine.
     * Not owned.
     */
    MAiPluginStateMachine* iParentStateMachine;

    /**
     * Alive active state.
     */
    TAiStateAliveActive iStateAliveActive;

    /**
     * Alive incall state.
     */
    TAiStateAliveIncall iStateAliveIncall;

    /**
     * Alive inactive state.
     */
    TAiStateAliveInactive iStateAliveInactive;    
    };

#endif // T_AISTATEALIVE_H
hs_app_aistateidle.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  State idle
*
*/


#ifndef T_AISTATEIDLE_H
#define T_AISTATEIDLE_H

#include "hs_app_aipluginstate.h"
#include "hs_app_aipluginstatemachine.h"

/**
 * @ingroup group_aifw
 * 
 * Idle state.
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( TAiStateIdle ) : public MAiPluginState
    {
public:
    // Construction
    
    TAiStateIdle();
    
    // from MAiPluginState
    
    void Enter( MAiPluginStateMachine& aStateMachine,
                TAiStateChanges aStateChange );
    
    TBool HandleEvent( MAiPluginStateMachine& aStateMachine,
                      TAiStateChanges aStateChange );
    
    void Exit( MAiPluginStateMachine& aStateMachine,
               TAiStateChanges aStateChange );
    
    };

#endif // T_AISTATEIDLE_H
hs_app_aistatemanager.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  State manager base class
*
*/


#ifndef M_AISTATEMANAGER_H
#define M_AISTATEMANAGER_H

#include "hs_app_aipluginstatemachine.h"

/**
 *  description
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
class MAiStateManager
    {
    
    public:
    
        /**
         * System status observers use this method to report status variable 
         * changes to state manager.
         *
         * @param TAiStateChanges aState the state that has changed.
         */
        virtual void ReportStateChange( TAiStateChanges aState ) = 0;
    
    protected:
    
        ~MAiStateManager(){}
    
    };
 
#endif // M_AISTATEMANAGER_H

// End of File.
hs_app_aistatesuspended.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  State suspended
*
*/


#ifndef T_AISTATESUSPENDED_H
#define T_AISTATESUSPENDED_H

#include "hs_app_aipluginstate.h"

/**
 * @ingroup group_aifw
 * 
 * Suspended state
 * 
 *  @lib aifw
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( TAiStateSuspended ) : public MAiPluginState
    {
public:
    // Construction
    
    TAiStateSuspended();
    
    // from MAiPluginState
    
    void Enter( MAiPluginStateMachine& aStateMachine,
                TAiStateChanges aStateChange );
    
    TBool HandleEvent( MAiPluginStateMachine& aStateMachine,
                      TAiStateChanges aStateChange );
    
    void Exit( MAiPluginStateMachine& aStateMachine,
               TAiStateChanges aStateChange );
    
    };

#endif // T_AISTATESUSPENDED_H
hs_app_aiuicontrollermanager.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  UI controller manager
*
*/


#ifndef C_AIUICONTROLLERMANAGER_H
#define C_AIUICONTROLLERMANAGER_H


#include 
#include "aiuiframeworkobserver.h"
#include "aicontentmodel.h"
#include "aifwdefs.h"

class CAiUiController;
class CAiContentPublisher;
class MAiMainUiController;
class MAiFwEventHandler;
class CRepository;
class CCoeEnv;

/**
 * @ingroup group_aifw
 * 
 *  Active Idle UI Controller manager.
 *
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( CAiUiControllerManager ) : public CBase,
                                              public MAiUiFrameworkObserver
	{
	public: // Constructors and destructor		

		static CAiUiControllerManager* NewL();
		~CAiUiControllerManager();
		
	public: // New functions
		
        /**
         * Returns all UI controllers in an array.
         */
		RPointerArray< CAiUiController >& UiControllers() const;
		
		/**
		 * Calls ActivateUI() for all UI controllers.
		 */
		void ActivateUI();
		
        /**
         * Returns the main ui controller object.
         */
		MAiMainUiController& MainUiController() const;
		
        /**
         * Returns true if aUiController is the main UI controller.
         */
		TBool IsMainUiController(CAiUiController& aUiController) const;
		    
        /**
         * Sets framework event handler for all UI controllers.
         */
		void SetEventHandler(MAiFwEventHandler& aEventHandler);
		
        /**
         * Calls RunApplicationL for the main UI controller.
         */
		void RunApplicationL();
		
        /**
         * Calls LoadUIDefinitionL for all UI controllers.
         */
		void LoadUIDefinition();
		
		/**
		 * Returns the main UI Controller's CONE environment object.
		 */
		CCoeEnv& CoeEnv() const;
		
        /**
         * Destroys all UI controllers except the main controller.
         */
		void DestroySecondaryUiControllers();
		
		/**
		 * Adds an UI Framework observer. No duplicates are allowed.
		 */
		void AddObserverL( MAiUiFrameworkObserver& aUiFwObserver );

		/**
		 * Removes an UI Framework observer.
		 */
		void RemoveObserver( MAiUiFrameworkObserver& aUiFwObserver );
		
		/**
		 * Removes plugin from UI.
		 */
		void RemovePluginFromUI( CAiContentPublisher& aPlugin );

        /**
         * Exits main UI controller
         */		
        void ExitMainController();
        
    private:  // From MAiUiFrameworkObserver
    
        void HandleResourceChange( TInt aType );
        void HandleForegroundEvent( TBool aForeground );
                 	
    private: // Constructors

		CAiUiControllerManager();
		void ConstructL();
        
    private: // new functions
        
		void LoadMainControllerL(CRepository& aCenRepConfig);
        void LoadSecondaryControllersL(CRepository& aCenRepConfig);
		
	private: // data
    	/**
		 * UI controller array.
		 * Own.
		 */
		mutable RPointerArray iUiControllerArray;
		
    	/**
		 * Main UI controller for app session. Owned in above array.
		 */
		MAiMainUiController*  iMainUiController;
		
		/**
		 * List of UI framework observers to delegate events
		 */
		RPointerArray iUiFrameworkObservers;
		
		/**
		 * List to check for duplicated creations.
		 */
		RArray iCreatedUICList;
	};

#endif // C_AIUICONTROLLERMANAGER_H

hs_app_aiuiframeworkobserverimpl.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  UI Framework observer for Active Idle
*
*/


#ifndef C_AIUIFRAMEWORKOBSERVERIMPL_H
#define C_AIUIFRAMEWORKOBSERVERIMPL_H


#include 
#include "hs_app_aistatemanager.h"
#include "aiuiframeworkobserver.h"
#include "hs_app_aidevicestatusobserver.h"

/**
 * CAiUiFrameworkObserverImpl implements MAiUiFrameworkObserver for
 * Active Idle framework. It is also a bridge between MAiUiFrameworkObserver
 * and Active Idle system state manager.
 *
 *  @lib hs_app_aifw.lib
 *  @since S60 3.2
 */
NONSHARABLE_CLASS( CAiUiFrameworkObserverImpl )
    : public CBase,
      public MAiUiFrameworkObserver,
      public MAiDeviceStatusObserver
    {
public:

    static CAiUiFrameworkObserverImpl* NewL( MAiStateManager& aManager );

    virtual ~CAiUiFrameworkObserverImpl();

// from base class MAiDeviceStatusObserver

    TAiStateChanges Status();

private:

    CAiUiFrameworkObserverImpl( MAiStateManager& aManager );

    void ConstructL();

// from base class MAiUiFrameworkObserver
    
    void HandleResourceChange( TInt aType );

    void HandleForegroundEvent( TBool aForeground );
    
private: // data

    /**
     * State manager.
     */
    MAiStateManager& iManager;

    };

#endif // C_AIUIFRAMEWORKOBSERVERIMPL_H
hs_app_aiidleappregister.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Idle application registration interface.
*
*/


#ifndef C_AIIDLEAPPREGISTER_H
#define C_AIIDLEAPPREGISTER_H

#include 

/**
 * @ingroup group_aiidleint
 *
 * Idle application registration interface.
 */
class CAiIdleAppRegister : public CBase
    {

public:

    IMPORT_C static CAiIdleAppRegister* NewLC();

    ~CAiIdleAppRegister() { }

    /**
     * Registers Active Idle as the system idle application.
     */
    virtual void RegisterL() = 0;
    };


#endif // C_AIIDLEAPPREGISTER_H

hs_app_aiwspluginmanager.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Window server plug-in manager.
*
*/


#ifndef C_AIWSPLUGINMANAGER_H
#define C_AIWSPLUGINMANAGER_H

#include 

class CCoeEnv;

/**
 * @ingroup group_aiidleint
 *
 * Registers Active Idle Window Server Plug-in at construction and
 * deregisters it at destruction.
 */
class CAiWsPluginManager : public CBase
    {
public:

    IMPORT_C static CAiWsPluginManager* NewL( CCoeEnv& aCoeEnv );

    ~CAiWsPluginManager() { }
    };


#endif // C_AIWSPLUGINMANAGER_H

hs_app_aipluginsettingsimpl.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#ifndef M_AIPLUGINSETTINGSIMPL_H
#define M_AIPLUGINSETTINGSIMPL_H

#include "aipluginsettings.h"

class CAiPluginSettingsItem;
class MAiPluginContentItem;

/**
 * Implementation of Active Idle framework settings access interface.
 *
 * @since S60 3.2
 */
NONSHARABLE_CLASS(CAiPluginSettings) : public CBase, public MAiPluginSettings
    {
public:

    static CAiPluginSettings* NewL();

    ~CAiPluginSettings();

    MAiPluginSettingsItem& AiPluginSettingsItem();
    
    TInt AiPluginItemType();
            
    MAiPluginContentItem& AiPluginContentItem();
    
    MAiPluginConfigurationItem& AiPluginConfigurationItem();

private:

    CAiPluginSettings();

    void ConstructL();

private:

    CAiPluginSettingsItem* iSettingsItem;
    
    TInt                    iItemType;

    };

#endif // M_AIPLUGINSETTINGSIMPL_H


hs_app_aipluginsettingsitemimpl.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#ifndef C_AIPLUGINSETTINGSITEMIMPL_H
#define C_AIPLUGINSETTINGSITEMIMPL_H

#include "aipluginsettings.h"

/**
 * Implementation of Active Idle framework settings item interface.
 *
 * @lib ?library
 * @since S60 3.2
 */
NONSHARABLE_CLASS(CAiPluginSettingsItem) : public CBase, public MAiPluginSettingsItem,
    public MAiPluginContentItem, public MAiPluginConfigurationItem 
    {
public:   // Constructors and destructor

    /**
     * Constructor.
     */
    CAiPluginSettingsItem();

    /**
     *
     */
    void ConstructL();

    /**
     * Destructor.
     */
    ~CAiPluginSettingsItem();

public:  // From MAiPluginSettingsItem

    /**
     * Get a pointer to the descriptor value of the setting.
     *
     * @return returns the value of the setting item.
     *
     * @since S60 3.2
     */
    TPtrC Value();

    /**
     * Sets the setting value.
     *
     * @param aValue       the descriptor value for the Setting.
     * @param aSaveToStore (this parameter is ignored)
     *
     * @since S60 3.2
     */
    void SetValueL(const TDesC& aValue, TBool aSaveToStore = ETrue);

    /**
     * Get publisher uid this setting item belongs to.
     *
     * @return publisher uid.
     *
     * @since S60 3.2
     */
    const TUid& PublisherId() const;

    /**
     * Set publisher uid this setting item belongs to.
     *
     * @param aUid publisher uid.
     *
     * @since S60 3.2
     */
    void SetPublisherId(const TUid& aUid);

    /**
     * Get setting item key.
     *
     * @return key value.
     *
     * @since S60 3.2
     */
    TInt32 Key() const;

    /**
     * Set setting item key.
     *
     * @param aKey setting item key.
     *
     * @since S60 3.2
     */
    void SetKey(TInt32 aKey);

    /**
     * Set storer for this setting item.
     *
     * @param aStorer pointer to instance of storer interface.
     *
     * @since S60 3.2
     */
    void SetStorer(MAiPluginSettingsStorer* aStorer);

    /**
     * Reads this setting item value from settings store.
     *
     * @since S60 3.2
     */
    virtual void ReadFromStoreL();

    /**
     * Saves this setting item value to settings store.
     *
     * @since S60 3.2
     */
    virtual void SaveToStoreL();

public: //From MAiPluginContentItem
    
    TPtrC Name();

    void SetNameL( const TDesC& aName );

    TPtrC Type();

    void SetTypeL( const TDesC& aType );
    
public: //From MAiPluginConfigurationItem

    TPtrC Owner();
    
    void SetOwnerL( const TDesC& aOwner );
    
    void SetValueL( const TDesC& aValue );

private:     // Data

    // Setting value.
    HBufC*                      iValue;

    // Uid of publisher plugin this setting item belongs to.
    TUid                        iPublisherId;

    // Setting item key.
    TInt32                      iKey;

    // Settings storer.
    MAiPluginSettingsStorer*    iStorer;

    HBufC*                      iName;
    
    HBufC*                      iType;
    
    HBufC*                      iOwner;
    };

#endif // C_AIPLUGINSETTINGSITEMIMPL_H

hs_app_caicontentitemarrayiterator.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/



#ifndef C_AIARRAYITERATOR_H
#define C_AIARRAYITERATOR_H


#include 
#include 

/**
 *  @ingroup group_aiutils
 * 
 *  Content item array iterator.
 *
 *  Iterator implementation for content item arrays
 *  Usage example:
 *
 *      const TAiContentItem KExPluginContent[] =
 *          {
 *              { 1, "Counter", "text/plain" },
 *              { 2, "Status",  "text/plain" }
 *          };
 *
 *      CAiContentItemArrayIterator* iContent =
 *          CreateIteratorL( KExPluginContent );
 *
 *      while( iContent->HasNext() )
 *          {
 *          TAiContentItem& myItem = iContent->NextL();
 *          // My ops using myItem
 *          }
 *
 *  @since S60 3.1
 */
NONSHARABLE_CLASS(CAiContentItemArrayIterator) : 
    public CBase, public MAiContentItemIterator
    {
public:
    
    /**
     * Creates a new iterator instance from a TAiContentItem array.
     *
     * @param aArray content item array.
     * @param aCount  number of content items in aArray.
     * @return a new iterator object for aArray.
     * @see CreateIteratorL
     * @since S60 3.2
     */
    static CAiContentItemArrayIterator* NewL
        ( const TAiContentItem* aArray, TInt aCount );
        
    virtual ~CAiContentItemArrayIterator();
    
    void Release();

// from base class MAiContentItemIterator

    TBool HasNext() const;

    const TAiContentItem& NextL();

    const TAiContentItem& ItemL(TInt aId) const;
    
	const TAiContentItem& ItemL( const TDesC& aCid ) const;

    void Reset();

private:

     CAiContentItemArrayIterator( const TAiContentItem* aArray, TInt aCount );

private: // data

    /**
     * Array of items
     * Not Own.
     */
    const TAiContentItem*   iArray;

    /**
     * Total number of items
     */
    TInt                    iCount;

    /**
     * Current iterator index
     */
    TInt                    iIndex;
    };


#endif // C_CAiContentItemArrayIterator_H
hs_app_caiplugintool.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Collection of content plugin helper functions
*
*/


#ifndef C_AIPLUGINTOOL_H
#define C_AIPLUGINTOOL_H

#include 
#include "aiplugintool.h"

class TAiPublisherInfo;
class CAiContentPublisher;
class MAiContentItemIterator;
class MAiPropertyExtension;
class MAiEventHandlerExtension;

/**
*  @ingroup group_aiutils
* 
*  Plugin tool.
*
*  @since S60 3.2
*/
NONSHARABLE_CLASS( CAiPluginTool ) :
    public CBase, public MAiPluginTool
	{
public:
	
    static CAiPluginTool* NewL();
    
private:

    CAiPluginTool();
    
    void ConstructL();
    
    void Release();

    const TAiPublisherInfo* PublisherInfoL(
                                CAiContentPublisher& aContentPublisher );

    MAiContentItemIterator* ContentItemIteratorL(
                                CAiContentPublisher& aContentPublisher,
                                TInt aContentType = EAiPublisherContent );

    MAiPropertyExtension* PropertyExt(
                                CAiContentPublisher& aContentPublisher );

    MAiEventHandlerExtension* EventHandlerExt(
                                CAiContentPublisher& aContentPublisher );

    };

#endif // M_AIPLUGINTOOL_H





hs_app_caipspropertyobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#ifndef C_CPSPROPERTYOBSERVER_H
#define C_CPSPROPERTYOBSERVER_H

#include 
#include 
#include "aipspropertyobserver.h"

/**
 *  @ingroup group_aiutils
 * 
 *  Publish and subscribe key observer
 * 
 *	@lib hs_app_aiutils.lib
 *  @since S60 3.2
 */
 
NONSHARABLE_CLASS(CPSPropertyObserver) : 
    public CActive, public MAiPSPropertyObserver
    {
    
public:

	/**
     * Two-phased constructor.
     */
    static CPSPropertyObserver* NewL (TCallBack aCallBack, TUid aCategory, TInt aKey);
	
	/**
     * Destructor.
     */
    ~CPSPropertyObserver();

	/**
     * Release the observer
     */
	void Release();
	
// from base class CActive

    void RunL();
	
    void DoCancel();
    
// from base class MAiPSPropertyObserver    

    TInt Get( TInt& aValue );
    
    TInt Get( TDes8& aString );

    TInt Get( TDes16& aString );

private:

	/**
     * By default Symbian 2nd phase constructor is private.
     */
    void ConstructL();
	
	/**
     * C++ default constructor.
     */
    CPSPropertyObserver( TCallBack aCallBack,
                         TUid aCategory,
                         TInt aKey );
    
private:

    /**
     * Callback member
     */
    TCallBack   iCallBack;

    /**
     * PS category id
     */
    TUid        iCategory;

    /**
     * PS key
     */
    TInt        iKey;

    /**
     * Property member
     */
    RProperty   iProperty;
    
    };

#endif // C_CPSPROPERTYOBSERVER_H

// End of File.
hs_app_caistrparser.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Collection of string parsing methods.
*
*/


#ifndef C_STRPARSER_H
#define C_STRPARSER_H

#include 
#include 
#include "aistrparser.h"

// CLASS DECLARATION

/**
*  @ingroup group_aiutils
* 
*  String Parser
*
*  @since S60 3.2
*/
NONSHARABLE_CLASS(CStrParser) : 
    public CBase, public MAiStrParser
	{
	
public:
	
    static CStrParser* NewL();
    
private:

    CStrParser();
    
    void ConstructL();
    
    void Release();
    	  
	TInt ParseInt( TInt32& aResult, const TDesC8& aSourceString );

	HBufC16* CopyToBufferL( HBufC16* aTargetBuffer, const TDesC16& aSourceText );

	HBufC16* CopyToBufferL( HBufC16* aTargetBuffer, const TDesC8& aSourceText );

	HBufC8* CopyToBufferL( HBufC8* aTargetBuffer, const TDesC8& aSourceText );

	HBufC8* CopyToBufferL( HBufC8* aTargetBuffer, const TDesC16& aSourceText );

    };

#endif // C_STRPARSER_H





hs_app_aifw.loc
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Localization strings for project IdleFW
*
*/


// d: It is text of Active Idle 3 application in application shell grid. 
// d: When user selects that item, then phone goes to idle state 
// d: or call related state.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_idle_grid "Idle"

// d: It is possible that user activates Idle theme which
// d: contains one or more plug-ins which can not be loaded to framework.
// l: popup_note_window
// w:
// r: 3.2
//
#define qtn_idle_theme_error_incompatible "Problems with theme. It may not work correctly."

// d: In case plug-in dies during operation error note is shown.
// l: popup_note_window
// w:
// r: 3.2
//
#define qtn_idle_theme_error_notloaded "Error in theme."
hs_app_aibtsappublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Listens Bluetooth SIM Access Profile (BT SAP) and publishes
*					text when BT SAP is activated.
*
*/


#ifndef C_AIBTSAPPUBLISHER_H
#define C_AIBTSAPPUBLISHER_H


#include 
#include 
#include 
#include 
#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_aidevicestatuscontentmodel.h"

class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Listens Bluetooth SIM Access Profile (BT SAP) and publishes text from
 *  resource file with EAiDeviceStatusContentBTSAP content id when
 *  BT SAP is activated.
 *
 *  @since S60 3.2
 */
class CAiBTSAPPublisher : public CActive, public MAiDeviceStatusPublisher
    {
public:

    static CAiBTSAPPublisher* NewL();

    virtual ~CAiBTSAPPublisher();

// from base class MAiDeviceStatusPublisher

    void ResumeL();
    void Subscribe( MAiContentObserver& aObserver, 
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );
    void RefreshL( TBool aClean );
    TBool RefreshL( TInt aContentId, TBool aClean );
    TBool RefreshContentWithPriorityL( TInt aContentId, TInt aPriority );
    
protected:

// from base class CActive

    void RunL();
    void DoCancel();
    TInt RunError( TInt aError );

private:

    CAiBTSAPPublisher();

    void ConstructL();

    void FreeEngine();

private: // data

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;
    
	/**
	 * Content prioritizer.
	 * Not own.
	 */
	MAiPublishPrioritizer* iPrioritizer;
    
	/**
	 * Publish broadcaster.
	 * Not own.
	 */
	MAiPublisherBroadcaster* iBroadcaster;
	
    /**
     * Publish-subscribe client used to observer BT SAP activation.
     */
    RProperty iPubSub;

    /**
     * Variable which tells if publisher has published previously or not.
     */
    TBool iFirstPublish;

    /**
     * True if publish was successful.
     */
    TBool iSuccess;
    };


#endif // C_AIBTSAPPUBLISHER_H
hs_app_aicontentobserveroptimizer.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Active Idle Content Observer optimizer
*
*/


#ifndef C_AIMULTICONTENTOBSERVEROPTIMIZER_H
#define C_AIMULTICONTENTOBSERVEROPTIMIZER_H


#include 
#include "aicontentobserver.h"

/**
 *  @ingroup group_devicestatusplugin
 *
 * Active Idle Content Observer optimizer. 
 * 
 * Optimizes the Commit calls to different UI controllers. In 
 * case nothing is published nothing is committed.
 *
 * @see MAiContentObserver
 * @since S60 3.2
 */
class CAiContentObserverOptimizer : public CBase      
    {

private:
    struct TAiPublishBlackList
        {
        TInt iContentId;
        
        TInt iIndex;              
        };

public:
    static CAiContentObserverOptimizer* NewL(MAiContentObserver& aObserver);
    ~CAiContentObserverOptimizer();
    
    /**
     * Starts a transaction
     * 
     * @return KErrAlreadyExists in case transaction already ongoing. 
     *         KErrNotSupported in case transaction not supported
     *         KErrNone in case transaction succesfuly started
     */
    TInt StartTransaction( TInt aTxId );
    
    /**
     * Commits a started transaction. In case no committing is needed
     * (no publish calls has been made) the transaction is cancelled.
     * 
     * @return KErrNotReady in case no transaction is ongoing.
     *         KErrNotSupported in case transaction not supported
     *         KErrNone in case succesfully committed.
     */         
    TInt Commit( TInt aTxId );
    
    /**
     * Cancels a transactions in case a transaction was started.
     * 
     * @return KErrNotReady in case no transaction is ongoing.
     *         KErrNotSupported in case transactions are not supported
     *         KErrNone in case transaction succesfully cancelled     
     */
    TInt CancelTransaction( TInt aTxId );
    
    /*
     * @see MAiContentObserver
     */
    TBool CanPublish( MAiPropertyExtension& aPlugin, TInt aContent, TInt aIndex );
    
    /**
     * @see MAiContentObserver
     */
    TInt Publish( MAiPropertyExtension& aPlugin, TInt aContent,
                  TInt aResource, TInt aIndex );

    /**
     * @see MAiContentObserver
     */
    TInt Publish( MAiPropertyExtension& aPlugin, TInt aContent,
                  const TDesC16& aText, TInt aIndex );
    /**
     * @see MAiContentObserver
     */
    TInt Publish( MAiPropertyExtension& aPlugin, TInt aContent,
                  const TDesC8& aBuf, TInt aIndex );

    /**
     * @see MAiContentObserver
     */
    TInt Publish( MAiPropertyExtension& aPlugin, TInt aContent,
                  RFile& aFile, TInt aIndex );
    /**
     * @see MAiContentObserver
     */
    TInt Clean( MAiPropertyExtension& aPlugin, TInt aContent, TInt aIndex );

    /**
     * Returns the actual content observer.
     */
    MAiContentObserver& Observer() const;
    
private:
    CAiContentObserverOptimizer(MAiContentObserver& aObserver);

    TInt AddToBlackList( TInt aContentId, TInt aIndex );

    TBool IsInBlackList( TInt aContentId, TInt aIndex ) const;

private: // data

    /**
     * Handle to the observer that receives
     * the publish calls.
     */
    MAiContentObserver &iObserver;
    
    TBool iCommitNeeded;

    TBool iTransactionStarted;
    
    RArray iBlackList;
    };


#endif // C_AIMULTICONTENTOBSERVEROPTIMIZER_H
hs_app_aicugmcnpublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Closed user group (CUG) publisher.
*
*/


#ifndef C_AICUGMCNPUBLISHER_H
#define C_AICUGMCNPUBLISHER_H


#include 
#include 
#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_aidevicestatuscontentmodel.h"
#include "hs_app_ainetworkinfoobserver.h"

class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;
class CAiNetworkInfoListener;

const TInt KAnimDelay = 2000000;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Closed user group (CUG) and Micro Cellular Network (MCN) publisher.
 *
 *  @since S60 3.2
 */
class CAiCUGMCNPublisher : public CBase, public MAiDeviceStatusPublisher,
                        public MSSSettingsObserver, public MAiNetworkInfoObserver
    {
public:

    static CAiCUGMCNPublisher* NewL();

    virtual ~CAiCUGMCNPublisher();

protected:

// from base class MAiDeviceStatusPublisher

    void ResumeL();
    void Subscribe( MAiContentObserver& aObserver, 
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );
    void RefreshL( TBool aClean );
    TBool RefreshL( TInt aContentId, TBool aClean );

// from base class MSSSettingsObserver

    void PhoneSettingChanged( TSSSettingsSetting aSetting, TInt aNewValue );

//from base class MAiNetworkInfoObserver

    void HandleNetworkInfoChange( const MNWMessageObserver::TNWMessages& aMessage, 
        						const TNWInfo& aInfo, 
        						const TBool aShowOpInd );

private:

    CAiCUGMCNPublisher();

    void ConstructL();

    /**
     * Updates CUGMCN indicator if needed.
     */
    void UpdateCUGMCNIndicatorL( TInt aValue );
    
    void Animate();
    
    void PublishCUG();
    
    void PublishMCN();
    
    /**
     * The call back function.
     * \param aAny A pointer to this class.
     */
    static TInt PeriodicTimerCallBack(TAny* aAny);
    
    void DoAnimation();


private: // data

    /**
     * Used for doing the animation.
     * Own.
     */
    CPeriodic* iPeriodic;
    
    /**
     * Content observer.
     * Not own.
     */
    MAiContentObserver* iContentObserver;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;

    /**
     * SS Settings client. Used to observer CUGMCN changes.
     */
    RSSSettings iSSSettings;
    
    /**
     * Network info listener.
     * Own.
     */
    CAiNetworkInfoListener* iListener;
    
    /**
     * Soft indicators.
     */
    HBufC* iCUG;
    HBufC* iMCN;
    
    TBool iAnimationDone;
    };

#endif // C_AICUGMCNPUBLISHER_H
hs_app_aicugpublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Closed user group (CUG) publisher.
*
*/


#ifndef C_AICUGPUBLISHER_H
#define C_AICUGPUBLISHER_H


#include 
#include 
#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_aidevicestatuscontentmodel.h"

class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Closed user group (CUG) publisher.
 *
 *  @since S60 3.2
 */
class CAiCUGPublisher : public CBase, public MAiDeviceStatusPublisher,
                        public MSSSettingsObserver
    {
public:

    static CAiCUGPublisher* NewL();

    virtual ~CAiCUGPublisher();


protected:

// from base class MAiDeviceStatusPublisher

    void ResumeL();
    void Subscribe( MAiContentObserver& aObserver, 
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );
    void RefreshL( TBool aClean );
    TBool RefreshL( TInt aContentId, TBool aClean );

// from base class MSSSettingsObserver

    void PhoneSettingChanged( TSSSettingsSetting aSetting, TInt aNewValue );


private:

    CAiCUGPublisher();

    void ConstructL();

    /**
     * Updates CUG indicator if needed.
     */
    void UpdateCUGIndicatorL( TInt aValue );
    

private: // data

    /**
     * Content observer.
     * Not own.
     */
    MAiContentObserver* iContentObserver;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;

    /**
     * SS Settings client. Used to observer CUG changes.
     */
    RSSSettings iSSSettings;
    
    /**
     * Published CUG text. Owned.
     */
    HBufC* iCugText;
    
    /**
     * Previous CUG value
     */
    TInt iCugValue;
    };


#endif // C_AICUGPUBLISHER_H
hs_app_aidatepublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Date publisher
*
*/


#ifndef C_AIDATEPUBLISHER_H
#define C_AIDATEPUBLISHER_H

#include 
#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_aidevicestatuscontentmodel.h"

class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;
class CEnvironmentChangeNotifier;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Date publisher.
 *
 *  Publishes current date formatted according to current locale if profile
 *  if either general or offline.
 *
 *  @since S60 3.2
 */
class CAiDatePublisher : public CBase, public MAiDeviceStatusPublisher
    {
public:

    static CAiDatePublisher* NewL();

    virtual ~CAiDatePublisher();

protected:

// from base class MAiDeviceStatusPublisher

    void ResumeL();
    void Subscribe( MAiContentObserver& aObserver, 
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );
    void RefreshL( TBool aClean );
    TBool RefreshL( TInt aContentId, TBool aClean );

private:

    CAiDatePublisher();

    void ConstructL();

	/// Re-publish date
	void RefreshDateL();
	
	/// Create day name string
	HBufC* GetDayNameStringLC( TDay aDay, CCoeEnv& aCoeEnv );

	/// Create date string
    HBufC* ConstructDateStringL();
    
    /// Callback when enviroment changed.
    static TInt HandleCallBackL( TAny *aPtr );



protected: // data

    /**
     * Content observer.
     * Not own.
     */
    MAiContentObserver* iContentObserver;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;
 
	/**
	 * Content prioritizer.
	 * Not own.
	 */
	MAiPublishPrioritizer* iPrioritizer;
   
    /**
	 * Environment notifier.
	 * own.
	 */
	CEnvironmentChangeNotifier* iEnvNotifier;
	
	/**
	 * Constructed date text.
	 * Own.
	 */
	HBufC* iDateText;
	
    };


#endif // C_AIDATEPUBLISHER_H
hs_app_aidevicestatuscontentmodel.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Device Status plug-in content model
*
*/


#ifndef AIDEVICESTATUSCONTENTMODEL_H
#define AIDEVICESTATUSCONTENTMODEL_H

#include 

/**
 * Content model for Device Status plug-in.
 * This header defines which information Device Status publishes
 */

// ================================= CONTENT ===================================

//content item id's
enum TAiDeviceStatusContentIds
    {
    EAiDeviceStatusContentNetworkIdentity,
    EAiDeviceStatusContentProfileName,
    EAiDeviceStatusContentGeneralProfileName,
    EAiDeviceStatusContentDate,
    EAiDeviceStatusContentSilentIndicator,
    EAiDeviceStatusContentTimedProfileIndicator,
    EAiDeviceStatusContentSIMRegStatus,
    EAiDeviceStatusContentNWStatus,
    EAiDeviceStatusContentMCNIndicator,
    EAiDeviceStatusContentVHZIndicator,
    EAiDeviceStatusContentCUGIndicator,
    EAiDeviceStatusContentGeneralIndicator,
    EAiDeviceStatusContentVHZText,
    EAiDeviceStatusContentCUGMCNIndicator
    };


//content item textual id's
const wchar_t KAiDeviceStatusContentNetworkIdentity_Cid[]	  	= L"NetworkIdentity";
const wchar_t KAiDeviceStatusContentProfileName_Cid[]	  		= L"ProfileName";
const wchar_t KAiDeviceStatusContentGeneralProfileName_Cid[]	= L"GeneralProfileName";
const wchar_t KAiDeviceStatusContentDate_Cid[]			  		= L"Date";
const wchar_t KAiDeviceStatusContentSilentIndicator_Cid[] 		= L"SilentIndicator";
const wchar_t KAiDeviceStatusContentTimedProfileIndicator_Cid[] = L"TimedProfileIndicator";
const wchar_t KAiDeviceStatusContentSIMRegStatus_Cid[]	  		= L"SIMRegStatus";
const wchar_t KAiDeviceStatusContentNWStatus_Cid[]	  		    = L"NWStatus";
const wchar_t KAiDeviceStatusContentMCNIndicator_Cid[]	  		= L"MCNIndicator";
const wchar_t KAiDeviceStatusContentVHZIndicator_Cid[]	  		= L"VHZIndicator";
const wchar_t KAiDeviceStatusContentCUGIndicator_Cid[]	  		= L"CUGIndicator";
const wchar_t KAiDeviceStatusContentGeneralIndicator_Cid[]	  	= L"GeneralIndicator";
const wchar_t KAiDeviceStatusContentVHZText_Cid[]       	  	= L"VHZText";
const wchar_t KAiDeviceStatusContentCUGMCNIndicator_Cid[]	  	= L"CUGMCNIndicator";


const char KAiDeviceStatusMimeTypeTextPlain[]			= "text/plain";

/**
*  Content what device status plugin publishes
*/

const TAiContentItem KAiDeviceStatusContent[] =
    {
    //Published data can be service provider name, offline profile,
    //operator logo or anything related to network status
    { EAiDeviceStatusContentNetworkIdentity, KAiDeviceStatusContentNetworkIdentity_Cid,
    	 KAiDeviceStatusMimeTypeTextPlain },

    //Published data is name of the profile from profiles engine
    { EAiDeviceStatusContentProfileName, KAiDeviceStatusContentProfileName_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },

    //Published data is name of the general profile from profiles engine
    { EAiDeviceStatusContentGeneralProfileName, KAiDeviceStatusContentGeneralProfileName_Cid,
    	 KAiDeviceStatusMimeTypeTextPlain },

    //Published data is current date as a text. Formatted according to current locale
    { EAiDeviceStatusContentDate, KAiDeviceStatusContentDate_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },

    //Published data silent indicator as a text
    { EAiDeviceStatusContentSilentIndicator, KAiDeviceStatusContentSilentIndicator_Cid,
    	 KAiDeviceStatusMimeTypeTextPlain },

    //Published data timed profile indicator as a text
    { EAiDeviceStatusContentTimedProfileIndicator, KAiDeviceStatusContentTimedProfileIndicator_Cid,
    	 KAiDeviceStatusMimeTypeTextPlain },

    //Published data is resource id
    { EAiDeviceStatusContentSIMRegStatus, KAiDeviceStatusContentSIMRegStatus_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },

    //Published data is resource id
    { EAiDeviceStatusContentNWStatus, KAiDeviceStatusContentNWStatus_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },

    //Published data is MCN message
    { EAiDeviceStatusContentMCNIndicator, KAiDeviceStatusContentMCNIndicator_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },

    //Published data is VHZ name
    { EAiDeviceStatusContentVHZIndicator, KAiDeviceStatusContentVHZIndicator_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },

    //Published data is localized text, for example "Group 1"
    { EAiDeviceStatusContentCUGIndicator, KAiDeviceStatusContentCUGIndicator_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },

    //Published data general indicator as a text
    { EAiDeviceStatusContentGeneralIndicator, KAiDeviceStatusContentGeneralIndicator_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },

    //Published data VHZ text
    { EAiDeviceStatusContentVHZText, KAiDeviceStatusContentVHZText_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },
    	
    //Published data is localized text, for example "Group 1" or MCN message
    { EAiDeviceStatusContentCUGMCNIndicator, KAiDeviceStatusContentCUGMCNIndicator_Cid,
        KAiDeviceStatusMimeTypeTextPlain }
    };

const TInt KAiDeviceStatusContentCount = sizeof( KAiDeviceStatusContent ) /
                                            sizeof( KAiDeviceStatusContent[0] );



//content item id's
enum TAiDeviceStatusResourceIds
    {
    EAiDeviceStatusResourceSIMRegFail,
    EAiDeviceStatusResourceNWOk,
    EAiDeviceStatusResourceNWLost
    };

const wchar_t KAiDeviceStatusResourceSIMRegFail_Cid[] = L"SIMRegFail";
const wchar_t KAiDeviceStatusResourceShowNWLost_Cid[] = L"NWLost";


const TAiContentItem KAiDeviceStatusResources[] =
{
    //Published data is resource id
    { EAiDeviceStatusResourceSIMRegFail, KAiDeviceStatusResourceSIMRegFail_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },
    { EAiDeviceStatusResourceNWLost, KAiDeviceStatusResourceShowNWLost_Cid,
    	KAiDeviceStatusMimeTypeTextPlain },
};

const TInt KAiDeviceStatusResourceCount = sizeof( KAiDeviceStatusResources ) /
                                            sizeof( KAiDeviceStatusResources[0] );


#endif // AIDEVICESTATUSCONTENTMODEL_H
hs_app_aidevicestatuscontentobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Device status content publisher
*
*/


#ifndef M_AIDEVICESTATUSCONTENTOBSERVER_H
#define M_AIDEVICESTATUSCONTENTOBSERVER_H


class MAiDeviceStatusPublisher;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Device status content publisher.
 *
 *  All of the publishers uses this interface to publish content.
 *
 *  @since S60 3.2
 */
class MAiDeviceStatusContentObserver
    {

protected:
    /**
     * Virtual destructor.
     *
     * This cannot be used to destroy observer object.
     */
     virtual ~MAiDeviceStatusContentObserver() {};

public:

    /**
     * Publish unicode text.
     *
     * @since S60 3.2
     * @param aPublisher is reference to publisher which is publishing.
     * @param aContent is content id.
     * @param aText is published text.
     * @param aPriority is priority of the content.
     * @return KErrNone if publish is successful, otherwise system wide error code.
     */
    virtual TInt Publish( MAiDeviceStatusPublisher& aPublisher, TInt aContent,
                          const TDesC16& aText, TInt aPriority ) = 0;

    /**
     * Publish data buffer.
     *
     * @since S60 3.2
     * @param aPublisher is reference to publisher which is publishing.
     * @param aContent is content id.
     * @param aBuf is data buffer.
     * @param aPriority is priority of the content.
     * @return KErrNone if publish is successful, otherwise system wide error code.
     */
    virtual TInt Publish( MAiDeviceStatusPublisher& aPublisher, TInt aContent,
                          const TDesC8& aBuf, TInt aPriority ) = 0;

    /**
     * Publish resource.
     *
     * @since S60 3.2
     * @param aPublisher is reference to publisher which is publishing.
     * @param aContent is content id.
     * @param aResource is resource id.
     * @param aPriority is priority of the content.
     * @return KErrNone if publish is successful, otherwise system wide error code.
     */
    virtual TInt Publish( MAiDeviceStatusPublisher& aPublisher, TInt aContent,
                          TInt aResource, TInt aPriority ) = 0;

    /**
     * Clean content.
     *
     * @since S60 3.2
     * @param aPublisher is reference to publisher which is publishing.
     * @param aContent is content id.
     * @param aPriority is priority of the content.
     * @return KErrNone if publish is successful, otherwise system wide error code.
     */
    virtual TInt Clean( MAiDeviceStatusPublisher& aPublisher, TInt aContent, TInt aPriority ) = 0;

    };


#endif // M_AIDEVICESTATUSCONTENTOBSERVER_H
hs_app_aidevicestatusplugin.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Device status plugin interface.
*
*/


#ifndef C_AIDEVICESTATUSPLUGIN_H
#define C_AIDEVICESTATUSPLUGIN_H


#include 
#include 
#include 

class MAiDeviceStatusPublisher;
class CAiContentItemArrayIterator;
class CAiDeviceStatusPluginEngine;
class CAiMultiContentObserver;
class CAiPublishPrioritizer;
class CAiNetworkInfoListener;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Device status plugin interface.
 *
 *  This class implements required active idle plugin API.
 *
 *  @since S60 3.2
 */
class CAiDeviceStatusPlugin : public CAiContentPublisher, 
                                public MAiPropertyExtension, 
                                public MAiContentRequest
    {
public:

    static CAiDeviceStatusPlugin* NewL();
    static CAiDeviceStatusPlugin* NewLC();

    virtual ~CAiDeviceStatusPlugin();

protected:

// from base class CAiContentPublisher
    void Resume( TAiTransitionReason aReason );
    void Suspend( TAiTransitionReason aReason );
    void Stop( TAiTransitionReason aReason );
    void SubscribeL(MAiContentObserver& aObserver);
    TAny* Extension(TUid aUid);
    void ConfigureL(RAiSettingsItemArray& aSettings);

protected:

// from base class MAiPropertyExtension
    TAny* GetPropertyL(TInt aProperty);
    void SetPropertyL(TInt aProperty, TAny* aValue);

// from base class MAiContentRequest
    TBool RefreshContent( TInt aContentId );


private:

    CAiDeviceStatusPlugin();
    void ConstructL();

    void AllocateResourcesL();
    void FreeResources();
    void DoResumeL( TAiTransitionReason aReason );
    TBool IgnoreReason( TAiTransitionReason aReason );

     /**
     * Add device status publisher.
     */
    void AddPublisherL( MAiDeviceStatusPublisher* aPublisher );

private: // data

	/**
	 * Device Status Plug-in Engine.
	 * Own.
	 */
	 CAiDeviceStatusPluginEngine* iEngine;

    /**
     * Content observers.
     * Own.
     */
    CAiMultiContentObserver* iContentObservers;

	/**
	 * Device Status Plug-in content prioritizer.
	 * Own.
	 */
	 CAiPublishPrioritizer* iPrioritizer;

    /**
     * Content item array iterator.
     * Own.
     */
    MAiContentItemIterator* iContent;

    /**
     * Content item array iterator for resources.
     * Own.
     */
    MAiContentItemIterator* iResources;

    /**
     * Publisher info.
     */
    TAiPublisherInfo iInfo;

    /**
     * Offset of the loaded resource file.
     */
    TInt iResourceOffset;
    
    /**
     * Network info listener.
     * Own.
     */
    CAiNetworkInfoListener* iListener;    
    };


#endif // C_AIDEVICESTATUSPLUGIN_H
hs_app_aidevicestatuspluginengine.h
/*
* Copyright (c) 2006-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Engine class for Device Status Plug-in
*
*/


#ifndef AIDEVICESTATUSPLUGINENGINE_H
#define AIDEVICESTATUSPLUGINENGINE_H

#include 
#include 

#include "hs_app_aipublisherbroadcaster.h"
#include "hs_app_aidevicestatuspublisher.h"

//device status plugin UI
const TInt KImplUidDevStaPlugin = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DEVSTAPLUGIN;

class MAiContentObserver;
class MAiPropertyExtension;
class MAiPublishPrioritizer;


/**
 *  @ingroup group_devicestatusplugin
 *
 *  Engine class for Device Status Plug-in
 *
 *  This class works as an engine for Device Status Plug-in.
 *  It owns the publishers and communicates between them and
 *	the subscribers.
 *
 *  @since S60 v3.2
 */
class CAiDeviceStatusPluginEngine : public CBase, public MAiPublisherBroadcaster
    {

public:

    static CAiDeviceStatusPluginEngine* NewL( MAiContentObserver& aObserver, 
                                                MAiPropertyExtension& aExtension,
                                                MAiPublishPrioritizer& aPrioritizer);

    virtual ~CAiDeviceStatusPluginEngine();

    /**
     * Resumes all publishers.
     */
    void ResumePublishersL();
    
    /**
     * Refreshes all publishers.
     * @param aClean Indicates if publishers should clean their content before
     *                  re-publish.
     */    
    void RefreshPublishersL( TBool aClean );

    /**
     * Refreshes specific publishers.
     * @param aContentId Indicates which publishers should publish their 
     *                  content.
     * @param aClean Indicates if publishers should clean their content before
     *                  re-publish.
     * @return ETrue if publisher informed that publish was successful.
     */    
    TBool RefreshPublishersL( TInt aContentId, TBool aClean );


public: // from MAiPublisherBroadcaster
    
    TBool RefreshPriorizedPublishersL( TInt aContentId, TInt aPriority );


private:

    CAiDeviceStatusPluginEngine( MAiContentObserver& aObserver, 
								    MAiPropertyExtension& aExtension,
                                    MAiPublishPrioritizer& aPrioritizer);

    void ConstructL();

     /**
      * Add Device Status publisher.
      */
    void AddPublisherL( MAiDeviceStatusPublisher* aPublisher );


private: // data

    /**
     * Array of publishers.
     * Own.
     */
    RPointerArray iPublishers;

    /**
     * Content observer.
     * Not own.
     */
    MAiContentObserver* iContentObserver;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;

	/**
	 * Content prioritizer.
	 * Not own.
	 */
	MAiPublishPrioritizer* iPrioritizer;
    };

#endif // AIDEVICESTATUSPLUGINENGINE_H
hs_app_aidevicestatuspublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Interface for device status publisher.
*
*/


#ifndef M_AIDEVICESTATUSPUBLISHER_H
#define M_AIDEVICESTATUSPUBLISHER_H

#include 
#include "aicontentobserver.h"

class MAiPublishPrioritizer;
class MAiPublisherBroadcaster;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Interface for device status publisher.
 *
 *  @since S60 3.2
 */
class MAiDeviceStatusPublisher
    {

public:
    /**
     * Virtual destructor.
     *
     * Publisher can be destroyed through this interface.
     */
    virtual ~MAiDeviceStatusPublisher() {};

    /**
     * Subscribe content observer.
     *
     * @param aObserver is reference to content observer.
     * @param aExtension is reference to property extension.
     * @param aPrioritizer is reference to publish prioritizer.
     * @param aBroadcaster is reference for publisher broadcaster.
     */
    virtual void Subscribe( MAiContentObserver& aObserver, 
                            MAiPropertyExtension& aExtension,
                            MAiPublishPrioritizer& aPrioritizer,
                            MAiPublisherBroadcaster& aBroadcaster ) = 0;

    /**
     * Resume publisher.
     *
     * Publisher publishes content if it is available.
     */
    virtual void ResumeL() = 0;

    /**
     * Refresh publisher.
     *
     * This has the same effect as the publisher would get content update from system.
     * Publisher publishes content if it is available.
     * @param aClean ETrue if current content needs to be cleaned.
     */
    virtual void RefreshL( TBool aClean ) = 0;
    
    /**
     * Refresh specific content.
     *
     * This has the same effect as the publisher would get content update from system.
     * Publisher publishes content if it is available.
     * @param aContentId Id of the content item that is requested to republish.
     * @param aClean ETrue if current content needs to be cleaned.
     * @return true if content was republished.
     */
    virtual TBool RefreshL( TInt /*aContentId*/, TBool /*aClean*/ ) { return EFalse; }

    /**
     * Refresh specific content with specific priority.
     *
     * This has the same effect as the publisher would get content update from system.
     * Publisher publishes content if it is available and has correct priority.
     * @param aContentId Id of the content item that is requested to republish.
     * @param aPriority Priority of the content that needs to be refreshed.
     * @return true if content was republished.
     */
    virtual TBool RefreshContentWithPriorityL( TInt /*aContentId*/, TInt /*aPriority*/ ) { return EFalse; }
    };


#endif // M_AIDEVICESTATUSPUBLISHER_H
hs_app_aimcnpublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Micro Cellular Network (MCN) publisher.
*
*/


#ifndef C_AIMCNPUBLISHER_H
#define C_AIMCNPUBLISHER_H


#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_aidevicestatuscontentmodel.h"
#include "hs_app_ainetworkinfoobserver.h"

class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;
class CAiNetworkInfoListener;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Micro Cellular Network (MCN) publisher.
 *
 *  This publisher listens network info changes and publishes
 *  received MCN messages.
 *
 *  @since S60 3.2
 */
class CAiMCNPublisher : public CBase, public MAiDeviceStatusPublisher,
                                public MAiNetworkInfoObserver
    {
public:

    static CAiMCNPublisher* NewL();

    virtual ~CAiMCNPublisher();

protected:

// from base class MAiDeviceStatusPublisher

    void ResumeL();
    void Subscribe( MAiContentObserver& aObserver, 
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );
    void RefreshL( TBool aClean );
    TBool RefreshL( TInt aContentId, TBool aClean );


//from base class MAiNetworkInfoObserver

    void HandleNetworkInfoChange( const MNWMessageObserver::TNWMessages& aMessage, 
    							  const TNWInfo& aInfo, 
    							  const TBool aShowOpInd );


private:

    CAiMCNPublisher();

    void ConstructL();

private: // data


    /**
     * Content observer.
     * Not own.
     */
    MAiContentObserver* iContentObserver;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;

    /**
     * Network info listener.
     * Own.
     */
    CAiNetworkInfoListener* iListener;
    };


#endif // C_AIMCNPUBLISHER_H
hs_app_aimulticontentobserver.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Active Idle Content Observer interface multiplexer interface.
*
*/


#ifndef C_AIMULTICONTENTOBSERVER_H
#define C_AIMULTICONTENTOBSERVER_H


#include 
#include "aicontentobserver.h"


// Forward declarations
class CAiContentObserverOptimizer;
/**
 *  @ingroup group_devicestatusplugin
 *
 * Active Idle Content Observer interface multiplexer.
 *
 * @see MAiContentObserver
 * @since S60 3.2
 */
class CAiMultiContentObserver : 
        public CBase,
        public MAiContentObserver
    {
public:
    static CAiMultiContentObserver* NewL();
    ~CAiMultiContentObserver();
    
    /**
     * Adds a new observer to this multiplexer.
     */
    void AddObserverL(MAiContentObserver& aObserver);

//from base class MAiContentObserver
    TInt StartTransaction( TInt aTxId );
    TInt Commit( TInt aTxId );
    TInt CancelTransaction( TInt aTxId );
    TBool CanPublish( MAiPropertyExtension& aPlugin, TInt aContent, TInt aIndex );
    TInt Publish( MAiPropertyExtension& aPlugin, TInt aContent,
                  TInt aResource, TInt aIndex );
    TInt Publish( MAiPropertyExtension& aPlugin, TInt aContent,
                  const TDesC16& aText, TInt aIndex );
    TInt Publish( MAiPropertyExtension& aPlugin, TInt aContent,
                  const TDesC8& aBuf, TInt aIndex );
    TInt Publish( MAiPropertyExtension& aPlugin, TInt aContent,
                  RFile& aFile, TInt aIndex );
    TInt Clean( MAiPropertyExtension& aPlugin, TInt aContent, TInt aIndex );
    TAny* Extension( TUid aUid );
    TBool RequiresSubscription( const TAiPublisherInfo& aPublisherInfo ) const;

    TInt SetProperty( MAiPropertyExtension& aPlugin,
               const TDesC8& aElementId,
               const TDesC8& aPropertyName,
               const TDesC8& aPropertyValue );
       
    TInt SetProperty( MAiPropertyExtension& aPlugin,
               const TDesC8& aElementId,
               const TDesC8& aPropertyName,
               const TDesC8& aPropertyValue,  
               MAiContentObserver::TValueType aValueType);

private:
    CAiMultiContentObserver();
    void ConstructL();

private: // data
    /**
     * Array of observers.
     * Own.
     */
    RPointerArray iObserverOptimizers;

    };


#endif // C_AIMULTICONTENTOBSERVER_H
hs_app_ainetworkinfolistener.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network info listener.
*
*/


#ifndef C_AINETWORKINFOLISTENER_H
#define C_AINETWORKINFOLISTENER_H


#include 
#include 


class MAiNetworkInfoObserver;
class CNWSession;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Network info listener.
 *
 *  Client can use this object to listen network info changes. Client must implement
 *  MAiNetworkInfoObserver interface to retrieve network info change events.
 *
 *  @since S60 3.2
 */
class CAiNetworkInfoListener : public CBase, public MNWMessageObserver
    {
public:

    /**
     * Get pointer to network info listener.
     * When this is called first time, object is created, later calls
     * gets pointer to previously created object.
     *
     * @since S60 3.2
     * @return pointer to network info listener.
     */
    static CAiNetworkInfoListener* InstanceL();

    /**
     * Release network info listener.
     * This must be called when client doesn't listen network info
     * changes anymore. When all of the listener instances are released,
     * the object is destroyed. After client calls this method, the pointer
     * returned by InstanceL must not be used anymore.
     *
     * @since S60 3.2
     * @param ?arg1
     * @param ?arg2
     * @return
     */
    void Release();

    /**
     * Add network info observer.
     *
     * @since S60 3.2
     * @param aObserver is interface which is used to inform network info changes.
     */
    void AddObserverL( MAiNetworkInfoObserver& aObserver );

    /**
     * Remove network info observer.
     *
     * @since S60 3.2
     * @param aObserver must be exactly same object as was given to AddObserverL call.
     */
    void RemoveObserver( MAiNetworkInfoObserver& aObserver );

    /**
     * Get cached network info structure.
     * When network info changes, it is stored in this listener, client can use this
     * method to receive the latest network info.
     *
     * @since S60 3.2
     * @return latest network info structure.
     */
    const TNWInfo& NetworkInfo() const;

    /**
     * Is the operator indicator allowed to be shown.
     * 
     * @since S60 v3.2
     * @return ETrue if the indicator can be shown.
     */
    TBool IsOperatorIndicatorAllowed() const;
    
    /**
     * Client can use this method to check if certain network message has been already
     * received.
     *
     * @since S60 3.2
     * @param aMessage is type of the message.
     * @return ETrue if the message has been received.
     */
    TBool MessageReceived( MNWMessageObserver::TNWMessages aMessage );

    /**
     * Check if it's allowed to show operator indicator.
     * Number of rules control operator indicator visibility. 
     * Parameter aMessage is used for fulfilling these rules - it can have
     * various values so this method is called many times. The sum of the
     * calls (and thus sum of different aMessage values) defines whether
     * rules are fulfilled and indicator is shown.
     * @param aMessage Network message 
     * @return ETrue if rules are not fulfilled and indicator should 
     *                  not be shown.
     */
	TBool NotAllowedToDisplayOperatorIndicator( const TNWMessages aMessage );
	
	/**
	 * Check if network info has been changed.
	 * @param aMessage Network message
	 * @return ETrue if network info has changed since last check.
	 */
	TBool HasNetworkInfoChanged( const TNWMessages aMessage );
	

// from base class MNWMessageObserver

    /**
     * From MNWMessageObserver.
     * Called by network handling engine when network info changes.
     *
     * @since S60 3.2
     * @param aMessage is type of the change.
     */
    void HandleNetworkMessage( const TNWMessages aMessage );

    /**
     * From MNWMessageObserver.
     * Called fi network handling engine fails.
     *
     * @since S60 3.2
     * @param aOperation is failed operation.
     * @param aErrorCode is fail reason.
     */
    void HandleNetworkError( const TNWOperation aOperation, TInt aErrorCode );

private:

    CAiNetworkInfoListener();

    void ConstructL();

    ~CAiNetworkInfoListener();

    /**
     * Increase access count.
     */
    TInt IncAccessCount();

    /**
     * Decrease access count, when this goes to zero, object is deleted.
     */
    TInt DecAccessCount();

private: // data

    /**
     * Array of observers.
     * Not own.
     */
    RArray iObservers;

    /**
     * Session to network handling engine.
     * Own.
     */
    CNWSession* iSession;

    /**
     * Cached network info structure.
     */
    TNWInfo iInfo;
	
	/**
	 * Previous network information.
	 */
    TNWInfo iOldInfo;
    
    /**
     * Message cache. There is only one instance of one type of message.
     * Own.
     */
    CArrayFixFlat* iMessageCache;

    /**
     * Sorting rule.
     */
    TKeyArrayFix iKeyProperties;

    /**
     * Access count.
     */
    TInt iAccessCount;
    
    /**
     * Network related message flags
     */
    enum TNetInfoFlags 
    	{
        ENetworkProviderNameReceived      = 0x00000001,
        ENetworkProviderNameOk            = 0x00000002,
        EServiceProviderNameReceived      = 0x00000004,
        EServiceProviderNameOk            = 0x00000008,
        ERegistrationStatusReceived       = 0x00000010,
        ENetworkInfoChangeReceived        = 0x00000020,
        EProgrammableOperatorInfoReceived = 0x00000040,
        EProgrammableOperatorInfoReceivedOk = 0x00000080
        };
        
	/**
     * Subset of sum of TNetInfoFlags.
     */    
    TUint iReceivedMessageFlags;
    
    /**
     * Subset of sum of old TNetInfoFlags.
     */    
    TUint iOldReceivedMessageFlags;
    
    /**
     * Is the operator indicator allowed to show
     */
    TBool iShowOpInd;
    };
    


#endif // C_AINETWORKINFOLISTENER_H
hs_app_ainetworkinfoobserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network info observer.
*
*/


#ifndef M_AINETWORKINFOOBSERVER_H
#define M_AINETWORKINFOOBSERVER_H

#include 
#include 

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Network info observer.
 *
 *  Client gets network info changes through this interface.
 *
 *  @since S60 3.2
 */
class MAiNetworkInfoObserver
    {

protected:

    /**
     * Virtual destructor.
     * Cannot be used to destruct the object.
     */
    virtual ~MAiNetworkInfoObserver() {};

public:

    /**
     * Called when network info changes.
     *
     * @since S60 3.2
     * @param aMessage is type of the change.
     * @param aInfo is new network info structure.
     */
    virtual void HandleNetworkInfoChange( const MNWMessageObserver::TNWMessages& aMessage, 
    							  		  const TNWInfo& aInfo, 
    							  		  const TBool aShowOpInd ) = 0;
    };


#endif // M_AINETWORKINFOOBSERVER_H
hs_app_ainwidpriorities.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network identity related priorities.
*
*/



#ifndef AINWIDPRIORITIES_H
#define AINWIDPRIORITIES_H

#include 


const TInt KHighestPriority = 20;

enum TAiNWIdPrioritities
    {
    EAiInvalidPriority      = -1,
    EAiOperatorNetInfoName  = 0,
    EAiMCC_MCN,
    EAiCountryMNC,
    EAiLatinOperatorName,
    EAiUnicodeOperatorName,
    EAiNITZ,
    EAiNetworkOperatorName,
    EAiServiceProviderName,
    EAiFlexiblePLMN,
    EAiProgOperatorLogo,
    EAiOTAOperatorLogo,
    EAiOfflineProfile,
    EAiBTSAP
    };


#endif // AINWIDPRIORITIES_H
hs_app_ainwspublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network status publisher
*
*/


#ifndef C_AINWSPUBLISHER_H
#define C_AINWSPUBLISHER_H


#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_aidevicestatuscontentmodel.h"
#include "hs_app_ainetworkinfoobserver.h"


class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;
class CAiNetworkInfoListener;
class CRepository;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Listens Network status and publishes data if network selection dialog is needed.
 *
 *  @since S60 3.2
 */
class CAiNwsPublisher : public CBase, public MAiDeviceStatusPublisher,
                                public MAiNetworkInfoObserver
    {
public:

    static CAiNwsPublisher* NewL();

    virtual ~CAiNwsPublisher();

// from base class MAiDeviceStatusPublisher

    void ResumeL();

    void Subscribe( MAiContentObserver& aObserver,
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );

    void RefreshL( TBool aClean );

    TBool RefreshL( TInt aContentId, TBool aClean );

protected:

//from base class MAiNetworkInfoObserver

    void HandleNetworkInfoChange( const MNWMessageObserver::TNWMessages& aMessage,
    							  const TNWInfo& aInfo,
    							  const TBool aShowOpInd );

private:


    CAiNwsPublisher();

    void ConstructL();

    void HandleStateChange( const TNWInfo& aInfo );

    void HandleNetworkFound();

    void HandleNetworkLost( const TNWNetworkSelectionSetting &aSelectionSetting  );


    /**
     * Tests if offline mode is engaged.
     *
     * @return ETrue if offline mode is currently active
     */
    TBool IsOffLineMode() const;

    /**
     * Tests if Bluetooth SAP is in connected mode.
     *
     * @return ETrue if Bluetooth SAP is active.
     */
    TBool IsBluetoothSAPConnected() const;

private: // data

    /**
     * Content observer.
     * Not own.
     */
    MAiContentObserver* iContentObserver;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;

    /**
     * Network info listener.
     * Own.
     */
    CAiNetworkInfoListener* iListener;

    /**
     * Profile API.
     */
    CRepository* iProfileApi;


    /**
     * A true value if registered to network.
     */
    TBool iRegistered;

    };


#endif // C_AINWSPUBLISHER_H
hs_app_aioperatorlogopublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Operator logo publisher.
*
*/


#ifndef C_AIOPERATORLOGOPUBLISHER_H
#define C_AIOPERATORLOGOPUBLISHER_H


#include 
#include 
#include 
#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_ainetworkinfoobserver.h"

class CAiNetworkInfoListener;
class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;
class CGulIcon;
class CCenRepNotifyHandler;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Operator logo publisher.
 *
 *  Listens operator logo changes (OTA and programmable) and publishes
 *  the new logo when it is updated.
 *
 *  @since S60 3.2
 */
class CAiOperatorLogoPublisher : public CBase, public MAiDeviceStatusPublisher,
                               public MAiNetworkInfoObserver, /*public MAiCenRepNotifierCallBack*/
                               public MCenRepNotifyHandlerCallback
    {
public:

    static CAiOperatorLogoPublisher* NewL();

    virtual ~CAiOperatorLogoPublisher();

protected:

//from base class MAiDeviceStatusPublisher

    void ResumeL();
    void Subscribe( MAiContentObserver& aObserver, 
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );
    void RefreshL( TBool aClean );
    TBool RefreshL( TInt aContentId, TBool aClean );
    TBool RefreshContentWithPriorityL( TInt aContentId, TInt aPriority );


//from base class MAiNetworkInfoObserver

    /**
     * From MAiNetworkInfoObserver.
     * Called when network info changes.
     */
    void HandleNetworkInfoChange( const MNWMessageObserver::TNWMessages& aMessage, 
    							  const TNWInfo& aInfo, 
    							  const TBool aShowOpInd );


// from base class MCenRepNotifyHandlerCallback

    /** 
     * This callback method is used to notify the client about
     * changes for integer value keys, i.e. key type is EIntKey.
     *
     * @param aId Id of the key that has changed.
     * @param aNewValue The new value of the key.
     */
    void HandleNotifyInt( TUint32 aId, TInt aNewValue );




private:

    CAiOperatorLogoPublisher();

    void ConstructL();

    /**
     * Called when central repository key changes.
     *
     * @since S60 3.2
     * @param aMCC is country code.
     * @param aMNC is network code.
     * @return pointer to loaded logo. Ownership is transferred to caller.
     */
    CFbsBitmap* LoadLogoL( TInt aMCC,
                           TInt aMNC );

    /**
     * Update operator logo.
     * @param aClean ETrue if currently published logo must be cleaned.
     */
    void UpdateOperatorLogoL( TBool aClean );

    /**
     * Returns ETrue if operator logo is allowed to be displayed.
     */
    TBool AllowToShowLogoL() const;
    
    /** 
     * Create monochrome bitmaps (main & mask).
     * 
     * @since S60 3.2
     * @param aBitmap monochrome bitmap.
     * @param aNewLogoMain bitmap, ownership passed to caller.
     * @param aNewLogoMask bitmap mask, ownership passed to caller.
     */
    void CreateMonochromeBitmapsL( 
    	const CFbsBitmap& aBitmap, 
    	CFbsBitmap*& aNewLogoMain,
    	CFbsBitmap*& aNewLogoMask );

    /**
     * Getter method for title pane size.
     * @param aSize Initialized with title pane size in return.
     * @return KErrNotFound if title pane is not found, KErrNone otherwise.
     */
	TInt GetTitlePaneSize( TSize& aSize );
	
	/**
	 * Callback method for changes in operator logo.
	 * Called if operator logo has been changed.
	 */
	static TInt HandleOperatorLogoUpdateL( TAny *aPtr );


private: // data

    /**
     * Network info listener.
     * Own.
     */
    CAiNetworkInfoListener* iListener;

    /**
     * Operator logo bitmap and mask.
     * Own.
     */
    CGulIcon* iIcon;

    /**
     * Content observer.
     * Not own.
     */
    MAiContentObserver* iContentObserver;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;

	/**
	 * Content prioritizer.
	 * Not own.
	 */
	MAiPublishPrioritizer* iPrioritizer;
    
	/**
	 * Publish broadcaster.
	 * Not own.
	 */
	MAiPublisherBroadcaster* iBroadcaster;
    
    /**
     * Publish-subscribe client.
     */
    MAiPSPropertyObserver* iOperatorLogoObserver;

    /**
     * Central repository client.
     * Own.
     */
    CRepository* iCenRep;

    /**
     * Central repository notifier.
     * Own.
     */
    CCenRepNotifyHandler* iCenRepNotify;

    /**
     * Operator logo priority, can have one of the following values:
     * 1) EAiOTAOperatorLogo
     * 2) EAiProgOperatorLogo
     * 3) EAiInvalidPriority
     */
    TInt iPriority;

    /**
     * True if publish was successful.
     */
    TBool iSuccess;
    
    /**
     * Show operator indicator.
     */
    TBool iShowOpInd;
    };


#endif // C_AIOPERATORLOGOPUBLISHER_H
hs_app_aioperatornamepublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Operator/Service provider name publisher.
*
*/


#ifndef C_AIOPERATORPROVIDERNAMEPUBLISHER_H
#define C_AIOPERATORPROVIDERNAMEPUBLISHER_H


#include 
#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_ainetworkinfoobserver.h"

class CAiNetworkInfoListener;
class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Operator/Service provider name publisher.
 *
 *  Listens network info changes and publishes operator name
 *  if it is received.
 *
 *  @since S60 3.2
 */
class CAiOperatorNamePublisher : public CBase, public MAiDeviceStatusPublisher,
                               public MAiNetworkInfoObserver
    {
public:

    static CAiOperatorNamePublisher* NewL();

    virtual ~CAiOperatorNamePublisher();

//from base class MAiDeviceStatusPublisher

    void ResumeL();
    void Subscribe( MAiContentObserver& aObserver, 
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );
    void RefreshL( TBool aClean );
    TBool RefreshL( TInt aContentId, TBool aClean );
    TBool RefreshContentWithPriorityL( TInt aContentId, TInt aPriority );


protected:

//from base class MAiNetworkInfoObserver

    /**
     * From MAiNetworkInfoObserver.
     * Called when network info changes.
     */
    void HandleNetworkInfoChange( const MNWMessageObserver::TNWMessages& aMessage, 
    							  const TNWInfo& aInfo, 
    							  const TBool aShowOpInd );


private:

    CAiOperatorNamePublisher();

    void ConstructL();

    /**
     * Check SPN status from PLMNField. Also check if current country and network
     * codes are in PLMNField.
     */
    void CAiOperatorNamePublisher::CheckServiceProviderDisplayListStatus(
        TInt aMCC,
        TInt aMNC,
        TBool& aShowSPN,
        TBool& aIsInSPDI ) const;

    /**
     * Check if current network is ready. Returns ETrue if all needed messages are
     * received from network info listener.
     */
    TBool CurrentNetworkOk() const;

    /**
     * Returns ETrue if phone is currently roaming.
     */
    TBool IsRoaming() const;

    /**
     * If operator indicator needs to be animated, start delayed clean operation.
     * Operator indicator will be replaced by plmn indicator after clean operation.
     */
    void StartDelayedPLMNOperation();

    /**
     * Called by CPeriodic when timer expires.
     */
    static TInt CleanAndShowPLMNOperationCallback( TAny* aPtr );

    /**
     * Do delayed clean operation.
     */
    void DoCleanOperationL();
    
    /**
     * Show network indicator
     * @param aTryToPublish 
     * ETrue: Sets operator name, priority and tries to publish operator name. 
     * EFalse: Sets operator name, priority and not to try to publish it.
     */
    void ShowNetworkIdentityNameL( TBool aTryToPublish );
    
    /**
     * Check priority of operator name
     */	
    TBool OperatorNamePriority( TInt& aPriority );
    
    /**
     * Construct PLMN and SPN indicators to same string
     */
    HBufC* ConstructOperatorNameStringL( const TDesC& aServiceProviderName );
    
    /**
     * Check status of keylock
     */
    TBool IsKeyLockEnabled();

private: // data

    /**
     * Network info listener.
     * Own.
     */
    CAiNetworkInfoListener* iListener;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;

	/**
	 * Content prioritizer.
	 * Not own.
	 */
	MAiPublishPrioritizer* iPrioritizer;
    
	/**
	 * Publish broadcaster.
	 * Not own.
	 */
	MAiPublisherBroadcaster* iBroadcaster;
    
    /**
     * Used to do delayed clean operation.
     * Own.
     */
    CPeriodic* iPeriodic;
    
    /**
     * True if publish was successful.
     */
    TBool iSuccess;
    
    /**
     * Operator name priority
     */
    TInt iPriority;
    
    /**
     * Show operator indicator.
     */
    TBool iShowOpInd;
    
    /**
     * Network identity name
     */
    TPtrC iNetworkIdentityName;
    };


#endif // C_AIOPERATORPROVIDERNAMEPUBLISHER_H
hs_app_aiprioritizer.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network identity related prioritizer.
*
*/



#ifndef M_AIPUBLISHPRIORITIZER_H
#define M_AIPUBLISHPRIORITIZER_H

#include "aicontentobserver.h"

class MAiPublisherBroadcaster;


/**
 *  @ingroup group_devicestatusplugin
 *
 *  Network identity related prioritizer.
 *
 *  This class is used as proxy between publishers which publish data that
 *  needs to be priorised and content observers. It keeps record of published
 *  data and decides if new published data has high enough priority to go 
 *  through to content observer.
 *
 *  @since S60 3.2
 */
class MAiPublishPrioritizer
    {

public:

    /**
     * Invoked by publisher that publishes prioritized data.
     * Data is published only if aPriority is same or higher than
     * current priority.
     *
     * @param  aBroadcaster - Publisher broadcaster implementation.
     * @param  aContent - identification of content selector, MUST correspond
     *         single content selector supported by plug-in. The framework
     *         utilizes the selector id to match for cid and MIME type.
     * @param  aResource - identification of content reference, MUST correspond
     *         single content reference supported by plug-in. The framework
     *         utilizes the reference if to match for cid and MIME type of the
     *         content supplied with in UI definition.
     * @param  aPriority - priority of published data.
     */
    virtual void TryToPublishL( MAiPublisherBroadcaster& aBroadcaster, 
                                TInt aContent, 
                                TInt aResource, 
                                TInt aPriority ) = 0;

    /**
     * Invoked by publisher that publishes prioritized data.
     * Data is published only if aPriority is same or higher than
     * current priority.
     *
     * @param  aBroadcaster - Publisher broadcaster implementation.
     * @param  aContent - identification of content selector, MUST correspond
     *         single content selector supported by plug-in. The framework
     *         utilizes the selector id to match for cid and MIME type.
     * @param  aText - Textual content in UNICODE.
     * @param  aPriority - priority of published data.
     */
    virtual void TryToPublishL( MAiPublisherBroadcaster& aBroadcaster, 
                                TInt aContent, 
                                const TDesC16& aText, 
                                TInt aPriority ) = 0;

    /**
     * Invoked by publisher that publishes prioritized data.
     * Data is published only if aPriority is same or higher than
     * current priority.
     *
     * @param  aBroadcaster - Publisher broadcaster implementation.
     * @param  aContent - identification of content selector, MUST correspond
     *         single content selector supported by plug-in. The framework
     *         utilizes the selector id to match for cid and MIME type.
     * @param  aBuf - instance of content.
     * @param  aPriority - priority of published data.
     */ 
    virtual void TryToPublishL( MAiPublisherBroadcaster& aBroadcaster, 
                                TInt aContent, 
                                const TDesC8& aBuf, 
                                TInt aPriority ) = 0;
                                
    /**
     * Invoked by publisher that wants to clean previously published data.
     * Data is cleaned only if aPriority is same than current priority.
     *
     * @param  aBroadcaster - Publisher broadcaster implementation.
     * @param  aContent - identification of content selector, MUST correspond
     *         single content selector supported by plug-in. The framework
     *         utilizes the selector id to match for cid and MIME type.
     * @param  aPriority - priority of published data.
     */
    virtual void TryToCleanL( MAiPublisherBroadcaster& aBroadcaster, 
                                TInt aContent, 
                                TInt aPriority ) = 0;

    };


#endif // M_AIPUBLISHPRIORITIZER_H
hs_app_aiprofilepublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Profile publisher
*
*/


#ifndef C_AIPROFILEPUBLISHER_H
#define C_AIPROFILEPUBLISHER_H

#include 
#include 
#include 
#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_aidevicestatuscontentmodel.h"

class MProfileEngine;
class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;
class CProfileChangeNotifyHandler;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Observers profile changes and publishes profile name when profile
 *  has been changed or if ALS status changes.
 *
 *  @since S60 3.2
 */
class CAiProfilePublisher : public CBase, public MAiDeviceStatusPublisher,
                            public MSSSettingsObserver, public MProfileChangeObserver
    {
public:

    static CAiProfilePublisher* NewL();

    virtual ~CAiProfilePublisher();

protected:

// from base class MAiDeviceStatusPublisher

    void ResumeL();
    void Subscribe( MAiContentObserver& aObserver, 
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );
    void RefreshL( TBool aClean );
    TBool RefreshL( TInt aContentId, TBool aClean );
    TBool RefreshContentWithPriorityL( TInt aContentId, TInt aPriority );
    
    
protected:

// from base class MSSSettingsObserver

    /**
     * Called when SS Settings changes.
     */
    void PhoneSettingChanged( TSSSettingsSetting aSetting, TInt aNewValue );

// from base class MProfileChangeObserver

    /**
     * Called when active profile changes.
     */
    void HandleActiveProfileEventL( TProfileEvent aProfileEvent, TInt aProfileId );

private:

    CAiProfilePublisher();

    void ConstructL();

    /**
     * Clean last published profile.
     */
    void CleanLastProfileL();

    /**
     * Get active profile from profile engine and publish it.
     */
    void RefreshProfileL(TBool aClean);


protected: // data

    /**
     * Client to listen SS setting changes.
     */
    RSSSettings iSSSettings;

    /**
     * Profile engine.
     * Own.
     */
    MProfileEngine* iProfileEngine;

    /**
     * Profile change notifier.
     * Own.
     */
    CProfileChangeNotifyHandler* iProfileNotifier;

    /**
     * Content observer.
     * Not own.
     */
    MAiContentObserver* iContentObserver;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;

	/**
	 * Content prioritizer.
	 * Not own.
	 */
	MAiPublishPrioritizer* iPrioritizer;
	
	/**
	 * Publish broadcaster.
	 * Not own.
	 */
	MAiPublisherBroadcaster* iBroadcaster;
    
    enum TLastPublishedProfile
        {
        ENothingPublished = -1,        
        EGeneralProfilePublished = 0,
        EOfflineProfilePublished = 5,
        EOtherProfilePublished = 10
        };
    
    /**
     * Last published profile.
     */
    TLastPublishedProfile iLastPublishedProfileId;
    
    /**
     * True if last published profile was silent.
     */
    TBool iLastPublishedProfileSilent;
    
    /**
     * True if last published profile was timed.
     */    
    TBool iLastPublishedProfileTimed;

    /**
     * True if publish was successful.
     */
    TBool iSuccess;
    
    /**
     * True if active profile is changed or modified.
     */
    TBool iActiveProfilePublish;
    };


#endif // C_AIPROFILEPUBLISHER_H
hs_app_aipublisherbroadcaster.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Owner of publishers.
*
*/



#ifndef M_AIPUBLISHERBROADCASTER_H
#define M_AIPUBLISHERBROADCASTER_H

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Broadcaster for Device Status Plug-in.
 *
 *  This class should be implemented by an instance that owns Device Status 
 *  Plug-in publishers. The purpose of this class is to offer a method for 
 *  single publisher to broadcast events to all other publishers.
 *
 *  @since S60 3.2
 */
class MAiPublisherBroadcaster
    {

public:

    /**
     *  Invoke a refresh call for publishers that publish specific content 
     *  with specific priority.
     *
     *  This has the same effect as the publisher would get content update from system.
     *  Publisher publishes content if it is available and has correct priority.
     *  @param aContentId Id of the content item that is requested to republish.
     *  @param aPriority Priority of the content that needs to be refreshed.
     *  @return true if content was republished.
     */
    virtual TBool RefreshPriorizedPublishersL( TInt aContentId, TInt aPriority ) = 0;
    };


#endif // M_AIPUBLISHERBROADCASTER_H
hs_app_aipublisherfactory.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Static factory class used to create publishers.
*
*/


#ifndef AIPUBLISHERFACTORY_H
#define AIPUBLISHERFACTORY_H

class MAiDeviceStatusPublisher;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Static factory class used to create publishers.
 *
 *  @since S60 3.2
 */
class AiPublisherFactory
    {

public:

    /**
     * Create profile publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateProfilePublisherL();

    /**
     * Create date profile publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateDatePublisherL();

    /**
     * Create operator logo publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateOperatorLogoPublisherL();

    /**
     * Create operator name publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateOperatorNamePublisherL();

    /**
     * Create BT SAP publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateBTSAPPublisherL();

    /**
     * Create MCN publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateMCNPublisherL();

    /**
     * Create CUG publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateCUGPublisherL();

    /**
     * Create SIM registration status publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateSimRegPublisherL();

    /**
     * Create Network status publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateNWSPublisherL();

    /**
     * Create VHZ publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateVHZPublisherL();
    
    /**
     * Create CUGMCN publisher.
     *
     * @since S60 3.2
     * @return pointer to publisher or NULL if publisher is not supported
     *         by platform.
     */
    static MAiDeviceStatusPublisher* CreateCUGMCNPublisherL();
    };


#endif // AIPUBLISHERFACTORY_H
hs_app_aipublishprioritizer.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network identity related prioritizer.
*
*/


#ifndef C_AIPUBLISHPRIORITIZER_H
#define C_AIPUBLISHPRIORITIZER_H

#include 
#include "hs_app_ainwidpriorities.h"
#include "hs_app_aiprioritizer.h"
#include "aipropertyextension.h"

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Network identity related prioritizer.
 *
 *  This class is used as proxy between publishers which publish data that
 *  needs to be priorised and content observers. It keeps record of published
 *  data and decides if new published data has high enough priority to go 
 *  through to content observer.
 *
 *  @since S60 3.2
 */
 
class CAiPublishPrioritizer : public CBase, public MAiPublishPrioritizer
    {

public:

    static CAiPublishPrioritizer* NewL( MAiContentObserver& aContentObserver,
                                        MAiPropertyExtension& aPropertyExtension );

    virtual ~CAiPublishPrioritizer();


    // from MAiPublishPrioritizer
    
    void TryToPublishL( MAiPublisherBroadcaster& aBroadcaster, 
                        TInt aContent, 
                        TInt aResource, 
                        TInt aPriority );

    void TryToPublishL( MAiPublisherBroadcaster& aBroadcaster, 
                        TInt aContent, 
                        const TDesC16& aText, 
                        TInt aPriority );

    void TryToPublishL( MAiPublisherBroadcaster& aBroadcaster, 
                        TInt aContent, 
                        const TDesC8& aBuf, 
                        TInt aPriority );
                                
    void TryToCleanL( MAiPublisherBroadcaster& aBroadcaster, 
                        TInt aContent, 
                        TInt aPriority );
                        
    TInt NextPriority() const;

    
private:

    CAiPublishPrioritizer( MAiContentObserver& aContentObserver,
                            MAiPropertyExtension& aPropertyExtension );


private: // data

    /**
     * Content observer.
     */
    MAiContentObserver& iContentObserver;
    
    /**
     * Property extension.
     */
    MAiPropertyExtension& iPropertyExtension;

    /// Current priority
    TInt iPriority;
    };


#endif // C_AIPUBLISHPRIORITIZER_H
hs_app_aisimregpublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  SIM registration status publisher
*
*/


#ifndef C_AISIMREGFAILPUBLISHER_H
#define C_AISIMREGFAILPUBLISHER_H


#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_aidevicestatuscontentmodel.h"
#include "hs_app_ainetworkinfoobserver.h"


class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;
class CAiNetworkInfoListener;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Listens SIM Registration status and publishes data if SIM registration failed.
 *
 *  @since S60 3.2
 */
class CAiSimRegPublisher : public CBase, public MAiDeviceStatusPublisher,
                                public MAiNetworkInfoObserver
    {
public:

    static CAiSimRegPublisher* NewL();

    virtual ~CAiSimRegPublisher();

// from base class MAiDeviceStatusPublisher

    void ResumeL();
    void Subscribe( MAiContentObserver& aObserver, 
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );
    void RefreshL( TBool aClean );
    TBool RefreshL( TInt aContentId, TBool aClean );

protected:

//from base class MAiNetworkInfoObserver

    void HandleNetworkInfoChange( const MNWMessageObserver::TNWMessages& aMessage, 
    							  const TNWInfo& aInfo, 
    							  const TBool aShowOpInd );


private:

    CAiSimRegPublisher();

    void ConstructL();


private: // data

    /**
     * Content observer.
     * Not own.
     */
    MAiContentObserver* iContentObserver;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;

    /**
     * Network info listener.
     * Own.
     */
    CAiNetworkInfoListener* iListener;
    };


#endif // C_AISIMREGFAILPUBLISHER_H
hs_app_aivhzpublisher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Viag Home Zone (VHZ) publisher.
*
*/


#ifndef C_AIVHZPUBLISHER_H
#define C_AIVHZPUBLISHER_H


#include 
#include "hs_app_aidevicestatuspublisher.h"
#include "hs_app_aidevicestatuscontentmodel.h"
#include "hs_app_ainetworkinfoobserver.h"

class MAiDeviceStatusContentObserver;
class MAiPropertyExtension;
class CAiNetworkInfoListener;

/**
 *  @ingroup group_devicestatusplugin
 *
 *  Viag Home Zone (VHZ) publisher.
 *
 *  Observes network info changes and publishes zone name
 *  when phone arrives to home or city zone.
 *
 *  @since S60 3.2
 */
class CAiVHZPublisher : public CBase, public MAiDeviceStatusPublisher,
                                public MAiNetworkInfoObserver
    {
public:

    static CAiVHZPublisher* NewL();

    virtual ~CAiVHZPublisher();

protected:

// from base class MAiDeviceStatusPublisher

    void ResumeL();
    void Subscribe( MAiContentObserver& aObserver, 
                    MAiPropertyExtension& aExtension,
                    MAiPublishPrioritizer& aPrioritizer,
                    MAiPublisherBroadcaster& aBroadcaster );
    void RefreshL( TBool aClean );
    TBool RefreshL( TInt aContentId, TBool aClean );

//from base class MAiNetworkInfoObserver

    void HandleNetworkInfoChange( const MNWMessageObserver::TNWMessages& aMessage, 
    							  const TNWInfo& aInfo, 
    							  const TBool aShowOpInd );


private:

    CAiVHZPublisher();

    void ConstructL();

private: // data

    /**
     * Content observer.
     * Not own.
     */
    MAiContentObserver* iContentObserver;

    /**
     * Property extension.
     * Not own.
     */
    MAiPropertyExtension* iExtension;

    /**
     * Network info listener.
     * Not own.
     */
    CAiNetworkInfoListener* iListener;
    
    /**
     * Flag to indiate whether vhz is in navi or mainpane.
     */    
     TBool iVhzInMainpane;

    };


#endif // C_AIVHZPUBLISHER_H
hs_app_aidevstaplgres.loc
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Localization strings for project Active Idle
*
*/



// d: The format string defines how date are shown on the navi pane of idle state. 
// d: %0U stands for the week day, and %1U stands for date. 
// l: navi_text_pane_t1
// w: 
// r: 3.2
//
#define qtn_idle_time_format "%0U %1U"


// d: Text in title pane in idle state
// d: Remote SIM Access Profile is active. SIM or network  is not accessible
// d: from the terminal. This doesn't relate to normal user profiles like General
// d: or Meeting.
// l: title_pane_t2/opt9
// w:
// r: 3.2
//
#define qtn_mode_sap "Remote SIM"


// d: The unit format of the cug soft indicator
// l: soft_indicator_pane_t1
// w:
// r: 3.2

#define qtn_cug_indic_group "Group %N"

// d: The format string defines how operator and service provider names
// d: are concatenated to one string, which is shown on the title pane 
// d: of idle state.
// d: %0U stands for operator name, %1U stands for service provider name. 
// l: title_pane_t2/opt9
// w:
// r: 3.2
//
#define qtn_ai_opn_spn_separator "%0U - %1U"
hs_app_aibtsappublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Listens Bluetooth SIM Access Profile (BT SAP) and publishes
*					text when BT SAP is activated.
*
*/


#include 
#include 
#include 
#include 
#include 
#include "hs_app_aibtsappublisher.h"
#include "hs_app_aiprioritizer.h"
#include "hs_app_ainwidpriorities.h"


// ======== MEMBER FUNCTIONS ========

CAiBTSAPPublisher::CAiBTSAPPublisher()
: CActive( CActive::EPriorityStandard )
    {
    CActiveScheduler::Add( this );
    }


void CAiBTSAPPublisher::ConstructL()
    {
	//if platform doesn't support BTSAP, there is no reason
	//to create this object.
    if( !FeatureManager::FeatureSupported( KFeatureIdBtSap ) )
        {
        User::Leave( KErrNotSupported );
        }
    }


CAiBTSAPPublisher* CAiBTSAPPublisher::NewL()
    {
    CAiBTSAPPublisher* self = new( ELeave ) CAiBTSAPPublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiBTSAPPublisher::~CAiBTSAPPublisher()
    {
    Cancel();
    iPubSub.Close();
    }


void CAiBTSAPPublisher::ResumeL()
    {
    Cancel();

    iPubSub.Close();
	//attach to BTSAP key.
    User::LeaveIfError( iPubSub.Attach( KPSUidBluetoothSapConnectionState,
    									KBTSapConnectionState ) );

    iFirstPublish = ETrue;

    //subscribe to get notification when key changes.
    iPubSub.Subscribe( iStatus );
    SetActive();
    }


void CAiBTSAPPublisher::Subscribe( MAiContentObserver& /*aObserver*/,
								    MAiPropertyExtension& aExtension,
                                    MAiPublishPrioritizer& aPrioritizer,
                                    MAiPublisherBroadcaster& aBroadcaster )
    {
    iExtension = &aExtension;
    iPrioritizer = &aPrioritizer;
    iBroadcaster = &aBroadcaster;
    }


void CAiBTSAPPublisher::RefreshL( TBool aClean )
    {
    iSuccess = EFalse;
    if( aClean )
        {
        iPrioritizer->TryToCleanL( *iBroadcaster,
        							EAiDeviceStatusContentNetworkIdentity,
        							EAiBTSAP );
        }

    //Get BTSAP state
    TInt sapState( 0 );
    TInt err = RProperty::Get( KPSUidBluetoothSapConnectionState,
                               KBTSapConnectionState,
                               sapState );

    //If key is not found, it is treated same way as the BTSAP is not on.
    if( err == KErrNotFound )
        {
        err = KErrNone;
        sapState = EBTSapNotConnected;
        }

    User::LeaveIfError( err );

    if( sapState == EBTSapConnected )
        {
        iPrioritizer->TryToPublishL( *iBroadcaster,
        							EAiDeviceStatusContentNetworkIdentity,
        							R_ACTIVEIDLE_BT_SIM_ACCESS_PROFILE_STRING,
        							EAiBTSAP );
        iSuccess = ETrue;
        }

    else if( !iFirstPublish )
        {
		//BTSAP is not anymore active, call clean.
        iPrioritizer->TryToCleanL( *iBroadcaster,
        							EAiDeviceStatusContentNetworkIdentity,
        							EAiBTSAP );
        }
    iFirstPublish = EFalse;
    }


void CAiBTSAPPublisher::RunL()
    {
    if( iStatus.Int() == KErrNone )
        {
	    //PS key changed, refresh publisher.
        RefreshL( ETrue );
        iPubSub.Subscribe( iStatus );
        SetActive();
        }
    }


void CAiBTSAPPublisher::DoCancel()
    {
    iPubSub.Cancel();
    }


TInt CAiBTSAPPublisher::RunError( TInt /*aError*/ )
    {
    iPubSub.Cancel();
    //failed to publish, lets however ignore it
    return KErrNone;
    }


TBool CAiBTSAPPublisher::RefreshL( TInt aContentId, TBool aClean )
	{
    if( aContentId == EAiDeviceStatusContentNetworkIdentity )
        {
   	    RefreshL( aClean );
        if( iSuccess )
	        {
	        return ETrue;
	        }
        }
    return EFalse;
	}


TBool CAiBTSAPPublisher::RefreshContentWithPriorityL( TInt aContentId,
                                                        TInt aPriority )
	{
	if( aContentId == EAiDeviceStatusContentNetworkIdentity &&
	    aPriority == EAiBTSAP )
        {
	    RefreshL( EFalse );
        if( iSuccess )
	        {
	        return ETrue;
	        }
        }
    return EFalse;
	}
hs_app_aicontentobserveroptimizer.cpp
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Active Idle Content Observer optimizer
*
*/


#include "hs_app_aicontentobserveroptimizer.h"

CAiContentObserverOptimizer* CAiContentObserverOptimizer::NewL(MAiContentObserver& aObserver)
    {
    return new(ELeave) CAiContentObserverOptimizer( aObserver );
    }
    
CAiContentObserverOptimizer::~CAiContentObserverOptimizer()
    {
    iBlackList.Close();
    }

TInt CAiContentObserverOptimizer::StartTransaction( TInt aTxId )
    {
    TInt err = KErrAlreadyExists;
    if ( iTransactionStarted )
        {
        return err;
        }
    iCommitNeeded = EFalse;
    
    err = iObserver.StartTransaction( aTxId );
    if ( err == KErrNone )
        {
        iTransactionStarted = ETrue;
        }
    return err;   
    }
    

TInt CAiContentObserverOptimizer::Commit( TInt aTxId )
    {
    TInt err = KErrNotReady;
    if ( iTransactionStarted )
        {
        if ( iCommitNeeded )
            {
            iCommitNeeded = EFalse;
            err = iObserver.Commit( aTxId );
            }
        else
            {
            err = CancelTransaction( aTxId );
            }
        }
    iTransactionStarted = EFalse;
    return err;
    }
    

TInt CAiContentObserverOptimizer::CancelTransaction( TInt aTxId )
    {
    TInt err = KErrNotReady;
    if ( iTransactionStarted )
        {
        err = iObserver.CancelTransaction( aTxId );
        }
    iTransactionStarted = EFalse;
    return err;
    }
    
    
TBool CAiContentObserverOptimizer::CanPublish( MAiPropertyExtension& aPlugin,
                                           TInt aContent,
                                           TInt aIndex )
    {
    return iObserver.CanPublish( aPlugin, aContent, aIndex );
    }
  
TInt CAiContentObserverOptimizer::Publish( MAiPropertyExtension& aPlugin,
                                       TInt aContent,
                                       TInt aResource,
                                       TInt aIndex )
    {
    if ( IsInBlackList( aContent, aIndex ) )
        {
        return KErrNotFound;
        }   
    TInt err = iObserver.Publish( aPlugin, aContent, aResource, aIndex );
    // Publish went through OK, we need to commit the transaction
    if ( err == KErrNone && iTransactionStarted )
        {
        iCommitNeeded = ETrue;
        }
    // publish failed because the ui declaration doesn't
    // include this content => add to black list and 
    // don't try to publish again    
    else if ( err == KErrNotFound || err == KErrNotSupported )
        {
        AddToBlackList( aContent, aIndex );
        }
    return err;
    }
    
    
TInt CAiContentObserverOptimizer::Publish( MAiPropertyExtension& aPlugin,
                                       TInt aContent,
                                       const TDesC16& aText,
                                       TInt aIndex )
    {
    if ( IsInBlackList( aContent, aIndex ) )
        {
        return KErrNotFound;
        }   
    TInt err = iObserver.Publish( aPlugin, aContent, aText, aIndex );
    // Publish went through OK, we need to commit the transaction
    if ( err == KErrNone && iTransactionStarted )
        {
        iCommitNeeded = ETrue;
        }
    // publish failed because the ui declaration doesn't
    // include this content => add to black list and 
    // don't try to publish again    
    else if ( err == KErrNotFound || err == KErrNotSupported )
        {
        AddToBlackList( aContent, aIndex );
        }
    return err;
    }
    
    
TInt CAiContentObserverOptimizer::Publish( MAiPropertyExtension& aPlugin,
                                       TInt aContent,
                                       const TDesC8& aBuf,
                                       TInt aIndex )
    {
    if ( IsInBlackList( aContent, aIndex ) )
        {
        return KErrNotFound;
        }
    TInt err = iObserver.Publish( aPlugin, aContent, aBuf, aIndex );
    // Publish went through OK, we need to commit the transaction
    if ( err == KErrNone && iTransactionStarted )
        {
        iCommitNeeded = ETrue;
        }
    // publish failed because the ui declaration doesn't
    // include this content => add to black list and 
    // don't try to publish again    
    else if ( err == KErrNotFound || err == KErrNotSupported )
        {
        AddToBlackList( aContent, aIndex );
        }
    return err;
    
    }
    
    
TInt CAiContentObserverOptimizer::Publish( MAiPropertyExtension& aPlugin,
                                       TInt aContent,
                                       RFile& aFile,
                                       TInt aIndex )
    {
    if ( IsInBlackList( aContent, aIndex ) )
        {
        return KErrNotFound;
        }    
    TInt err = iObserver.Publish( aPlugin, aContent, aFile, aIndex );
    // Publish went through OK, we need to commit the transaction
    if ( err == KErrNone && iTransactionStarted )
        {
        iCommitNeeded = ETrue;
        }
    // publish failed because the ui declaration doesn't
    // include this content => add to black list and 
    // don't try to publish again
    else if ( err == KErrNotFound || err == KErrNotSupported )
        {
        AddToBlackList( aContent, aIndex );
        }
    return err;
    }
    
    
TInt CAiContentObserverOptimizer::Clean( MAiPropertyExtension& aPlugin,
                                     TInt aContent,
                                     TInt aIndex )
    {
    return iObserver.Clean( aPlugin, aContent, aIndex );    
    }

MAiContentObserver& CAiContentObserverOptimizer::Observer() const
    {
    return iObserver;
    }

TInt CAiContentObserverOptimizer::AddToBlackList( TInt aContentId, TInt aIndex )
    {
    TInt err = KErrNone;
    if ( !IsInBlackList( aContentId, aIndex ) )
        {
        TAiPublishBlackList entry;
        entry.iContentId = aContentId;
        entry.iIndex = aIndex;
        err = iBlackList.Append( entry );
        }
    return err;
    }

TBool CAiContentObserverOptimizer::IsInBlackList( TInt aContentId, TInt aIndex ) const 
    {
    for (TInt i = 0; i < iBlackList.Count(); ++i )
        {       
        if ( iBlackList[i].iContentId == aContentId &&
             iBlackList[i].iIndex == aIndex )
            {
            return ETrue;                   
            }
        }
    return EFalse;
    }

CAiContentObserverOptimizer::CAiContentObserverOptimizer(MAiContentObserver& aObserver): 
    iObserver( aObserver )
    {
    }

// end of file
hs_app_aicugmcnpublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Closed user group (CUG) publisher.
*
*/


#include 
#include 
#include "hs_app_aicugmcnpublisher.h"
#include "aicontentobserver.h"
#include "hs_app_ainetworkinfolistener.h"

// ======== MEMBER FUNCTIONS ========

CAiCUGMCNPublisher::CAiCUGMCNPublisher()
    {
    }


void CAiCUGMCNPublisher::ConstructL()
    {
    iListener = CAiNetworkInfoListener::InstanceL();
    User::LeaveIfError( iSSSettings.Open() );
    
    // Initialize the periodic timer.
    iPeriodic = CPeriodic::NewL( CActive::EPriorityStandard );
    }


CAiCUGMCNPublisher* CAiCUGMCNPublisher::NewL()
    {
    CAiCUGMCNPublisher* self = new( ELeave ) CAiCUGMCNPublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( );
    //CleanupStack::Pop( self );
    return self;
    }


CAiCUGMCNPublisher::~CAiCUGMCNPublisher()
    {
    if( iPeriodic )
            {
            iPeriodic->Cancel();
            delete iPeriodic;
            }
    if( iListener )
            {
            iListener->RemoveObserver( *this );
            iListener->Release();
            }
    //Cancel listenning CUG changes.
    iSSSettings.CancelAll( *this );
    iSSSettings.Close();
    
    delete iCUG;
    delete iMCN;
    }

TInt CAiCUGMCNPublisher::PeriodicTimerCallBack(TAny* aAny)
	{
	CAiCUGMCNPublisher* self = static_cast( aAny );
  
	if( self )
	        {
	        self->DoAnimation();
	        }

	    return KErrNone;
	}

void CAiCUGMCNPublisher::DoAnimation()
	{
	if ( iAnimationDone )
		{
		PublishCUG();
		iPeriodic->Cancel();
		}
	else
		{
		iAnimationDone = ETrue;
		PublishMCN();
		}

	}


void CAiCUGMCNPublisher::ResumeL()
    {
    iListener->AddObserverL( *this );
    
	//Start listening CUG changes.
    TInt err = iSSSettings.Register( ESSSettingsCug, *this );

    if( err == KErrNotSupported ||
        err == KErrAlreadyExists  )
        {
        //CUG not supported, or already registered
        err = KErrNone;
        }

    User::LeaveIfError( err );
    }


void CAiCUGMCNPublisher::Subscribe( MAiContentObserver& aObserver, 
							        MAiPropertyExtension& aExtension,
                                    MAiPublishPrioritizer& /*aPrioritizer*/,
                                    MAiPublisherBroadcaster& /*aBroadcaster*/ )
    {
    iContentObserver = &aObserver;
    iExtension = &aExtension;
    }


void CAiCUGMCNPublisher::RefreshL( TBool /*aClean*/ )
    {
	//Get current CUG value and publish it.
    TInt value;
    if ( iSSSettings.Get( ESSSettingsCug, value ) != KErrNone )
        {
        value = ESSSettingsCugDefault;
        }

    UpdateCUGMCNIndicatorL( value );
    }


void CAiCUGMCNPublisher::PhoneSettingChanged( TSSSettingsSetting aSetting, 
											TInt aNewValue )
    {
    if( aSetting == ESSSettingsCug )
        {
        TRAP_IGNORE( UpdateCUGMCNIndicatorL( aNewValue ) );
        }
    }

void CAiCUGMCNPublisher::UpdateCUGMCNIndicatorL( TInt aValue )
    {
	//Check if the CUG is valid...
    if( iSSSettings.IsValueValidCugIndex( aValue ) )
        {
		//...and then read CUG indicator format from resource file and publish 
		// content as a text.
        if (iCUG)
        	{
        	delete iCUG;
        	iCUG = NULL;
        	}
        iCUG = StringLoader::LoadL( 
        						R_ACTIVEIDLE_CUG_INDICATOR_FORMAT, 
        						aValue );
        						
		Animate();
        }
    else
        {            
		//CUG is not valid, call clean.
		if ( iCUG )
			{
			iContentObserver->Clean( *iExtension, 
        					EAiDeviceStatusContentCUGMCNIndicator, 
        					0 );
			iCUG = NULL;
			}
        }
    }

void CAiCUGMCNPublisher::HandleNetworkInfoChange( 
						const MNWMessageObserver::TNWMessages& aMessage, 
						const TNWInfo& aInfo,
						const TBool /*aShowOpInd*/ )
    {
	//If MSN message was received, publish it.
    if ( aMessage == MNWMessageObserver::ENWMessageCurrentCellInfoMessage )
        {
        if ( aInfo.iMCNIndicatorType == ENWMCNIndicatorTypeActive )
            {
            TPtrC msg = aInfo.iMCNName;
            if (iMCN)
            	{
            	delete iMCN;
            	iMCN = NULL;
            	}
            	
            TRAP_IGNORE(iMCN = msg.AllocL());
			Animate();
            }
        else if ( aInfo.iMCNIndicatorType == ENWMCNIndicatorTypeNone )
            {
			if ( iMCN )
				{
				//MCN is not valid, call clean.
				iContentObserver->Clean( *iExtension, 
								EAiDeviceStatusContentCUGMCNIndicator,
			            		0 );
				iMCN = NULL;
				}
            }
        }
    }


TBool CAiCUGMCNPublisher::RefreshL( TInt aContentId, TBool aClean )
	{
    if( ( aContentId == EAiDeviceStatusContentCUGMCNIndicator ) 
    		|| ( aContentId == EAiDeviceStatusContentNetworkIdentity ) )
        {
   	    RefreshL( aClean );
   	    return ETrue;
    	}
    	
    return EFalse;
	}

void CAiCUGMCNPublisher::Animate()
	{
	if ( iCUG && iMCN )
		{
		if ( !iPeriodic->IsActive() )
			{
			iAnimationDone = EFalse;
			PublishCUG();
			iPeriodic->Start( KAnimDelay, KAnimDelay, TCallBack( PeriodicTimerCallBack, this ) );
			}
		}
	else
		{
		if ( iCUG )
			{
			PublishCUG();
			}
		else if ( iMCN )
			{
			PublishMCN();
			}
		}
	}

void CAiCUGMCNPublisher::PublishCUG()
	{
	iContentObserver->Publish( *iExtension, 
			        	EAiDeviceStatusContentCUGMCNIndicator, 
			        	*iCUG, 
			        	0 );
	}

void CAiCUGMCNPublisher::PublishMCN()
	{
	iContentObserver->Publish( *iExtension, 
						EAiDeviceStatusContentCUGMCNIndicator, 
		            	*iMCN, 
		            	0 );
	}

hs_app_aicugpublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Closed user group (CUG) publisher.
*
*/


#include 
#include 
#include "hs_app_aicugpublisher.h"
#include "aicontentobserver.h"
#include "hs_app_ainetworkinfolistener.h"


// ======== MEMBER FUNCTIONS ========

CAiCUGPublisher::CAiCUGPublisher()
    {
    }


void CAiCUGPublisher::ConstructL()
    {
    User::LeaveIfError( iSSSettings.Open() );    
    }


CAiCUGPublisher* CAiCUGPublisher::NewL()
    {
    CAiCUGPublisher* self = new( ELeave ) CAiCUGPublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiCUGPublisher::~CAiCUGPublisher()
    {
    //Cancel listenning CUG changes.
    iSSSettings.CancelAll( *this );
    iSSSettings.Close();
    delete iCugText;
    }


void CAiCUGPublisher::ResumeL()
    {
	//Start listening CUG changes.
    TInt err = iSSSettings.Register( ESSSettingsCug, *this );

    if( err == KErrNotSupported ||
        err == KErrAlreadyExists  )
        {
        //CUG not supported, or already registered
        err = KErrNone;
        }

    User::LeaveIfError( err );
    }


void CAiCUGPublisher::Subscribe( MAiContentObserver& aObserver, 
							        MAiPropertyExtension& aExtension,
                                    MAiPublishPrioritizer& /*aPrioritizer*/,
                                    MAiPublisherBroadcaster& /*aBroadcaster*/ )
    {
    iContentObserver = &aObserver;
    iExtension = &aExtension;
    }


void CAiCUGPublisher::RefreshL( TBool /*aClean*/ )
    {
	//Get current CUG value and publish it.
    TInt value;
    if ( iSSSettings.Get( ESSSettingsCug, value ) != KErrNone )
        {
        value = ESSSettingsCugDefault;
        }

    UpdateCUGIndicatorL( value );
    }


void CAiCUGPublisher::PhoneSettingChanged( TSSSettingsSetting aSetting, 
											TInt aNewValue )
    {
    if( aSetting == ESSSettingsCug )
        {
        TRAP_IGNORE( UpdateCUGIndicatorL( aNewValue ) );
        }
    }


void CAiCUGPublisher::UpdateCUGIndicatorL( TInt aValue )
    {
	//Check if the CUG is valid
    if( iSSSettings.IsValueValidCugIndex( aValue ) )
        {
        // Information already current, no need to update text
        if ( iCugValue != aValue )
            {
            iCugValue = aValue;
            delete iCugText;
            iCugText = NULL;
            // Read CUG indicator format from resource file and publish 
            // content as a text.
            iCugText = StringLoader::LoadL( 
                                    R_ACTIVEIDLE_CUG_INDICATOR_FORMAT, 
                                    aValue );

            }
        if ( iCugText )
            {
            iContentObserver->Publish( *iExtension, 
                                EAiDeviceStatusContentCUGIndicator, 
                                *iCugText, 
                                0 );            
            } 
        else
            {           
            iContentObserver->Clean( *iExtension, 
                                EAiDeviceStatusContentCUGIndicator, 
                                0 );            
            }
        }
    else
        {            
		//CUG is not valid, call clean.
        iContentObserver->Clean( *iExtension, 
        					EAiDeviceStatusContentCUGIndicator, 
        					0 );
        }
    }
    

TBool CAiCUGPublisher::RefreshL( TInt aContentId, TBool aClean )
	{
    if( aContentId == EAiDeviceStatusContentCUGIndicator )
        {
   	    RefreshL( aClean );
   	    return ETrue;
    	}
    	
    return EFalse;
	}
hs_app_aidatepublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Date publisher
*
*/


#include 
#include 
#include 
#include 
#include 
#include "hs_app_aidatepublisher.h"
#include "aicontentobserver.h"

const TInt KMaxDateStringLength = 100;

// ======== MEMBER FUNCTIONS ========

CAiDatePublisher::CAiDatePublisher()
    {
    }


void CAiDatePublisher::ConstructL()
    {
  	// Create enviroment notifier
    iEnvNotifier = CEnvironmentChangeNotifier::NewL( 
		CActive::EPriorityStandard, TCallBack( HandleCallBackL, this ) );
    iDateText = NULL;
	// Start listening notifications
    iEnvNotifier->Start(); 
    }


CAiDatePublisher* CAiDatePublisher::NewL()
    {
    CAiDatePublisher* self = new( ELeave ) CAiDatePublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiDatePublisher::~CAiDatePublisher()
    {
    delete iDateText;
    delete iEnvNotifier;
    }


void CAiDatePublisher::ResumeL()
    {
    RefreshDateL();
    }


void CAiDatePublisher::Subscribe( MAiContentObserver& aObserver, 
								    MAiPropertyExtension& aExtension,
                                    MAiPublishPrioritizer& /*aPrioritizer*/,
                                    MAiPublisherBroadcaster& /*aBroadcaster*/ )
    {
    iContentObserver = &aObserver;
    iExtension = &aExtension;
    }


void CAiDatePublisher::RefreshL( TBool /*aClean*/ )
    {
    RefreshDateL();
    }


void CAiDatePublisher::RefreshDateL()
    {
    if( !iContentObserver )
        {
        return;
        }

    delete iDateText;
    iDateText = NULL;
    iDateText = ConstructDateStringL();
    if ( iDateText )
        {
        iContentObserver->Publish( *iExtension,
    						EAiDeviceStatusContentDate,
    						*iDateText,
    						0 );
        }
    }


HBufC* CAiDatePublisher::GetDayNameStringLC( TDay aDay, CCoeEnv& aCoeEnv )
    {
	//Create week day string
    TInt wkDayRes = KErrNotFound;

    switch( aDay )
        {
        case EMonday:
            wkDayRes = R_QTN_WEEK_TWO_CHARS_MO;
            break;
        case ETuesday:
            wkDayRes = R_QTN_WEEK_TWO_CHARS_TU;
            break;
        case EWednesday:
            wkDayRes = R_QTN_WEEK_TWO_CHARS_WE;
            break;
        case EThursday:
            wkDayRes = R_QTN_WEEK_TWO_CHARS_TH;
            break;
        case EFriday:
            wkDayRes = R_QTN_WEEK_TWO_CHARS_FR;
            break;
        case ESaturday:
            wkDayRes = R_QTN_WEEK_TWO_CHARS_SA;
            break;
        case ESunday:
            wkDayRes = R_QTN_WEEK_TWO_CHARS_SU;
            break;
        default:
            // invalid weekday fetched
	        User::Leave( KErrNotFound );
        }

    return StringLoader::LoadLC( wkDayRes, &aCoeEnv );
    }


HBufC* CAiDatePublisher::ConstructDateStringL()
    {
    // Construct date string using date format from resource file
    CCoeEnv* coeEnv = CCoeEnv::Static();

    if( !coeEnv )
        {
        User::Leave( KErrNotReady );
        }

    TTime time;
    time.HomeTime();

    HBufC* aiDateString = HBufC::NewLC( KMaxDateStringLength );
    HBufC* aiDateFormatString = StringLoader::LoadLC( R_ACTIVEIDLE_TIME_FORMAT,
    													coeEnv );
    HBufC* dateStringBuf = HBufC::NewLC( KMaxDateStringLength );
    HBufC* dateFormatString = StringLoader::LoadLC( R_QTN_DATE_SHORT_WITH_ZERO,
    												coeEnv );
    TPtr dateString( dateStringBuf->Des() );
    time.FormatL( dateString, *dateFormatString );
    CleanupStack::PopAndDestroy( dateFormatString );

    //now dateString contains string which is formatted using
    //R_QTN_DATE_USUAL_WITH_ZERO

    // To arabic
    AknTextUtils::DisplayTextLanguageSpecificNumberConversion( dateString );

    TPtr aiDateStringPtr = aiDateString->Des();
    
    TDayNameAbb wkDayAbb = TDayNameAbb();
    wkDayAbb.Set(time.DayNoInWeek());
        
    //add date to string
    StringLoader::Format( aiDateStringPtr, *aiDateFormatString,	1,dateString );

    //reuse dateString
    dateString.Copy( aiDateStringPtr );

    //add weekday to string
    StringLoader::Format( aiDateStringPtr, dateString, 0, wkDayAbb );

    CleanupStack::PopAndDestroy( dateStringBuf );//dateStringBuf, aiDateFormatString
    CleanupStack::PopAndDestroy( aiDateFormatString );

    CleanupStack::Pop( aiDateString );
    return aiDateString;
    }


TBool CAiDatePublisher::RefreshL( TInt aContentId, TBool /*aClean*/ )
	{
	if( aContentId == EAiDeviceStatusContentDate )
	    {
	    RefreshDateL();
	    return ETrue;
	    }
	return EFalse;
	}
	
	
TInt CAiDatePublisher::HandleCallBackL( TAny *aPtr )
	{
	CAiDatePublisher* self = static_cast( aPtr );
	
	if( self )
	    {
        TInt changes( self->iEnvNotifier->Change() );
        
        if ( changes & 
        	( EChangesLocale | EChangesMidnightCrossover | EChangesSystemTime ) )
        	{
        	self->RefreshDateL();
        	}	    
	    }    
    	
	return KErrNone;
	}
hs_app_aidevicestatusplugin.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Device status plugin interface.
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include "hs_app_aidevicestatusplugin.h"
#include "hs_app_aidevicestatuspluginengine.h"
#include "hs_app_aipublishprioritizer.h"
#include "hs_app_aidevicestatuscontentmodel.h"
#include "hs_app_aimulticontentobserver.h"
#include "aipluginsettings.h"
#include "hs_app_ainetworkinfolistener.h"

_LIT( KResourceDrive, "Z:" );
_LIT( KResourceFile, "hs_app_aidevstaplgres.rsc" );
#define KResourcePath KDC_APP_RESOURCE_DIR

// ECOM implementation table
const TImplementationProxy KImplementationTable[] =
    {
    IMPLEMENTATION_PROXY_ENTRY(KImplUidDevStaPlugin, CAiDeviceStatusPlugin::NewL)
    };


// ======== MEMBER FUNCTIONS ========

CAiDeviceStatusPlugin::CAiDeviceStatusPlugin() :
   	iResourceOffset( KErrNotFound )
    {
    }


void CAiDeviceStatusPlugin::ConstructL()
    {
    iInfo.iUid.iUid = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DEVSTAPLUGIN; 

    FeatureManager::InitializeLibL();
    
    // Create master instance to prevent deletion on Stop()
    iListener = CAiNetworkInfoListener::InstanceL();
    
	//Create content here since this is needed in optimization phase.
    iContent = AiUtility::CreateContentItemArrayIteratorL( KAiDeviceStatusContent );
    iResources = AiUtility::CreateContentItemArrayIteratorL( KAiDeviceStatusResources );
    iContentObservers = CAiMultiContentObserver::NewL();
    iPrioritizer = CAiPublishPrioritizer::NewL( *iContentObservers, *this );
    }


CAiDeviceStatusPlugin* CAiDeviceStatusPlugin::NewL()
    {
    CAiDeviceStatusPlugin* self = CAiDeviceStatusPlugin::NewLC();
    CleanupStack::Pop( self );
    return self;
    }


CAiDeviceStatusPlugin* CAiDeviceStatusPlugin::NewLC()
    {
    CAiDeviceStatusPlugin* self = new( ELeave ) CAiDeviceStatusPlugin;
    CleanupStack::PushL( self );
    self->ConstructL();
    return self;
    }


CAiDeviceStatusPlugin::~CAiDeviceStatusPlugin()
    {
    delete iPrioritizer;
    FreeResources();
    delete iContentObservers;
    Release( iResources );
    Release( iContent );
    FeatureManager::UnInitializeLib();
    if( iListener )
        {
        iListener->Release();
        }
    }


/**
 * Allocates all resourcers required for plug-in operation.
 */
void CAiDeviceStatusPlugin::AllocateResourcesL()
    {
    //create engine
    if( !iEngine )
    	{
   	    iEngine = CAiDeviceStatusPluginEngine::NewL( *iContentObservers,
   	                                                    *this,
   	                                                    *iPrioritizer);
    	}

	if( iResourceOffset < 0 )
		{
		CCoeEnv* coe = CCoeEnv::Static();

		if( !coe )
		    {
		    User::Leave( KErrNotReady );
		    }

		//Add resource file to cone
		TFullName resourceFile( KResourceDrive );
		resourceFile.Append( KResourcePath );
		resourceFile.Append( KResourceFile );
		BaflUtils::NearestLanguageFile( CCoeEnv::Static()->FsSession(), resourceFile );
		iResourceOffset = coe->AddResourceFileL( resourceFile );
		}
    }


/**
 * Frees all allocated resources.
 */
void CAiDeviceStatusPlugin::FreeResources()
    {
	if( iResourceOffset >= 0 )
	    {
	    CCoeEnv* coe = CCoeEnv::Static();
    	//If device status plugin is created when CCoeEnv is available and
    	//destroyed when it is not anymore available, cone will inform about
    	//resource leak.
	    if ( coe )
	        {
        	coe->DeleteResourceFile( iResourceOffset );
        	iResourceOffset = KErrNotFound;
        	}
	    }

	delete iEngine;
	iEngine = NULL;
    }


void CAiDeviceStatusPlugin::Resume(TAiTransitionReason aReason)
    {
    if( IgnoreReason( aReason ) )
        {
        return;
        }
    // resume all publishers only in startup
    if( iEngine )
        {
        if (  aReason == EAiIdleForeground || aReason == EAiKeylockDisabled )
        	{
        	// not much can be done if some publisher cannot be refreshed
        	TRAP_IGNORE( iEngine->RefreshPublishersL( 
        	                EAiDeviceStatusContentNetworkIdentity, ETrue ) );
        	
        	TRAP_IGNORE( iEngine->RefreshPublishersL( 
        					EAiDeviceStatusContentCUGMCNIndicator, ETrue ) );
        	}
        // if layout changed republish some information
        else if ( aReason == EAiScreenLayoutChanged )
            {
            TRAP_IGNORE( iEngine->RefreshPublishersL( EAiDeviceStatusContentDate, ETrue )); 
            TRAP_IGNORE( iEngine->RefreshPublishersL( EAiDeviceStatusContentCUGMCNIndicator, ETrue ));
            TRAP_IGNORE( iEngine->RefreshPublishersL( EAiDeviceStatusContentVHZText, ETrue ));
            TRAP_IGNORE( iEngine->RefreshPublishersL( EAiDeviceStatusContentNetworkIdentity, ETrue ));
            }
        return;
        }
    // If engine has been deleted. create it again.
    else
        {
        iContentObservers->StartTransaction( KImplUidDevStaPlugin );

        TRAPD( err, DoResumeL(aReason) );

        if( err == KErrNone )
            {
            iContentObservers->Commit( KImplUidDevStaPlugin );
            }
        else
            {
            iContentObservers->CancelTransaction( KImplUidDevStaPlugin );
            }
        }
    }


void CAiDeviceStatusPlugin::DoResumeL(TAiTransitionReason /*aReason*/)
    {
    AllocateResourcesL( );
    iEngine->ResumePublishersL();
    iEngine->RefreshPublishersL( EFalse );
    }
    

TBool CAiDeviceStatusPlugin::IgnoreReason( TAiTransitionReason aReason )
    {
    switch( aReason )
        {
        case EAiBacklightOff:
            return ETrue;
        }
    return EFalse;
    }


void CAiDeviceStatusPlugin::Stop(TAiTransitionReason /*aReason*/)
    {
    FreeResources();
    }


void CAiDeviceStatusPlugin::Suspend(TAiTransitionReason /*aReason*/)
    {
    }


void CAiDeviceStatusPlugin::SubscribeL(MAiContentObserver& aObserver)
    {
    iContentObservers->AddObserverL( aObserver );
    }


TAny* CAiDeviceStatusPlugin::Extension(TUid aUid)
    {
	//Access to extensions
    if( aUid == KExtensionUidProperty )
        {
        return static_cast(this);
        }

    return NULL;
    }


void CAiDeviceStatusPlugin::ConfigureL(RAiSettingsItemArray& aSettings)
    {
	aSettings.ResetAndDestroy();
    }

TAny* CAiDeviceStatusPlugin::GetPropertyL(TInt aProperty)
    {
	//Return properties.
    switch (aProperty)
        {
        case EAiPublisherInfo:
                return &iInfo;

        case EAiPublisherContent:
            return static_cast(iContent);

        case EAiPublisherResources:
            return static_cast(iResources);

        case EAiContentRequest:
            return static_cast(this);
        }

    return NULL;
    }

void CAiDeviceStatusPlugin::SetPropertyL(TInt aProperty, TAny* aValue)
    {
    if( aProperty == EAiPublisherInfo )
        {
        ASSERT( aValue );
        
        const TAiPublisherInfo* info( 
                static_cast( aValue ) );
        
        iInfo = *info;
        }
    }

TBool CAiDeviceStatusPlugin::RefreshContent( TInt aContentId )
    {
    TBool result = EFalse;

    TRAP_IGNORE( result = iEngine->RefreshPublishersL( aContentId, EFalse ) );
    return result;
    }


/**
 * ECom component entry point.
 */
EXPORT_C const TImplementationProxy* ImplementationGroupProxy( TInt& aTableCount )
    {
    aTableCount = sizeof(KImplementationTable) / sizeof(TImplementationProxy);
    return KImplementationTable;
    }
hs_app_aidevicestatuspluginengine.cpp
/*
* Copyright (c) 2006-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Engine class for Device Status Plug-in
*
*/


#include "hs_app_aidevicestatuspluginengine.h"
#include "hs_app_aipublisherfactory.h"
#include "hs_app_aidevicestatuspublisher.h"

CAiDeviceStatusPluginEngine::CAiDeviceStatusPluginEngine( 
                                            MAiContentObserver& aObserver, 
											MAiPropertyExtension& aExtension,
                                            MAiPublishPrioritizer& aPrioritizer )
    : iContentObserver( &aObserver ), 
        iExtension( &aExtension ), 
        iPrioritizer( &aPrioritizer )
	{	
	}


void CAiDeviceStatusPluginEngine::ConstructL()
    {
    // Instantiate all publishers via factory
    MAiDeviceStatusPublisher* publisher = AiPublisherFactory::CreateProfilePublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );

    publisher = AiPublisherFactory::CreateDatePublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );

    publisher = AiPublisherFactory::CreateSimRegPublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );

    publisher = AiPublisherFactory::CreateNWSPublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );

    publisher = AiPublisherFactory::CreateBTSAPPublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );

    publisher = AiPublisherFactory::CreateOperatorLogoPublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );

    publisher = AiPublisherFactory::CreateOperatorNamePublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );

    publisher = AiPublisherFactory::CreateMCNPublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );

    publisher = AiPublisherFactory::CreateCUGPublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );

    publisher = AiPublisherFactory::CreateVHZPublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );
    
    publisher = AiPublisherFactory::CreateCUGMCNPublisherL();
    CleanupStack::PushL( publisher );
    AddPublisherL( publisher );
    CleanupStack::Pop( publisher );

    // Subscribe all publishers once they are instantiated
    const TInt count = iPublishers.Count();

    for( TInt i( 0 ); i < count; i++ )
        {
        iPublishers[i]->Subscribe( *iContentObserver, 
                                    *iExtension, 
                                    *iPrioritizer, 
                                    *this );
        }    
    }


CAiDeviceStatusPluginEngine* CAiDeviceStatusPluginEngine::NewL( 
                                            MAiContentObserver& aObserver, 
											MAiPropertyExtension& aExtension,
                                            MAiPublishPrioritizer& aPrioritizer)
    {
    CAiDeviceStatusPluginEngine* self = 
    	new( ELeave ) CAiDeviceStatusPluginEngine( aObserver, 
											        aExtension,
                                                    aPrioritizer);
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiDeviceStatusPluginEngine::~CAiDeviceStatusPluginEngine()
    {
    iPublishers.ResetAndDestroy();
    }


void CAiDeviceStatusPluginEngine::AddPublisherL( MAiDeviceStatusPublisher* aPublisher )
    {
	//Add publisher to list.
    if( aPublisher )
        {
        CleanupDeletePushL( aPublisher );
        User::LeaveIfError( iPublishers.Append( aPublisher ) );
        CleanupStack::Pop(aPublisher);//aPublisher
        }
    }


void CAiDeviceStatusPluginEngine::ResumePublishersL()
	{
    const TInt count = iPublishers.Count();

    for( TInt i( 0 ); i < count; i++ )
        {
        iPublishers[i]->ResumeL();
        }    
	}


void CAiDeviceStatusPluginEngine::RefreshPublishersL( TBool aClean )
	{
	iContentObserver->StartTransaction( KImplUidDevStaPlugin );

    const TInt count = iPublishers.Count();

    for( TInt i( 0 ); i < count; i++ )
        {
        iPublishers[i]->RefreshL( aClean );
        }    
        
	iContentObserver->Commit( KImplUidDevStaPlugin );
	}


TBool CAiDeviceStatusPluginEngine::RefreshPublishersL( TInt aContentId, 
                                                        TBool aClean )
	{
	TBool success = EFalse;
	
	iContentObserver->StartTransaction( KImplUidDevStaPlugin );

    const TInt count = iPublishers.Count();

    for( TInt i( 0 ); i < count; i++ )
        {
        if( iPublishers[i]->RefreshL( aContentId, aClean ) )
            {
            success = ETrue;
            }
        }

    if ( success )
    	{
    	iContentObserver->Commit( KImplUidDevStaPlugin );
    	}
    else
        {
        iContentObserver->CancelTransaction( KImplUidDevStaPlugin );
        }

    return success;
	}


TBool CAiDeviceStatusPluginEngine::RefreshPriorizedPublishersL( TInt aContentId,
                                                                TInt aPriority )
	{
	iContentObserver->StartTransaction( KImplUidDevStaPlugin );
	TBool success = EFalse;
    const TInt count = iPublishers.Count();

    for( TInt i( 0 ); i < count; i++ )
        {
        if( iPublishers[i]->RefreshContentWithPriorityL( aContentId,
                                                            aPriority ) )
            {
            success = ETrue;
            break;
            }
        }
    if ( success )
        {
        iContentObserver->Commit( KImplUidDevStaPlugin );
        }
    else
        {
        iContentObserver->CancelTransaction( KImplUidDevStaPlugin );
        }
    return success;
	}

hs_app_aidevstaplg.rss
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


//  INCLUDES
#include 


//  RESOURCE DEFINITIONS
// -----------------------------------------------------------------------------
//
// ?resource_name
// 
//
// -----------------------------------------------------------------------------
//
RESOURCE REGISTRY_INFO registry_info
{
    resource_format_version = RESOURCE_FORMAT_VERSION_2;
    // UID for the DLL
    dll_uid = 0x102750F7;

    // Interface info array
    interfaces =
    {
        INTERFACE_INFO
        {
            // UID of the implemented interface
            interface_uid = 0x102750ED;

            implementations =
            {
                IMPLEMENTATION_INFO
                {
                    implementation_uid  =  0x102750F8;
                    version_no          =  1;
                    display_name        =  "DeviceStatus";
                    default_data        =  "";
                    opaque_data         =  "";
                    rom_only            =  1;
                }
            };
        }
    };
}

// End of File.
hs_app_aidevstaplgres.rss
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Resource definitions for project ?myapp
*
*/



NAME AIDP

#include 
#include 
#include 
#include 
#include 

#include 

RESOURCE RSS_SIGNATURE { }
RESOURCE TBUF { buf=""; }

// ---------------------------------------------------------------------------
// ?resource_name
// 
// ---------------------------------------------------------------------------
//
RESOURCE TBUF r_activeidle_time_format
    {
    buf = qtn_idle_time_format; 
    }

RESOURCE TBUF r_activeidle_bt_sim_access_profile_string
    {
    buf = qtn_mode_sap;
    }
    
RESOURCE TBUF r_activeidle_cug_indicator_format
    {
    buf = qtn_cug_indic_group;
    }

RESOURCE TBUF r_ai_opn_spn_separator_format
    {
    buf = qtn_ai_opn_spn_separator;
    }
hs_app_aimcnpublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Micro Cellular Network (MCN) publisher.
*
*/


#include "hs_app_aimcnpublisher.h"
#include "aicontentobserver.h"
#include "hs_app_ainetworkinfolistener.h"


// ======== MEMBER FUNCTIONS ========

CAiMCNPublisher::CAiMCNPublisher()
    {
    }


void CAiMCNPublisher::ConstructL()
    {
    iListener = CAiNetworkInfoListener::InstanceL();
    }


CAiMCNPublisher* CAiMCNPublisher::NewL()
    {
    CAiMCNPublisher* self = new( ELeave ) CAiMCNPublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiMCNPublisher::~CAiMCNPublisher()
    {
    if( iListener )
        {
        iListener->RemoveObserver( *this );
        iListener->Release();
        }
    }


void CAiMCNPublisher::ResumeL()
    {
    iListener->AddObserverL( *this );
    }


void CAiMCNPublisher::Subscribe( MAiContentObserver& aObserver, 
							        MAiPropertyExtension& aExtension,
                                    MAiPublishPrioritizer& /*aPrioritizer*/,
                                    MAiPublisherBroadcaster& /*aBroadcaster*/ )
    {
    iContentObserver = &aObserver;
    iExtension = &aExtension;
    }
    
    
void CAiMCNPublisher::RefreshL( TBool /*aClean*/ )
    {
    //cannot be refreshed
    }


void CAiMCNPublisher::HandleNetworkInfoChange( 
						const MNWMessageObserver::TNWMessages& aMessage, 
						const TNWInfo& aInfo,
						const TBool /*aShowOpInd*/ )
    {
	//If MSN message was received, publish it.
    if ( aMessage == MNWMessageObserver::ENWMessageCurrentCellInfoMessage )
        {
        if ( aInfo.iMCNIndicatorType == ENWMCNIndicatorTypeActive )
            {
            TPtrC msg = aInfo.iMCNName;
            iContentObserver->Publish( *iExtension, 
            							EAiDeviceStatusContentMCNIndicator, 
            							msg, 
            							0 );
            }
        else if ( aInfo.iMCNIndicatorType == ENWMCNIndicatorTypeNone )
            {
            iContentObserver->Clean( *iExtension, 
            							EAiDeviceStatusContentMCNIndicator,
            							0 );
            }
        }
    }


TBool CAiMCNPublisher::RefreshL( TInt aContentId, TBool aClean )
	{
    if( aContentId == EAiDeviceStatusContentMCNIndicator )
        {
   	    RefreshL( aClean );
   	    return ETrue;
    	}
    	
    return EFalse;
	}
hs_app_aimulticontentobserver.cpp
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Active Idle Content Observer interface multiplexer 
*                implementation.
*
*/


#include "hs_app_aimulticontentobserver.h"
#include "hs_app_aicontentobserveroptimizer.h"

CAiMultiContentObserver* CAiMultiContentObserver::NewL()
    {
    return new(ELeave) CAiMultiContentObserver;
    }
    
    
CAiMultiContentObserver::~CAiMultiContentObserver()
    {
    iObserverOptimizers.ResetAndDestroy();
    }
    
    
void CAiMultiContentObserver::AddObserverL(MAiContentObserver& aObserver)
    {
    TBool foundExisting = EFalse;
    
    for( TInt i = 0; i < iObserverOptimizers.Count(); ++i )
        {
        if ( &(iObserverOptimizers[i]->Observer()) == &aObserver )
            {
            foundExisting = ETrue;
            break;
            }
        }
    if( !foundExisting )
        {
        CAiContentObserverOptimizer *optimizer = 
            CAiContentObserverOptimizer::NewL( aObserver );
        iObserverOptimizers.AppendL( optimizer );       
        }
    }


TInt CAiMultiContentObserver::StartTransaction( TInt aTxId )
    {
    TInt result = KErrNone;
    const TInt count = iObserverOptimizers.Count();
    for ( TInt i = 0; i < count; ++i )
        {
        const TInt r = iObserverOptimizers[i]->StartTransaction( aTxId );
   
        if ( r != KErrNone )
            {
            result = r;
            }
        }
    return result;
    }
    

TInt CAiMultiContentObserver::Commit( TInt aTxId )
    {
    TInt result = KErrNone;
    const TInt count = iObserverOptimizers.Count();
    for ( TInt i = 0; i < count; ++i )
        {
        const TInt r = iObserverOptimizers[i]->Commit( aTxId );
      
        if ( r != KErrNone )
            {
            result = r;
            }
        }
    return result;
    }
    

TInt CAiMultiContentObserver::CancelTransaction( TInt aTxId )
    {
    TInt result = KErrNone;
    const TInt count = iObserverOptimizers.Count();
    for ( TInt i = 0; i < count; ++i )
        {
        const TInt r = iObserverOptimizers[i]->CancelTransaction( aTxId );
        if ( r != KErrNone )
            {
            result = r;
            }
        }
    return result;
    }
    
    
TBool CAiMultiContentObserver::CanPublish( MAiPropertyExtension& aPlugin,
                                           TInt aContent,
                                           TInt aIndex )
    {
    const TInt count = iObserverOptimizers.Count();
    for ( TInt i = 0; i < count; ++i )
        {
        if( iObserverOptimizers[i]->CanPublish( aPlugin, aContent, aIndex ) )
            {
            return ETrue;
            }
        }
    return EFalse;
    }
    
    
TInt CAiMultiContentObserver::Publish( MAiPropertyExtension& aPlugin,
                                       TInt aContent,
                                       TInt aResource,
                                       TInt aIndex )
    {
    TInt result = KErrNone;
    const TInt count = iObserverOptimizers.Count();
    for ( TInt i = 0; i < count; ++i )
        {
        const TInt r = iObserverOptimizers[i]->Publish( aPlugin, aContent, aResource, aIndex );
        if ( r != KErrNone )
            {
            result = r;
            }
        }
    return result;
    }
    
    
TInt CAiMultiContentObserver::Publish( MAiPropertyExtension& aPlugin,
                                       TInt aContent,
                                       const TDesC16& aText,
                                       TInt aIndex )
    {
    TInt result = KErrNone;
    const TInt count = iObserverOptimizers.Count();
    for ( TInt i = 0; i < count; ++i )
        {
        const TInt r = iObserverOptimizers[i]->Publish( aPlugin, aContent, aText, aIndex );
        if ( r != KErrNone )
            {
            result = r;
            }
        }
    return result;
    }
    
    
TInt CAiMultiContentObserver::Publish( MAiPropertyExtension& aPlugin,
                                       TInt aContent,
                                       const TDesC8& aBuf,
                                       TInt aIndex )
    {
    TInt result = KErrNone;
    const TInt count = iObserverOptimizers.Count();
    for ( TInt i = 0; i < count; ++i )
        {
        const TInt r = iObserverOptimizers[i]->Publish( aPlugin, aContent, aBuf, aIndex );
        if ( r != KErrNone )
            {
            result = r;
            }
        }
    return result;
    }
    
    
TInt CAiMultiContentObserver::Publish( MAiPropertyExtension& aPlugin,
                                       TInt aContent,
                                       RFile& aFile,
                                       TInt aIndex )
    {
    TInt result = KErrNone;
    const TInt count = iObserverOptimizers.Count();
    for ( TInt i = 0; i < count; ++i )
        {
        const TInt r = iObserverOptimizers[i]->Publish( aPlugin, aContent, aFile, aIndex );
        if ( r != KErrNone )
            {
            result = r;
            }
        }
    return result;
    }
    
    
TInt CAiMultiContentObserver::Clean( MAiPropertyExtension& aPlugin,
                                     TInt aContent,
                                     TInt aIndex )
    {
    TInt result = KErrNone;
    const TInt count = iObserverOptimizers.Count();
    for ( TInt i = 0; i < count; ++i )
        {
        const TInt r = iObserverOptimizers[i]->Clean( aPlugin, aContent, aIndex );
        if ( r != KErrNone )
            {
            result = r;
            }
        }
    return result;
    }


TAny* CAiMultiContentObserver::Extension( TUid /*aUid*/ )
    {
    return NULL;
    }

TBool CAiMultiContentObserver::RequiresSubscription( 
    const TAiPublisherInfo& /*aPublisherInfo*/ ) const
    {
    return ETrue;
    }

TInt CAiMultiContentObserver::SetProperty( MAiPropertyExtension& /*aPlugin*/,
           const TDesC8& /*aElementId*/,
           const TDesC8& /*aPropertyName*/,
           const TDesC8& /*aPropertyValue*/ )
    {
        return KErrNotSupported;
    }
   
TInt CAiMultiContentObserver::SetProperty( MAiPropertyExtension& /*aPlugin*/,
           const TDesC8& /*aElementId*/,
           const TDesC8& /*aPropertyName*/,
           const TDesC8& /*aPropertyValue*/,  
           MAiContentObserver::TValueType /*aValueType*/)
    {
    return KErrNotSupported;
    }

CAiMultiContentObserver::CAiMultiContentObserver()
    {
    }

hs_app_ainetworkinfolistener.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network info listener.
*
*/


#include 
#include 
#include "hs_app_ainetworkinfolistener.h"
#include "hs_app_ainetworkinfoobserver.h"
#include "debug.h"

const TInt KAiMessageCacheGranularity = 4;

// ======== MEMBER FUNCTIONS ========

CAiNetworkInfoListener::CAiNetworkInfoListener()
: iKeyProperties( 0, ECmpTInt )
    {
    }


void CAiNetworkInfoListener::ConstructL()
    {
	//Store pointer in TLS
    User::LeaveIfError( Dll::SetTls( this ) );

    //Create network handling engine session.
    iSession = CreateL( *this, iInfo );
    
    iShowOpInd = EFalse;
    //Create message cache
    iMessageCache = new( ELeave )CArrayFixFlat
        ( KAiMessageCacheGranularity );
    }


CAiNetworkInfoListener* CAiNetworkInfoListener::InstanceL()
    {
    CAiNetworkInfoListener* self = static_cast( Dll::Tls() );

    if( !self )
        {
		//If instance of network listener is not already constructed, create it
        self = new( ELeave ) CAiNetworkInfoListener;
        CleanupStack::PushL( self );
        self->ConstructL();
        CleanupStack::Pop( self );
        }

	//increase access count
    self->IncAccessCount();
    return self;
    }


void CAiNetworkInfoListener::Release()
    {
	//Decrease access count, if it goes to zero, delete object.
    if( !DecAccessCount() )
        {
        delete this;
        }
    }


CAiNetworkInfoListener::~CAiNetworkInfoListener()
    {
	//Remove object from TLS
    Dll::SetTls( NULL );
    iObservers.Reset();
    delete iSession;
    delete iMessageCache;
    }


TInt CAiNetworkInfoListener::IncAccessCount()
    {
    return iAccessCount++;
    }

TInt CAiNetworkInfoListener::DecAccessCount()
    {
    return --iAccessCount;
    }


void CAiNetworkInfoListener::AddObserverL( MAiNetworkInfoObserver& aObserver )
    {
	//Removing observer doesn't remove slots from array, removed observers are only
	//set to NULL. Reason for this is found out later on the code. Adding observer
	//first tries to find free slot, if it is not found, observer is appended to the
	//array.
    TInt freeSlot = iObservers.Find( NULL );

    if( freeSlot == KErrNotFound )
        {
        User::LeaveIfError( iObservers.Append( &aObserver ) );
        }
    else
        {
        User::LeaveIfError( iObservers.Insert( &aObserver, freeSlot ) );
        }
    }
    
    
void CAiNetworkInfoListener::RemoveObserver( MAiNetworkInfoObserver& aObserver )
    {
	//Remove observer, removing is done by replacing it with NULL pointer.
    const TInt count( iObservers.Count() );

    for( TInt i( 0 ); i < count; i++ )
        {
        if( iObservers[i] == &aObserver )
            {
            //replace it with NULL
            iObservers.Remove( i );
            iObservers.Insert( NULL, i );
            break;
            }
        }
    }


const TNWInfo& CAiNetworkInfoListener::NetworkInfo() const
    {
    return iInfo;
    }

TBool CAiNetworkInfoListener::IsOperatorIndicatorAllowed() const
    {
    return iShowOpInd;
    }

TBool CAiNetworkInfoListener::MessageReceived( MNWMessageObserver::TNWMessages aMessage )
    {
	//check if the message is in message cache.
    TInt index( KErrNotFound );
    TBool found = ( iMessageCache->FindIsq( aMessage, iKeyProperties, index ) == 0 );
    return found;
    }


void CAiNetworkInfoListener::HandleNetworkMessage( const TNWMessages aMessage )
    {
    __PRINTS("XAI: Handle NW message");
	//Insert message into the message cache. Only one messsage of one type.
    TRAPD( err, iMessageCache->InsertIsqL( aMessage, iKeyProperties ) );
    if( err == KErrAlreadyExists )
        {
        err = KErrNone;
        }
        
    if( err != KErrNone )
        {
        return;        
        }

	iShowOpInd 		= !NotAllowedToDisplayOperatorIndicator( aMessage );
	
	
	TBool hasNetInfoChanged = HasNetworkInfoChanged( aMessage );
	
	if ( !hasNetInfoChanged )
		{
		return;
		}
	
	__PRINT(__DBG_FORMAT("XAI: Show operator indicator %d, info changed %d"), iShowOpInd, hasNetInfoChanged );
	
    const TInt count( iObservers.Count() );


    for( TInt i( 0 ); i < count; i++ )
        {
		//Observer might be NULL. When HandleNetworkInfoChange is called, it may
		//cause deleting of the publisher which means that observer is removed from listener.
		//This is the reason why observer pointers are replaced by NULL when it is removed
		//from this listener. If the slot would be removed, it would easily cause index overflow
		//or missing HandleNetworkInfoChange calls.
		//For example lets assume that we have 5 observers, we are going in loop 3, so variable i
		//has value 2. When third call is done, it would cause two publishers to be deleted and
		//observers removed. Lets assume that these observers are in place 0 and 1. So now we have
		//only 3 observers and the count is still 2. So we miss a call to a observers in index 3 and 4.

        if( iObservers[i] )
            {
            iObservers[i]->HandleNetworkInfoChange( aMessage, iInfo, iShowOpInd );
            }
        }
    }


void CAiNetworkInfoListener::HandleNetworkError( const TNWOperation aOperation, TInt aErrorCode )
    {
    __PRINT(__DBG_FORMAT("XAI: Error code %d"), aErrorCode );
    switch ( aOperation )
        {
        case MNWMessageObserver::ENWGetNetworkProviderName:
            iReceivedMessageFlags |= ENetworkProviderNameReceived;
            iReceivedMessageFlags &= ~ENetworkProviderNameOk;
            iInfo.iNPName.Zero();
            __PRINTS("XAI: NPN error received");
            break;
        case MNWMessageObserver::ENWGetProgrammableOperatorName:
            iReceivedMessageFlags |= EProgrammableOperatorInfoReceived;
            iReceivedMessageFlags &= ~EProgrammableOperatorInfoReceivedOk;
            iInfo.iOperatorNameInfo.iName.Zero();
            __PRINTS("XAI: PON error received");
            break;
        case MNWMessageObserver::ENWGetServiceProviderName:
            iReceivedMessageFlags |= EServiceProviderNameReceived;
            iReceivedMessageFlags &= ~EServiceProviderNameOk;
            iInfo.iServiceProviderNameDisplayReq = RMobilePhone::KDisplaySPNNotRequired;
            iInfo.iSPName.Zero();
            iInfo.iPLMNField.Zero();
            __PRINTS("XAI: SPN error received");
            break;
        default:
            break;
        }
    
    HandleNetworkMessage( TNWMessages( KErrGeneral ) );
    }
    
    
TBool CAiNetworkInfoListener::NotAllowedToDisplayOperatorIndicator( const TNWMessages aMessage )
	{
	// Service provider name must have been fetched.
    // Network provider name must have been fetched.
    // Registration status and network information must have been received.
    // Operator name information must have been received.
    // Device must be camped to a network.
	
	switch ( aMessage )
    	{
        case MNWMessageObserver::ENWMessageNetworkInfoChange:
            iReceivedMessageFlags |= ENetworkInfoChangeReceived;
            break;
        case MNWMessageObserver::ENWMessageNetworkRegistrationStatusChange:
            iReceivedMessageFlags |= ERegistrationStatusReceived;
            break;
        case MNWMessageObserver::ENWMessageNetworkProviderNameChange:
            iReceivedMessageFlags |= 
                ( ENetworkProviderNameReceived + ENetworkProviderNameOk );
            break;
        case MNWMessageObserver::ENWMessageServiceProviderNameChange:
            iReceivedMessageFlags |= 
                ( EServiceProviderNameReceived + EServiceProviderNameOk );
            break;
        case MNWMessageObserver::ENWMessageProgrammableOperatorInfoChange:
            iReceivedMessageFlags |= 
                ( EProgrammableOperatorInfoReceived + 
                  EProgrammableOperatorInfoReceivedOk );
            break;
        case MNWMessageObserver::ENWMessageNetworkProviderNameUpdating:
            iReceivedMessageFlags &= 
                ~( ENetworkProviderNameReceived + ENetworkProviderNameOk );
            break;
        case MNWMessageObserver::ENWMessageServiceProviderNameUpdating:
            iReceivedMessageFlags &= 
                ~( EServiceProviderNameReceived + EServiceProviderNameOk );
            break;
        case MNWMessageObserver::ENWMessageProgrammableOperatorInfoUpdating:
            iReceivedMessageFlags &= 
                ~( EProgrammableOperatorInfoReceived + 
                   EProgrammableOperatorInfoReceivedOk );
            break;       
        default:
            break;
        }
    
    TBool serviceProviderNameFetched( EServiceProviderNameReceived & iReceivedMessageFlags );
    TBool networkProviderNameFetched( ENetworkProviderNameReceived & iReceivedMessageFlags );
    TBool registrationStatusReceived( ERegistrationStatusReceived & iReceivedMessageFlags );
    TBool networkInformationReceived( ENetworkInfoChangeReceived & iReceivedMessageFlags );
    TBool operatorNameInformationReceived(
    	 EProgrammableOperatorInfoReceived & iReceivedMessageFlags );  
    TBool currentNetworkOk( 
    	( ENetworkInfoChangeReceived  & iReceivedMessageFlags ) && 
        ( ERegistrationStatusReceived & iReceivedMessageFlags ) &&
        ( iInfo.iStatus == ENWStatusCurrent ) );  
      
  	return
        !serviceProviderNameFetched ||
        !networkProviderNameFetched ||
        !( registrationStatusReceived && networkInformationReceived 
        	&& operatorNameInformationReceived ) ||
        !currentNetworkOk;              
	}


TBool CAiNetworkInfoListener::HasNetworkInfoChanged( const TNWMessages aMessage )
    {
    TBool result = ETrue;
    
    // pass through
   	if ( aMessage == MNWMessageObserver::ENWMessageCurrentHomeZoneMessage 	||
   	 	 aMessage == MNWMessageObserver::ENWMessageNetworkConnectionFailure	||
   	 	 aMessage == MNWMessageObserver::ENWMessageCurrentCellInfoMessage )
   		{
   		return result;
   		}
    
    result = ( iReceivedMessageFlags != iOldReceivedMessageFlags );
    
    if ( !result )
        {
        // Check if contents of iInfo has changed. Most probable to the 
        // beginning of the expression.
        result = 
            iInfo.iRegistrationStatus != iOldInfo.iRegistrationStatus ||
            iInfo.iStatus != iOldInfo.iStatus ||
            iInfo.iCountryCode != iOldInfo.iCountryCode ||
            iInfo.iNetworkId != iOldInfo.iNetworkId ||
            iInfo.iOperatorNameInfo.iType != 
                iOldInfo.iOperatorNameInfo.iType ||
            iInfo.iOperatorNameInfo.iName != 
                iOldInfo.iOperatorNameInfo.iName ||
            iInfo.iDisplayTag != iOldInfo.iDisplayTag ||
            iInfo.iShortName != iOldInfo.iShortName ||
            iInfo.iLongName != iOldInfo.iLongName ||
            iInfo.iSPName != iOldInfo.iSPName ||
            iInfo.iServiceProviderNameDisplayReq != 
                iOldInfo.iServiceProviderNameDisplayReq ||
            iInfo.iNPName != iOldInfo.iNPName ||
            iInfo.iPLMNField != iOldInfo.iPLMNField;
        }

    iOldReceivedMessageFlags = iReceivedMessageFlags;
    iOldInfo = iInfo;

    return result;
    }

hs_app_ainwspublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network status publisher
*
*/


#include "hs_app_ainwspublisher.h"
#include "aicontentobserver.h"
#include "hs_app_ainetworkinfolistener.h"

#include 
#include 
#include 
#include 
#include 

#include "debug.h"

// Offline profile, from ProfileEngineSDKCRKeys.h
const TInt KOfflineProfileId = 5;

// ======== MEMBER FUNCTIONS ========

CAiNwsPublisher::CAiNwsPublisher()
    {
    iRegistered = ETrue;
    }


void CAiNwsPublisher::ConstructL()
    {
    iListener = CAiNetworkInfoListener::InstanceL();
    iProfileApi = CRepository::NewL( KCRUidProfileEngine );
    }

CAiNwsPublisher* CAiNwsPublisher::NewL()
    {
    CAiNwsPublisher* self = new( ELeave ) CAiNwsPublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiNwsPublisher::~CAiNwsPublisher()
    {
    if( iListener )
        {
        iListener->RemoveObserver( *this );
        iListener->Release();
        }
    delete iProfileApi;
    }


void CAiNwsPublisher::ResumeL()
    {
    iListener->AddObserverL( *this );
    }


void CAiNwsPublisher::Subscribe( MAiContentObserver& aObserver,
								    MAiPropertyExtension& aExtension,
                                    MAiPublishPrioritizer& /*aPrioritizer*/,
                                    MAiPublisherBroadcaster& /*aBroadcaster*/ )
    {
    iContentObserver = &aObserver;
    iExtension = &aExtension;
    }


void CAiNwsPublisher::RefreshL( TBool /*aClean*/ )
    {
    HandleStateChange( iListener->NetworkInfo() );
    }

TBool CAiNwsPublisher::RefreshL( TInt aContentId, TBool aClean )
	{
    if( aContentId == EAiDeviceStatusContentNWStatus )
        {
   	    RefreshL( aClean );
   	    return ETrue;
    	}

    return EFalse;
	}



void CAiNwsPublisher::HandleNetworkInfoChange(
                            const MNWMessageObserver::TNWMessages& /*aMessage*/,
                            const TNWInfo& aInfo,
                            const TBool /*aShowOpInd*/ )
    {
    HandleStateChange( aInfo );
    }

void CAiNwsPublisher::HandleStateChange( const TNWInfo& aInfo )
    {
    switch( aInfo.iRegistrationStatus )
           {
           case ENWNotRegisteredNoService:
               // Fall-through
           case ENWNotRegisteredEmergencyOnly:
               // Fall-through
           case ENWNotRegisteredSearching:
               // Fall-through
           case ENWRegistrationDenied:
               HandleNetworkLost( aInfo.iSelectionSetting );
               break;

           case ENWRegisteredBusy:
               // Fall-through
           case ENWRegisteredOnHomeNetwork:
               // Fall-through
           case ENWRegisteredRoaming:
               HandleNetworkFound();
               break;

           case ENWRegistrationUnknown:
               // Take no action
           default:
               break;
           }
    }

void CAiNwsPublisher::HandleNetworkFound()
    {
    __PRINTS( "XAI: Network found, clean state" );
    iRegistered = ETrue;
    if ( iContentObserver && iExtension )
        {
        iContentObserver->Clean( *iExtension, EAiDeviceStatusContentNWStatus, 0 );
        }
    }

void CAiNwsPublisher::HandleNetworkLost( const TNWNetworkSelectionSetting &aSelectionSetting )
    {
    if( aSelectionSetting == ENWNetworkSelectionManual )
        {
        // See if we were registered before
        if( iRegistered )
            {
            iRegistered = EFalse;

            if( !IsOffLineMode() &&
                    !IsBluetoothSAPConnected() &&
                    iContentObserver &&
                    iExtension )
                {
                __PRINTS( "XAI: Network lost, publish state" );
                iContentObserver->Publish( *iExtension,
                            EAiDeviceStatusContentNWStatus,
                            EAiDeviceStatusResourceNWLost,
                            0 );
                }
            }
        }
    }

TBool CAiNwsPublisher::IsOffLineMode() const
    {
    TInt profileId;
    TInt err = iProfileApi->Get( KProEngActiveProfile, profileId );
    return profileId == KOfflineProfileId && err == KErrNone;
    }

TBool CAiNwsPublisher::IsBluetoothSAPConnected() const
    {
    TInt btSapState( EBTSapNotConnected );
    TInt err = RProperty::Get( KPSUidBluetoothSapConnectionState,
                               KBTSapConnectionState,
                               btSapState );
    return btSapState != EBTSapNotConnected && err == KErrNone;
    }
hs_app_aioperatorlogopublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Operator logo publisher.
*
*/


#include 

#include 
#include 

#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include "hs_app_aioperatorlogopublisher.h"
#include "hs_app_ainetworkinfolistener.h"
#include "hs_app_aidevicestatuscontentmodel.h"
#include "hs_app_aiprioritizer.h"
#include "hs_app_ainwidpriorities.h"
#include "debug.h"

// Operator Logo showing state is OFF.
const TInt KAIDisplayOperatorLogoOff = 0;

// Operator Logo showing state is ON.
const TInt KAIDisplayOperatorLogoOn = 1;

const TInt KAddTwoPixels = 2;
const TInt KMaskBlitStartOffset = -1;
const TInt KMaskBlitEndOffset = 2;


// ======== MEMBER FUNCTIONS ========

CAiOperatorLogoPublisher::CAiOperatorLogoPublisher()
: iPriority( EAiInvalidPriority )
    {
   
    }


void CAiOperatorLogoPublisher::ConstructL()
    {
    __PRINTS("CAiOperatorLogoPublisher:: ConstructL >>");
    iListener = CAiNetworkInfoListener::InstanceL();
    
    iOperatorLogoObserver = AiUtility::CreatePSPropertyObserverL( 
    	TCallBack( HandleOperatorLogoUpdateL, this ), 
    	KPSUidPhoneClientServerInformation, KTelOperatorLogoUpdated );
    
    iCenRep = CRepository::NewL( KCRUidPersonalizationSettings );
    
    iCenRepNotify = CCenRepNotifyHandler::NewL( *this, 
    											*iCenRep,
    											CCenRepNotifyHandler::EIntKey, 
    											KSettingsDisplayOperatorLogo );
    											
    iCenRepNotify->StartListeningL();
    __PRINTS("CAiOperatorLogoPublisher:: ConstructL <<");
    }


CAiOperatorLogoPublisher* CAiOperatorLogoPublisher::NewL()
    {
    CAiOperatorLogoPublisher* self = new( ELeave ) CAiOperatorLogoPublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiOperatorLogoPublisher::~CAiOperatorLogoPublisher()
    {
    __PRINTS("CAiOperatorLogoPublisher:: ~CAiOperatorLogoPublisher >>");
    if( iCenRepNotify )
        {
        iCenRepNotify->StopListening();
        }
    delete iCenRepNotify;
    delete iCenRep;
    if( iListener )
        {
	    iListener->RemoveObserver( *this );
        iListener->Release();
        }
    delete iIcon;
    Release( iOperatorLogoObserver );
    __PRINTS("CAiOperatorLogoPublisher:: ~CAiOperatorLogoPublisher <<");
    }


void CAiOperatorLogoPublisher::ResumeL()
    {
    __PRINTS("CAiOperatorLogoPublisher:: ResumeL >>");
    iListener->AddObserverL( *this );
    __PRINTS("CAiOperatorLogoPublisher:: ResumeL <<");
    }


void CAiOperatorLogoPublisher::HandleNetworkInfoChange(
							const MNWMessageObserver::TNWMessages& /*aMessage*/,
							const TNWInfo& /*aInfo*/,
							const TBool aShowOpInd )
    {
    __PRINT(__DBG_FORMAT("CAiOperatorLogoPublisher:: HandleNetworkInfoChange >> aShowOpInd %d "), aShowOpInd);
        if( aShowOpInd )
        	{
        	TRAP_IGNORE(UpdateOperatorLogoL( ETrue ));
        	}
        else
        	{
        	TRAP_IGNORE (iPrioritizer->TryToCleanL( *iBroadcaster,
            							EAiDeviceStatusContentNetworkIdentity,
            							iPriority ));
        	}
        
    __PRINTS("CAiOperatorLogoPublisher:: HandleNetworkInfoChange <<");
    }


void CAiOperatorLogoPublisher::HandleNotifyInt( TUint32 aId, TInt /*aNewValue*/ )
	{
	__PRINT(__DBG_FORMAT("CAiOperatorLogoPublisher:: HandleNotifyInt >> aId %d "), aId);
    if( aId == KSettingsDisplayOperatorLogo )
        {
        TRAP_IGNORE( UpdateOperatorLogoL( ETrue ) );
        }
    __PRINTS("CAiOperatorLogoPublisher:: HandleNotifyInt <<");
	}
	
	
void CAiOperatorLogoPublisher::Subscribe( MAiContentObserver& aObserver, 
									        MAiPropertyExtension& aExtension,
                                            MAiPublishPrioritizer& aPrioritizer,
                                            MAiPublisherBroadcaster& aBroadcaster )
    {
    iContentObserver = &aObserver;
    iExtension = &aExtension;
    iPrioritizer = &aPrioritizer;
    iBroadcaster = &aBroadcaster;
    }


void CAiOperatorLogoPublisher::RefreshL( TBool aClean )
    {
    __PRINTS("CAiOperatorLogoPublisher:: RefresL >> ");
    TRAP_IGNORE( UpdateOperatorLogoL( aClean ) );
    __PRINTS("CAiOperatorLogoPublisher:: RefresL << ");
    }


CFbsBitmap* CAiOperatorLogoPublisher::LoadLogoL( TInt aMCC, 
                                                 TInt aMNC )
    {
    __PRINT(__DBG_FORMAT("CAiOperatorLogoPublisher:: LoadLogo >> aMCC %d, aMNC %d"), aMCC, aMNC);
    CPhCltImageHandler* imageHandler = CPhCltImageHandler::NewL();       
    User::LeaveIfNull( imageHandler );
    
    CleanupStack::PushL( imageHandler );
    
    // Create image parameter class
    CPhCltImageParams* params = 
    	imageHandler->CPhCltBaseImageParamsL( EPhCltTypeOperatorLogo );
    CleanupStack::PushL( params );
    
    TInt err = KErrNotFound;
    iPriority = EAiOTAOperatorLogo;
    
    CPhCltExtOperatorLogoParams* opLogoParams = 
    	static_cast(params);
	
	if( opLogoParams )
        {
		opLogoParams->SetCodesL( aMCC, aMNC, EPhCltLogoTypeOTA );
		err = imageHandler->LoadImages( params );
		
		if( err == KErrNotFound )
       		{
            // OTA logo wasn't found, try programmable logo
            opLogoParams->SetCodesL( aMCC, aMNC, EPhCltLogoTypeProgrammable );
            err = imageHandler->LoadImages( params );
            iPriority = EAiProgOperatorLogo;
            }        
        }
    else
        {
        err = KErrNotFound;
        }
    __PRINT(__DBG_FORMAT("CAiOperatorLogoPublisher:: LoadLogo >> err %d"), err);
	User::LeaveIfError( err );
	 
	//take always first image, we can show only one logo
    TInt bitmapHandle = params->GetImageL( 0 );
    
    CFbsBitmap* bitmap = new ( ELeave ) CFbsBitmap;
    CleanupStack::PushL( bitmap );
    User::LeaveIfError( bitmap->Duplicate( bitmapHandle ) );

    CleanupStack::Pop( bitmap );
    
    CleanupStack::PopAndDestroy( params );
    CleanupStack::PopAndDestroy( imageHandler );
    __PRINTS("CAiOperatorLogoPublisher:: LoadLogo << ");
    return bitmap;
    }


void CAiOperatorLogoPublisher::UpdateOperatorLogoL( TBool aClean )
    {
    __PRINT(__DBG_FORMAT("CAiOperatorLogoPublisher:: UpdateOperatorLogoL >> aClean %d"), aClean);
    iSuccess = EFalse;
    if( aClean )
        {
        iPrioritizer->TryToCleanL( *iBroadcaster,
        							EAiDeviceStatusContentNetworkIdentity,
        							iPriority );
        }
        
    if( !AllowToShowLogoL() )
        {
        iPrioritizer->TryToCleanL( *iBroadcaster,
        							EAiDeviceStatusContentNetworkIdentity,
        							iPriority );

        delete iIcon;
        iIcon = NULL;
        __PRINTS("CAiOperatorLogoPublisher:: UpdateOperatorLogoL : not allowed to show logo");
        return;
        }

    const TNWInfo& info = iListener->NetworkInfo();

    if ( info.iRegistrationStatus == ENWNotRegisteredNoService ||
    		info.iRegistrationStatus ==ENWRegistrationUnknown )
    	{
    	__PRINTS("CAiOperatorLogoPublisher:: UpdateOperatorLogoL : registrationstatus unknown");
    	return;
    	}

    TInt mcc;

    TLex lex( info.iCountryCode );
    User::LeaveIfError( lex.Val( mcc ) );

    TInt mnc;
    lex.Assign( info.iNetworkId );
    User::LeaveIfError( lex.Val( mnc ) );

    CFbsBitmap* opLogo = NULL;
	CFbsBitmap* opLogoMask = NULL;

    TRAPD( err, opLogo = LoadLogoL( mcc,
    								mnc ) );

	if( err )
        {
        opLogo = NULL;
        }

	if ( opLogo && opLogo->IsMonochrome() )
        {
        __PRINTS("CAiOperatorLogoPublisher:: UpdateOperatorLogoL : monochrome icon");
        CFbsBitmap* bitmap = opLogo;
        opLogo = NULL;

        CleanupStack::PushL( bitmap );
        CreateMonochromeBitmapsL( *bitmap, opLogo, opLogoMask );
        
        CleanupStack::PopAndDestroy( bitmap );
        }

    //clean always, might be that there is old logo published
    //and now the logo isn't valid anymore. So publish clean
    //even if we didn't get new logo
    if( opLogo )
        {
        delete iIcon;
        iIcon = NULL;

        if( opLogoMask )
        	{
        	iIcon = CGulIcon::NewL( opLogo, opLogoMask );
        	}
        else
        	{
        	iIcon = CGulIcon::NewL( opLogo, NULL );
        	}

        opLogo = NULL;
        opLogoMask = NULL;

        TPckg pckg( iIcon );

        iPrioritizer->TryToPublishL( *iBroadcaster,
        							EAiDeviceStatusContentNetworkIdentity,
        							pckg,
        							iPriority );
        __PRINTS("CAiOperatorLogoPublisher:: UpdateOperatorLogoL : logo published ");
        iSuccess = ETrue;
        }
    else
        {
        iPrioritizer->TryToCleanL( *iBroadcaster,
        							EAiDeviceStatusContentNetworkIdentity,
        							iPriority );
        __PRINTS("CAiOperatorLogoPublisher:: UpdateOperatorLogoL : logo cleaned ");
        }
    __PRINTS("CAiOperatorLogoPublisher:: UpdateOperatorLogoL << ");
    }


TBool CAiOperatorLogoPublisher::AllowToShowLogoL() const
    {
    TInt val;
    iCenRep->Get( KSettingsDisplayOperatorLogo, val );
    return val && iListener->IsOperatorIndicatorAllowed();
    }


void CAiOperatorLogoPublisher::CreateMonochromeBitmapsL(
    const CFbsBitmap& aBitmap,
    CFbsBitmap*& aNewLogoMain,
    CFbsBitmap*& aNewLogoMask )
    {
    
    __PRINTS("CAiOperatorLogoPublisher:: CreateMonochromeBitmapsL >> ");
    TSize size = aBitmap.SizeInPixels();
    const TRgb white = TRgb::Gray2( 1 );

    // New size 2 pixels larger in every dimension.
    TSize newSize( size.iWidth + KAddTwoPixels, size.iHeight + KAddTwoPixels );
    TPoint delta( 1, 1 ); // adjust image position.

    TSize opLogoSize;
    TInt err = GetTitlePaneSize( opLogoSize );
    if ( err != KErrNone )
        {
        return;
        }

    if ( newSize.iWidth > opLogoSize.iWidth &&
        size.iWidth <= opLogoSize.iWidth )
        {
        newSize.iWidth = size.iWidth;
        delta.iX = 0;
        }
    if ( newSize.iHeight > opLogoSize.iHeight &&
        size.iHeight <= opLogoSize.iHeight )
        {
        newSize.iHeight = size.iHeight;
        delta.iY = 0;
        }

    // Create mask image
    CFbsBitmap* bitmapLargeMain =
        new (ELeave) CFbsBitmap;
    CleanupStack::PushL( bitmapLargeMain );
    User::LeaveIfError(
        bitmapLargeMain->Create( newSize, EGray2 ) );

    CFbsBitmapDevice* device =
        CFbsBitmapDevice::NewL( bitmapLargeMain );
    CleanupStack::PushL( device );

    CFbsBitGc* gc = NULL;
    User::LeaveIfError( device->CreateContext( gc ) );

    gc->SetPenStyle(CGraphicsContext::ENullPen);
    gc->SetBrushColor( white );
    gc->SetBrushStyle(CGraphicsContext::ESolidBrush);
    gc->Clear();

    gc->BitBlt( TPoint() + delta, &aBitmap );

    delete gc;
    gc = NULL;

    CleanupStack::PopAndDestroy( device );

    // Create main image
    CFbsBitmap* bitmapLargeMask =
        new (ELeave) CFbsBitmap;
    CleanupStack::PushL( bitmapLargeMask );
    User::LeaveIfError(
        bitmapLargeMask->Create( newSize, EGray2 ) );

    CFbsBitmapDevice* deviceMask =
        CFbsBitmapDevice::NewL( bitmapLargeMask );
    CleanupStack::PushL( deviceMask );

    User::LeaveIfError( deviceMask->CreateContext( gc ) );

    gc->SetPenStyle(CGraphicsContext::ENullPen);
    gc->SetBrushColor( white );
    gc->SetBrushStyle(CGraphicsContext::ESolidBrush);
    gc->Clear();
    gc->SetBrushStyle(CGraphicsContext::ENullBrush);

    TPoint point;
    TRect rect( point, size );

    // Blit with mask 3 points from top left to down right.
    for ( TInt j = KMaskBlitStartOffset;
          j < KMaskBlitEndOffset;
          j++ )
        {
        for ( TInt i = KMaskBlitStartOffset;
              i < KMaskBlitEndOffset;
              i++ )
            {
            point = TPoint( i, j );
            point += delta;
            gc->BitBltMasked(
                point, &aBitmap, rect, &aBitmap, ETrue );
            }
        }

    delete gc;
    gc = NULL;

    CleanupStack::PopAndDestroy( deviceMask );

    CleanupStack::Pop( bitmapLargeMask );
    CleanupStack::Pop( bitmapLargeMain );

    aNewLogoMain = bitmapLargeMain;
    aNewLogoMask = bitmapLargeMask;
    __PRINTS("CAiOperatorLogoPublisher:: CreateMonochromeBitmapsL << ");
    }


TInt CAiOperatorLogoPublisher::GetTitlePaneSize( TSize& aSize )
    {
   	TRect titlePaneRect;
    TBool hasTitlePane = AknLayoutUtils::LayoutMetricsRect( 
        AknLayoutUtils::ETitlePane, titlePaneRect );
    
    if ( !hasTitlePane )
        {
        return KErrNotFound;            
        }
    
    TAknLayoutRect oplogoLayout;
    
    if ( AknStatuspaneUtils::StaconPaneActive() )
        {
        // stacon
        oplogoLayout.LayoutRect( titlePaneRect, 
            AknLayoutScalable_Avkon::title_pane_stacon_g2(0).LayoutLine() );    
        }
    else if ( AknStatuspaneUtils::FlatLayoutActive() )
        {
        // flat
        oplogoLayout.LayoutRect( titlePaneRect, 
            AknLayoutScalable_Avkon::title_pane_stacon_g2(0).LayoutLine() );    
        }   
    else
        {
        // usual idle
        oplogoLayout.LayoutRect( titlePaneRect, 
            AknLayout::Title_pane_elements_Line_1() );
        }             
     
    aSize = oplogoLayout.Rect().Size(); 
    
    
    return KErrNone;  
    }


TBool CAiOperatorLogoPublisher::RefreshL( TInt aContentId, TBool aClean )
	{
	
    if(aContentId == EAiDeviceStatusContentNetworkIdentity )
        {
        __PRINTS("CAiOperatorLogoPublisher:: RefreshL >> ");
   	    RefreshL( aClean );
   	    if( iSuccess )
   	        {
   	        __PRINTS("CAiOperatorLogoPublisher:: RefreshL << success ");
   	        return ETrue;
   	        }   
   	    __PRINTS("CAiOperatorLogoPublisher:: RefreshL << failed ");	    
    	}    	
    return EFalse;
	}


TInt CAiOperatorLogoPublisher::HandleOperatorLogoUpdateL( TAny *aPtr )
	{
	__PRINTS("CAiOperatorLogoPublisher::  HandleOperatorLogoUpdateL >> ");
	CAiOperatorLogoPublisher* self = static_cast( aPtr );
    
    TTelOTALogoUpdate logoUpd;
    TTelOTALogoUpdate::TOTALogoUpdatePckg logoUpdPckg( logoUpd );

    if ( RProperty::Get( 
    		KPSUidPhoneClientServerInformation, 
        	KTelOperatorLogoUpdated, 
        	logoUpdPckg ) == KErrNone )
    	{
        __PRINT(__DBG_FORMAT("CAiOperatorLogoPublisher:: HandleOperatorLogoUpdateL >> logoUpd.iEvent %d"), logoUpd.iEvent);
        if ( logoUpd.iEvent == TTelOTALogoUpdate::EPSTelephonyLogoChanged )
        	{
        	if(self)
        		{
        		__PRINTS("CAiOperatorLogoPublisher::  HandleOperatorLogoUpdateL: logo changed ");
        		self->iCenRep->Set( KSettingsDisplayOperatorLogo, KAIDisplayOperatorLogoOn );
        		self->UpdateOperatorLogoL( ETrue );        			
        		}
        	}
        else if ( logoUpd.iEvent == TTelOTALogoUpdate::EPSTelephonyLogoDeleted ||
                  logoUpd.iEvent == TTelOTALogoUpdate::EPSTelephonyAllLogosDeleted )
            {
            if(self)
                {  
                __PRINTS("CAiOperatorLogoPublisher::  HandleOperatorLogoUpdateL: logo deleted ");
        		self->iCenRep->Set( KSettingsDisplayOperatorLogo, KAIDisplayOperatorLogoOff );
        		self->UpdateOperatorLogoL( ETrue );        			            
                }
            }
  
       	}
    __PRINTS("CAiOperatorLogoPublisher::  HandleOperatorLogoUpdateL << ");
    return KErrNone;
	}


TBool CAiOperatorLogoPublisher::RefreshContentWithPriorityL( TInt aContentId, 
                                                                TInt aPriority )
	{
	if( aContentId == EAiDeviceStatusContentNetworkIdentity &&
	    ( aPriority == EAiOTAOperatorLogo || 
	    aPriority == EAiProgOperatorLogo ) )
        {
        __PRINTS("CAiOperatorLogoPublisher::  RefreshContentWithPriorityL >> ");
	    RefreshL( EFalse );
	    if( iSuccess )
	        {
	        __PRINTS("CAiOperatorLogoPublisher::  RefreshContentWithPriorityL << success");
	        return ETrue;	        
	        }
	    __PRINTS("CAiOperatorLogoPublisher::  RefreshContentWithPriorityL << failed");
        }
    return EFalse;
	}
	
hs_app_aioperatornamepublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Operator/Service provider name publisher.
*
*/


#include 
#include 
#include 
#include 
#include 
#include "hs_app_aioperatornamepublisher.h"
#include "hs_app_ainetworkinfolistener.h"
#include "hs_app_aidevicestatuscontentmodel.h"
#include "hs_app_aiprioritizer.h"
#include "hs_app_ainwidpriorities.h"
#include "activeidle2domaincrkeys.h"

//Delay used to animate
const TInt KCleanOperationDelay = 2 * 1000000;


const TInt KBitShiftByFour = 4;
const TInt KIsDigitLowLimit = 0;
const TInt KIsDigitHighLimit = 10;

LOCAL_C void AppendDigit( TDes& aCode, TInt aValue )
    {
    // add a digit if valid value.
    if ( aValue >= KIsDigitLowLimit && aValue < KIsDigitHighLimit )
        {
        aCode.AppendNumUC( static_cast( aValue ) );
        }
    }


//Convert string to integer.
LOCAL_C TInt StrToInt( const TDesC& aDesc )
    {
    TLex lex( aDesc );

    TInt ret;
    TInt err = lex.Val( ret );

    if( err != KErrNone )
        {
        ret = KErrNotFound;
        }
    return ret;
    }


// ======== MEMBER FUNCTIONS ========

CAiOperatorNamePublisher::CAiOperatorNamePublisher()
: iPriority( EAiInvalidPriority )
    {
    }


void CAiOperatorNamePublisher::ConstructL()
    {
    iListener = CAiNetworkInfoListener::InstanceL();
    iPeriodic = CPeriodic::NewL( CActive::EPriorityStandard );
    }


CAiOperatorNamePublisher* CAiOperatorNamePublisher::NewL()
    {
    CAiOperatorNamePublisher* self = new( ELeave ) CAiOperatorNamePublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiOperatorNamePublisher::~CAiOperatorNamePublisher()
    {
    if( iListener )
        {
	    iListener->RemoveObserver( *this );
        iListener->Release();
        }
    if( iPeriodic )
        {
        iPeriodic->Cancel();
        delete iPeriodic;
        }
    }


void CAiOperatorNamePublisher::ResumeL()
    {
    iListener->AddObserverL( *this );
    }


void CAiOperatorNamePublisher::HandleNetworkInfoChange(
                const MNWMessageObserver::TNWMessages& /*aMessage*/,
                const TNWInfo& /*aInfo*/,
                const TBool aShowOpInd )
    {
        if( aShowOpInd )
        	{
        	TRAP_IGNORE  ( RefreshL( ETrue ));
        	}
        else
        	{
        	TRAP_IGNORE (
        		iPrioritizer->TryToCleanL( *iBroadcaster,
            							EAiDeviceStatusContentNetworkIdentity,
            							iPriority ));
        	}
        
    }


void CAiOperatorNamePublisher::Subscribe( MAiContentObserver& /*aObserver*/,
									                MAiPropertyExtension& aExtension,
                                                    MAiPublishPrioritizer& aPrioritizer,
                                                    MAiPublisherBroadcaster& aBroadcaster )
    {
    iExtension = &aExtension;
    iPrioritizer = &aPrioritizer;
    iBroadcaster = &aBroadcaster;
    }


void CAiOperatorNamePublisher::RefreshL( TBool aClean )
    {
    iSuccess = EFalse;

    if( aClean )
        {
        iPrioritizer->TryToCleanL( *iBroadcaster,
                                    EAiDeviceStatusContentNetworkIdentity,
                                    iPriority );
        }

    const TNWInfo& nwInfo = iListener->NetworkInfo();

#if defined(WINSCW) || defined(__WINS__)
    // Show operator name in emulator
#else
    if ( nwInfo.iRegistrationStatus == ENWNotRegisteredNoService ||
    	 	nwInfo.iRegistrationStatus == ENWRegistrationUnknown ||
    	 	!iListener->IsOperatorIndicatorAllowed() )
    	{
    	return;
    	}
#endif

    TBool showSimultaneously = EFalse;

    TUid uid = { KCRUidActiveIdleLV };
    CRepository* cenRep = CRepository::NewLC( uid );
    TInt err = cenRep->Get( KAISPNAndEONS, showSimultaneously );
    if( err )
    	{
    	showSimultaneously = EFalse;
    	}
    CleanupStack::PopAndDestroy( cenRep );
    
    const TBool isKeyLockEnabled = IsKeyLockEnabled();

    //Check if PLMN  must be shown.

    const TBool showPLMN = nwInfo.iServiceProviderNameDisplayReq & ENWDisplayPLMNRequired;

    TBool isInSPDI = EFalse;
    TBool showSPN = EFalse;

    //Check if we are in SPDI and SPN (Service Provider Name) must be shown.
    CheckServiceProviderDisplayListStatus(  StrToInt( nwInfo.iCountryCode ),
                                            StrToInt( nwInfo.iNetworkId ),
                                            showSPN,
                                            isInSPDI );

    //SPN must be shown if it is defined in PLMNField or if it is set in service provider name
    //display requirements.
    showSPN =
        showSPN ||
        ( nwInfo.iServiceProviderNameDisplayReq & ENWDisplaySPNRequired );

    
#if defined(WINSCW) || defined(__WINS__)
    _LIT( KOperator, "Operator" );    
    const TPtrC serviceProviderName( KOperator() );
#else
    const TPtrC serviceProviderName = nwInfo.iSPName;
#endif
        
    if ( ( !IsRoaming() || isInSPDI ) && serviceProviderName.Length() )
        {
        if ( showPLMN )
            {
            if ( showSimultaneously )
            	{
            	//spn & plmn (SPN.And.EONS)
            	HBufC* operatorName = ConstructOperatorNameStringL( serviceProviderName );
            	CleanupStack::PushL( operatorName );

            	iPriority = EAiServiceProviderName;
	            iPrioritizer->TryToPublishL( *iBroadcaster,
	                                        	EAiDeviceStatusContentNetworkIdentity,
	                                        	operatorName->Des(),
	                                        	iPriority );
	            CleanupStack::PopAndDestroy(operatorName);
            	}
            else if( isKeyLockEnabled )
            	{
            	//only plmn
        		ShowNetworkIdentityNameL( ETrue );
            	}
            else
            	{
	            //spn & plmn (SPN.And.EONS.No)
	            iPriority = EAiServiceProviderName;
	            iPrioritizer->TryToPublishL( *iBroadcaster,
	                                        	EAiDeviceStatusContentNetworkIdentity,
	                                        	serviceProviderName,
	                                        	iPriority );
	            StartDelayedPLMNOperation();//to publish PLMN name
            	}
            }
        else
            {
            //only spn
            iPriority = EAiServiceProviderName;
            iPrioritizer->TryToPublishL( *iBroadcaster,
                                            EAiDeviceStatusContentNetworkIdentity,
                                            serviceProviderName,
                                            iPriority );
            iSuccess = ETrue;
            }
        }
    else
        {
        if ( showSPN && serviceProviderName.Length() )
            {
            if ( showSimultaneously )
            	{
            	//spn & plmn (SPN.And.EONS)
            	HBufC* operatorName = ConstructOperatorNameStringL( serviceProviderName );
            	CleanupStack::PushL( operatorName );

            	iPriority = EAiServiceProviderName;
	            iPrioritizer->TryToPublishL( *iBroadcaster,
	                                        	EAiDeviceStatusContentNetworkIdentity,
	                                        	operatorName->Des(),
	                                        	iPriority );
	            CleanupStack::PopAndDestroy(operatorName);
            	}
            else if( isKeyLockEnabled )
            	{
            	//only plmn
        		ShowNetworkIdentityNameL( ETrue );
            	}
            else
            	{
	            //spn & plmn (SPN.And.EONS.No)
	            iPriority = EAiServiceProviderName;
	            iPrioritizer->TryToPublishL( *iBroadcaster,
	                                        	EAiDeviceStatusContentNetworkIdentity,
	                                        	serviceProviderName,
	                                        	iPriority );
	            StartDelayedPLMNOperation();//to publish PLMN name
            	}
            }
		else
        	{
        	//only plmn
        	ShowNetworkIdentityNameL( ETrue );
        	}
        }
    }

HBufC* CAiOperatorNamePublisher::ConstructOperatorNameStringL( const TDesC& aServiceProviderName )
	{
	ShowNetworkIdentityNameL( EFalse );

    CCoeEnv* coeEnv = CCoeEnv::Static();
    HBufC* opnSpnFormatString = StringLoader::LoadLC( R_AI_OPN_SPN_SEPARATOR_FORMAT,
            													coeEnv );
    HBufC* opnSpnStringTemp = HBufC::NewLC( iNetworkIdentityName.Length()
            									+ opnSpnFormatString->Length()
            									+ aServiceProviderName.Length() );

    HBufC* opnSpnString = HBufC::NewLC( iNetworkIdentityName.Length()
            									+ opnSpnFormatString->Length()
            									+ aServiceProviderName.Length() );

    TPtr opnSpnStringTempPtr = opnSpnStringTemp->Des();
    StringLoader::Format( opnSpnStringTempPtr,
    					*opnSpnFormatString,
    					1,
    					aServiceProviderName );

    TPtr opnSpnStringPtr = opnSpnString->Des();
	StringLoader::Format( opnSpnStringPtr,
						  opnSpnStringTempPtr,
						  0,
						  iNetworkIdentityName );

	CleanupStack::Pop( opnSpnString );
	CleanupStack::PopAndDestroy( opnSpnStringTemp ); //opnSpnStringTemp, opnSpnFormatString
	CleanupStack::PopAndDestroy( opnSpnFormatString );

	return opnSpnString;
	}



void CAiOperatorNamePublisher::ShowNetworkIdentityNameL( TBool aTryToPublish )
	{
	const TNWInfo& nwInfo = iListener->NetworkInfo();

	iNetworkIdentityName.Set( KNullDesC );

	iPriority = EAiInvalidPriority;

	// *** Network operator name (CPHS-ONS) ***
    if( nwInfo.iNPName.Length() > 0 &&
    		nwInfo.iOperatorNameInfo.iType != RMmCustomAPI::EOperatorNameFlexiblePlmn  &&
    			nwInfo.iRegistrationStatus == ENWRegisteredOnHomeNetwork )
    	{
    	//priority
    	iPriority = EAiNetworkOperatorName;
    	//name
    	iNetworkIdentityName.Set( nwInfo.iNPName );
    	//publish network identity name
    	if( aTryToPublish )
    		{
			iPrioritizer->TryToPublishL( *iBroadcaster,
                               	   		EAiDeviceStatusContentNetworkIdentity,
                                    	iNetworkIdentityName,
                                    	iPriority );
    		}

        iSuccess = ETrue;
    	return;
    	}

    // *** Operator name ***
    if( nwInfo.iOperatorNameInfo.iName.Length() > 0 )
    	{
    	//priority
    	OperatorNamePriority( iPriority );
    	//name
    	iNetworkIdentityName.Set( nwInfo.iOperatorNameInfo.iName );
    	//converted name
	    HBufC* convertedOperatorName = NULL;

	    if ( nwInfo.iOperatorNameInfo.iType == RMmCustomAPI::EOperatorNameFlexiblePlmn )
	        {
	        // Long & short name may be in the same buffer.
	        const TInt separatorPos = iNetworkIdentityName.Locate( KFlexibleNameSeparator );
	        if ( separatorPos != KErrNotFound )
	            {
	            convertedOperatorName = nwInfo.iOperatorNameInfo.iName.Left( separatorPos ).AllocLC();
	            }
	        }
	    else if ( nwInfo.iOperatorNameInfo.iType ==
	                  RMmCustomAPI::EOperatorNameMccMnc ||
	              nwInfo.iOperatorNameInfo.iType ==
	                  RMmCustomAPI::EOperatorNameCountryMcn )
	        {
	        // Perform display language specific conversion.
	        convertedOperatorName = nwInfo.iOperatorNameInfo.iName.AllocLC();
	        TPtr ptr = convertedOperatorName->Des();
	        AknTextUtils::DisplayTextLanguageSpecificNumberConversion( ptr );
	        }
	    else
	        {
	        // No changes needed.
	        }

		if ( convertedOperatorName )
	        {
	        iNetworkIdentityName.Set( *convertedOperatorName );
	        }

		if( iPriority != EAiInvalidPriority )
			{
			//Publish network identity name
			if( aTryToPublish )
    			{
				iPrioritizer->TryToPublishL( *iBroadcaster,
	                               			EAiDeviceStatusContentNetworkIdentity,
	                                		iNetworkIdentityName,
	                                		iPriority );
    			}

	        iSuccess = ETrue;
			}

		if ( convertedOperatorName )
	        {
	        CleanupStack::PopAndDestroy( convertedOperatorName );
	        convertedOperatorName = NULL;
	        }

		if( iPriority != EAiInvalidPriority )
	    	{
	    	return;
	    	}
	    }

	// *** Network info name ***
	if( iPriority == EAiInvalidPriority )
		{
	    //priority
	    iPriority = EAiOperatorNetInfoName;

	    if ( nwInfo.iLongName.Length() > 0 )
			{
		    iNetworkIdentityName.Set( nwInfo.iLongName );
		    }
		else if ( nwInfo.iShortName.Length() > 0 )
		    {
		    iNetworkIdentityName.Set( nwInfo.iShortName );
		    }
		else if ( nwInfo.iDisplayTag.Length() > 0 )
		    {
		    iNetworkIdentityName.Set( nwInfo.iDisplayTag );
		    }
		else
		   	{
		    iPriority = EAiInvalidPriority;
		    }

		//Publish network identity name
		if( aTryToPublish )
    		{
			iPrioritizer->TryToPublishL( *iBroadcaster,
	                               		EAiDeviceStatusContentNetworkIdentity,
	                                	iNetworkIdentityName,
	                                	iPriority );
    		}

	    iSuccess = ETrue;
	    return;
	    }
	}


void CAiOperatorNamePublisher::CheckServiceProviderDisplayListStatus(
    TInt aMCC,
    TInt aMNC,
    TBool& aShowSPN,
    TBool& aIsInSPDI ) const
    {

    // Not in list by default
    aIsInSPDI = EFalse;
    aShowSPN = EFalse;

    if ( !CurrentNetworkOk() )
        {
        return;
        }


    const TNWInfo& nwInfo = iListener->NetworkInfo();

    TInt bufferLength = nwInfo.iPLMNField.Length();
     if ( !bufferLength )
        {
        return;
        }

    const TUint8* field =
        reinterpret_cast< const TUint8* >( nwInfo.iPLMNField.Ptr() );

    TInt octetIndex = 0;

    // Update SPN showing. (in 3GPP a tag).
    aShowSPN = static_cast( field[ octetIndex ] ) ? EFalse : ETrue ;
    octetIndex++;

    // Number of PLMN pairs. (in 3GPP number of octets).
    const TUint8 length = static_cast( ( field[ octetIndex ] ) );
    octetIndex++;

    // Empty list (always with SIM and sometimes with UICC)
    if ( !( length > 0 ) )
        {
        return;
        }

    // Compare MCC&MNC pairs
    TNWCountryCode mcc;
    TNWIdentity    mnc;

    const TUint numberOfPairs = length;      // each pair has 3 octets

    for( TUint pair = 0; pair < numberOfPairs; pair++ )
        {
        // 1st octet
        AppendDigit( mcc, field[ octetIndex ] & 0x0F );
        AppendDigit( mcc, ( field[ octetIndex ] & 0xF0 ) >> KBitShiftByFour );
        octetIndex++;

        // 2nd octet
        AppendDigit( mcc, field[ octetIndex ] & 0x0F );
        TInt tmp = ( field[ octetIndex ] & 0xF0 ) >> KBitShiftByFour;
        octetIndex++;

        // 3rd octet
        AppendDigit( mnc, field[ octetIndex ] & 0x0F );
        AppendDigit( mnc, ( field[ octetIndex ] & 0xF0 ) >> KBitShiftByFour );
        octetIndex++;

        AppendDigit( mnc, tmp ); // mnc 3rd digit.

        TInt imcc = StrToInt( mcc );
        TInt imnc = StrToInt( mnc );

        if ( ( aMNC == imnc ) && ( aMCC == imcc ) )
            {
            // match.
            aIsInSPDI = ETrue;
            break;
            }


        // Reset
        mnc.Zero();
        mcc.Zero();
        }
    }


TBool CAiOperatorNamePublisher::CurrentNetworkOk() const
    {
    TBool ok = iListener->MessageReceived(
                            MNWMessageObserver::ENWMessageNetworkInfoChange ) ||
               iListener->MessageReceived(
                            MNWMessageObserver::ENWMessageNetworkRegistrationStatusChange );

    ok = ok & ( iListener->NetworkInfo().iStatus == ENWStatusCurrent );

    return ok;
    }


TBool CAiOperatorNamePublisher::IsRoaming() const
    {
    const TNWInfo& nwInfo = iListener->NetworkInfo();

    return iListener->MessageReceived(
                MNWMessageObserver::ENWMessageNetworkRegistrationStatusChange ) &&
           ( nwInfo.iRegistrationStatus == ENWRegisteredRoaming );
    }



void CAiOperatorNamePublisher::StartDelayedPLMNOperation()
    {
    if( !iPeriodic->IsActive() )
        {
        iPeriodic->Start( KCleanOperationDelay,
                          0,
                          TCallBack( CleanAndShowPLMNOperationCallback, this ) );
        }
    }


TInt CAiOperatorNamePublisher::CleanAndShowPLMNOperationCallback( TAny* aPtr )
    {
    CAiOperatorNamePublisher* self =
                    static_cast( aPtr );

    if( self )
        {
        TRAP_IGNORE
            (
            //clean
            self->DoCleanOperationL();
            //show PLMN name
            self->ShowNetworkIdentityNameL( ETrue );
            );
        }

    return KErrNone;
    }


void CAiOperatorNamePublisher::DoCleanOperationL()
    {
    iPrioritizer->TryToCleanL( *iBroadcaster,
                                EAiDeviceStatusContentNetworkIdentity,
                                EAiServiceProviderName );
    iPeriodic->Cancel();
    }


TBool CAiOperatorNamePublisher::RefreshL( TInt aContentId, TBool aClean )
	{
    if( aContentId == EAiDeviceStatusContentNetworkIdentity )
        {
   	    RefreshL( aClean );
   	    if( iSuccess )
   	        {
   	        return ETrue;
   	        }
    	}

    return EFalse;
	}


TBool CAiOperatorNamePublisher::RefreshContentWithPriorityL(
                                            TInt aContentId,
                                            TInt aPriority )
	{
	if( aContentId == EAiDeviceStatusContentNetworkIdentity && aPriority == EAiServiceProviderName )
        {
	    RefreshL( EFalse );
	    if( iSuccess )
   	        {
   	        return ETrue;
   	        }
        }
    return EFalse;
	}


TBool CAiOperatorNamePublisher::OperatorNamePriority( TInt& aPriority )
	{
	TBool succeeded = ETrue;

	const TNWInfo& nwInfo = iListener->NetworkInfo();

    switch ( nwInfo.iOperatorNameInfo.iType )
    	{
        case RMmCustomAPI::EOperatorNameFlexiblePlmn:
        	aPriority = EAiFlexiblePLMN;
            break;

       	case RMmCustomAPI::EOperatorNameNitzFull:
            aPriority = EAiNITZ;
            break;

        case RMmCustomAPI::EOperatorNameNitzShort:
            aPriority = EAiNITZ;
            break;

        case RMmCustomAPI::EOperatorNameProgrammableUcs2:
            aPriority = EAiUnicodeOperatorName;
            break;

        case RMmCustomAPI::EOperatorNameProgrammableLatin:
            aPriority = EAiLatinOperatorName;
            break;

        case RMmCustomAPI::EOperatorNameHardcodedUcs2:
            aPriority = EAiUnicodeOperatorName;
            break;

        case RMmCustomAPI::EOperatorNameHardcodedLatin:
            aPriority = EAiLatinOperatorName;
            break;

        case RMmCustomAPI::EOperatorNameCountryMcn:
            aPriority = EAiCountryMNC;
            break;

        case RMmCustomAPI::EOperatorNameMccMnc:
            aPriority = EAiMCC_MCN;
            break;

        default:
        	aPriority = EAiInvalidPriority;
        	succeeded = EFalse;
            break;
       	}
    return succeeded;
	}

TBool CAiOperatorNamePublisher::IsKeyLockEnabled()
	{
    TInt value;
    TInt err = RProperty::Get(KPSUidAvkonDomain, KAknKeyguardStatus, value);
    if ( err != KErrNone ) 
    	return EFalse;
    switch( value ) 
    	{
        case EKeyguardLocked:
        case EKeyguardAutolockEmulation:
        	return ETrue;
        case EKeyguardNotActive:
        default:
        	return EFalse;
       	}
  	}

hs_app_aiprofilepublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Profile publisher
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include "hs_app_aiprofilepublisher.h"
#include "hs_app_aiprioritizer.h"
#include "hs_app_ainwidpriorities.h"

// ======== MEMBER FUNCTIONS ========

// PUA code for the timed profile, missing from PUAcodes.hrh
#define KAiTimedProfilePUA 0xF815

CAiProfilePublisher::CAiProfilePublisher() : 
    iLastPublishedProfileId(ENothingPublished),
    iLastPublishedProfileSilent( EFalse ),
    iLastPublishedProfileTimed( EFalse )
    {
    }


void CAiProfilePublisher::ConstructL()
    {
    User::LeaveIfError( iSSSettings.Open() );

    iProfileEngine = CreateProfileEngineL();
    }


CAiProfilePublisher* CAiProfilePublisher::NewL()
    {
    CAiProfilePublisher* self = new( ELeave ) CAiProfilePublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiProfilePublisher::~CAiProfilePublisher()
    {
    //TRAP_IGNORE: leaving function called in non-leaving function
    TRAP_IGNORE(CleanLastProfileL());
    iSSSettings.CancelAll( *this );
    iSSSettings.Close();
    delete iProfileNotifier;

    if( iProfileEngine )
        {
        iProfileEngine->Release();
        }     
    }


void CAiProfilePublisher::ResumeL()
    {
  User::LeaveIfError( iSSSettings.Open() );
  //Register to listen ALS activation, if ALS status changes,
  //profile must be republished.
    TInt err = iSSSettings.Register( ESSSettingsAls, *this );

    if( err == KErrNotSupported ||
        err == KErrAlreadyExists )
        {
        //ALS not supported or already registered, that's fine
        err = KErrNone;
        }

    User::LeaveIfError( err );

  //Start to listen profile changes.
    delete iProfileNotifier;
    iProfileNotifier = NULL;
    iProfileNotifier = CProfileChangeNotifyHandler::NewL( this );
    }


void CAiProfilePublisher::Subscribe( MAiContentObserver& aObserver, 
                      MAiPropertyExtension& aExtension,
                                        MAiPublishPrioritizer& aPrioritizer,
                                        MAiPublisherBroadcaster& aBroadcaster )
    {
    iContentObserver = &aObserver;
    iExtension = &aExtension;
    iPrioritizer = &aPrioritizer;
    iBroadcaster = &aBroadcaster;
    }


void CAiProfilePublisher::RefreshL( TBool aClean )
    {
    TRAP_IGNORE( RefreshProfileL( aClean ) );
    }


void CAiProfilePublisher::PhoneSettingChanged( TSSSettingsSetting aSetting,
                        TInt /*aNewValue*/ )
    {
    if( aSetting == ESSSettingsAls )
        {
        //refresh profile, can't do much if it doesn't work
        TRAP_IGNORE( RefreshProfileL( ETrue ) );
        }
    }


void CAiProfilePublisher::HandleActiveProfileEventL(
              TProfileEvent aProfileEvent,
              TInt /*aProfileId*/ )
    {
  //Profile activated or modified.
    if( ( aProfileEvent == EProfileNewActiveProfile ) ||
      ( aProfileEvent == EProfileActiveProfileModified ) )
        {
        iActiveProfilePublish = ETrue; 
        RefreshProfileL( ETrue );
        }
    }


void CAiProfilePublisher::CleanLastProfileL()
    {
    if ( iLastPublishedProfileSilent )
        {
        iContentObserver->Clean( *iExtension,
                                  EAiDeviceStatusContentSilentIndicator,
                                  0 );
        iLastPublishedProfileSilent = EFalse;
        }
    
    if ( iLastPublishedProfileTimed )
        {
        iContentObserver->Clean( *iExtension,
                                  EAiDeviceStatusContentTimedProfileIndicator,
                                  0 );
        iLastPublishedProfileTimed = EFalse;
        }
    
    if( iLastPublishedProfileId == EGeneralProfilePublished )
      {
        iContentObserver->Clean( *iExtension,
                                  EAiDeviceStatusContentGeneralProfileName,
                                  0 );
        }
    else if( iLastPublishedProfileId == EOfflineProfilePublished )
      {
      iPrioritizer->TryToCleanL( *iBroadcaster,
                                  EAiDeviceStatusContentNetworkIdentity,
                                  EAiOfflineProfile );
      }
    else
      {
      iContentObserver->Clean( *iExtension,
                                EAiDeviceStatusContentProfileName,
                                0 );  
      }

    iLastPublishedProfileId = ENothingPublished;
    iActiveProfilePublish = EFalse;
    }


void CAiProfilePublisher::RefreshProfileL( TBool aClean )
    {
    // Profile is changed or Refresh is called for some other reason
    //  -> re-publish profile
    iSuccess = EFalse;
    if( !iContentObserver )
        {
        return;
        }

    MProfile* profile = iProfileEngine->ActiveProfileLC();

    const MProfileName& name = profile->ProfileName();
    
    TInt profileNameId = name.Id();
    
    if( ( aClean && iLastPublishedProfileId != profileNameId ) || iActiveProfilePublish ) 
        {
        CleanLastProfileL();
        }

    switch( profileNameId )
        {
        case EProfileGeneralId:
            {
            iContentObserver->Publish( *iExtension,
                                        EAiDeviceStatusContentGeneralProfileName,
                                        name.Name(),
                                        0 );
            break;
            }
            
        case EProfileOffLineId:
            {
            iContentObserver->Publish( *iExtension,
                                        EAiDeviceStatusContentGeneralProfileName,
                                        name.Name(),
                                        0 );

            iPrioritizer->TryToPublishL( *iBroadcaster,
                                          EAiDeviceStatusContentNetworkIdentity,
                                          name.Name(),
                                          EAiOfflineProfile );
            iSuccess = ETrue;
            break;
            }
          
        default:
            {
            iContentObserver->Publish( *iExtension,
                                        EAiDeviceStatusContentProfileName,
                                        name.Name(),
                                        0 );
            break;
            }
        }

    iLastPublishedProfileId = (TLastPublishedProfile)profileNameId;
        
    if ( iProfileEngine->IsActiveProfileTimedL() )
        {
        TBuf<1> timed; // one character
        timed.Append( KAiTimedProfilePUA );
        iContentObserver->Publish( *iExtension,
                                    EAiDeviceStatusContentTimedProfileIndicator,
                                    timed,
                                    0 );
        iLastPublishedProfileTimed = ETrue;
        }

  //If profile is silent, publish silent indicator.
    if( profile->IsSilent() )
        {
        TBuf<1> silent; // one character
        silent.Append( KPuaCodeSilentSymbol );
        iContentObserver->Publish( *iExtension,
                                    EAiDeviceStatusContentSilentIndicator,
                                    silent,
                                    0 );
        iLastPublishedProfileSilent = ETrue;
        }

    CleanupStack::PopAndDestroy();//profile
    }


TBool CAiProfilePublisher::RefreshL( TInt aContentId, TBool aClean )
  {
    switch( aContentId )
        {
        case EAiDeviceStatusContentProfileName:
        case EAiDeviceStatusContentGeneralProfileName:
        case EAiDeviceStatusContentNetworkIdentity:
          {
          RefreshProfileL( aClean );
          return ETrue;
          }
      }
    return EFalse;
  }


TBool CAiProfilePublisher::RefreshContentWithPriorityL( TInt aContentId, 
                                                        TInt aPriority )
  {
  if( aContentId == EAiDeviceStatusContentNetworkIdentity &&
      aPriority == EAiOfflineProfile )
        {
      RefreshProfileL( EFalse );
      if( iSuccess )
          {
          return ETrue;    
          }
        }
    return EFalse;
  }
hs_app_aipublisherfactory.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Static factory class used to create publishers.
*
*/


#include "hs_app_aipublisherfactory.h"

// Publishers
#include "hs_app_aiprofilepublisher.h"
#include "hs_app_aidatepublisher.h"
#include "hs_app_aioperatorlogopublisher.h"
#include "hs_app_aioperatornamepublisher.h"
#include "hs_app_aibtsappublisher.h"
#include "hs_app_aimcnpublisher.h"
#include "hs_app_aicugpublisher.h"
#include "hs_app_aivhzpublisher.h"
#include "hs_app_ainwspublisher.h"
#include "hs_app_aisimregpublisher.h"
#include "hs_app_aicugmcnpublisher.h"

template
class TPublisherFactory
    {
    public:
    MAiDeviceStatusPublisher* CreatePublisherL()
        {
		//Create publisher..
        MAiDeviceStatusPublisher* publisher = NULL;
        TRAPD( err, publisher = T::NewL() );

		//If publisher creation fails with error code KErrNotSupported,
		//return NULL.
        if( err == KErrNotSupported )
            {
            err = KErrNone;
            }

        User::LeaveIfError( err );

        return publisher;
        }
    };


MAiDeviceStatusPublisher* AiPublisherFactory::CreateProfilePublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }


MAiDeviceStatusPublisher* AiPublisherFactory::CreateDatePublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }


MAiDeviceStatusPublisher* AiPublisherFactory::CreateOperatorLogoPublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }


MAiDeviceStatusPublisher* AiPublisherFactory::CreateOperatorNamePublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }


MAiDeviceStatusPublisher* AiPublisherFactory::CreateBTSAPPublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }


MAiDeviceStatusPublisher* AiPublisherFactory::CreateMCNPublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }


MAiDeviceStatusPublisher* AiPublisherFactory::CreateCUGPublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }


MAiDeviceStatusPublisher* AiPublisherFactory::CreateSimRegPublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }


MAiDeviceStatusPublisher* AiPublisherFactory::CreateNWSPublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }


MAiDeviceStatusPublisher* AiPublisherFactory::CreateVHZPublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }

MAiDeviceStatusPublisher* AiPublisherFactory::CreateCUGMCNPublisherL()
    {
    TPublisherFactory factory;
    return factory.CreatePublisherL();
    }
hs_app_aipublishprioritizer.cpp
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network identity related prioritizer.
*
*/


#include "hs_app_aipublishprioritizer.h"
#include "hs_app_ainwidpriorities.h"
#include "hs_app_aidevicestatuscontentmodel.h"
#include 
#include "aipropertyextension.h"
#include "hs_app_aipublisherbroadcaster.h"
#include "debug.h"


CAiPublishPrioritizer::CAiPublishPrioritizer( 
                                        MAiContentObserver& aContentObserver,
                                        MAiPropertyExtension& aPropertyExtension )
    : iContentObserver( aContentObserver ),
        iPropertyExtension( aPropertyExtension ),
        iPriority( EAiInvalidPriority )
    {
    }


CAiPublishPrioritizer* CAiPublishPrioritizer::NewL( 
                                        MAiContentObserver& aContentObserver,
                                        MAiPropertyExtension& aPropertyExtension )
    {
    return new( ELeave ) CAiPublishPrioritizer( aContentObserver, 
                                                aPropertyExtension );
    }


CAiPublishPrioritizer::~CAiPublishPrioritizer()
    {
    }


void CAiPublishPrioritizer::TryToPublishL( MAiPublisherBroadcaster& /*aBroadcaster*/, 
                                            TInt aContent, 
                                            TInt aResource, 
                                            TInt aPriority )
    {
    if( aPriority >= iPriority )
        {
        iPriority = aPriority;
        (void)iContentObserver.Publish( iPropertyExtension, 
                                            aContent, 
                                            aResource, 
                                            0 );
        }
    }


void CAiPublishPrioritizer::TryToPublishL( MAiPublisherBroadcaster& /*aBroadcaster*/, 
                                            TInt aContent, 
                                            const TDesC16& aText, 
                                            TInt aPriority )
    {
    __PRINT(__DBG_FORMAT("XAI: prio publish - content %d, priority %d, text %S"), aContent, aPriority, &aText );
    
    if( aPriority >= iPriority )
        {
        __PRINTS("XAI: prio publish - priority check ok");
        iPriority = aPriority;
        (void)iContentObserver.Publish( iPropertyExtension, 
                                            aContent, 
                                            aText, 
                                            0 );
        }
        
    __PRINTS("XAI: prio publish - done");
    }


void CAiPublishPrioritizer::TryToPublishL( MAiPublisherBroadcaster& /*aBroadcaster*/, 
                                            TInt aContent, 
                                            const TDesC8& aBuf, 
                                            TInt aPriority )
    {
    if( aPriority >= iPriority )
        {
        iPriority = aPriority;
        (void)iContentObserver.Publish( iPropertyExtension, 
                                            aContent, 
                                            aBuf, 
                                            0 );
        }
    }
                            

void CAiPublishPrioritizer::TryToCleanL( MAiPublisherBroadcaster& aBroadcaster, 
                                        TInt aContent, 
                                        TInt aPriority )
    {
    __PRINT(__DBG_FORMAT("XAI: prio clean - content %d, priority %d"), aContent, aPriority );
    if( aPriority == EAiInvalidPriority )
        {
        // do nothing
        return;
        }
        
    else if( aPriority == iPriority )
        {
        __PRINTS("XAI: prio clean - priority matched");
        // Clean the current content...
        (void)iContentObserver.Clean( iPropertyExtension, aContent, 0 );

        TInt currentPriority = iPriority;
        iPriority = EAiInvalidPriority;

        TBool refreshed = EFalse;
        while( --currentPriority != EAiInvalidPriority && !refreshed )
        	{
        	__PRINT(__DBG_FORMAT("XAI: prio clean - refreshing %d"), currentPriority );
        	refreshed = aBroadcaster.RefreshPriorizedPublishersL( aContent, 
        	                                                currentPriority );
        	if( refreshed )
        	    {
                __PRINTS("XAI: prio clean - refresh success");        	    
        	    }
        	else
        	    {
                __PRINTS("XAI: prio clean - refresh failed");        	    
        	    }
        	}
        }
    }
hs_app_aisimregpublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  SIM registration status publisher
*
*/


#include "hs_app_aisimregpublisher.h"
#include "aicontentobserver.h"
#include "hs_app_ainetworkinfolistener.h"
#include 
#include 

#include 

// ======== LOCAL FUNCTIONS =======

TBool AllowedToShowSimRegFailed()
    {
    TInt simCardStatus = ESimStatusUninitialized;
    TInt err = RProperty::Get( KPSUidStartup, KPSSimStatus, simCardStatus );

    // Show note only when the SIM is usable
    if( err == KErrNone && simCardStatus == ESimUsable )
        {
        return ETrue;
        }
    return EFalse;
    }


// ======== MEMBER FUNCTIONS ========

CAiSimRegPublisher::CAiSimRegPublisher()
    {
    }


void CAiSimRegPublisher::ConstructL()
    {
    iListener = CAiNetworkInfoListener::InstanceL();
    }


CAiSimRegPublisher* CAiSimRegPublisher::NewL()
    {
    CAiSimRegPublisher* self = new( ELeave ) CAiSimRegPublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiSimRegPublisher::~CAiSimRegPublisher()
    {
    if( iListener )
        {
        iListener->RemoveObserver( *this );
        iListener->Release();
        }
    }


void CAiSimRegPublisher::ResumeL()
    {
    iListener->AddObserverL( *this );
    }


void CAiSimRegPublisher::Subscribe( MAiContentObserver& aObserver,
								    MAiPropertyExtension& aExtension,
                                    MAiPublishPrioritizer& /*aPrioritizer*/,
                                    MAiPublisherBroadcaster& /*aBroadcaster*/ )
    {
    iContentObserver = &aObserver;
    iExtension = &aExtension;
    }


void CAiSimRegPublisher::RefreshL( TBool /*aClean*/ )
    {
    TInt status = EPSSimRegFailedMessageNotReceived;
    RProperty::Get(
	    KPSUidAiInformation,
        KActiveIdleSimRegFailedReceived,
        status );
    //this cannot be refreshed
    switch( iListener->NetworkInfo().iRegistrationStatus )
        {
        case ENWRegistrationUnknown:
        case ENWNotRegisteredNoService:
        case ENWNotRegisteredEmergencyOnly:
        case ENWRegistrationDenied: // fallthrough
            {
            if( status == EPSSimRegFailedMessageReceived &&
                ::AllowedToShowSimRegFailed() )
            	{
            	iContentObserver->Publish( *iExtension,
            	        EAiDeviceStatusContentSIMRegStatus,
            	        EAiDeviceStatusResourceSIMRegFail,
            	        0 );
            	}
            break;
            }
        case ENWRegisteredOnHomeNetwork:
        case ENWRegisteredRoaming:
        case ENWRegisteredBusy: // fallthrough
            {
            if( status == EPSSimRegFailedMessageReceived )
                {
                iContentObserver->Clean( *iExtension,
                	EAiDeviceStatusContentSIMRegStatus,
                	0 );
                }
            break;
            }
        default:
            {
            // no op
            break;
            }
        }
    }


void CAiSimRegPublisher::HandleNetworkInfoChange(
							const MNWMessageObserver::TNWMessages& aMessage,
							const TNWInfo& aInfo,
							const TBool /*aShowOpInd*/ )
    {
    if ( aMessage ==
    		MNWMessageObserver::ENWMessageNetworkConnectionFailure &&
    		::AllowedToShowSimRegFailed())
        {

        // SIM registration failed. Publish SIM registration status.
        iContentObserver->Publish( *iExtension,
                EAiDeviceStatusContentSIMRegStatus,
                EAiDeviceStatusResourceSIMRegFail,
                0 );
        RProperty::Set(
                KPSUidAiInformation,
                KActiveIdleSimRegFailedReceived,
                EPSSimRegFailedMessageReceived );
        }

    else if ( aMessage ==
    		MNWMessageObserver::ENWMessageNetworkRegistrationStatusChange )
        {
        switch ( aInfo.iRegistrationStatus )
            {
            case ENWRegisteredOnHomeNetwork:
            case ENWRegisteredRoaming:
            case ENWRegisteredBusy:
                {
				//Call clean if registration is fine.
                iContentObserver->Clean( *iExtension,
                			EAiDeviceStatusContentSIMRegStatus,
                			0 );
                break;
                }
            default:
                break;
            }
        }
    }


TBool CAiSimRegPublisher::RefreshL( TInt aContentId, TBool aClean )
	{
    if( aContentId == EAiDeviceStatusContentSIMRegStatus )
        {
   	    RefreshL( aClean );
   	    return ETrue;
    	}

    return EFalse;
	}
hs_app_aivhzpublisher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Viag Home Zone (VHZ) publisher.
*
*/


#include 
#include "activeidle2domaincrkeys.h"
#include "hs_app_aivhzpublisher.h"
#include "aicontentobserver.h"
#include "hs_app_ainetworkinfolistener.h"


// ======== MEMBER FUNCTIONS ========

CAiVHZPublisher::CAiVHZPublisher()
    {
    }
    

void CAiVHZPublisher::ConstructL()
    {
    iListener = CAiNetworkInfoListener::InstanceL();
    
    CRepository* rep = CRepository::NewL( TUid::Uid( KCRUidActiveIdleLV ) ); 
    CleanupStack::PushL( rep );
    
    TBool value = EFalse;
    TInt err = rep->Get( KAIVHZInMainpane, value );
    if( err == KErrNone )
        {
        iVhzInMainpane = value;
        }
    CleanupStack::PopAndDestroy( rep );
    }


CAiVHZPublisher* CAiVHZPublisher::NewL()
    {
    CAiVHZPublisher* self = new( ELeave ) CAiVHZPublisher;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }


CAiVHZPublisher::~CAiVHZPublisher()
    {
    if( iListener )
        {
        iListener->RemoveObserver( *this );
        iListener->Release();
        }
    }


void CAiVHZPublisher::ResumeL()
    {
    iListener->AddObserverL( *this );
    }


void CAiVHZPublisher::Subscribe( MAiContentObserver& aObserver, 
							        MAiPropertyExtension& aExtension,
                                    MAiPublishPrioritizer& /*aPrioritizer*/,
                                    MAiPublisherBroadcaster& /*aBroadcaster*/ )
    {
    iContentObserver = &aObserver;
    iExtension = &aExtension;
    }


void CAiVHZPublisher::RefreshL( TBool /*aClean*/ )
    {
    const TNWInfo& nwInfo = iListener->NetworkInfo();

    //Check if the Viag indicator in network info is different than none...
    if( nwInfo.iViagIndicatorType != ENWViagIndicatorTypeNone )
        {
		//... and then publish it.
		if( !iVhzInMainpane )
		    {
            iContentObserver->Publish( *iExtension, 
                                        EAiDeviceStatusContentVHZIndicator, 
                                        nwInfo.iViagTextTag, 
                                        0 );
		    }
        else
		    {
            iContentObserver->Publish( *iExtension, 
                                        EAiDeviceStatusContentVHZText, 
                                        nwInfo.iViagTextTag, 
                                        0 );
		    }
        }
    else
    	{
		if( !iVhzInMainpane )
		    {
        	iContentObserver->Clean( *iExtension,
        							  EAiDeviceStatusContentVHZIndicator,
    	    						  0 );
		    }
		else
		    {
        	iContentObserver->Clean( *iExtension,
        							  EAiDeviceStatusContentVHZText,
    	    						  0 );
		    }
    	}
    }


void CAiVHZPublisher::HandleNetworkInfoChange( 
                        const MNWMessageObserver::TNWMessages& aMessage, 
                        const TNWInfo& /*aInfo*/,
                        const TBool /*aShowOpInd*/ )
    {
	//if home zone message has arrived, call refresh
    if ( aMessage == MNWMessageObserver::ENWMessageCurrentHomeZoneMessage )
        {
        TRAP_IGNORE( RefreshL( ETrue ) );
        }
    }


TBool CAiVHZPublisher::RefreshL( TInt aContentId, TBool aClean )
	{
    if( aContentId == EAiDeviceStatusContentVHZIndicator )
        {
   	    RefreshL( aClean );
   	    return ETrue;
    	}
    	
    return EFalse;
	}
aidevstaplg.mmp
/*
* Copyright (c) 2002-2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: 
*
*/


#include        
#include        

TARGET          hs_app_aidevstaplg.dll
TARGETTYPE      PLUGIN
UID             0x10009D8D 0x102750F7
VENDORID        VID_DEFAULT
CAPABILITY      CAP_ECOM_PLUGIN

SOURCEPATH      ../devicestatus/src
SOURCE          hs_app_aidevicestatusplugin.cpp
SOURCE          hs_app_aidevicestatuspluginengine.cpp
SOURCE          hs_app_aimulticontentobserver.cpp
SOURCE          hs_app_aiprofilepublisher.cpp
SOURCE          hs_app_aidatepublisher.cpp
SOURCE          hs_app_aipublisherfactory.cpp
SOURCE          hs_app_ainetworkinfolistener.cpp
SOURCE          hs_app_aioperatornamepublisher.cpp
SOURCE          hs_app_aibtsappublisher.cpp
SOURCE          hs_app_aisimregpublisher.cpp
SOURCE          hs_app_aimcnpublisher.cpp
SOURCE          hs_app_aicugpublisher.cpp
SOURCE		      hs_app_aicugmcnpublisher.cpp
SOURCE          hs_app_aivhzpublisher.cpp
SOURCE          hs_app_aipublishprioritizer.cpp 
SOURCE          hs_app_aicontentobserveroptimizer.cpp 
SOURCE          hs_app_aioperatorlogopublisher.cpp
SOURCE          hs_app_ainwspublisher.cpp

START RESOURCE  hs_app_aidevstaplg.rss
TARGET          hs_app_aidevstaplg.rsc
END

START RESOURCE  hs_app_aidevstaplgres.rss
HEADER
TARGET          hs_app_aidevstaplgres.rsc
TARGETPATH      APP_RESOURCE_DIR
LANGUAGE_IDS
END

USERINCLUDE     .

USERINCLUDE     ../devicestatus/inc
USERINCLUDE     ../devicestatus/loc
USERINCLUDE     ../../inc/common
USERINCLUDE     ../../cenrep

APP_LAYER_SYSTEMINCLUDE

LIBRARY         euser.lib
LIBRARY         ecom.lib
LIBRARY         avkon.lib
LIBRARY         sssettings.lib
LIBRARY         profileeng.lib
LIBRARY         networkhandling.lib
LIBRARY         phoneclient.lib
LIBRARY         fbscli.lib
LIBRARY         cone.lib
LIBRARY         commonengine.lib 
LIBRARY         featmgr.lib
LIBRARY         centralrepository.lib
LIBRARY         cenrepnotifhandler.lib
LIBRARY         egul.lib
LIBRARY         aknlayout2scalable.lib
LIBRARY         cdlengine.lib
LIBRARY         gdi.lib
LIBRARY         bitgdi.lib
LIBRARY         hs_app_aiutils.lib
LIBRARY         flogger.lib
LIBRARY         bafl.lib

aiwsplugin.mmp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  This is project specification for idle window server plug-
*                in. The plug-in provides service for routing of numeric key
*                events to Phone application and activation of key lock.
*
*/

#include 

TARGET          hs_app_aiwsplugin.dll
TARGETTYPE      ANI
UID             0x10003B22 0x10207206
CAPABILITY CAP_GENERAL_DLL
VENDORID VID_DEFAULT

USERINCLUDE     ../wsplugin/inc
USERINCLUDE     ../../inc/common
APP_LAYER_SYSTEMINCLUDE

SOURCEPATH      ../wsplugin/src
SOURCE			hs_app_aiwspluginanimdll.cpp
SOURCE			hs_app_aiwspluginanim.cpp
SOURCE          hs_app_modifierkeytracker.cpp
SOURCE          hs_app_keylockhandler.cpp
SOURCE          hs_app_keylockstates.cpp
SOURCE          hs_app_keypadsettings.cpp
SOURCE          hs_app_numerickeyhandler.cpp
SOURCE          hs_app_logslaunchhandler.cpp
SOURCE          hs_app_sindlaunchhandler.cpp
SOURCE          hs_app_keyhandlertimer.cpp
SOURCE          hs_app_panic.cpp


LIBRARY         euser.lib
LIBRARY         cone.lib
LIBRARY			ws32.lib
LIBRARY			apgrfx.lib
LIBRARY			centralrepository.lib
LIBRARY			flogger.lib

LIBRARY			featmgr.lib
LIBRARY         cenrepnotifhandler.lib
LIBRARY         ptiengine.lib
LIBRARY         keylockpolicyapi.lib

LIBRARY			hs_app_aiutils.lib

// End of File
bld.inf
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Bld.inf for all plugins under ActiveIdle2 project.
*
*/


#ifdef RD_CUSTOMIZABLE_AI

PRJ_PLATFORMS
DEFAULT

PRJ_MMPFILES
aidevstaplg.mmp
aiwsplugin.mmp

PRJ_EXPORTS
../wsplugin/rom/hs_app_aiwsplugin.iby        CORE_MW_LAYER_IBY_EXPORT_PATH(hs_app_aiwsplugin.iby)

// Include bld.inf-files of new plugins here

#include "../shortcutplugin/group/bld.inf"
//#include "../pslnactiveidleplugin/group/bld.inf"
#include "../profileplugin/group/bld.inf"
#include "../sapidataplugin/group/bld.inf"
#include "../wrtdataplugin/group/bld.inf"
#include "../mcsplugin/group/bld.inf"

#endif // RD_CUSTOMIZABLE_AI

// End of File.
hs_app_mcspluginwatcher.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/

#ifndef __MCSPLUGINWATCHER_H
#define __MCSPLUGINWATCHER_H

#include 

class CMenuOperation;
class CMCSPluginEngine;

/**
 *  @ingroup group_mcsplugin
 *
 *  MCS Plugin Watcher Observer
 *
 *  @since S60 9.1
 */
class MMCSPluginWatcherObserver
    {
    public:
    /**
     * HandleNotifyL
     */
    virtual void HandleNotifyL() = 0;
    };

/**
 *  @ingroup group_mcsplugin
 *
 *  This class implements MCS menu action watcher for async calls.
 * 
 *  @since S60 9.1
 */
class CMCSPluginWatcher: public CActive
    {
    public:
        
        /**
         * enum Type
         */
        enum Type
            {
            EOperation,
            ENotify
            };
        
        /**
         * Two-phased constructor.
         * 
         * @param aType
         */
        static CMCSPluginWatcher* NewL( const Type& aType );
        
        /**
         * Destructor.
         */
        virtual ~CMCSPluginWatcher();

        /**
         * Watch menu operation or notification.
         * 
         * @param aOperation
         */
        void Watch( CMenuOperation* aOperation = NULL );
        
        /**
         * WatchNotify
         * 
         * @param aObserver
         */
        void WatchNotify( MMCSPluginWatcherObserver* aObserver );
        
        /**
         * StopAndWatch
         * 
         * @param aOperation
         * @param aWaitScheduler
         */
        void StopAndWatch( CMenuOperation* aOperation, 
                           CActiveSchedulerWait* aWaitScheduler );
        
        /**
         * GetStatus 
         */
        TInt GetStatus();

    private:
    
        /** 
         * Default constructor.
         * 
         * @param aType
         */
        CMCSPluginWatcher( const Type& aType );

        /** 
         * ConstructL
         */
        void ConstructL();
        
        /**
        * Inherited from CActive class 
        */ 
        void RunL();
        
        /**
        * Inherited from CActive class 
        */ 
        void DoCancel();
    
    private:
        
        /** 
         * Menu operation
         * Owned
         */
        CMenuOperation* iOperation; 
        
        /**
         * Wait scheduler
         * Not owned
         */
        CActiveSchedulerWait* iWaitScheduler;

        /** 
         * Observer reference
         * Not owned
         */
        MMCSPluginWatcherObserver* iObserver;
        
        /** 
         * iType
         */
        Type iType;
    };

#endif /*__MCSPLUGINWATCHER_H*/
hs_app_mcspluginwatcher.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Menu item operation watcher. 
*
*/

#include 
#include "hs_app_mcspluginwatcher.h"
#include "../publisher/inc/mcspluginengine.h"

// ---------------------------------------------------------------------------
// two-phased constructor
// ---------------------------------------------------------------------------
CMCSPluginWatcher* CMCSPluginWatcher::NewL( const Type& aType )
	{
	CMCSPluginWatcher* self = new (ELeave) CMCSPluginWatcher( aType );
	CleanupStack::PushL( self );
	self->ConstructL();
	CleanupStack::Pop( self );
	return self;
	}

// ---------------------------------------------------------------------------
// default constructor
// ---------------------------------------------------------------------------
CMCSPluginWatcher::CMCSPluginWatcher( const Type& aType )
	: CActive( CActive::EPriorityStandard ),
	iType( aType )
    {
    CActiveScheduler::Add( this );
    }

// ---------------------------------------------------------------------------
// destructor
// ---------------------------------------------------------------------------
CMCSPluginWatcher::~CMCSPluginWatcher()
    {
    Cancel();
    }

// ---------------------------------------------------------------------------
// second phase constructor
// ---------------------------------------------------------------------------
void CMCSPluginWatcher::ConstructL()
	{
	
	}

// ---------------------------------------------------------------------------
// Watch  Async
// ---------------------------------------------------------------------------
void CMCSPluginWatcher::Watch( CMenuOperation* aOperation)
    {
    __ASSERT_DEBUG( KRequestPending == iStatus.Int(), User::Invariant() );
    //__ASSERT_DEBUG( !iOperation, User::Invariant() ); 
    iOperation = aOperation;
    SetActive();
    }

// ---------------------------------------------------------------------------
// Watch  Async
// ---------------------------------------------------------------------------
void CMCSPluginWatcher::WatchNotify( MMCSPluginWatcherObserver* aObserver )
    {
    __ASSERT_DEBUG( KRequestPending == iStatus.Int(), User::Invariant() );
    //__ASSERT_DEBUG( !iOperation, User::Invariant() ); 
    iObserver = aObserver;
    SetActive();
    }

void CMCSPluginWatcher::StopAndWatch( CMenuOperation* aOperation, 
                                      CActiveSchedulerWait* aWaitScheduler )
    {
    __ASSERT_DEBUG( KRequestPending == iStatus.Int(), User::Invariant() );
    iWaitScheduler = aWaitScheduler;
    iOperation = aOperation;
    SetActive();
    }

// ---------------------------------------------------------------------------
// Inherited from CActive class 
// ---------------------------------------------------------------------------
void CMCSPluginWatcher::RunL()
    {
    delete iOperation;
    iOperation = NULL;  
    
    if( iType == ENotify )
        {
        iObserver->HandleNotifyL();
        }
    if ( iWaitScheduler && iWaitScheduler->IsStarted() )
        {
        Cancel();
        iWaitScheduler->AsyncStop();
        }
    //CActiveScheduler::Stop();
    }

// ---------------------------------------------------------------------------
// Inherited from CActive class 
// ---------------------------------------------------------------------------
void CMCSPluginWatcher::DoCancel()
    {
    delete iOperation;
    iOperation = NULL;
    }

TInt CMCSPluginWatcher::GetStatus()
    {
    return iStatus.Int();
    }

hs_app_mcsplugin.rss
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Registry info
 *
*/


// INCLUDES
#include 
#include "hs_app_mcspluginuids.hrh"


// -----------------------------------------------------------------------------
//   
// registry_info
// Registry information required for identifying the ECOM component
//
// -----------------------------------------------------------------------------
//

RESOURCE REGISTRY_INFO registry_info
{
    resource_format_version = RESOURCE_FORMAT_VERSION_2;

    dll_uid = AI_UID_ECOM_DLL_CONTENTPUBLISHER_MCSPLUGIN; 

    // Declare array of interface info
    interfaces = 
    {
        INTERFACE_INFO
        {
            // UID of interface that is implemented
            interface_uid = AI_UID_ECOM_INTERFACE_CONTENTPUBLISHER; 

            implementations = 
            {
                IMPLEMENTATION_INFO
                {
                    implementation_uid = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_MCSPLUGIN;
                    version_no         = 1;
                    display_name       = "MCS plug-in";
                    default_data       = "";
                    opaque_data        = "";
                }
            };
        }
    };
}


// End of File
hs_app_mcspluginhandler.rss
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/
#include 
#include "hs_app_mcspluginuids.hrh"
#include 

#define str_datatype_shortcut "menu:shortcut"

RESOURCE REGISTRY_INFO theInfo
    {
    resource_format_version = RESOURCE_FORMAT_VERSION_2;
    dll_uid = AI_UID_ECOM_DLL_MCSPLUGIN_HANDLER;
    interfaces = 
        {
        INTERFACE_INFO
            {
            interface_uid = MENU_HANDLER_IF_UID;
            implementations = 
                {
                IMPLEMENTATION_INFO
                    {
                    implementation_uid = AI_UID_ECOM_IMPLEMENTATION_MCSPLUGIN_HANDLER;
                    version_no = 1;
                    display_name = "";
                    default_data = str_datatype_shortcut;
                    opaque_data = "";
                    }
                };
            }
        };
    }

hs_app_mcspluginres.rss
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Resource definitions for MCS plug-in settings
*
*/


#include 
#include 
#include 
#include 
#include 

#include 


NAME MCPL

RESOURCE RSS_SIGNATURE { }

RESOURCE TBUF { buf="MCPL"; }

//----------------------------------------------------
// EIK_APP_INFO
// Contains application information.
//----------------------------------------------------
//
RESOURCE EIK_APP_INFO
{
}

//----------------------------------------------------
// R_MCS_DISABLE_OPEN_ITEM
// Contains application information.
//----------------------------------------------------
//
RESOURCE TBUF r_mcs_disable_open_item
{
    buf = qtn_mcs_disable_open_item;
}

//----------------------------------------------------
// R_MCS_DISABLE_OPEN_ITEM_DLG
// Contains application information.
//----------------------------------------------------
//
RESOURCE DIALOG r_mcs_disable_open_item_dlg
{
    flags = EAknWarningNoteFlags | EEikDialogFlagWait;
    buttons = R_AVKON_SOFTKEYS_OK_EMPTY;
    items =
        {
        DLG_LINE
            {
            type = EAknCtNote;
            id = EGeneralNote;
            control = AVKON_NOTE
                {
                layout = EGeneralLayout;
                animation = R_QGN_NOTE_INFO_ANIM;
                };
            }
        };
}


hs_app_mcspluginsettings.rss
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  ECOM plug-in resource file
*
*/


#include 

#include "hs_app_mcspluginuids.hrh"

// ---------------------------------------------------------------------------
// registry_info
//
// ---------------------------------------------------------------------------
//
RESOURCE REGISTRY_INFO registry_info
{
    resource_format_version = RESOURCE_FORMAT_VERSION_2;

    dll_uid = AI_UID_ECOM_DLL_SETTINGS_MCSPLUGIN;

    // Interface info array.
    interfaces =
    {
        INTERFACE_INFO
        {
            // UID of the implemented interface.
            interface_uid = 0x10207236; 

            implementations =
            {
                IMPLEMENTATION_INFO
                {
                    implementation_uid  =  AI_UID_ECOM_IMPLEMENTATION_SETTINGS_MCSPLUGIN;
                    version_no          =  1;
                    display_name        =  "MCSplugin";
                    default_data        =  "0x1020723B"; // Parent UID (PrslnPlugin)
                    opaque_data         =  "-1"; // Order number
                }
            };
        }
    };
}

// End of File.
hs_app_mcspluginsettingsres.rss
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Resource definitions for MCS plug-in settings
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

#include 

#include "hs_app_mcspluginsettings.hrh"


NAME MCPS

RESOURCE RSS_SIGNATURE { }

RESOURCE TBUF { buf="MCPS"; }

//----------------------------------------------------
// EIK_APP_INFO
// Contains application information.
//----------------------------------------------------
//
RESOURCE EIK_APP_INFO
{
}

//----------------------------------------------------
// r_ai_mcs_settings_menubar
//
//----------------------------------------------------
//
RESOURCE MENU_BAR r_ai_mcs_settings_menubar
{
    titles =
    {
        MENU_TITLE { menu_pane = r_ai_mcs_settings_menupane; }
    };
}

//----------------------------------------------------
// r_ai_mcs_settings_menupane
// Options menu.
//----------------------------------------------------
//
RESOURCE MENU_PANE r_ai_mcs_settings_menupane
{
    items =
    {
        MENU_ITEM
        {
            command = EAiScutSettingsCmdChange;
            txt     = qtn_options_change;
            flags   = EEikMenuItemAction;
        }

#ifdef __SERIES60_HELP
        ,
        MENU_ITEM
        {
            command = EAknCmdHelp;
            txt     = qtn_options_help;
        }
#endif  // __SERIES60_HELP
        ,
        MENU_ITEM
        {
            command = EAknCmdExit;
            txt     = qtn_options_exit;
        }
    };
}

//----------------------------------------------------
// r_ai_mcs_settings_view
// Settings views.
//----------------------------------------------------
//
RESOURCE AVKON_VIEW r_ai_mcs_settings_view
{
    menubar = r_ai_mcs_settings_menubar;
    //cba = R_AVKON_SOFTKEYS_OPTIONS_BACK;
    cba = r_scut_softkeys_options_back_change;
}

//----------------------------------------------------
// r_ai_mcs_setting_listbox
// Common listbox editor resource for setting pages.
//----------------------------------------------------
//
RESOURCE LISTBOX r_ai_mcs_setting_listbox
{
    flags = EEikListBoxMultipleSelection;
}

//----------------------------------------------------
// r_ai_mcs__settings_applist_page
// Selection key idle softkey setting page.
//----------------------------------------------------
//
RESOURCE AVKON_SETTING_PAGE r_ai_mcs_settings_applist_page
{
    number = EAknSettingPageNoOrdinalDisplayed;
    //    label = qtn_set_idle_selec_key;
    // note: default cba resource is ok_cancel_select
    //softkey_resource = R_AVKON_SOFTKEYS_OK_CANCEL;
    type = EAknSetListBox;
    editor_resource_id = r_ai_mcs_setting_listbox;
}

//----------------------------------------------------
// r_ai_mcs_change_to_page_lbx
// "Change To" setting page.
//----------------------------------------------------
//
RESOURCE ARRAY r_ai_mcs_change_to_page_lbx
{
    items =
    {
        LBUF { txt = qtn_ai_mcs_set_change_apps;     },
        LBUF { txt = qtn_ai_mcs_set_change_bookmark; }
        
        // Only this menu option disabled.
        // The implementation of url functionality still exists in code, 
        // even though this option has been decided to remove due to better
        // usability. Affects lots of code if removed entirely.
        /*,
        LBUF { txt = qtn_ai_mcs_set_change_url;    }*/
    };
}

//----------------------------------------------------
// r_ai_mcs_listquery_change_to_page
// "Change To" setting page.
//----------------------------------------------------
//
RESOURCE AVKON_LIST_QUERY r_ai_mcs_listquery_change_to_page
{
    softkeys=R_AVKON_SOFTKEYS_SELECT_CANCEL;
    items =
    {
        AVKON_LIST_QUERY_DLG_LINE
        {
            control = AVKON_LIST_QUERY_CONTROL
            {
                listtype = EAknCtSinglePopupMenuListBox;
                heading = qtn_ai_mcs_set_change_prompt;
                listbox = AVKON_LIST_QUERY_LIST
                {
                    // array of items will be defined dynamically
                };
            };
        }
    };
}

//----------------------------------------------------
// r_ai_mcs_settings_view_caption
// View caption for plug-in. max 256
//----------------------------------------------------
//
RESOURCE TBUF r_ai_mcs_settings_view_caption
{
    buf = qtn_ai_mcs_set_pers_shortcuts;
}

//----------------------------------------------------
// r_ai_mcs_settings_view_title
// View title.
//----------------------------------------------------
//
RESOURCE TITLE_PANE r_ai_mcs_settings_view_title
{
    txt = qtn_ai_mcs_set_title_pers_shortcuts;
}

//----------------------------------------------------
//  r_ai_mcs_settings_txt_fixed_item
//  Text used in information note when attempting
//  to change a read-only shortcut
//----------------------------------------------------
//
RESOURCE TBUF r_ai_mcs_settings_txt_fixed_item
{
    buf = qtn_ai_mcs_set_app_note_fixed;
}

//----------------------------------------------------
//  r_ai_mcs_settings_txt_all_fixed
//  Text for empty listbox item
//----------------------------------------------------
//
RESOURCE TBUF r_ai_mcs_settings_txt_all_fixed
{
    buf = qtn_ai_mcs_set_all_fixed;
}

//----------------------------------------------------
//  r_ai_mcs_settings_txt_linkn
//
//----------------------------------------------------
//
RESOURCE TBUF r_ai_mcs_settings_txt_linkn
{
    buf = qtn_ai_mcs_set_myt_linkn;
}


// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
//
RESOURCE CBA r_scut_softkeys_options_back_change
{
    buttons =
    {
        CBA_BUTTON {id = EAknSoftkeyOptions;       txt = text_softkey_option; },
        CBA_BUTTON {id = EAknSoftkeyBack;          txt = text_softkey_back;   },
        CBA_BUTTON {id = EAiScutSettingsCmdChange; txt = qtn_msk_change;      }
    };
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
//
RESOURCE CBA r_scut_softkeys_options_exit_change
{
    buttons =
    {
        CBA_BUTTON {id = EAknSoftkeyOptions;       txt = text_softkey_option; },
        CBA_BUTTON {id = EAknSoftkeyExit;          txt = text_softkey_exit;   },
        CBA_BUTTON {id = EAiScutSettingsCmdChange; txt = qtn_msk_change;      }
    };
}

// End of File.
hs_app_mcspluginuids.hrh
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  UIDs for the Active Idle subsystem components.
*
*/


#ifndef MCSPLUGINUIDS_HRH
#define MCSPLUGINUIDS_HRH

#include 

/**
 * Ecom dll uid for MCS plug-in.
 */
#define AI_UID_ECOM_DLL_CONTENTPUBLISHER_MCSPLUGIN 0x2001CB57

/**
 * Ecom implementation uid for MCS plug-in.
 */
#define AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_MCSPLUGIN 0x2001CB58

/**
 * Ecom dll uid for MCS settings plug-in.
 */
#define AI_UID_ECOM_DLL_SETTINGS_MCSPLUGIN 0x20022FDC

/**
 * Ecom implementation uid for MCS settings plug-in.
 */
#define AI_UID_ECOM_IMPLEMENTATION_SETTINGS_MCSPLUGIN 0x20022FDD

/**
 * Ecom dll uid for MCS handler plug-in.
 */
#define AI_UID_ECOM_DLL_MCSPLUGIN_HANDLER 0x20022FDE

/**
 * Ecom implementation uid for MCS handler plug-in.
 */
#define AI_UID_ECOM_IMPLEMENTATION_MCSPLUGIN_HANDLER 0x20022FDF

#endif //MCSPLUGINUIDS_HRH
bld.inf
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  The build information file of Profile Plugin
*
*/


#ifdef RD_CUSTOMIZABLE_AI
#include 


PRJ_PLATFORMS
DEFAULT
//  Help exports
#include "../help/group/bld.inf"

PRJ_EXPORTS
../loc/hs_app_mcspluginsettings.loc             MW_LAYER_LOC_EXPORT_PATH(hs_app_mcspluginsettings.loc)
../loc/hs_app_mcsplugin.loc             MW_LAYER_LOC_EXPORT_PATH(hs_app_mcsplugin.loc)


../rom/hs_app_mcsplugin_resources.iby      LANGUAGE_MW_LAYER_IBY_EXPORT_PATH(hs_app_mcsplugin_resources.iby)
../rom/hs_app_mcsplugin.iby                CORE_MW_LAYER_IBY_EXPORT_PATH(hs_app_mcsplugin.iby)

../handler/inc/hs_app_mcspluginparamval.h     MW_LAYER_PLATFORM_EXPORT_PATH(hs_app_mcspluginparamval.h)

qgn_mcsplugin_log_out.svg             /epoc32/s60/icons/qgn_mcsplugin_log_out.svg


PRJ_EXTENSIONS

START EXTENSION s60/mifconv
OPTION TARGETFILE aimcsplugin.mif
OPTION HEADERFILE aimcsplugin.mbg
OPTION SOURCES -c8,8 qgn_prop_ai_shortcut -c8,8 qgn_menu_url \
               -c8,8 qgn_menu_mce_sel_mes -c8,8 qgn_menu_mce_syncmail \
               -c8,8 qgn_menu_am -c8,8 qgn_prop_cp_conn_shortcut \
               -c8,8 qgn_prop_psln_ai_sub -c8,8 qgn_mcsplugin_log_out
END


PRJ_MMPFILES
mcsplugin.mmp
mcspluginsettings.mmp
mcspluginhandler.mmp

#endif // RD_CUSTOMIZABLE_AI

// End of File.
mcsplugin.mmp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project definition file for project ProfilePlugin
*
*/

#include 
#include 

#include "../data/hs_app_mcspluginuids.hrh"

TARGET          hs_app_mcsplugin.dll
TARGETTYPE      PLUGIN
UID             0x10009D8D  AI_UID_ECOM_DLL_CONTENTPUBLISHER_MCSPLUGIN

CAPABILITY      CAP_ECOM_PLUGIN
VENDORID        VID_DEFAULT

SOURCEPATH      ../publisher/src
SOURCE          hs_app_mcsplugin.cpp
SOURCE          hs_app_mcspluginengine.cpp
SOURCE          hs_app_mcsplugindata.cpp
SOURCEPATH      ../commonsrc
SOURCE          hs_app_mcspluginwatcher.cpp

USERINCLUDE     ../publisher/inc
USERINCLUDE     ../loc
USERINCLUDE     ../data
USERINCLUDE     ../commoninc

APP_LAYER_SYSTEMINCLUDE

SOURCEPATH            ../data
START RESOURCE          hs_app_mcsplugin.rss
TARGET                  hs_app_mcsplugin.rsc
END

START RESOURCE          hs_app_mcspluginres.rss
HEADER
TARGET                  hs_app_mcspluginres.rsc
TARGETPATH              RESOURCE_FILES_DIR
LANGUAGE_IDS
END
LIBRARY         euser.lib
LIBRARY         mcsmenu.lib
LIBRARY         mcsextendedmenu.lib
LIBRARY         egul.lib
LIBRARY         cone.lib
LIBRARY         ecom.lib
LIBRARY         hs_app_aiutils.lib
LIBRARY         aknskins.lib
LIBRARY         aknicon.lib
LIBRARY         mcsmenuutils.lib
LIBRARY         hspluginsettings.lib
LIBRARY         msgs.lib
LIBRARY         apgrfx.lib
LIBRARY         apparc.lib


LIBRARY         bafl.lib
LIBRARY         avkon.lib 
LIBRARY         eikcoctl.lib
LIBRARY         eikcore.lib
LIBRARY         efsrv.lib
LIBRARY         fbscli.lib 
LIBRARY         gslauncher.lib
LIBRARY         eikdlg.lib
LIBRARY         commonengine.lib 
LIBRARY         favouritesengine.lib

LIBRARY         gfxtrans.lib 
LIBRARY         centralrepository.lib


// End of File
mcspluginhandler.mmp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/

// To get the MW_LAYER_SYSTEMINCLUDE-definition
#include 
#include "../data/hs_app_mcspluginuids.hrh"

TARGET          hs_app_mcspluginhandler.dll
TARGETTYPE      PLUGIN
UID             0x10009D8D AI_UID_ECOM_DLL_MCSPLUGIN_HANDLER

CAPABILITY      CAP_ECOM_PLUGIN
VENDORID        VID_DEFAULT

SOURCEPATH      ../handler/src

SOURCE          hs_app_mcspluginhandler.cpp
SOURCE          hs_app_mcsplugincompletedoperation.cpp

USERINCLUDE     ../data
USERINCLUDE     ../handler/inc

APP_LAYER_SYSTEMINCLUDE

LIBRARY         euser.lib
LIBRARY         ecom.lib
LIBRARY         cone.lib
LIBRARY         mcsmenu.lib
LIBRARY         mcsmenuutils.lib
LIBRARY         sendui.lib
LIBRARY         viewcli.lib
LIBRARY         apparc.lib
LIBRARY         apgrfx.lib

SOURCEPATH      ../data
START RESOURCE  hs_app_mcspluginhandler.rss
TARGET          hs_app_mcspluginhandler.rsc
END // RESOURCE

mcspluginsettings.mmp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project definition file for project MCSPlugin settings
*
*/


#include 

#include 

#include "../data/hs_app_mcspluginuids.hrh"


TARGET                  hs_app_mcspluginsettings.dll
TARGETTYPE              PLUGIN
UID                     0x10009D8D AI_UID_ECOM_DLL_SETTINGS_MCSPLUGIN

CAPABILITY              CAP_ECOM_PLUGIN
VENDORID                VID_DEFAULT

SOURCEPATH              ../settings/src
SOURCE                  hs_app_mcspluginsettings.cpp
SOURCE                  hs_app_mcspluginsettingscontainer.cpp
SOURCE                  hs_app_mcspluginsettingsmodel.cpp
SOURCE                  hs_app_mcspluginsettingsapplist.cpp
SOURCE                  hs_app_mcspluginsettingsbkmlist.cpp
SOURCEPATH              ../commonsrc
SOURCE                  hs_app_mcspluginwatcher.cpp

USERINCLUDE             ../settings/inc
USERINCLUDE             ../commoninc
USERINCLUDE             ../data

SOURCEPATH            ../data
START RESOURCE          hs_app_mcspluginsettings.rss
TARGET                  hs_app_mcspluginsettings.rsc
END

START RESOURCE          hs_app_mcspluginsettingsres.rss
HEADER
TARGET                  hs_app_mcspluginsettingsres.rsc
TARGETPATH              RESOURCE_FILES_DIR
LANGUAGE_IDS
END

APP_LAYER_SYSTEMINCLUDE
MW_LAYER_SYSTEMINCLUDE

LIBRARY                 euser.lib
LIBRARY                 ecom.lib
LIBRARY                 avkon.lib
LIBRARY                 bafl.lib
LIBRARY                 cone.lib
LIBRARY                 efsrv.lib
LIBRARY                 eikcoctl.lib
LIBRARY                 eikcore.lib
LIBRARY                 cdlengine.lib
//LIBRARY                 centralrepository.lib
LIBRARY                 cenrepnotifhandler.lib  // CCenRepNotifyHandler
LIBRARY                 gsframework.lib         // For base classes
LIBRARY                 gslistbox.lib           // For CGSListBoxItemTextArray
LIBRARY                 gsecomplugin.lib
LIBRARY                 commonengine.lib        // For RConeResourceLoader
LIBRARY                 inetprotutil.lib        // For TUriParser
//LIBRARY                 apgrfx.lib              // For RApaLsSession
//LIBRARY                 apparc.lib              // For TApaAppInfo
LIBRARY                 msgs.lib                // For Message Server
LIBRARY                 platformenv.lib         // For PathInfo
LIBRARY                 hlplch.lib              // for HlpLauncher
LIBRARY                 featmgr.lib             // For feature manager
LIBRARY                 favouritesengine.lib
//LIBRARY                 javaregistryclient.lib  // For JavaRegistry
#ifdef __WEB_WIDGETS
//LIBRARY                 widgetregistryclient.lib
#endif

// Debugging dependencies
//LIBRARY           flogger.lib
LIBRARY         mcsmenu.lib
LIBRARY         hspluginsettings.lib
LIBRARY         hs_app_aiutils.lib

// End of File.
qgn_mcsplugin_log_out.svg


























































































































hs_app_mcsplugincompletedoperation.h
/*
* Copyright (c) 2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Definition of completed menu operation
*
*/


#ifndef __MCSPLUGINCOMPLETEDOPERATION_H__
#define __MCSPLUGINCOMPLETEDOPERATION_H__

#include 
#include 

class RMenu;

/**
 *  @ingroup group_mcsplugin
 *
 *  Completed CMenuOperation.
 *  Utility class to wrap synchronous functionality as asynchronous menu
 *  operation. Used in CMenuHandlers and other menu operations where the
 *  API requires an asynchronous operation but the concrete functionality
 *  is synchronous and the result is already available.
 *  @lib mcsmenu.lib
 *  @since S60 v9.1
 */
NONSHARABLE_CLASS( CMCSPluginCompletedOperation ): public CMenuOperation
    {

public:

    /**
     * Destructor.
     */
    virtual ~CMCSPluginCompletedOperation();

    /**
    * Two-phased constructor. Constructs an operation that is already complete.
    * @param aMenu Menu.
    * @param aPriority Active Object priority.
    * @param aStatus Observer request status. Completes with aError.
    * @param aError Completion code (result of the operation).
    * @return Asynchronous operation. Owned by the caller.
    */
    static CMCSPluginCompletedOperation* NewL(
        RMenu &aMenu,
        TInt aPriority,
        TRequestStatus &aObserverStatus,
        TInt aError );

private:

    /**
    * Constructor
    * @param aMenu Menu.
    * @param aPriority Active Object priority.
    * @param aStatus Observer request status.
    */
    CMCSPluginCompletedOperation(
        RMenu &aMenu,
        TInt aPriority,
        TRequestStatus &aObserverStatus );

    /**
    * Report completion.
    * @param aError Completion code (result of the operation).
    */
    void ReportCompletion( TInt aError );

// from base class CActive

    /**
    * Report completion to observer.
    */
    void RunL();

    /**
    * Cancel object (never called).
    */
    void DoCancel();

    /**
    * Handle error.
    * @param aError Error code.
    * @return KErrNone.
    */
    TInt RunError( TInt aError );

    };

#endif // __MCSPLUGINCOMPLETEDOPERATION_H__
hs_app_mcspluginhandler.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/

#ifndef __MCSPLUGINHANDLER_H__
#define __MCSPLUGINHANDLER_H__

#include 

#include 
#include  // For CVwsSessionWrapper
#ifdef SYMBIAN_ENABLE_SPLIT_HEADERS
#include 
#endif

#include   // For TVwsViewId


class CEikonEnv;
class CVwsSessionWrapper;

/**
 *  @ingroup group_mcsplugin
 *
* Handler for menu items of type "menu:shortcut" "menu:folder" and "menu:suite".
 *
 *  @since S60 9.1
*/
NONSHARABLE_CLASS( CMCSPluginHandler ): public CMenuHandlerPlugin
    {

public:     // construction

    /**
    * Destructor.
    */
    virtual ~CMCSPluginHandler();

    /**
    * Two-phased constructor. Leaves on failure.
    * @param aMenu Menu.
    * @return The constructed object.
    */
    static CMCSPluginHandler* NewL( RMenu &aMenu );

protected:  // construction

    /**
    * Constructor.
    * @param aMenu Menu.
    */
    CMCSPluginHandler( RMenu &aMenu );

    /**
    * Second-phase constructor.
    */
    void ConstructL();

public:     // from CMenuHandler

    /**
    * Query support for item type.
    * @param aType Type.
    * @return ETrue if handler supports this type, EFalse otherwise.
    */
    TBool SupportsType( const TDesC& aType );

    /**
    * Handle command.
    * @param aItem Item of supported type.
    * @param aCommand Command.
    * @param aParams. Command parameters.
    * @param aStatus Observer request status. When the operation completes,
    * this status will be completed with the resulting error code.
    * @return Asynchronous operation. Owned by the caller.
    */
    CMenuOperation* HandleCommandL(
        CMenuItem& aItem,
        const TDesC8& aCommand,
        const TDesC8& aParams,
        TRequestStatus& aStatus );
        
private:    // internal

    void LaunchShortcutL( CMenuItem& aItem );

private:    // data
    
    CEikonEnv* iEikEnv;
    
    /**
     * View server session wrapper.
     * Own
     */
    CVwsSessionWrapper* iVwsSession;

    };

#endif // __MCSPLUGINHANDLER_H__
hs_app_mcspluginparamval.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/


#ifndef __MCSPLUGINPARAMVAL_H__
#define __MCSPLUGINPARAMVAL_H__


/** Parameter value for new message shortcuts. */
_LIT( KParamValueSelType, "messaging:seltype" );

/** Parameter value for new message shortcuts. */
_LIT( KParamValueMsg, "messaging:msg" );

/** Parameter value for new email shortcuts */
_LIT( KParamValueEmail, "messaging:email" );

/** Parameter value for new syncml mail shortcuts */
_LIT( KParamValueSyncMLMail, "messaging:syncmlmail" );

/** Parameter value for new postcard shortcuts */
_LIT( KParamValuePostcard, "messaging:postcard" );

/** Parameter value for new audio message shortcuts */
_LIT( KParamValueAudioMsg, "messaging:audiomsg" );

/** Parameter value for mailbox shortcuts */
_LIT( KParamValueMailbox, "mailbox:" );

#endif // __MCSPLUGINPARAMVAL_H__
hs_app_mcsplugincompletedoperation.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/

// INCLUDE FILES

#include "hs_app_mcsplugincompletedoperation.h"
#include 

// ================= MEMBER FUNCTIONS =======================

// ---------------------------------------------------------
// CMCSPluginCompletedOperation::~CMCSPluginCompletedOperation
// ---------------------------------------------------------
//
CMCSPluginCompletedOperation::~CMCSPluginCompletedOperation()
    {
    Cancel();
    }

// ---------------------------------------------------------
// CMCSPluginCompletedOperation::NewL
// ---------------------------------------------------------
//
CMCSPluginCompletedOperation* CMCSPluginCompletedOperation::NewL(
        RMenu &aMenu,
        TInt aPriority,
        TRequestStatus &aObserverStatus,
        TInt aError )
    {
    CMCSPluginCompletedOperation* op = new (ELeave) CMCSPluginCompletedOperation
        ( aMenu, aPriority, aObserverStatus );
    op->ReportCompletion( aError );
    return op;
    }

// ---------------------------------------------------------
// CMCSPluginCompletedOperation::CMCSPluginCompletedOperation
// ---------------------------------------------------------
//
CMCSPluginCompletedOperation::CMCSPluginCompletedOperation
( RMenu &aMenu, TInt aPriority, TRequestStatus &aObserverStatus )
: CMenuOperation( aMenu, aPriority, aObserverStatus )
    {
    CActiveScheduler::Add( this );
    }

// ---------------------------------------------------------
// CMCSPluginCompletedOperation::ReportCompletion
// ---------------------------------------------------------
//
void CMCSPluginCompletedOperation::ReportCompletion( TInt aError )
    {
    iObserverStatus = KRequestPending;
    TRequestStatus* ownStatus = &iStatus;
    *ownStatus = KRequestPending;
    SetActive();
    User::RequestComplete( ownStatus, aError );
    }

// ---------------------------------------------------------
// CMCSPluginCompletedOperation::RunL
// ---------------------------------------------------------
//
void CMCSPluginCompletedOperation::RunL()
    {
    // Propagate completion to observer.
    TRequestStatus* status = &iObserverStatus;
    User::RequestComplete( status, iStatus.Int() );
    }

// ---------------------------------------------------------
// CMCSPluginCompletedOperation::DoCancel
// ---------------------------------------------------------
//
void CMCSPluginCompletedOperation::DoCancel()
    {
    TRequestStatus* status = &iObserverStatus;
    User::RequestComplete( status, KErrCancel );
    }

// ---------------------------------------------------------
// CMCSPluginCompletedOperation::RunError
// ---------------------------------------------------------
//
TInt CMCSPluginCompletedOperation::RunError( TInt aError )
    {
    TRequestStatus* status = &iObserverStatus;
    User::RequestComplete( status, aError );

    return KErrNone;
    }
hs_app_mcspluginhandler.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/

#include 
#include 
#include 
#include 

#include 
#include 

#include                 // For CVwsSessionWrapper
#ifdef SYMBIAN_ENABLE_SPLIT_HEADERS
#include 
#endif

#include                  // For TVwsViewId
#include 
#include 

#include "hs_app_mcsplugincompletedoperation.h"
#include "hs_app_mcspluginhandler.h"
#include "hs_app_mcspluginuids.hrh"

#include "aiscutdefs.h"
class CVwsSessionWrapper;

_LIT( KMenuTypeShortcut, "menu:shortcut" ); ///< Menu folder type.
_LIT( KMenuAttrParamLogs, "logs:dialed" );

/** Argument value for parameter*/
_LIT( KMenuAttrParam, "param" );

const TInt KImplUidMCSPluginHandler = AI_UID_ECOM_IMPLEMENTATION_MCSPLUGIN_HANDLER;

const TImplementationProxy ImplementationTable[] = 
    {
    IMPLEMENTATION_PROXY_ENTRY( KImplUidMCSPluginHandler, CMCSPluginHandler::NewL)
    };

// ================= MEMBER FUNCTIONS =======================

// ---------------------------------------------------------
// CMCSPluginHandler::~CMCSPluginHandler
// ---------------------------------------------------------
//
CMCSPluginHandler::~CMCSPluginHandler()
    {
    delete iVwsSession;
    }

// ---------------------------------------------------------
// CMCSPluginHandler::NewL
// ---------------------------------------------------------
//
CMCSPluginHandler* CMCSPluginHandler::NewL( RMenu &aMenu )
    {
    CMCSPluginHandler* handler = new (ELeave) CMCSPluginHandler( aMenu );
    CleanupStack::PushL( handler );
    handler->ConstructL();
    CleanupStack::Pop( handler );
    return handler;
    }

// ---------------------------------------------------------
// CMCSPluginHandler::CMCSPluginHandler
// ---------------------------------------------------------
//
CMCSPluginHandler::CMCSPluginHandler( RMenu &aMenu )
: CMenuHandlerPlugin( aMenu )
    {
    iEikEnv = CEikonEnv::Static();
    }

// ---------------------------------------------------------
// CMCSPluginHandler::ConstructL
// ---------------------------------------------------------
//
void CMCSPluginHandler::ConstructL()
    {
    BaseConstructL();
    iVwsSession = CVwsSessionWrapper::NewL();
    }

// ---------------------------------------------------------
// Supported menu item types
// ---------------------------------------------------------
//
TBool CMCSPluginHandler::SupportsType( const TDesC& aType )
    {
    if ( !aType.Compare( KMenuTypeFolder() ) ||
         !aType.Compare( KMenuTypeSuite() )  ||
         !aType.Compare( KMenuTypeShortcut ) )
        {
        return ETrue;
        }
    return EFalse;
    }

// ---------------------------------------------------------
// Main command handler
// ---------------------------------------------------------
//
CMenuOperation* CMCSPluginHandler::HandleCommandL(
        CMenuItem& aItem,
        const TDesC8& aCommand,
        const TDesC8& /*aParams*/,
        TRequestStatus& aStatus )
    {
    if ( aCommand != KMenuCmdOpen() )
        {
        User::Leave ( KErrNotSupported );
        }

    if( aItem.Type() == KMenuTypeFolder() )
        {
        
        return CMCSPluginCompletedOperation::NewL
            ( iMenu, CActive::EPriorityStandard, aStatus, KErrNone );
        }
    else if ( aItem.Type() == KMenuTypeSuite() )
        {
        return CMCSPluginCompletedOperation::NewL
            ( iMenu, CActive::EPriorityStandard, aStatus, KErrNone );
        }
    else if ( aItem.Type() == KMenuTypeShortcut() )
        {
        LaunchShortcutL( aItem );
        return CMCSPluginCompletedOperation::NewL
            ( iMenu, CActive::EPriorityStandard, aStatus, KErrNone );
        }
    else
        {
        User::Leave ( KErrNotSupported );
        }
    return NULL;
    }

// ---------------------------------------------------------
// Handles menu:shortcut specific commands
// Must be extended to launch e.g. MailBoxes
// caiscuttargetmessagingview.cpp implements the mailbox launching in old shortcut plugin
// ---------------------------------------------------------
//
void CMCSPluginHandler::LaunchShortcutL( CMenuItem& aItem )
    {

    // menu:shortcut type of items are launched based on attribute param
    TBool attrExists = ETrue;
    TPtrC param = aItem.GetAttributeL( KMenuAttrParam, attrExists );

    if ( !attrExists )
        {
        User::Leave( KErrCorrupt );
        }

    // Messaging specific commands
    CSendUi* sendUi = CSendUi::NewLC();
    if ( param == KParamValueSelType ) // Select message type
        {
        TSendingCapabilities capabs( 0, 0, TSendingCapabilities::ESupportsEditor );

        TUid uid = sendUi->ShowTypedQueryL( CSendUi::EWriteMenu, NULL, capabs, NULL, KNullDesC );
        if ( uid != KNullUid )
            {
            sendUi->ServiceCapabilitiesL( uid, capabs );
            sendUi->CreateAndSendMessageL( uid, NULL, KNullUid, EFalse ); // launch standalone
            }
        }
    else if ( param == KParamValueMsg ) // New text message
        {
        sendUi->CreateAndSendMessageL(KSenduiMtmUniMessageUid, NULL, KNullUid, EFalse);
        }
    else if ( param == KParamValueEmail ) // New email
        {
        sendUi->CreateAndSendMessageL( KSenduiMtmSmtpUid, NULL, KNullUid, EFalse );
        }
#ifdef __SYNCML_DS_EMAIL
    else if ( param == KParamValueSyncMLMail ) // New SyncML mail
        {
        sendUi->CreateAndSendMessageL( KSenduiMtmSyncMLEmailUid, NULL, KNullUid, EFalse );
        }
#endif
    else if ( param == KParamValuePostcard ) // New postcard
        {
        sendUi->CreateAndSendMessageL( KSenduiMtmPostcardUid, NULL, KNullUid, EFalse );
        }
    else if ( param == KParamValueAudioMsg ) // New audio message
        {
        sendUi->CreateAndSendMessageL( KSenduiMtmAudioMessageUid, NULL, KNullUid, EFalse );
        }
    else if ( param.Find( KParamValueMailbox ) != KErrNotFound ) // Mailbox
        {
        TBool attrExists = ETrue;
        TInt pos = param.Locate( TChar( ':' ) ) + 1;
        TPtrC mailboxId = param.Mid( pos );

        if ( attrExists )
            {
            TInt number;
            TLex16 lextmp( mailboxId );
            lextmp.Val( number );
            TUid uId = TUid::Uid( number );
            const TVwsViewId viewId( KScutMessagingUid, KScutRemoteMailboxViewId );
            iVwsSession->CreateActivateViewEvent( viewId, uId, KNullDesC8() );
            }
        }
    else if ( param.Find( KMenuAttrParamLogs ) != KErrNotFound )
        {
        LogsUiCmdStarter::CmdStartL( LogsUiCmdStarterConsts::KDialledView() );
        }
    CleanupStack::PopAndDestroy( sendUi );
    }

// ============================ GLOBAL FUNCTIONS ===============================

EXPORT_C const TImplementationProxy* ImplementationGroupProxy( TInt& aTableCount )
    {
    aTableCount = sizeof(ImplementationTable) / sizeof(TImplementationProxy);
    return ImplementationTable;
    }
xhtml.zip
PK
1S?;xhtml/PK
1S?;	xhtml/01/PK
1S?;xhtml/01/0x20022FDC/PK©^ó;Ä0πªSj xhtml/01/0x20022FDC/contents.zip?R[LRΩ ?£2*?4|]Wêõ–è???LQ&(W?fSìø2
_?£≈?
?µEôs”?J-5Ç@k9"mÈõ?ÆPÛ'j?
?ù?ùsvvvv??Å(~çP ??g’≤??|¢ìL2bíi≈$&=ù?D*a?…¥2F? '±[9◊tSñ??%%â3?>??ΩJ?ãj-_/Ø85oTD?Wo?R?C©??ﬁ¥?>´’T¥í?:‰gx?1K∂Tãv?í???ÛïsÑJ?Æ?*Ö<ç-M???;?,?nùêï3
Ç’?ZeAnw:?T??ZÈIA~g??<π?ê"??+¢^r,È??ô˛?ﬁ?ãΩ??SCMøF???U’s:?¶ñw?]÷??‹O?ï	_¥π?∞Ωk'?≥D?Ö?(_oh ?,ª–mw3î?µΩ£F?Taì7???D!æì?n?ƒ/oƒáµlÇG"??!AQu?˛t{nÜ¥?8?–È>Ö?ZÖ?…>bÇj?=m??"Ö?j?Öo?”hBªÑX?7ciô?´YwPnV?Ç?ó????s]?‹?(\UÄˆçÑx?H‰’?ï???~?\G¸ñ4ˆj?Ä¶B?	?Ø?N?:Tx?ƒQ˛∏0?(?]?ìSM^Æ?õ¥?§π?+◊??r8?	;?ø¥7??>Q?I`(?ó?P??wq??∏ùO@???#‰s? ?PK?^ó;??X??&xhtml/01/0x20022FDC/index.xml]ﬁ?j?0E˜?–aˆ∂õÆ??J??@?î®Yõ M+ÅF??´4Yf3‹?πg≥]?Öôb2?◊è.??? ??©?‹?ã‹6≠"?’R?D #}◊XñU>÷‰çZí≠?W¥<î:???◊??ƒ??NB|]{<ıªsﬂï75ô{BA?H?êt?,'NXe◊?.?¸PK
?^ó;˛Ø?È22 xhtml/01/0x20022FDC/keywords.xmlPK?^ó;~õô´uãxhtml/01/0x20022FDC/meta.xml-??
?0Ö?}?b?}?≈??$≈M?{}Ä?HSçc???my?µ?±??Û'O’£ΩÆ?îr}{|=;u?644≤ƒ?Iñ??qî??}?ç,Ü? ya?Sa?{qƒ'¨?ï¢ppØ‹ïu?]Io?–?]?PK
1S?;xhtml/PK
1S?;	$xhtml/01/PK
1S?;Kxhtml/01/0x20022FDC/PK©^ó;Ä0πªSj  }xhtml/01/0x20022FDC/contents.zipPK?^ó;??X??& xhtml/01/0x20022FDC/index.xmlPK
?^ó;˛Ø?È22  $xhtml/01/0x20022FDC/keywords.xmlPK?^ó;~õô´uã îxhtml/01/0x20022FDC/meta.xmlPK?C
bld.inf
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - Initial contribution
* 
* Contributors:
* 
* 
* Description:
* Export help related files.
*
*/

#include 				
PRJ_EXPORTS
:zip ../data/xhtml.zip   /epoc32/data/z/resource/ overwrite
:zip ../data/xhtml.zip   /epoc32/winscw/c/resource/ overwrite

../inc/ai.hlp.hrh	MW_LAYER_PLATFORM_EXPORT_PATH(csxhelp/ai.hlp.hrh)
../rom/hs_app_mcspluginhelps_variant.iby		CUSTOMER_APP_LAYER_IBY_EXPORT_PATH(hs_app_mcspluginhelps_variant.iby)
ai.hlp.hrh
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
* 
* Description:
*
*/
	
//
// ai.hlp.hrh generated by CSXHelp Utilities.
//           

#ifndef __AI_HLP_HRH__
#define __AI_HLP_HRH__

_LIT(KSET_HLP_HOME_SCREEN_SHORTCUTS, "SET_HLP_HOME_SCREEN_SHORTCUTS"); // 

#endif 
hs_app_mcspluginhelps_variant.iby
/*
* Copyright (c) 2010 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: 
*
*/

#ifndef __MCSPLUGINHELPS_VARIANT_IBY__
#define __MCSPLUGINHELPS_VARIANT_IBY__

#if defined(FF_S60_HELPS_IN_USE)
    data=LOCALISE(DATAZ_\resource\xhtml\%02d\0x20022FDC\contents.zip, RESOURCE_FILES_DIR\xhtml\%02d\0x20022FDC\contents.zip)
    data=LOCALISE(DATAZ_\resource\xhtml\%02d\0x20022FDC\index.xml, RESOURCE_FILES_DIR\xhtml\%02d\0x20022FDC\index.xml)
    data=LOCALISE(DATAZ_\resource\xhtml\%02d\0x20022FDC\keywords.xml, RESOURCE_FILES_DIR\xhtml\%02d\0x20022FDC\keywords.xml)
    data=LOCALISE(DATAZ_\resource\xhtml\%02d\0x20022FDC\meta.xml, RESOURCE_FILES_DIR\xhtml\%02d\0x20022FDC\meta.xml)
#endif

#endif
hs_app_mcsplugin.loc
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:    Localization strings for project MCS Plugin
*
*/

// d: A dialog which is shown to user when (s)he is trying to 
// d: launch shortcut item during backup state.
// l: popup_note_window
// w:
// r: tb9.2
//
#define qtn_mcs_disable_open_item "Application cannot be opened during backup"

//End file
hs_app_mcspluginsettings.loc
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:    Localization strings for project MCS Plugin
*
*/

// d: Text in title pane
// l: title_pane_t2/opt9
// w:
// r: tb9.2
//
#define qtn_ai_mcs_set_title_pers_shortcuts "Shortcuts"

// d: Text of a list item in personalisation view's folder list
// d: Item opens Shortcuts folder
// l: list_setting_pane_t1
// w:
// r: tb9.2
//
#define qtn_ai_mcs_set_pers_shortcuts "Shortcuts"

// d: Shortcuts Item caption
// d: Active Idle Shortcut Settings View
// d: %N order number of the shortcut item
// l: list_setting_pane_t1
// w:
// r: tb9.2
//
#define qtn_ai_mcs_set_myt_linkn "%N. Shortcut item"

// d: Prompt text for change shortcut type query
// d: Active Idle Shortcut Settings View
// l: heading_pane_t1
// w:
// r: tb9.2
//
#define qtn_ai_mcs_set_change_prompt "Change to:"

// d: Application shortcut type choice item in change shortcut type query
// d: Active Idle Shortcut Settings View
// l: list_set_graphic_pane_t1
// w:
// r: tb9.2
//
#define qtn_ai_mcs_set_change_apps "Application"

// d: Bookmark shortcut type choice item in change shortcut type query
// d: Active Idle Shortcut Settings View
// l: list_set_graphic_pane_t1
// w:
// r: tb9.2
//
#define qtn_ai_mcs_set_change_bookmark "Bookmark"

// d: URL shortcut type choice item in change shortcut type query
// d: Active Idle Shortcut Settings View
// l: list_set_graphic_pane_t1
// w:
// r: tb9.2
//
#define qtn_ai_mcs_set_change_url "Web address"

// d: Text for fixed item information note
// d: Shown when user tries to change fixed shortcut in settings
// l: popup_note_window
// w:
// r: tb9.2
//
#define qtn_ai_mcs_set_app_note_fixed "Fixed item. Can't be changed"

// d: Text for empty listbox item
// d: Shown when there are no modifiable shortcuts in settings
// l: main_list_empty_pane
// w:
// r: tb9.2
//
#define qtn_ai_mcs_set_all_fixed "(No editable shortcuts available in this Idle theme.)"
hs_app_mcsplugin.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#ifndef CMCSPLUGIN_H
#define CMCSPLUGIN_H

#include 
#include 
#include 
#include 
#include 
#include "hs_app_mcspluginwatcher.h"

class MAiContentObserver;
class MAiContentItemIterator;
class CMCSPluginEngine;
class TMCSData;
//class CMCSPluginData;

//class RAiSettingsItemArray;

/**
 *  @ingroup group_mcsplugin
 *
 *  Plug-in main class
 *
 *  @since S60 v3.2
 */
class CMCSPlugin : public CAiContentPublisher,
                   public MAiPropertyExtension,
                   public MAiEventHandlerExtension,
                   public MMCSPluginWatcherObserver


    {

public:

    /**
    * Part of the two phased constuction
    *
    * @param none
    * @return none
    */
    static CMCSPlugin* NewL();

    /**
     * CompareItems
     * 
     * @param aFirst
     * @param aSecond
     */
    static TInt CompareItems(const MAiPluginSettings& aFirst,
        const MAiPluginSettings& aSecond );
    /**
    * Constructor
    *
    * @param none
    * @return none
    */
    CMCSPlugin();
    
    /**
    * Destructor
    *
    * @param none
    * @return none
    */
    ~CMCSPlugin();
    
    /**
    * Publishes profile names
    *
    * @param void
    * @return void
    */
    void PublishL();

    /**
    * From base class MMCSPluginWatcherObserver
    * .a method for Skin UID cenrep key change handeling
    */
    void HandleNotifyL();

// from base class CAiContentPublisher
  
    /**
    * From CAiContentPublisher
    * The method is called by the framework to request the plug-in free all
    * memory and CPU resources and close all its open files, e.g. the plug-in 
    * should unload its engines due backup operation. The method transits the 
    * plug-in to "Idle" state.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */
    void Stop( TAiTransitionReason aReason );

    /**
    * From CAiContentPublisher
    * The method is called by the framework to instruct plug-in that it is
    * allowed to consume CPU resources, e.g plug-in is able to run timers,
    * perform asynchronous operations, etc. The method transits the plug-in
    * to "Alive" state.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */
    void Resume( TAiTransitionReason aReason );

    /**
    * From CAiContentPublisher
    * The method is called by the framework to instruct plug-in that it is
    * not allowed to consume CPU resources, e.g plug-in MUST stop each
    * timers, cancel outstanding asynchronous operations, etc. The method
    * transits the plug-in to "Suspendend" state.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */
    void Suspend( TAiTransitionReason aReason );

    /**
    * From CAiContentPublisher
    * Adds the content observer / subscriber to plug-in. The plug-in MUST
    * maintain a registry of subscribers and send notification to all them
    * whenever the plug-in changes state or new content available.
    *
    * @param aObserver content observer to register.
    * @return void
    */
    void SubscribeL( MAiContentObserver& aObserver );
    
    /**
    * From CAiContentPublisher
    * Configures the plug-in.
    * Plug-ins take ownership of the settings array, so it must either
    * store it in a member or free it. Framework has put the array in cleanup
    * stack so the plugin shouldn't do that.
    * If this leaves, the plug-in will be destroyed by AI FW.
    * Plug-in must support LaunchByValue-event even if normal shortcuts don't
    * work. The only allowed serious enough leave is KErrNotFound from CenRep.
    *
    * @param aSettings setting items defined in the UI definition.
    * @return void
    */
    void ConfigureL( RAiSettingsItemArray& aSettings );

    /**
    * From CAiContentPublisher
    * Returns interface extension. In Series 60 3.1 only event & property
    * extensions are supported. See MAiEventExtension & MAiPropertyExtension
    * interfaces.
    *
    * @param  aUid - UID of the extension interface to access.
    * @return the extension interface. Actual type depends on the passed aUid 
    *         argument.
    */
    TAny* Extension( TUid aUid );  

// from base class MAiPropertyExtension

    /**
    * From MAiPropertyExtension.
    * Read property of publisher plug-in.
    *
    * @param aProperty - identification of property.
    * @return pointer to property value.
    */
    TAny* GetPropertyL( TInt aProperty );

    /**
    * From MAiPropertyExtension.
    * Write property value.
    *
    * @param aProperty - identification of property.
    * @param aValue - contains pointer to property value.
    */
    void SetPropertyL( TInt aProperty, TAny* aValue );
  
 // from base class MAiEventHandlerExtension
   
     /**
     * From MAiEventHandlerExtension
     * Invoked by the framework when plug-in must handle an event.
     *
     * @param aEvent - unique identifier of event from plug-in content model.
     * @param aParam - parameters associated with event. Each UI Definition
     *        declares events in the format: (),
     *        where  is mapped by the framework to unique
     *        identifier supplied in aEvent,  are provided to
     *        plug-in as-is in the descriptor.
     * @since S60 3.2
     */
    void HandleEvent(TInt aEvent, const TDesC& aParam);
    
    /**
     * From MAiEventHandlerExtension
     * Invoked by the framework when plug-in must handle an event.
     *
     * @param aEventName - name of the event from plug-in content model.
     * @param aParam - parameters associated with event. Each UI Definition
     *        declares events in the format: (),
     *        where   mapping to unique identifier supplied by event 
     *        is failed by the frame work then the   and  
     *          are provided to plug-in as-is in the descriptor.
     */
     void HandleEvent(const TDesC& aEventName, const TDesC& aParam);

protected:

private:

    /**
    * Part of the two phased construction
    *
    * @param void
    * @return void
    */
    void ConstructL();
    
    /**
    * Resume the plug-in.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */    
    void DoResumeL(TAiTransitionReason aReason);
    
    /**
     * Publishes content for one menu item
     */
    void PublishLItemL( MAiContentObserver& aObserver, TMCSData& aDataItem, TInt aIndex );
        
    /**
    * Free the engine
    *
    * @param void
    * @return void
    */  
    void FreeEngine();

    /**
    * Delete content model
    */  
    void DeleteContentModel();    
    
private: // data

    // Iterator for plugin content
    // Own
    MAiContentItemIterator* iContent;

    // Number of data in the content model.
    TInt iDataCount;

    // Dynamic content model
    // Own.
    TAiContentItem* iContentModel;

    // Plugin engine
    // Own
    CMCSPluginEngine* iEngine;

    // Array of content observers
    // not own
    RPointerArray iObservers;

    // Information about the content publisher (this plug-in)
    TAiPublisherInfo iInfo;

    // For accessing central repository keys
    CRepository* iRepository;

    // For observing central repository Skin UID key change 
    CMCSPluginWatcher* iRepositoryWatcher;

    };

#endif // CMCSPLUGIN_H
hs_app_mcsplugindata.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in data class
*
*/


#ifndef CMCSPLUGINDATA_H
#define CMCSPLUGINDATA_H

// INCLUDE FILES
#include 
#include 
#include 
#include 
#include 

class TMenuItem;
class CMCSPluginEngine;
class CMCSPluginWatcher;


/**
 *  @ingroup group_mcsplugin
 *
 *  TMCData class
 *
 *  @since S60 v9.1
 */
class TMCSData
    {
public:
    /**
     * SetMenuItem
     * 
     * @param aMenuItem
     */
    void SetMenuItem( TMenuItem& aMenuItem );

    /**
     * MenuItem
     * 
     * @return TMenuItem
     */
    TMenuItem& MenuItem();

    /**
     * SetDirty
     * 
     * @param aDirty
     * @return TBool
     */
    void SetDirty( TBool aDirty );

    /**
     * IsDirty
     * 
     * @return TBool
     */
    TBool IsDirty() const;

private:
    /**
     * iMenuItem
     */
    TMenuItem iMenuItem;

    /**
     * iDirty
     */
    TBool iDirty;
    };

/**
 *  @ingroup group_mcsplugin
 *
 *  Plug-in data class
 *
 *  @since
 */
class CMCSPluginData : public CBase,
    public HSPluginSettingsIf::MHomeScreenSettingsObserver
    {

public:

    /**
    * Part of the two phased constuction
    *
    * @param aEngine
    * @param aInstanceUid
    * @return Pointer to the created CMCSPluginData object
    */
    static CMCSPluginData* NewL( CMCSPluginEngine& aEngine,
        const TDesC8& aInstanceUid );

    /**
    * Constructor
    *
    * @param aEngine
    * @param aInstanceUid
    * @return none
    */
    CMCSPluginData( CMCSPluginEngine& aEngine, const TDesC8& aInstanceUid );

    /**
    * Destructor
    *
    * @param none
    * @return none
    */
    ~CMCSPluginData();

    /**
     * DataItem
     * 
     * @param aIndex
     * @return TMCSData&
     */
    TMCSData& DataItemL( TInt aIndex );

    /**
     * ReplaceMenuItemL
     * 
     * @param aIndex
     * @param aMenuItem
     */
    void ReplaceMenuItemL( const TInt& aIndex, TMenuItem& aMenuItem );

    /**
     * SaveSettingsL
     * 
     * @param aIndex
     * @param aMenuItem
     */
    void SaveSettingsL( const TInt& aIndex, CMenuItem& aMenuItem );

    /**
     * DataCount
     * 
     * @return TInt
     */
    TInt DataCount(){ return iData.Count();};

    /**
     * UpdateDataL
     */
    void UpdateDataL();

    // From MHomeScreenSettingsObserver
    /**
     * SettingsChangedL
     * 
     * @param aEvent
     * @param aPluginName
     * @param aPluginUid
     * @param aPluginId
     * @return TInt
     */
    TInt SettingsChangedL( const TDesC8& aEvent,  const TDesC8& aPluginName,
                           const TDesC8& aPluginUid, const TDesC8& aPluginId );

private:

    /**
    * Part of the two phased construction
    *
    * @param void
    * @return void
    */
    void ConstructL();

    /**
     * CreateMenuItemL
     * @param aProperties
     * @return TMenuItem
     */
    TMenuItem CreateMenuItemL(
        RPointerArray& aProperties );

private: // data

    // Menu items, which are defined in settings
    // Own
    RArray iData;

    // Plugin settings
    HSPluginSettingsIf::CHomescreenSettings* iPluginSettings;

    // Reference to MCS plug-in engine
    CMCSPluginEngine& iEngine;

    // Reference to instance uid of HSPS widget
    const TDesC8& iInstanceUid;
    };

#endif // CMCSPLUGINDATA_H
hs_app_mcspluginengine.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: 
*
*/


#ifndef CMCSPLUGINENGINE_H
#define CMCSPLUGINENGINE_H

// INCLUDE FILES
#include 
#include 
#include 
#include    // For MFavouritesDbObserver
#include            // For RFavouritesDb
#include                  // For MMsvSessionObserver

#include "hs_app_mcspluginwatcher.h"

class CGulIcon;
class CMCSPluginData;
class TMCSData;
class CMCSPlugin;
class CActiveFavouritesDbNotifier;

/**
 *  @ingroup group_mcsplugin
 *
 *  MCSPluginEngine class
 *
 *  @since S60 9.1
 */
class CMCSPluginEngine : public CBase, public MMCSPluginWatcherObserver,
    public MFavouritesDbObserver, public MMsvSessionObserver
{

public:  // Constructors and destructor

    /**
     * Constructor to use in the object creation. Initializes the necessary 
     * data.
     *
     * @param aPlugin
     * @param aInstanceUid
     */
    CMCSPluginEngine( CMCSPlugin& aPlugin, const TDesC8& aInstanceUid );

    /**
    * Part of the two phased constuction
    *
    * @param aPlugin
    * @param aInstanceUid
    * @return Pointer to the created CMCSPluginEngine object
    */
    static CMCSPluginEngine* NewL( CMCSPlugin& aPlugin, 
        const TDesC8& aInstanceUid );

    /**
    * Destructor
    *
    * @param none
    * @return none
    */
    ~CMCSPluginEngine();

    /**
     * Gets the menu data.
     * 
     * @param aIndex
     * @return TMCSData&
     */
    TMCSData& MenuDataL( const TInt& aIndex );

    /** Gets the menu item count
     * 
     * @return TInt
     */
    TInt MenuItemCount();

    /**
     * Finds the menu item header for given filter.
     * 
     * @param aFilter
     * @return TMenuItem
     */
    TMenuItem FindMenuItemL( CMenuFilter& aFilter );

    /**
     * Retrieves the menu item object from MCS.
     * 
     * @param aMenuItem
     * @return CMenuItem*
     */
    CMenuItem* FetchMenuItemL( const TMenuItem& aMenuItem );

    /**
     * Returns icon for given menu item and given attribute
     * 
     * @param aMenuItem
     * @param aAttr
     * @return CGulIcon*
     */
    CGulIcon* ItemIconL( CMenuItem& aMenuItem, const TDesC& aAttr );

    /**
     * Returns text for given menu item and given attribute
     * 
     * @param aMenuItem
     * @param aAttr
     */
    TPtrC ItemTextL( CMenuItem& aMenuItem, const TDesC& aAttr );

    /** 
     * Launches menu item
     * 
     * @param aIndex
     */
    void LaunchItemL( const TInt& aIndex );

    /**
    * Resumes the engine
    *
    * @param void
    * @return void
    */
    void ResumeL();

    /**
    * Suspends the engine
    *
    * @param void
    * @return void
    */
    void Suspend();

    /**
     * ShowSettingsL
     */
    void ShowSettingsL();

    /**
     * From MMCSPluginWatcherObserver
     */
    void HandleNotifyL();

    // From MFavouritesDbObserver
    /**
     * Handles database event.
     * @param aEvent Database event.
     */
    void HandleFavouritesDbEventL( RDbNotifier::TEvent aEvent );

    // from base class MMsvSessionObserver
    /**
     * Handles an event from the message server.
     * Not used, but must be defined to be able to use the messaging server.
     *
     * @since S60 v3.2
     * @param aEvent Indicates the event type.
     * @param aArg1 Event type-specific argument value
     * @param aArg2 Event type-specific argument value
     * @param aArg3 Event type-specific argument value
     */
    void HandleSessionEventL( TMsvSessionEvent aEvent, TAny* aArg1,
        TAny* aArg2, TAny* aArg3 );

    /**
    * Called during plugin desctruction
    * Decrements reference counters of all run-time generated items
    * and deletes those which have reference counter == 0
    */
    void CleanMCSItemsL();

private:
    /*
     * Part of the two phased construction
     */
    void ConstructL();

    /**
     * InitL
     */
    void InitL();

    /**
     * Tells the settings container to start observing for changes in favorites
     * database and mailbox db.
     *
     */
    void StartObservingL();

    /**
     * Tells the settings container to stop observing for changes in favorites
     * database and mailbox db.
     *
     */
    void StopObserving();

    /**
     * ConstructMenuItemForIconL
     * 
     * @param aPath
     * @param aMenuItem
     * @return TBool
     */
    TBool ConstructMenuItemForIconL( const TDesC& aPath, CMenuItem& aMenuItem );

    /**
    * Helper method. Adds a given constant to a value of reference counter
    *
    * @param aItem A Menu Item to update
    * @param aValueToAdd A constant to add 
    * @return The actual value of updated reference count
    */
    TInt UpdateMenuItemsRefCountL( CMenuItem* aItem, const TInt aValueToAdd );

protected:

private:

    /* Plugin data
    * Own
    */
    CMCSPluginData* iPluginData;

    // MCS resource
    RMenu iMenu;

    // MCS change notifier
    RMenuNotifier iNotifier;

    // MCS asynchronous operation watcher
    CMCSPluginWatcher* iWatcher;

    // MCS change notifier watcher
    CMCSPluginWatcher* iNotifyWatcher;

    //
    CMCSPlugin& iPlugin;

    // Reference to plugin owned instanceUid
    const TDesC8& iInstanceUid;
    // Indicating that backup is in progress
    TBool iSuspend;
    //Offset of resource file.
    TInt iResourceOffset;

    /**
     * Bookmark database change observer.
     * Own.
     */
    CActiveFavouritesDbNotifier* iBookmarkDbObserver;

    /**
     * Bookmark database.
     */
    RFavouritesDb iBookmarkDb;

    /**
     * Bookmark database session.
     */
    RFavouritesSession iBookmarkSession;

    /**
     * Message server session
     * Own.
     */
    CMsvSession* iMsvSession;
};

#endif // CMCSPLUGINENGINE_H


hs_app_mcsplugin.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  MCS plugin publisher
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
#include 

#include  // For working with settings API
#include  // Headers Used for CRepository

#include "hs_app_mcspluginuids.hrh"
#include "hs_app_mcsplugin.h"
#include "hs_app_mcsplugindata.h"
#include "hs_app_mcspluginengine.h"
#include "aipluginsettings.h"


const TUint KPluginNameSeprator =  '/';

const TInt KImplUidMCSPlugin = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_MCSPLUGIN;
// CONST CLASS VARIABLES
const TImplementationProxy KImplementationTable[] =
    {
    IMPLEMENTATION_PROXY_ENTRY( KImplUidMCSPlugin, CMCSPlugin::NewL ) 
    };

_LIT( KEventNameLaunchByIndex,  "LaunchByIndex" );
_LIT( KEventNameShowSettings,   "ShowSettings" );
_LIT( KContentItemTypeText, "text" );
_LIT( KContentItemTypeImage, "image" );

// ======== LOCAL FUNCTIONS ========

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
CMCSPlugin* CMCSPlugin::NewL()
    {
    CMCSPlugin* self = new (ELeave) CMCSPlugin;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
 
    return self;
    }
    
// ---------------------------------------------------------------------------
// Default constructor
// ---------------------------------------------------------------------------
//
CMCSPlugin::CMCSPlugin()
    {
    }
    
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
void CMCSPlugin::ConstructL()
    { 
    iInfo.iUid.iUid = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_MCSPLUGIN; 
    // We need to Query Central Repository
    iRepository  = CRepository::NewL( KCRUidPersonalisation );

    // Setting up watcher which calls HandleNotifyL method 
    // everytime the SkinUID changes in central repository
    iRepositoryWatcher = CMCSPluginWatcher::NewL( CMCSPluginWatcher::ENotify );
    iRepository->NotifyRequest( KPslnActiveSkinUid, iRepositoryWatcher->iStatus );
    iRepositoryWatcher->WatchNotify( this );
    }

// ---------------------------------------------------------------------------
// Handle Skin UID change
// ---------------------------------------------------------------------------
//
void CMCSPlugin::HandleNotifyL()
    {

    // Skin ID has changed. Set all MenuItems on Widget dirty
    // and re-publish to update icons
    if ( iEngine )
        {
        TInt dataCount = iEngine->MenuItemCount();
        for ( TInt i = 0; i < dataCount; i++ )
            {
            iEngine->MenuDataL( i ).SetDirty( ETrue );
            }
        PublishL();
        }

    // Skin ID Notification must be activated again
    iRepositoryWatcher->Cancel();
    iRepository->NotifyRequest( KPslnActiveSkinUid, iRepositoryWatcher->iStatus );
    iRepositoryWatcher->WatchNotify( this );
    }
    
// ---------------------------------------------------------------------------
// Destructor
// Deletes all data created to heap
// ---------------------------------------------------------------------------
//
CMCSPlugin::~CMCSPlugin()
    {
    Release( iContent );
    
    if ( iEngine )
        {
        TRAP_IGNORE( iEngine->CleanMCSItemsL() );
        }
    
    delete iEngine;
    iObservers.Close();
    
    DeleteContentModel();

    if ( iRepository )
        {
        delete iRepository;
        iRepository = NULL;
        }

    if ( iRepositoryWatcher )
        {
        iRepositoryWatcher->Cancel();
        delete iRepositoryWatcher;
        iRepositoryWatcher = NULL;
        }
    }

// ---------------------------------------------------------------------------
// Publishes the all the items
// ---------------------------------------------------------------------------
//
void CMCSPlugin::PublishL()
    {
    
    if ( !iEngine )
        {
        iEngine = CMCSPluginEngine::NewL( *this, iInfo.iNamespace );
        }

    TInt err( KErrNone );
    TInt observers( iObservers.Count() );
    TInt transactionId = reinterpret_cast( this );
    TInt menuItems ( iEngine->MenuItemCount() );

    for ( TInt i = 0; i < observers; i++ )
        {
        MAiContentObserver* observer = iObservers[ i ];
        err = observer->StartTransaction( transactionId );
        if ( err == KErrNotSupported )
            {
            return;
            }
        // Publish content to all items
        for ( TInt j = 0; j < menuItems; j++ )
            {
            // Index has to start from 1 ( j + 1 )
            PublishLItemL( *observer, iEngine->MenuDataL( j ), ( j + 1 ) );
            }// shortcut count
        if ( err == KErrNone )
            {
            err = observer->Commit( transactionId );
            if ( err == KErrNotSupported )
                {
                return;
                }
            }
        }//observers

    // Set all items not dirty.
    for ( TInt j = 0; j < menuItems; j++ )
        {
        iEngine->MenuDataL( j ).SetDirty( EFalse );
        }
    }

// ---------------------------------------------------------------------------
// Publishes one item to given index
// ---------------------------------------------------------------------------
//
void CMCSPlugin::PublishLItemL( MAiContentObserver& aObserver, TMCSData& aData, TInt aIndex )
    {

    if( !aData.IsDirty() )
        {
        return;
        }

    CMenuItem* item = iEngine->FetchMenuItemL( aData.MenuItem() );
    CleanupStack::PushL( item );
    // One widget item has iDataCount number of elements
    for ( TInt i = 0; i < iDataCount; i++ )
        {
        if ( iContentModel[i].type == KAiContentTypeBitmap )
            {
            //Publish image
            if ( aObserver.CanPublish( *this, i, aIndex ) )
                {
                CGulIcon* icon = iEngine->ItemIconL( *item, TPtrC16( ( const TText16* ) iContentModel[ i ].cid ) );
                aObserver.PublishPtr( *this, i, icon , aIndex );
                }
            }
        else if ( iContentModel[ i ].type == KAiContentTypeText )
            {
            //Publish  text
            if ( aObserver.CanPublish( *this, i, aIndex ) )
                {
                TPtrC name = iEngine->ItemTextL( *item, TPtrC16( ( const TText16* ) iContentModel[ i ].cid ) );
                aObserver.Publish( *this, i, name, aIndex );
                }
            }
        }//content items

    CleanupStack::PopAndDestroy( item );

    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is requested to unload its engines due backup operation
// ---------------------------------------------------------------------------
//
void CMCSPlugin::Stop( TAiTransitionReason aReason )
    {
    
    if ( aReason == EAiBackupRestoreStarted )
        {
        Suspend( aReason );
        }

    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is instructed that it is allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CMCSPlugin::Resume( TAiTransitionReason aReason )
    {
    if( aReason == EAiIdleBackground )
        {
        return;
        }

    if ( aReason == EAiBackupRestoreEnded )
        {
        if ( iEngine )
            {
            TRAP_IGNORE( iEngine->ResumeL() );
            }
        }

    TRAP_IGNORE( DoResumeL( aReason ) );
    return;
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is instructed that it is not allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CMCSPlugin::Suspend( TAiTransitionReason aReason )
    {
    if ( aReason == EAiBackupRestoreStarted && iEngine )
        {
        iEngine->Suspend();
        }
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// The plug-in MUST maintain a registry of subscribers and send 
// notification to all of them whenever the state changes or new content
// is available
// ---------------------------------------------------------------------------
//
void CMCSPlugin::SubscribeL( MAiContentObserver& aObserver )
    { 
    iObservers.AppendL( &aObserver );
    }
   
// ---------------------------------------------------------------------------
// Compare method to exclude the similar content items from array.
// ---------------------------------------------------------------------------
//
TInt CMCSPlugin::CompareItems( const MAiPluginSettings& aFirst,
        const MAiPluginSettings& aSecond )
    {
    MAiPluginSettings& first = const_cast(aFirst);
    MAiPluginSettings& second = const_cast(aSecond);
    return first.AiPluginContentItem().Name().CompareC(second.AiPluginContentItem().Name());    
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-ins take ownership of the settings array, so it must either
// store it in a member or free it.
// Creates dynamic content model.
// ---------------------------------------------------------------------------
//
void CMCSPlugin::ConfigureL( RAiSettingsItemArray& aSettings )
    {
    
    TLinearOrder sortMethod( CMCSPlugin::CompareItems );
    RAiSettingsItemArray contentItemsArr;

    TInt count = aSettings.Count();
    for ( TInt i = 0; i < count; i++ )
       {
       MAiPluginSettings* pluginSetting = aSettings[ i ];
       if( pluginSetting->AiPluginItemType() == EAiPluginContentItem )
           {
           MAiPluginContentItem& contItem = pluginSetting->AiPluginContentItem();
           TPtrC name = contItem.Name();
           TPtrC type = contItem.Type();
           contentItemsArr.InsertInOrder( pluginSetting, sortMethod );
           }

       }
    iDataCount = contentItemsArr.Count();
    if ( iDataCount > 0 )
        {
        // Create the dynamic content Model
        DeleteContentModel();
        iContentModel = new ( ELeave ) TAiContentItem[ iDataCount ];
        for ( TInt i = 0; i < iDataCount; i++ )
            {
            iContentModel[i].id = i;
            MAiPluginContentItem& contentItem = ( contentItemsArr[ i ] )->AiPluginContentItem();

            if( contentItem.Type() == KContentItemTypeText )
                {
                // text
                iContentModel[i].type = KAiContentTypeText;
                }
            if( contentItem.Type() == KContentItemTypeImage )
                {
                // image
                iContentModel[i].type = KAiContentTypeBitmap;
                }
            TInt pos = contentItem.Name().Locate( KPluginNameSeprator );
            
            HBufC* contentId = HBufC::NewL( contentItem.Name().Length() );
            CleanupStack::PushL( contentId );
            TPtr ptr = contentId->Des();
            ptr = contentItem.Name().Mid( pos + 1 );
            TInt sizeOfContentId = ptr.Size() +sizeof( wchar_t );
            iContentModel[i].cid = static_cast( User::AllocL( sizeOfContentId ) );
            Mem::Copy((TAny*)iContentModel[i].cid, ptr.PtrZ(), sizeOfContentId);
            CleanupStack::PopAndDestroy( contentId );
            }
        iContent = AiUtility::CreateContentItemArrayIteratorL( iContentModel, iDataCount );
        }
    contentItemsArr.Reset();
    // We own the array so destroy it
    aSettings.ResetAndDestroy();
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Returns the extension interface. Actual type depends on the passed 
// aUid argument.
// ---------------------------------------------------------------------------
//
TAny* CMCSPlugin::Extension( TUid aUid )
    {    
    if (aUid == KExtensionUidProperty)
           {
        return static_cast(this);
        }
    else if (aUid == KExtensionUidEventHandler)
        {
        return static_cast(this);
        }
    else
        {    
        return NULL;
        }
    }

// ---------------------------------------------------------------------------
// From class MAiPropertyExtension
// Read property of publisher plug-in.
// ---------------------------------------------------------------------------
//
TAny* CMCSPlugin::GetPropertyL( TInt aProperty )
    {
    TAny* property = NULL;
    
    switch ( aProperty )
        {
        case EAiPublisherInfo:
            {
             property = static_cast( &iInfo );
            break;  
            }       
    
        case EAiPublisherContent:
            {
            property = static_cast( iContent );
            break;    
            }
        }
    return property;
    }

// ---------------------------------------------------------------------------
// From class MAiPropertyExtension
// Write property value to optimize the content model.
// ---------------------------------------------------------------------------
//
void CMCSPlugin::SetPropertyL( TInt aProperty, TAny* aValue )
    {  
    switch ( aProperty )
        {
		case EAiPublisherInfo:
			{
			if( aValue )
			    {
    		    const TAiPublisherInfo* info = static_cast( aValue );
	    	    iInfo.iName.Copy(info->iName);
	    	    iInfo.iNamespace.Copy(info->iNamespace);
			    }
		    break;
		    }
		default:
		    break;         
        }
    }
 
// ---------------------------------------------------------------------------
// From class MAiEventHandlerExtension.
// Handles an event sent by the AI framework.
// ---------------------------------------------------------------------------
//
void CMCSPlugin::HandleEvent( TInt /*aEvent*/, const TDesC& /*aParam*/ )
    {
    // We have no way of reporting errors to framework so just ignore them.
    //TRAP_IGNORE( iEngine->HandleEventL(aEvent, aParam ));
    } 

// ---------------------------------------------------------------------------
// From class MAiEventHandlerExtension.
// Handles an event sent by the AI framework.
// ---------------------------------------------------------------------------
//
void CMCSPlugin::HandleEvent( const TDesC& aEventName, const TDesC& aParam )
    {
    if ( iEngine )
        {
        if( aEventName == KEventNameLaunchByIndex )
            {
            // We have no way of reporting errors to framework so just ignore them.
            TInt32 index;
            AiUtility::ParseInt( index, aParam );
            TRAP_IGNORE( iEngine->LaunchItemL( index - 1 ));
            }
        else if( aEventName == KEventNameShowSettings )
            {
            TRAP_IGNORE( iEngine->ShowSettingsL() );
            }
        }
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// framework instructs plug-in that it is allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CMCSPlugin::DoResumeL( TAiTransitionReason /*aReason*/ )
    {
    PublishL();
    }
    
// ---------------------------------------------------------------------------
// Frees engine resources
// ---------------------------------------------------------------------------
//    
void CMCSPlugin::FreeEngine()
    {
    delete iEngine;
    iEngine = NULL;
    }

// ---------------------------------------------------------------------------
// Delete content model
// ---------------------------------------------------------------------------
//    
void CMCSPlugin::DeleteContentModel()
    {
    if( iContentModel )
        {
        for ( TInt i = 0; i < iDataCount; i++ )
            {             
            if( iContentModel[i].cid )
                {
                TAny* cell = static_cast( const_cast( iContentModel[i].cid ) );
                User::Free( cell ); // Originally allocated with User::Alloc, so delete
                                    // with correlating method.
                iContentModel[i].cid = NULL;
                }
            }
        
        delete iContentModel;
        iContentModel = NULL;        
        }    
    }
  
// ======== GLOBAL FUNCTIONS ========
// ---------------------------------------------------------------------------
// Constructs and returns an application object.
// ---------------------------------------------------------------------------
//
EXPORT_C const TImplementationProxy* ImplementationGroupProxy( 
    TInt& aTableCount )
    {
    aTableCount = sizeof( KImplementationTable ) / 
        sizeof( TImplementationProxy );
    return KImplementationTable;
    }
hs_app_mcsplugindata.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/
#include 
#include 
#include 
#include 

#include "hs_app_mcsplugindata.h"
#include "hs_app_mcspluginengine.h"

using namespace HSPluginSettingsIf;

_LIT8( KAppUid, "271012080" );
_LIT( KMenuAttrParam, "param" );
_LIT( KMenuAttrLocked, "locked" );
_LIT8( KProperNameType, "type" );
_LIT8( KProperNameParam, "param" );
_LIT8( KProperNameUid, "uid" );
_LIT8( KProperNameView, "view" );
_LIT8( KProperValueFolder, "folder" );
_LIT8( KProperValueBookmark, "bookmark" );
_LIT8( KProperValueAppl, "application" );

// ======== LOCAL FUNCTIONS ========

static void ItemMapArrayCleanupFunc( TAny* aPointerArray )
    {
    RPointerArray* p = static_cast*>( aPointerArray ); 
    p->ResetAndDestroy();
    p->Close();
    }

// ======== MEMBER FUNCTIONS ========

void TMCSData::SetMenuItem( TMenuItem& aMenuItem )
    {
    iMenuItem = aMenuItem;
    }

TMenuItem& TMCSData::MenuItem()
    {
    return iMenuItem;
    }

void TMCSData::SetDirty( TBool aDirty )
    {
    iDirty = aDirty;
    }

TBool TMCSData::IsDirty() const
    {
    return iDirty;
    }
    
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
CMCSPluginData* CMCSPluginData::NewL( CMCSPluginEngine& aEngine, const TDesC8& aInstanceUid )
    {
    CMCSPluginData* self = new (ELeave) CMCSPluginData( aEngine, aInstanceUid );
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
 
    return self;
    }
    
// ---------------------------------------------------------------------------
// Default constructor
// ---------------------------------------------------------------------------
//
CMCSPluginData::CMCSPluginData( CMCSPluginEngine& aEngine, const TDesC8& aInstanceUid )
    : iEngine( aEngine ), iInstanceUid( aInstanceUid )
    {
    }
    
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
void CMCSPluginData::ConstructL()
    {
     // AILaunch uid in decimal format
    iPluginSettings = CHomescreenSettings::NewL( KAppUid,
                                                 iInstanceUid,
                                                 this );
    UpdateDataL();
    }

// ---------------------------------------------------------------------------
// Destructor
// ---------------------------------------------------------------------------
//
CMCSPluginData::~CMCSPluginData()
    {   
    iData.Close();
    delete iPluginSettings;
    }

// ---------------------------------------------------------------------------
// Gets the instance specific settings from HSPS and creates data items
// ---------------------------------------------------------------------------
//
void CMCSPluginData::UpdateDataL()
    {
    RPointerArray settings;
    TCleanupItem settingsCleanupItem( ItemMapArrayCleanupFunc, &settings );
    CleanupStack::PushL( settingsCleanupItem );
    iPluginSettings->GetSettingsL( iInstanceUid, settings );
    TInt count = settings.Count();
    for( TInt i = 0; i < count; i++ )
       {
        CItemMap* itemMap = settings[i];
        RPointerArray& properties
            = itemMap->Properties();
        TMenuItem item = CreateMenuItemL( properties );
        TMCSData data;
        TInt id = -1;
        
        if ( count == iData.Count() )
            {
            id = iData[i].MenuItem().Id();
            }
                   
        if ( id > 0 )
            {
            if ( item.Id() != id )
                {
                data.SetMenuItem( item );
                data.SetDirty( ETrue );
                iData.Remove( i );
                iData.InsertL( data, i );
                }
        	}
        else
            {
            data.SetMenuItem( item );
            data.SetDirty( ETrue );
            iData.AppendL( data );
        	}
        }
    
        CleanupStack::PopAndDestroy(); // settingsCleanupItem
    }

// ---------------------------------------------------------------------------
// 
// ---------------------------------------------------------------------------
//
TInt CMCSPluginData::SettingsChangedL( const TDesC8& /*aEvent*/,  const TDesC8& /*aPluginName*/,
                           const TDesC8& /*aPluginUid*/, const TDesC8& /*aPluginId*/ )
    {
    UpdateDataL();
    return KErrNone;
    }

// ---------------------------------------------------------------------------
// Gets the menu item from engine using the setting properties as filter
// ---------------------------------------------------------------------------
//
TMenuItem CMCSPluginData::CreateMenuItemL( RPointerArray& aProperties )
    {
    CMenuFilter* filter = CMenuFilter::NewLC();

    // Exclude 'view' and 'param' attributes from search criteria by default
    // Criterias will be added to filter if setting defines them
    filter->DoNotHaveAttributeL( KMenuAttrView );
    filter->DoNotHaveAttributeL( KMenuAttrParam );
    TBool isFolder = EFalse;
    
    // first, we need to check if the item is folder
    for ( TInt i = 0; i < aProperties.Count(); i++ )
        {
        if ( aProperties[i]->Name() == KProperNameType )
            {
            if ( aProperties[i]->Value() == KProperValueFolder )
                {
                isFolder = ETrue;
                }
            break;
            }
        }

    // then add all property/value pairs to the filter
    for ( TInt i = 0; i < aProperties.Count(); i++ )
        {

        // skip the type property
        if( aProperties[i]->Name() == KProperNameType )
            {
            continue;
            }

        HBufC* name( NULL );
        HBufC* value( NULL );
        name = AiUtility::CopyToBufferL( name, aProperties[i]->Name() );
        CleanupStack::PushL( name );
        value = AiUtility::CopyToBufferL( value, aProperties[i]->Value() );
        CleanupStack::PushL( value );

        if ( value->Length() != 0 )
            {
            // in case of folder, we just have to extract 
            // id from param attribute and return item with this id
            if ( aProperties[i]->Name() ==  KProperNameParam && isFolder )
                {
                TMenuItem item;
                // convert id to integer
                TInt id;
                TLex16 lextmp( value->Ptr() );
                lextmp.Val( id );
                item.SetType( KMenuTypeFolder );
                item.SetId( id );

                CleanupStack::PopAndDestroy( value );
                CleanupStack::PopAndDestroy( name );
                CleanupStack::PopAndDestroy( filter );

                return item;
                }
            else
                {
                // otherwise, we just add name/value into filter
                filter->HaveAttributeL( *name, *value );
                }
            }
        CleanupStack::PopAndDestroy( value );
        CleanupStack::PopAndDestroy( name );
        }
    
    // locked property excluded from search pattern 
    filter->DoNotHaveAttributeL( KMenuAttrLocked );
    
    TMenuItem item = iEngine.FindMenuItemL( *filter );
    CleanupStack::PopAndDestroy( filter );
    return item;
    }

// ---------------------------------------------------------------------------
// Returns menu item for given index
// ---------------------------------------------------------------------------
//
TMCSData& CMCSPluginData::DataItemL( TInt aIndex )
    {
    if( aIndex < 0 || aIndex >= iData.Count())
        {
        User::Leave( KErrArgument ); 
        }
    return iData[aIndex];
    }

// ---------------------------------------------------------------------------
// Replaces menuitem in data instance
// ---------------------------------------------------------------------------
//
void CMCSPluginData::ReplaceMenuItemL( const TInt& aIndex, TMenuItem& aMenuItem )
    {
    TMCSData& data = iData[aIndex];
    data.SetMenuItem( aMenuItem );
    data.SetDirty( ETrue );
    }

// ---------------------------------------------------------------------------
// Save the setting persistently to HSPS
// TODO HSPS setting api should be changed so that items and properties can 
// be added/removed dynamically. Now widgetconfiguration.xml must have all the
// properties for every item even though property is not used.
// It makes this function more compolicated.
// ---------------------------------------------------------------------------
//
void CMCSPluginData::SaveSettingsL( const TInt& aIndex, CMenuItem& aMenuItem )
    {
    RPointerArray settingItems;
    CleanupClosePushL( settingItems );
    iPluginSettings->GetSettingsL( iInstanceUid, settingItems );
    if ( aIndex >= 0 && aIndex < settingItems.Count() )
        {
        TBool exists( EFalse );
        CItemMap* itemMap = settingItems[aIndex];
        RPointerArray properties;
        properties = itemMap->Properties();
        for ( TInt i= 0; i < properties.Count(); i++ )
            {
            if ( properties[i]->Name() == KProperNameType )
                {
                TPtrC type = aMenuItem.Type();
                if ( type == KMenuTypeUrl )
                    {
                    properties[i]->SetValueL( KProperValueBookmark );
                    }
                else
                    {
                    properties[i]->SetValueL( KProperValueAppl );
                    }
                }
            else if ( properties[i]->Name() == KProperNameUid )
                {
                TPtrC uid = aMenuItem.GetAttributeL( KMenuAttrUid, exists );
                if ( exists )
                    {
                    HBufC8* uid8( NULL );
                    uid8 = AiUtility::CopyToBufferL( uid8, uid );
                    CleanupStack::PushL( uid8 );
                    properties[i]->SetValueL( *uid8 );
                    CleanupStack::PopAndDestroy( uid8 );
                    }
                else
                    {
                    properties[i]->SetValueL( KNullDesC8 );
                    }
                }
            else if ( properties[i]->Name() == KProperNameView )
                {
                TPtrC view = aMenuItem.GetAttributeL( KMenuAttrView, exists );
                if ( exists )
                    {
                    HBufC8* view8( NULL );
                    view8 = AiUtility::CopyToBufferL( view8, view );
                    CleanupStack::PushL( view8 );
                    properties[i]->SetValueL( *view8 );
                    CleanupStack::PopAndDestroy( view8 );
                    }
                else
                    {
                    properties[i]->SetValueL( KNullDesC8 );
                    }
                }
            else if ( properties[i]->Name() == KProperNameParam )
                {
                TPtrC param = aMenuItem.GetAttributeL( KMenuAttrParam, exists );
                if ( exists )
                    {
                    HBufC8* param8( NULL );
                    param8 = AiUtility::CopyToBufferL( param8, param );
                    CleanupStack::PushL( param8 );
                    properties[i]->SetValueL( *param8 );
                    CleanupStack::PopAndDestroy( param8 );
                    }
                else
                    {
                    properties[i]->SetValueL( KNullDesC8 );
                    }
                }
            }
        }
		// ETrue tells that changes are stored also to plugin reference 
    iPluginSettings->SetSettingsL( iInstanceUid, settingItems, ETrue );
    CleanupStack::PopAndDestroy( &settingItems );
    }

hs_app_mcspluginengine.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  The engine class of MCS plugin. 
*
*/


// INCLUDE FILES
#include "hs_app_mcspluginengine.h"

#include 
#include 
#include 
#include 

#include 
#include 
#include 
#include 
#include 
#include 

#include 
#include 
#include 
#include 
#include 
#include "hs_app_mcsplugin.h"
#include "hs_app_mcsplugindata.h"
#include "hs_app_mcspluginuids.hrh"

#include 
#include  
#include 
#include       // For Transition effect
#include 

#include 
_LIT( KMyMenuData, "matrixmenudata" );
_LIT( KSkin,         "skin" );
_LIT( KMif,          "mif" );
_LIT( KResourceDrive, "Z:" );
_LIT( KResourceFile, "hs_app_mcspluginres.rsc" );
_LIT( KResPath, "\\resource\\" );
_LIT( KMenuAttrRefcount, "ref_count" );
_LIT( KMMApplication, "mm://" );
_LIT( KHideExit2, "&exit=hide" );
_LIT( KSetFocusString, "!setfocus?applicationgroup_name=" );
_LIT( KApplicationGroupName, "applicationgroup_name" );
_LIT( KIcon, "icon" );
_LIT( KMenuAttrUndefUid, "0x99999991" );

const TUid KHomescreenUid = { AI_UID3_AIFW_COMMON };
const TUid KMMUid = { 0x101F4CD2 };

// ======== LOCAL FUNCTIONS ========

static TPtrC NextIdToken( TLex& aLexer )
   {
   aLexer.SkipSpace();
   aLexer.Mark();
   while( !aLexer.Eos() && !aLexer.Peek().IsSpace() && aLexer.Peek() != ')' )
       {
       aLexer.Inc();
       }
   return aLexer.MarkedToken();
   }

// ============================ MEMBER FUNCTIONS ===============================
// ---------------------------------------------------------
// Default constructor
// ---------------------------------------------------------
//
CMCSPluginEngine::CMCSPluginEngine( CMCSPlugin& aPlugin, const TDesC8& aInstanceUid ) 
    : iPlugin( aPlugin ), iInstanceUid( aInstanceUid ),
      iSuspend( EFalse )
    {
    }
    
// ---------------------------------------------------------
// Two-phased constructor.
// Create instance of concrete ECOM interface implementation
// ---------------------------------------------------------
//
CMCSPluginEngine* CMCSPluginEngine::NewL( CMCSPlugin& aPlugin, const TDesC8& aInstanceUid )
    {
    CMCSPluginEngine* self = new( ELeave ) CMCSPluginEngine( aPlugin, aInstanceUid );
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );

    return self;
    }

// ---------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------
//
void CMCSPluginEngine::ConstructL()
    {
    TFullName resourceFile( KResourceDrive );
    resourceFile.Append( KResPath );
    resourceFile.Append( KResourceFile );
    BaflUtils::NearestLanguageFile(
        CCoeEnv::Static()->FsSession(),
        resourceFile );
    iResourceOffset =
        CCoeEnv::Static()->AddResourceFileL( resourceFile );
    InitL();
    StartObservingL();
    }
    

// ---------------------------------------------------------
// Destructor.
// ---------------------------------------------------------
//
CMCSPluginEngine::~CMCSPluginEngine()
    {
    StopObserving();
    
    delete iPluginData;
    iNotifier.Close();
    iMenu.Close();
    //iWatcher->Cancel();
    delete iWatcher;
    delete iNotifyWatcher;
    CCoeEnv::Static()->DeleteResourceFile( iResourceOffset );
    }


// ---------------------------------------------------------------------------
// 
// ---------------------------------------------------------------------------
//
void CMCSPluginEngine::InitL()
    {
    iMenu.OpenL( KMyMenuData );
    iPluginData = CMCSPluginData::NewL( *this, iInstanceUid );
    iWatcher = CMCSPluginWatcher::NewL( CMCSPluginWatcher::EOperation );
    TInt err = iNotifier.Open( iMenu ); 
    if ( err == KErrNone )
        {
        iNotifyWatcher = CMCSPluginWatcher::NewL( CMCSPluginWatcher::ENotify );
        iNotifier.Notify( 0,
            RMenuNotifier::EItemsAddedRemoved |
            RMenuNotifier::EItemsReordered |
            RMenuNotifier::EItemAttributeChanged,
            iNotifyWatcher->iStatus );
        iNotifyWatcher->WatchNotify( this );
        }
    }

// ---------------------------------------------------------------------------
// Tells the settings container to start observing for changes
// ---------------------------------------------------------------------------
//
void CMCSPluginEngine::StartObservingL()
    {
    // registering to bookmarks db. changes observing
    User::LeaveIfError( iBookmarkSession.Connect() );
    User::LeaveIfError( iBookmarkDb.Open( iBookmarkSession, KBrowserBookmarks ) );

    iBookmarkDbObserver = new (ELeave) CActiveFavouritesDbNotifier(
                                        iBookmarkDb, *this );
    iBookmarkDbObserver->Start();

    // registering to mailbox db. changes observing
    iMsvSession = CMsvSession::OpenAsObserverL( *this) ;
    }

// ---------------------------------------------------------------------------
// Tells the settings container to stop observing for changes
// ---------------------------------------------------------------------------
//
void CMCSPluginEngine::StopObserving()
    {
    if ( iBookmarkDbObserver )
        {
        delete iBookmarkDbObserver;
        iBookmarkDbObserver = NULL;
        }
    iBookmarkDb.Close();
    iBookmarkSession.Close();

    if ( iMsvSession )
        {
        delete iMsvSession;
        iMsvSession = NULL;
        }
    }

// ---------------------------------------------------------------------------
// 
// ---------------------------------------------------------------------------
//
TMCSData& CMCSPluginEngine::MenuDataL( const TInt& aIndex )
    {
    return iPluginData->DataItemL( aIndex );
    }

// ---------------------------------------------------------------------------
// 
// ---------------------------------------------------------------------------
//
TInt CMCSPluginEngine::MenuItemCount()
    {
    return iPluginData->DataCount();
    }

// ---------------------------------------------------------------------------
// Returns the menu item header, which matches the given filter.
// ---------------------------------------------------------------------------
//
TMenuItem CMCSPluginEngine::FindMenuItemL( CMenuFilter& aFilter )
    {    
    TMenuItem item;
    const TInt root = iMenu.RootFolderL();
    RArray items;
    CleanupClosePushL( items );
    iMenu.GetItemsL( items, root, &aFilter, ETrue );
    if( items.Count() > 0 )
        {

        item = items[0];
        }

    CleanupStack::PopAndDestroy( &items );
    return item;
    }

// ---------------------------------------------------------------------------
// Returns the actual menu item for the given header.
// ---------------------------------------------------------------------------
//
CMenuItem* CMCSPluginEngine::FetchMenuItemL( const TMenuItem& aMenuItem )
    {
    return CMenuItem::OpenL( iMenu, aMenuItem );
    }

// ---------------------------------------------------------------------------
// Returns MCS default icon if attribute is 'icon' else parses the
// skin definition from attribute and sets attributes to aMenuItem.
// ---------------------------------------------------------------------------
//
CGulIcon* CMCSPluginEngine::ItemIconL( CMenuItem& aMenuItem, const TDesC& aAttr )
    {
    CAknIcon* icon( NULL );
    CGulIcon* gIcon( NULL );
    TBool exists( ETrue );
    if( aAttr != KIcon )
        {
        // Resolve secondary icon definition from attribute
        TPtrC iconDef = aMenuItem.GetAttributeL( aAttr, exists );
        if( exists )
            {
            exists = ConstructMenuItemForIconL( iconDef, aMenuItem );
            }
        }
    if( exists )
        {
        icon = MenuIconUtility::GetItemIconL( aMenuItem );
        if( icon )
            {
            CleanupStack::PushL( icon );
            gIcon = CGulIcon::NewL(icon->Bitmap(), icon->Mask());
            // Detach and delete
            icon->SetBitmap( NULL );
            icon->SetMask( NULL );    
            CleanupStack::PopAndDestroy( icon );
            }
        }
    return gIcon;
    }

// ---------------------------------------------------------------------------
// Returns text string for the given attribute
// ---------------------------------------------------------------------------
//
TPtrC CMCSPluginEngine::ItemTextL( CMenuItem& aMenuItem, const TDesC& aAttr  )
    {    
    TBool exists( KErrNotFound );
    TPtrC name = aMenuItem.GetAttributeL( aAttr, exists );
    if( exists )
        {
        return name;
        }
    else
        {
        return KNullDesC();
        }
    }

// ---------------------------------------------------------------------------
// Calls the open command for the given menu item header
// ---------------------------------------------------------------------------
//
void CMCSPluginEngine::LaunchItemL( const TInt& aIndex )
    {

    if ( iSuspend )
        {
        HBufC* temp = StringLoader::LoadLC( R_MCS_DISABLE_OPEN_ITEM );

        CAknNoteDialog* dialog = new (ELeave) CAknNoteDialog(
            CAknNoteDialog::EConfirmationTone,
            CAknNoteDialog::ENoTimeout );
        dialog->SetTextL( temp->Des() );
        dialog->ExecuteDlgLD( R_MCS_DISABLE_OPEN_ITEM_DLG );
        CleanupStack::PopAndDestroy( temp );
        return;
        }
    if( iWatcher->IsActive())
        {
        return;
        }


    TMCSData& dataItem = iPluginData->DataItemL( aIndex );
    CMenuItem* item = CMenuItem::OpenL( iMenu, dataItem.MenuItem());
    CleanupStack::PushL( item );
    TPtrC type = item->Type();

    // run folder
    if ( type == KMenuTypeFolder )
        {

        // message for MM application
        HBufC8* message; 

        // prepare message for launching folder
        TBool hasApplicationGroupName = EFalse;
        TPtrC applicationGroupName = item->GetAttributeL( KApplicationGroupName, 
                                                          hasApplicationGroupName );
        if ( !hasApplicationGroupName )
            {
            CleanupStack::PopAndDestroy( item );
            return;
            }
        message = HBufC8::NewLC( KMMApplication().Length() + 
                                 KSetFocusString().Length() +
                                 applicationGroupName.Length() + 
                                 KHideExit2().Length() );

        message->Des().Copy( KMMApplication );
        message->Des().Append( KSetFocusString );
        message->Des().Append( applicationGroupName );
        message->Des().Append( KHideExit2 );

        // find MM application
        TApaTaskList taskList( CCoeEnv::Static()->WsSession() );
        TApaTask task = taskList.FindApp( KMMUid );

        if ( task.Exists() )
            {
            // MM is already running in background - send APA Message
            task.SendMessage( TUid::Uid( KUidApaMessageSwitchOpenFileValue ), *message );
            }
        else
            { 
            // MM not running yet - use Command Line Tail
            RApaLsSession appArcSession;
            CleanupClosePushL( appArcSession );
            User::LeaveIfError( appArcSession.Connect() );
            TApaAppInfo appInfo;
            TInt err = appArcSession.GetAppInfo( appInfo, KMMUid );
            if ( err == KErrNone )
                {
                CApaCommandLine* cmdLine = CApaCommandLine::NewLC();
                cmdLine->SetExecutableNameL( appInfo.iFullName );
                cmdLine->SetCommandL( EApaCommandRun );
                cmdLine->SetTailEndL( *message );
                appArcSession.StartApp( *cmdLine );
                CleanupStack::PopAndDestroy( cmdLine );
                }
            CleanupStack::PopAndDestroy( &appArcSession ); 
            }
        CleanupStack::PopAndDestroy( message );
        }
    else
        {
        TBool exists( EFalse );
        TPtrC desc( item->GetAttributeL( KMenuAttrUid, exists ) );
        
        if( exists )
            {      
            _LIT( KPrefix, "0x" );
            const TInt pos( desc.FindF( KPrefix ) );
            
            if( pos != KErrNotFound )
                {
                TLex lex( desc.Mid( pos + KPrefix().Length() ) );
                // Hex parsing needs unsigned int
                TUint32 value = 0;
                const TInt parseResult = lex.Val( value, EHex );
                
                if ( parseResult == KErrNone )
                    {
                    TUid uid( KNullUid );  
                    TInt32 value32( value );
                    uid.iUid = value32;   
                    
                    if( uid != KNullUid )
                        {
                        //start a full screen effect
                        GfxTransEffect::BeginFullScreen( 
                        AknTransEffect::EApplicationStart,
                        TRect(0,0,0,0), 
                        AknTransEffect::EParameterType, 
                        AknTransEffect::GfxTransParam( uid,
                        AknTransEffect::TParameter::EActivateExplicitContinue ));
                        }
                    }
                }
            }

        // run application/shortcut/bookmark
        CMenuOperation* operation = item->HandleCommandL(
            KMenuCmdOpen, KNullDesC8, iWatcher->iStatus );
        iWatcher->Watch( operation );  
        }
    CleanupStack::PopAndDestroy( item );
    }

// ---------------------------------------------------------------------------
// Handle the change in Menu Content
// ---------------------------------------------------------------------------
//
void CMCSPluginEngine::HandleNotifyL()
    {
    TInt count( iPluginData->DataCount());
    for( TInt i = 0; i < count; i++ )
        {
        TMCSData& data = iPluginData->DataItemL(i);
        // Check that all the data still exist is MCS, if flag is hidden or
        // missing, we have to remove data from UI
        CMenuItem* menuItem = CMenuItem::OpenL( iMenu, data.MenuItem().Id() );
        CleanupStack::PushL( menuItem );
        if ( !menuItem || 
             ( menuItem->Flags() & TMenuItem::EHidden ) ||
             ( menuItem->Flags() & TMenuItem::EMissing ) )
            {
            // Get the replacement for hidden data
            CMenuFilter* filter = CMenuFilter::NewL();
            CleanupStack::PushL( filter );
            // 'Undefined' item
            filter->HaveAttributeL( KMenuAttrUid, KMenuAttrUndefUid );
            TMenuItem undefItem = FindMenuItemL( *filter );
            iPluginData->ReplaceMenuItemL( i, undefItem );
            iPluginData->SaveSettingsL( i, *FetchMenuItemL(undefItem) );
            CleanupStack::PopAndDestroy( filter );
            }
        CleanupStack::PopAndDestroy( menuItem );
        menuItem = NULL;
        }
    // Notification must be activated again
    iNotifyWatcher->Cancel();
    iNotifier.Notify( 0,
                RMenuNotifier::EItemsAddedRemoved |
                RMenuNotifier::EItemsReordered |
                RMenuNotifier::EItemAttributeChanged,
                iNotifyWatcher->iStatus );

    iNotifyWatcher->WatchNotify( this );
    // Publish changed data
    iPlugin.PublishL();
    }

// ---------------------------------------------------------------------------
// From class MMsvSessionObserver.
// Handles an event from the message server.
// ---------------------------------------------------------------------------
//
void CMCSPluginEngine::HandleSessionEventL(
    TMsvSessionEvent aEvent, TAny* /*aArg1*/, TAny* /*aArg2*/, TAny* /*aArg3*/)
    {
    switch ( aEvent )
        {
    case EMsvEntriesDeleted:
        // fall-through intended here
    case EMsvEntriesChanged:
        {

        }
        break;
    default:
        break;
        }
    }

// -----------------------------------------------------------------------------
// From class MFavouritesDbObserver.
// Handles database event.
// -----------------------------------------------------------------------------
//
void CMCSPluginEngine::HandleFavouritesDbEventL( RDbNotifier::TEvent aEvent )
    {
    switch ( aEvent )
        {
        case RDbNotifier::ERollback:
            // fall-through intended here
        case RDbNotifier::ERecover:
            // fall-through intended here
        case RDbNotifier::ECommit:
            {
            // Get list of favourites bookmarks
            CFavouritesItemList* favItems =
                    new (ELeave) CFavouritesItemList();
            CleanupStack::PushL( favItems );
            TInt err = iBookmarkDb.GetAll( *favItems, KFavouritesNullUid,
                    CFavouritesItem::EItem );
            if ( err != KErrNone )
                {
                ASSERT(0);
                }
            TInt count_fav = favItems->Count();

            // Do for each plugin data (4x times)
            TInt count_data( iPluginData->DataCount() );
            for ( TInt item_index = 0; item_index < count_data; item_index++ )
                {
                // Get item ID and open its menu related item
                TMCSData& data = iPluginData->DataItemL( item_index );
                TInt itemID( data.MenuItem().Id() );
                CMenuItem* menuItem = CMenuItem::OpenL( iMenu, itemID );
                CleanupStack::PushL( menuItem );

                // Get URL aatribute
                TBool attrExists = EFalse;
                TPtrC url = menuItem->GetAttributeL( _L("url"), attrExists );
                // If bookmark...
                if ( attrExists )
                    {
                    // Get bookmark UID
                    TPtrC uid_item_ptr = menuItem->GetAttributeL(
                            KMenuAttrUid, attrExists );

                    // Compare with each item in fav. bookmarks list
                    TBool itemExists = EFalse;
                    for ( TInt fav_index = count_fav - 1; fav_index >= 0; fav_index-- ) // newest on top
                        {
                        // Get list item UID 
                        TUid uid_fav = TUid::Uid( favItems->At( fav_index )->Uid() );
                        if ( uid_fav.Name() == uid_item_ptr )
                            {
                            // Bookmark still exist in fav. bookmarks list
                            itemExists = ETrue;
                            break;
                            }
                        }

                    if ( !itemExists )
                        {
                        // If item not axist any more, replace it by undefined icon
                        CMenuFilter* filter = CMenuFilter::NewL();
                        CleanupStack::PushL( filter );
                        // 'Undefined' item
                        filter->HaveAttributeL( KMenuAttrUid,
                                KMenuAttrUndefUid );
                        TMenuItem undefItem = FindMenuItemL( *filter );
                        iPluginData->ReplaceMenuItemL( item_index, undefItem );
                        iPluginData->SaveSettingsL( item_index, *FetchMenuItemL(
                                undefItem ) );
                        CleanupStack::PopAndDestroy( filter );
                        }
                    }
                CleanupStack::PopAndDestroy( menuItem );
                }
            CleanupStack::PopAndDestroy( favItems );
            }
            break;
        default:
            break;
        }
    }

// ---------------------------------------------------------------------------
// Resumes the engine
// ---------------------------------------------------------------------------
//
void CMCSPluginEngine::ResumeL()
    {
    iSuspend = EFalse;
    }

// ---------------------------------------------------------------------------
// Suspends the engine
// ---------------------------------------------------------------------------
//
void CMCSPluginEngine::Suspend()
    {
    iSuspend = ETrue;
    }

// ---------------------------------------------------------------------------
// Launch General Settings plugin
// ---------------------------------------------------------------------------
//
void CMCSPluginEngine::ShowSettingsL()
    { 
    TUid uid = {AI_UID_ECOM_IMPLEMENTATION_SETTINGS_MCSPLUGIN};
    CGSLauncher* l = CGSLauncher::NewLC();
    l->LaunchGSViewL ( uid,
                       KHomescreenUid,
                       iInstanceUid );            
    CleanupStack::PopAndDestroy( l );

    }
// ---------------------------------------------------------------------------
// ResolveSkinItemId
// Syntax: skin(major minor):mif(filename bimapId maskId)
// ---------------------------------------------------------------------------
//
TBool CMCSPluginEngine::ConstructMenuItemForIconL( const TDesC& aPath, CMenuItem& aMenuItem )
   {
   TInt pos = aPath.Locate( ':' );
   if( pos == KErrNotFound )
       {
       pos = aPath.Length();
       }
   TPtrC skin = aPath.Left( pos );
   TInt sf = skin.FindF( KSkin );
   if( sf == KErrNotFound )
       {
       return EFalse;
       }
   TPtrC temp = skin.Mid( sf + KSkin().Length());
   TLex input( temp );
   input.SkipSpace();
   if( !input.Eos() && input.Peek() == '(')
       {
       input.Inc();
       }
   TPtrC majorId = NextIdToken( input );
   TPtrC minorId = NextIdToken( input );
   aMenuItem.SetAttributeL( KMenuAttrIconSkinMajorId, majorId );
   aMenuItem.SetAttributeL( KMenuAttrIconSkinMinorId, minorId );
      
   //TPtrC mif = aPath.Mid( pos + 1 );
   //TInt mf = mif.FindF( KMif );
   if( aPath.Length() > pos && (aPath.Mid( pos + 1 ).FindF( KMif ) != KErrNotFound ))
       {
       TPtrC mif = aPath.Mid( pos + 1 );
       TInt mf = mif.FindF( KMif );
       //TPtrC temp1 = mif.Mid( mf+ KMif().Length());
       TLex input1( mif.Mid( mf+ KMif().Length()) );
       input1.SkipSpace();
       if( !input1.Eos() && input1.Peek() == '(')
          {
          input1.Inc();
          }
       TPtrC file = NextIdToken( input1 );
       TPtrC bitmapId = NextIdToken( input1 );
       TPtrC maskId = NextIdToken( input1 );
       aMenuItem.SetAttributeL( KMenuAttrIconFile, file );
       aMenuItem.SetAttributeL( KMenuAttrIconId, bitmapId );
       aMenuItem.SetAttributeL( KMenuAttrMaskId, maskId );
       }
   return ETrue;
   }

// ---------------------------------------------------------------------------
// Called during plugin desctruction
// Decrements reference counters of all run-time generated items
// and deletes those which have reference counter == 0
// ---------------------------------------------------------------------------
//
void CMCSPluginEngine::CleanMCSItemsL()
    {
    const TInt count( iPluginData->DataCount() );
    for( TInt i = 0; i < count; i++ )
        {
        TMCSData& data = iPluginData->DataItemL(i);
        
        CMenuItem* menuItem = CMenuItem::OpenL( iMenu, data.MenuItem().Id() );        
        if( !menuItem )
            {
            continue;
            }        
        CleanupStack::PushL( menuItem );
        
        // check if ref_count attribute exists
        TBool exists = EFalse;
        TPtrC param = menuItem->GetAttributeL( KMenuAttrRefcount, exists );
        if( exists )
            {                
            const TInt references = UpdateMenuItemsRefCountL( menuItem, -1 );
            
            // Create a nested loop inside CActiveScheduler.
            CActiveSchedulerWait* wait = new (ELeave) CActiveSchedulerWait;
            CleanupStack::PushL( wait );
            
            if( references > 0 )
                {
                // if counter is still > 0, update its value in MCS 
                CMenuOperation* op = menuItem->SaveL( iWatcher->iStatus );
                iWatcher->StopAndWatch( op, wait );
                
                // Start the nested scheduler loop.
                wait->Start();
                }
            else
                {                     
                 // counter reached 0 -> item is not referenced by any shortcut
                 // so remove it from MCS
                 if( !iWatcher->IsActive() )
                     {
                     CMenuOperation* op = iMenu.RemoveL( menuItem->Id(), iWatcher->iStatus );
                     iWatcher->StopAndWatch( op, wait );
                     
                      // Start the nested scheduler loop.
                     wait->Start();
                     }
                }
            
            CleanupStack::PopAndDestroy( wait );
            wait = NULL;
            }
        
        CleanupStack::PopAndDestroy( menuItem );
        menuItem = NULL;
        }
    }


// ---------------------------------------------------------------------------
// Helper method. Adds a given constant to a value of reference counter  
// ---------------------------------------------------------------------------
//
TInt CMCSPluginEngine::UpdateMenuItemsRefCountL( CMenuItem* aItem, 
                                                 const TInt aValueToAdd )
    {
    TBool exists = EFalse;
    CleanupStack::PushL( aItem ); 
    TPtrC param = aItem->GetAttributeL( KMenuAttrRefcount, exists );
    CleanupStack::Pop( aItem );
    if ( exists )
        {
        TInt references;
        TLex16 lextmp( param );
        lextmp.Val( references );
        references += aValueToAdd;
        TBuf<128> buf;
        buf.NumUC( references );

        // set new ref_count
        CleanupStack::PushL( aItem ); 
        aItem->SetAttributeL( KMenuAttrRefcount, buf);
        CleanupStack::Pop( aItem );
        // return new ref_count
        return references;
        }
    return -1;
    }
hs_app_mcsplugin.iby
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  IBY file for Profile plug-in
*
*/


#ifndef MCSPLUGIN_IBY
#define MCSPLUGIN_IBY
#include 

data=DATAZ_\BITMAP_DIR\aimcsplugin.mif BITMAP_DIR\aimcsplugin.mif

ECOM_PLUGIN(hs_app_mcsplugin.dll, hs_app_mcsplugin.rsc)
ECOM_PLUGIN(hs_app_mcspluginhandler.dll, hs_app_mcspluginhandler.rsc)
ECOM_PLUGIN(hs_app_mcspluginsettings.dll, hs_app_mcspluginsettings.rsc)

#endif // MCSPLUGIN_IBY

hs_app_mcsplugin_resources.iby
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  IBY file for Profile plug-in
*
*/


#ifndef MCSPLUGIN_RESOURCES_IBY
#define MCSPLUGIN_RESOURCES_IBY

#include 

data=DATAZ_\RESOURCE_FILES_DIR\hs_app_mcspluginres.rsc  RESOURCE_FILES_DIR\hs_app_mcspluginres.rsc
data=DATAZ_\RESOURCE_FILES_DIR\hs_app_mcspluginsettingsres.rsc  RESOURCE_FILES_DIR\hs_app_mcspluginsettingsres.rsc

#endif // MCSPLUGIN_RESOURCES_IBY
hs_app_mcspluginsettings.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  MCS settings plug-in main class.
*
*/


#ifndef MCSPLUGINSETTINGS_H
#define MCSPLUGINSETTINGS_H

#include 

class CMCSPluginSettingsContainer;
class CMCSPluginSettingsModel;

/**
 *  @ingroup group_mcsplugin
 *
 * MCS settings plug-in main class
 *
 * @lib hs_app_mcspluginsettings.lib
 * @since S60 9.1
 */
class CMCSPluginSettings : public CGSBaseView
{

public:
    /**
     * Part of the two phased constuction
     * 
     * @param aInitParams
     * @return CMCSPluginSettings*
     */
    static CMCSPluginSettings* NewL(TAny* aInitParams);

    /**
     * Destructor
     */
    virtual ~CMCSPluginSettings();

    // from base class CAknView

    /**
     * From CAknView
     * Returns view id.
     *
     * @since S60 3.2
     * @return TUid
     */
    TUid Id() const;

    /**
     * From CAknView
     * Handles commands.
     *
     * @since S60 3.2
     * @param aCommand Command to be handled.
     */
    void HandleCommandL(TInt aCommand);

    /**
     * See base class in AknView.h
     * 
     * @param aPrevViewId
     * @param aCustomMessageId
     * @param aCustomMessage
     */
    void DoActivateL(const TVwsViewId& aPrevViewId, TUid aCustomMessageId, 
        const TDesC8& aCustomMessage);

    /**
     * See base class.
     */
    void DoDeactivate();

    // from base class CGSPluginInterface

    /**
     * From CGSPluginInterface
     *
     * @since S60 3.2
     * @see CGSPluginInterface header file.
     * @param aCaption
     */
    void GetCaptionL(TDes& aCaption) const;

    /**
     * From CGSPluginInterface
     *
     * @since S60 3.2
     * @see CGSPluginInterface header file.
     * @return TInt
     */
    TInt PluginProviderCategory() const;

    /**
     * From CGSPluginInterface
     *
     * @since S60 3.2
     * @see CGSPluginInterface header file.
     * @return TBool
     */
    TBool Visible() const;

    /**
     * From CGSBaseView
     *
     * @since S60 3.2
     * Returns the container this view has.
     * @return pointer to container, does not transfer ownership.
     */
    CMCSPluginSettingsContainer* Container();

    /**
    * Check if view is activate
    * @since S60 5.1
    * @return ETrue if activated, EFalse otherwise
    */
    TBool Activated() const;

protected:

private: // From MEikMenuObserver

    /**
     * Changes MenuPane dynamically
     * 
     * @param aResourceId
     * @param aMenuPane
     */
    void DynInitMenuPaneL(TInt aResourceId, CEikMenuPane* aMenuPane);

private:
    /**
     * CMCSPluginSettings
     */
    CMCSPluginSettings();

    /**
     * Part of the two phased construction
     */
    void ConstructL();


    // from base class CGSBaseView

    /**
     * From CGSBaseView
     * Functionality for creating a container. Called by DoActivateL().
     */
    void NewContainerL();

    /**
     * From CGSBaseView
     * Handles listbox selection. Called by HandleListBoxEventL.
     * Implement by sub-class.
     */
    void HandleListBoxSelectionL();

    /**
     * DoHandleListBoxSelectionL
     * 
     * @param aAny
     * @return TInt
     */
    static TInt DoHandleListBoxSelectionL( TAny* aAny );


private:  // data

    /**
     * Settings plug-in model.
     * Own.
     */
    CMCSPluginSettingsModel* iModel;
};

#endif // MCSPLUGINSETTINGS_H

// End of File.
hs_app_mcspluginsettings.hrh
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Resource headers for MCS plug-in
*
*/


#ifndef MCSPLUGINSETTINGS_HRH
#define MCSPLUGINSETTINGS_HRH

/**
 * Menu command ids for the Shortcut plug-in Settings
 */
enum TAiScutSettingsMenuCommands
{
    EAiScutSettingsCmdChange = 0x6000,

    EAiScutSettingsCmdChangeToApps,
    EAiScutSettingsCmdChangeToUrl,
    EAiScutSettingsCmdChangeToBookmark,
    EAiScutSettingsCmdChangeShortcutType
};

/**
 * Shortcut setting types
 */
enum TAiScutSettingType
{
    EAiScutSettingTypeUndefined = -1,
    EAiScutSettingTypeApplication,
    EAiScutSettingTypeBookmark,
    EAiScutSettingTypeUrl
};

#endif // MCSPLUGINSETTINGS_HRH

// End of File.
hs_app_mcspluginsettingsapplist.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Application list for settings listbox.
*
*/


#ifndef CMCSPLUGINSETTINGSAPPLIST_H
#define CMCSPLUGINSETTINGSAPPLIST_H

#include 
#include    // For MDesCArray
#include      // For RApaLsSession
#include      // For MMsvSessionObserver
#include    // For MApaAppListServObserver
#include     // For MenuContentService
#include // For HSPS settings property map

/**
 *  @ingroup group_mcsplugin
 *
 * Observer interface for application list events
 *
 * @since S60 v3.2
 */
class MMCSPluginListObserver
{
public:

    /**
     * AppList event codes
     */
    enum TScutListEvent
    {
        EAppListReady,
        EAppListUpdated,
        EBkmListUpdated
    };

    /**
     * Callback for application list events
     *
     * @since S60 v3.2
     * @param aEvent AppList event code
     * @param aAdded ETrue if applications were added, EFalse if removed
     */
    virtual void HandleScutListEventL( 
        TScutListEvent aEvent, TBool aAdded ) = 0;

   // virtual TBool IsHidden(const TUid& aAppUid) const = 0;

};

struct TSettingItem;
/**
 * Application list for settings listbox
 *
 * @since S60 v3.2
 */

class CMCSPluginWatcher;

/**
 *  @ingroup group_mcsplugin
 *
 * MCSPluginSettingsAppList class
 *
 * @since S60 v9.1
 */
class CMCSPluginSettingsAppList : public CBase, //public CActive
    public MDesCArray, public MMsvSessionObserver
{

public:
    /**
     * Part of the two phased constuction
     * 
     * @return CMCSPluginSettingsAppList*
     */
    static CMCSPluginSettingsAppList* NewL();

    /**
     * CompareNameL
     * 
     * @param aFirst
     * @param aSecond
     */
    static TInt CompareNameL(const CMenuItem& aFirst, const CMenuItem& aSecond);

    /**
     * Destructor
     */
    virtual ~CMCSPluginSettingsAppList();

    // from base class MDesCArray

    /**
     * From MDesCArray
     * Returns the number of descriptor elements in a descriptor array.
     *
     * @since S60 v3.2
     * @return The number of descriptor elements in a descriptor array.
     */
    TInt MdcaCount() const;

    /**
     * From MDesCArray
     * Indexes into a descriptor array.
     *
     * @since S60 v3.2
     * @param aIndex The position of the descriptor element within a descriptor 
     *               array.
     * @return A 16 bit non-modifiable pointer descriptor representing the 
     *         descriptor element located at position aIndex within a descriptor 
     *         array.
     */
    TPtrC MdcaPoint( TInt aIndex ) const;

    // from base class MMsvSessionObserver

    /**
     * Handles an event from the message server.
     * Not used, but must be defined to be able to use the messaging server.
     *
     * @since S60 v3.2
     * @param aEvent Indicates the event type.
     * @param aArg1 Event type-specific argument value
     * @param aArg2 Event type-specific argument value
     * @param aArg3 Event type-specific argument value
     */
    void HandleSessionEventL( TMsvSessionEvent aEvent, TAny* aArg1, TAny* aArg2, 
        TAny* aArg3 );

    /**
     * Starts the asynchronous appliation list initialization
     *
     * @since S60 v3.2
     */
    void StartL();

    /**
     * FindItemL
     *
     * @since S60 
     * @param aProperties
     * @return TSettingItem
     */
    TSettingItem FindItemL( RPointerArray& 
        aProperties );

    /**
     * 
     *
     * @since S60 
     * @param 
     * @return
     */
    CMenuItem& ItemL(const TInt& aIndex );
    /**
     * RemoveMenuItemL
     * 
     * @param aIndex
     */
    void RemoveMenuItemL( TInt aIndex );

protected:

private:
    /**
     * Constructor
     */
    CMCSPluginSettingsAppList();

    /**
     * Second-phase constructor.
     */
    void ConstructL();

    /**
     * Adds the static list items to the application list.
     * For example "New Message" and "New Email" items are added here.
     *
     * @since S60 v3.2
     */
    void AddStaticItemsL();

    /**
     * Finds all mailboxes defined in the device
     */
    CMsvEntry* GetRootEntryL();

    /**
     * Adds remote mailboxes to the application list.
     *
     * @since S60 v3.2
     */
    void AddMailboxesL();

    /**
     * Adds a mailbox to the list
     *
     * @since S60 v3.2
     * @param aMailbox Name of the mailbox to add
     */
    void AddMailboxL( const TDesC& aMailbox, const TDesC& aMailboxId );

    /**
     * GetID of MCS Plugin Folder
     * 
     * @return TInt
     */
    TInt GetMCSPluginFolderIdL();

    /**
     * Update menu items
     * 
     * @return TInt
     */
    TInt UpdateMenuItemsRefCountL( CMenuItem* aItem, TInt aValueToAdd );

private:  // data

    /**
     * List of application items
     * Own.
     */
    RPointerArray iListItems;

    /**
     * Message server session
     * Own.
     */
    CMsvSession* iMsvSession;

    /**
     * Registered observer for application list events
     */
    //MMCSPluginListObserver& iObserver;

    /**
     * A flag indicating if the app list should observe changes
     */
    TBool iObserving;

    /**
     * iMenu
     */
    RMenu iMenu;

    /**
     * iSaveWatcher
     */
    CMCSPluginWatcher* iSaveWatcher;

    /**
     * iUpdateWatcher
     */
    CMCSPluginWatcher* iUpdateWatcher;

    /**
     * iRemoveWatcher
     */
    CMCSPluginWatcher* iRemoveWatcher;

    /**
     * iMCSPluginFolderId
     */
    TInt iMCSPluginFolderId;
};

#endif // CMCSPLUGINSETTINGSAPPLIST_H

// End of File.
hs_app_mcspluginsettingsbkmlist.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Bookmark list for settings listbox.
*
*/


#ifndef CMCSPLUGINSETTINGSBKMLIST_H
#define CMCSPLUGINSETTINGSBKMLIST_H

#include 
#include                // For MDesCArray
#include    // For MFavouritesDbObserver
#include            // For RFavouritesDb
#include      // For CFavouritesItemList
#include                 // For MenuContentService

class CActiveFavouritesDbNotifier;
class CAiScutSettingsItem;
class CMCSPluginSettingsModel;
class CMCSPluginWatcher;
struct TSettingItem;
/**
 *  @ingroup group_mcsplugin
 *
 * Bookmark list for settings listbox
 *
 * @since S60 v3.2
 */
class CMCSPluginSettingsBkmList : public CBase, public MDesCArray
{

    /**
     * TBookmarkType
     */
    enum TBookmarkType
        {
        EFavBookmark,
        EMCSBookmark
        };

public:

    /**
     * Part of the two phased constuction
     */
    static CMCSPluginSettingsBkmList* NewL();

    /**
     * Destructor
     */
    virtual ~CMCSPluginSettingsBkmList();

    // from base class MDesCArray

    /**
     * From MDesCArray
     * Returns the number of descriptor elements in a descriptor array.
     *
     * @since S60 v3.2
     * @return The number of descriptor elements in a descriptor array.
     */
    TInt MdcaCount() const;

    /**
     * From MDesCArray
     * Indexes into a descriptor array.
     *
     * @since S60 v3.2
     * @param aIndex The position of the descriptor element within a descriptor 
     *               array.
     * @return A 16 bit non-modifiable pointer descriptor representing the 
     *         descriptor element located at position aIndex within a descriptor 
     *         array.
     */
    TPtrC MdcaPoint(TInt aIndex) const;

    /**
     * Gets the bookmark list.
     *
     * @since S60 v3.2
     */
    void GetBookmarkListL();

    /**
     * 
     *
     * @since S60 
     * @param aIndex Setting item to find
     * @return MCS menu item
     */
    CMenuItem& ItemL( TInt aIndex );

    /**
     * Returns target bookmark data from the given index
     *
     * @since S60 v3.2
     * @param aIndex Index of the bookmark in the list
     * @param aParams On return, the bookmark parameters
     * @param aCaption On return, the bookmark caption
     * @return KErrNotFound if the bookmark cannot be found, KErrNone otherwise
     */
    //TInt GetDataByIndex(TInt aIndex, TPtrC& aParams, TPtrC& aCaption) const;
    
    TSettingItem FindItemL( 
        RPointerArray& aProperties );
    
    /**
     * Remove menu item
     * 
     * @param aIndex 
     */
    void RemoveMenuItemL( TInt aIndex );

protected:

private:

    /**
     * Constructor
     */
    CMCSPluginSettingsBkmList();
    
    /**
     * Second-phase constructor.
     */
    void ConstructL();

    /**
     * Adds an bookmark to the list
     *
     * @since S60 v3.2
     * @param aBkmInfo Bookmark information object
     */
    void AddBookmarkL( const TDesC&  aUid, const TDesC& aCaption, 
        const TDesC& aUrl, TBookmarkType aType );

    /**
     * Updates the bookmark list
     *
     * @since S60 v3.2
     */
    void UpdateBkmListL();

    /**
     * Get bookmarks from favourites
     */
    void GetBookmarksFromFavouritesL();

    /**
     * Get bookmarks from MCS
     */
    void GetBookmarksFromMCSL();

    /**
     * Create menu item
     * 
     * @param aUid
     * @param aName
     * @param aUrl
     * @return pointer to the created CMenuItem object 
     */
    CMenuItem* CreateMenuItemL( const TDesC& aUid,const TDesC& aName,
        const TDesC& aUrl );

    /**
     * MCSMenuItemL
     * 
     * @param aUid
     * @param aName
     * @param aUrl
     * @return pointer to the CMenuItem object
     */
    CMenuItem* MCSMenuItemL( const TDesC& aUid,const TDesC& aName,
        const TDesC& aUrl );

    /**
     * GetMCSPluginFolderIdL
     * 
     * @return TInt
     */
    TInt GetMCSPluginFolderIdL();

    /**
     * UpdateMenuItemsRefCountL
     * 
     * @param aItem
     * @param aValueToAdd
     * @return TInt
     */
    TInt UpdateMenuItemsRefCountL( CMenuItem* aItem, TInt aValueToAdd );


private:

    /**
     * Nested class to store individual bookmark list items
     *
     * @since S60 v3.2
     */
    class CBkmListItem : public CBase
    {
    public:

        /**
         * Part of the two phased constuction
         * 
         * @param aUid
         * @param aCaption
         */
        static CBkmListItem* NewLC( const TDesC&  aUid, const TDesC& aCaption);

        /**
         * Destructor
         */
        ~CBkmListItem();

        /**
         * Compare method used to add the items to the list in sorted order
         *
         * @since S60 v3.2
         * @param aFirst The first item to be compared
         * @param aSecond The second item to be compared
         * @return Negative if first comes before second, zero if equal and
         *         positive if first comes after second
         */
        static TInt CompareCaption(const CBkmListItem& aFirst,
            const CBkmListItem& aSecond);

        /**
         * Returns the item target bookmark uid
         *
         * @since S60 v3.2
         * @return Target bookmark uid
         */
        //TUid Uid() const;

        /**
         * Returns the item target bookmark caption
         *
         * @since S60 v3.2
         * @return Target bookmark caption
         */
        TPtrC Caption() const;

        /**
         * iType
         */
        TBookmarkType iType;

        /**
         * Target bookmark uid
         */
        HBufC* iUid;

        /**
         * Target bookmark caption
         */
        HBufC* iCaption;

        /**
         * Target bookmark parameters
         */
        HBufC* iUrl;

    private:

        /**
         * Constructor
         */
        CBkmListItem();

        /**
         * Second-phase constructor.
         * 
         * @param aUid
         * @param aCaption
         */
        void ConstructL( const TDesC&  aUid, const TDesC& aCaption);

    private:  // data


    };

private:  // data

    /**
     * List of bookmark items
     * Own.
     */
    RPointerArray iListItems;

    // Runtime created CMenuItems must be stored, because those are refered 
    RPointerArray iMenuItems;

    /**
     * A flag indicating if the bookmark list should observe changes
     */
    TBool iObserving;

    /**
     * Bookmark database session.
     * Own.
     */
    RFavouritesSession iBookmarkSess;

    /**
     * Bookmark database.
     * Own.
     */
    RFavouritesDb iBookmarkDb;

    /**
     * iMenu
     */
    RMenu iMenu;

    /**
     * Save watcher
     */

    CMCSPluginWatcher* iSaveWatcher;

    /**
     * Update watcher
     */
    CMCSPluginWatcher* iUpdateWatcher;

    /**
     * Remove watcher
     */
    CMCSPluginWatcher* iRemoveWatcher;

    /**
     * MCS plugin folder ID
     */
    TInt iMCSPluginFolderId;

};

#endif // CMCSPLUGINSETTINGSBKMLIST_H

// End of File.
hs_app_mcspluginsettingscontainer.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  MCS settings plug-in container.
*
*/


#ifndef CMCSPLUGINSETTINGSCONTAINER_H
#define CMCSPLUGINSETTINGSCONTAINER_H

// External includes
#include 
#include 
#include 
#include    // For MFavouritesDbObserver
#include            // For RFavouritesDb
#include                  // For MMsvSessionObserver

// Internal includes
#include "hs_app_mcspluginwatcher.h"

// Forward declaration
class CAknRadioButtonSettingPage;
class CMCSPluginSettingsModel;
class CActiveFavouritesDbNotifier;
class CMCSPluginWatcher;

/**
 *  @ingroup group_mcsplugin
 *
 * Shortcut settings plug-in container
 *
 * @lib hs_app_mcspluginsettings.lib
 * @since S60 v3.2
 */
class CMCSPluginSettingsContainer : public CGSBaseContainer, 
    public MFavouritesDbObserver, public MMsvSessionObserver,
    public MMCSPluginWatcherObserver
{

public:
    /**
     * Public constructor
     */
    CMCSPluginSettingsContainer();

    /*
     * Descructor
     */
    virtual ~CMCSPluginSettingsContainer();

    /**
     * Sets pointer to settings plug-in model.
     *
     * @since S60 v3.2
     * @param aModel Pointer to settings plug-in model
     */
    void SetModel(CMCSPluginSettingsModel* aModel);

    /**
     * Handles a setting change command
     *
     * @since S60 v3.2
     */
    void HandleChangeCommandL();

    /**
     * Handles a help command
     *
     * @since S60 v9.1
     */
    void HandleHelpCommandL();

    /**
     * Dialog showing changed
     *
     * @since S60 v3.2
      */
    TBool IsChangeDialogShowing();

    /**
     * Close change dialog
     *
     * @since S60 v3.2
     */
    void CloseChangeDialog();

    /**
     * Reset current list
     *
     * @since S60 v3.2
     */
    void ResetCurrentListL(TInt aIndex);

    // from base class MMsvSessionObserver

    /**
     * Handles an event from the message server.
     * Not used, but must be defined to be able to use the messaging server.
     *
     * @since S60 v3.2
     * @param aEvent Indicates the event type.
     * @param aArg1 Event type-specific argument value
     * @param aArg2 Event type-specific argument value
     * @param aArg3 Event type-specific argument value
     */
    void HandleSessionEventL( TMsvSessionEvent aEvent, TAny* aArg1, 
        TAny* aArg2, TAny* aArg3 );

    // from base class MMCSPluginWatcherObserver

    /**
     * Hanle notify
     */
    void HandleNotifyL();

private:

    /*
     * Leaving constructor
     * 
     * @param aRect
     */
    void ConstructL(const TRect& aRect);

    /**
     * Tells the settings container to start observing for changes in favorites
     * database and mailbox db.
     *
     */
    void StartObservingL();

    /**
     * Tells the settings container to stop observing for changes in favorites
     * database and mailbox db.
     *
     */
    void StopObserving();

    // from base class CGSBaseContainer

    /**
     * From CGSBaseContainer
     * Constructs the settings listbox
     *
     * @since S60 v3.2
     * @param aResLbxId Listbox resource id
     */
    void ConstructListBoxL(TInt aResLbxId);

    /**
     * Chandles a setting change command to select application from a list
     *
     * @since S60 v3.2
     * @param aItem Applist item to modify
     * @param aNew ETrue if selecting an application for first time, 
     *             EFalse if not
     * @return ETrue if shortcut was changed. EFalse if not
     */
    TBool HandleAppListChangeCommandL( const TInt& aIndex,
        const TInt& aSettingIndex );

    /**
     * Chandles a setting change command to select bookmark from a list
     *
     * @since S60 v3.2
     * @param aItem Applist item to modify
     * @param aNew ETrue if selecting an application for first time, 
     *             EFalse if not
     * @return ETrue if shortcut was changed. EFalse if not
     */
    TBool HandleBookmarkChangeCommandL( const TInt& aIndex,
        const TInt& aSettingIndex );

    /**
     * Creates Help Context for launching Shortcuts Help page.
     */
    TCoeHelpContext GetHelpContext() const;

    /**
     * Offer key event
     * 
     * @param aKeyEvent
     * @param aType
     */
    TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode aType);

    /**
     * Checks if there is a need to update the middle softkey label.
     */
    void CheckMiddleSoftkeyLabelL();

    // From MFavouritesDbObserver
    /**
     * Handles database event.
     * @param aEvent Database event.
     */
    void HandleFavouritesDbEventL(RDbNotifier::TEvent aEvent);

private:  // data

    /**
     * Settings plug-in model.
     * Not own.
     */
    CMCSPluginSettingsModel*       iModel;

    /**
     * Application selection list page.
     * Own.
     */
    CAknRadioButtonSettingPage* iAppListDialog;

    /**
     * Bookmark selection list page.
     * Own.
     */
    CAknRadioButtonSettingPage* iBkmListDialog;

    /**
     * Bookmark database change observer.
     * Own.
     */
    CActiveFavouritesDbNotifier* iBookmarkDbObserver;

    /**
     * Bookmark database.
     */
    RFavouritesDb iBookmarkDb;

    /**
     * Bookmark database session.
     */
    RFavouritesSession iBookmarkSession;

    /**
     * Message server session
     * Own.
     */
    CMsvSession* iMsvSession;

    // MCS resource
    RMenu iMenu;

    // MCS change notifier
    RMenuNotifier iNotifier;

    /* MCS change notifier watcher
     * Own
     */
    CMCSPluginWatcher* iNotifyWatcher;
};

#endif // CMCSPLUGINSETTINGSCONTAINER_H

// End of File.
hs_app_mcspluginsettingsmodel.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  MCS settings plug-in model.
*
*/


#ifndef CMCSPLUGINSETTINGSMODEL_H
#define CMCSPLUGINSETTINGSMODEL_H

// External includes
#include 
#include                // For MDesCArray
#include 
#include 
#include 
#include 

// Internal includes
#include "hs_app_mcspluginsettingsapplist.h"
#include "hs_app_mcspluginsettingsbkmlist.h"

// Forward declaration
class CCoeEnv;
class CMCSPluginSettingsContainer;
class CMCSPluginSettings;
class HSPluginSettingsIf::CItemMap;

/**
 * TSettingType
 */
enum TSettingType
    {
    EApplication,
    EBookmark
    };

/**
 * TSettingItem
 */
struct TSettingItem
    {
    TInt id;
    TSettingType type;
    TBool locked;
    };

/**
 *  @ingroup group_mcsplugin
 *
 * MCS settings plug-in model
 *
 * @lib hs_app_mcspluginsettings.lib
 * @since S60 9.1
 */
class CMCSPluginSettingsModel : public CBase
    , public MDesCArray
    , public HSPluginSettingsIf::MHomeScreenSettingsObserver
{

public:

    /**
     * Two phase constructor
     * 
     * @param aPlugin
     * @param aEnv
     */
    static CMCSPluginSettingsModel* NewL( CMCSPluginSettings& aPlugin,
        CCoeEnv* aEnv);

    /**
     * Descructor
     */
    virtual ~CMCSPluginSettingsModel();

public: // from MDesCArray

    /**
     * Returns the number of descriptor elements in a descriptor array.
     *
     * @since S60 v3.2
     * @return The number of descriptor elements in a descriptor array.
     */
    TInt MdcaCount() const;

    /**
     * Indexes into a descriptor array.
     *
     * @since S60 v3.2
     * @param aIndex The position of the descriptor element within 
     *               a descriptor array.
     * @return A 16 bit non-modifiable pointer descriptor representing the 
     *         descriptor element located at position aIndex within a descriptor 
     *         array.
     */
    TPtrC MdcaPoint(TInt aIndex) const;

public:

    /**
     * Returns an ID of a setting item for the given index
     *
     * @since S60 v3.2
     * @param aIndex Index of the setting item
     * @return ID of a setting item
     */
    TInt ItemId( TInt aIndex ) const;

    /**
     * Returns a pointer to setting item for the given index
     *
     * @since S60 v9.1
     * @param aIndex Index of the setting item
     * @return setting item
     */
    const TSettingItem Item( TInt aIndex ) const;

    /**
     *
     */
    TBool ReplaceItemL( const TInt& aItemIndex, TInt aValue,
        TSettingType aType );

    /**
     * Sets pointer to settings plug-in container.
     *
     * @since S60 v3.2
     * @param aContainer Pointer to settings plug-in container.
     */
    void SetContainer(CMCSPluginSettingsContainer* aContainer);


    /**
     * Get application list
     */
    CMCSPluginSettingsAppList* AppList();

    /**
     * Get bookmark list
     */
    CMCSPluginSettingsBkmList* BkmList();

    /**
     * Update application list
     */
    void UpdateAppListL();

    /**
     * Update bookmark list
     */
    void UpdateBkmListL();

    /**
     * Update settings container
     * 
     * @param aPluginId
     */
    void UpdateSettingsContainerL( const TDesC8& aPluginId );

    // From MHomeScreenSettingsObserver
    /**
     * Settings changed
     * 
     * @param aEvent
     * @param aPluginName
     * @param aPluginUid
     * @param aPluginId
     * @return TInt
     */
    TInt SettingsChangedL( const TDesC8& aEvent,  const TDesC8& aPluginName,
        const TDesC8& aPluginUid, const TDesC8& aPluginId );

private:

    /**
     * Private constructor
     * 
     * @param aPlugin
     * @param aEnv
     */
    CMCSPluginSettingsModel(CMCSPluginSettings& aPlugin, CCoeEnv* aEnv);

    /**
     * Leaving constructor
     */
    void ConstructL();

    /**
     * ListBoxLineL
     * 
     * @param aCaption
     * @param aIndex
     * @return TPtrC
     */
    TPtrC ListBoxLineL( const TDesC& aCaption, TInt aIndex ) const;

    /**
     * ItemL
     * 
     * @param aProperties
     * @return TSettingItem
     */
    TSettingItem ItemL( 
        RPointerArray& aProperties );

    /**
     * Setting type
     * 
     * @param aProperties
     * @return TSettingType
     */
    TSettingType SettingTypeL( 
       RPointerArray& aProperties );

    /**
     * Setting locked
     * 
     * @param aProperties
     * @return TBool
     */
    TBool SettingLockedL( 
        RPointerArray& aProperties );

    /**
     * Update settings
     * 
     * @param aPluginId
     */
    void UpdateSettingsL( const TDesC8& aPluginId );

    /**
     * Save settings
     * 
     * @param aIndex
     * @param aMenuItem
     */
    void SaveSettingsL( const TInt& aIndex, CMenuItem& aMenuItem );

private: // data

    /**
     * Array of setting items.
     * Own.
     */
    RArray iSettings;

    // Homescreen settings API
    HSPluginSettingsIf::CHomescreenSettings* iPluginSettings;

    HBufC8* iPluginId;

    // Stores the text which is drawn by listbox
    // Listbox takes only reference
    mutable HBufC* iListBoxLine;

    /**
     * Settings plugin
     * Not own.
     */
    CMCSPluginSettings& iPlugin;

    /**
     * Coe environment.
     * Not own.
     */
    CCoeEnv* iEnv;

    /**
     * Application list.
     * Own.
     */
    CMCSPluginSettingsAppList* iAppList;

    /**
     * Bookmark list.
     * Own.
     */
    CMCSPluginSettingsBkmList* iBkmList;

    /**
     * Settings plugin container.
     * Not own.
     */
    CMCSPluginSettingsContainer* iContainer;
};

#endif // CMCSPLUGINSETTINGSMODEL_H

// End of File.
hs_app_mcspluginsettings.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  MCS settings plug-in main class.
*
*/

#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include                 // For RProperty
#include     // For KPSUidActiveIdle2

#include 
#include 
#include 

#include "hs_app_mcspluginsettings.hrh"
#include "hs_app_mcspluginsettings.h"
#include "hs_app_mcspluginsettingscontainer.h"
#include "hs_app_mcspluginsettingsmodel.h"
#include "hs_app_mcspluginuids.hrh"

const TUid KUidScutSettingsPlugin =
{
    AI_UID_ECOM_IMPLEMENTATION_SETTINGS_MCSPLUGIN
};

const TUid KUidAiFwCommon =
{
        AI_UID3_AIFW_COMMON
};

_LIT(KMCSSettingsResourceFileName, "hs_app_mcspluginsettingsres.rsc");

/** Implementation table for MCS settings plug-in */
const TImplementationProxy KMCSPluginSettingsImplementationTable[] =
{
    IMPLEMENTATION_PROXY_ENTRY(
        AI_UID_ECOM_IMPLEMENTATION_SETTINGS_MCSPLUGIN, CMCSPluginSettings::NewL)
};


// ---------------------------------------------------------------------------
// Gate/factory function.
// ---------------------------------------------------------------------------
//
EXPORT_C const TImplementationProxy* ImplementationGroupProxy(TInt& aTableCount)
{
    aTableCount =
        sizeof(KMCSPluginSettingsImplementationTable) /
        sizeof(TImplementationProxy);
    return KMCSPluginSettingsImplementationTable;
}

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
// First phase construction
// ---------------------------------------------------------------------------
//
CMCSPluginSettings::CMCSPluginSettings()
{
}

// ---------------------------------------------------------------------------
// Second phase construction
// ---------------------------------------------------------------------------
//
void CMCSPluginSettings::ConstructL()
{
    FeatureManager::InitializeLibL();

    TParsePtrC driveParse(PathInfo::RomRootPath());
    TFileName resourceName(driveParse.Drive());
    // Find the resource file.
    TParse parse;
    parse.Set(KMCSSettingsResourceFileName, &KDC_RESOURCE_FILES_DIR, NULL);
    resourceName.Append(parse.FullName());
    // Open resource file.
    iResourceLoader.OpenL(resourceName);

    iModel = CMCSPluginSettingsModel::NewL(*this, iCoeEnv);

    BaseConstructL(R_AI_MCS_SETTINGS_VIEW);
}

// ---------------------------------------------------------------------------
// Two-phased constructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettings* CMCSPluginSettings::NewL( TAny* /*aInitParams*/ )
{
    CMCSPluginSettings* self = new (ELeave) CMCSPluginSettings;
    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);
    return self;
}

// ---------------------------------------------------------------------------
// Destructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettings::~CMCSPluginSettings()
{
    FeatureManager::UnInitializeLib();
    iResourceLoader.Close();
    delete iModel;
}

// ---------------------------------------------------------------------------
// From CAknView
// Returns view id.
// ---------------------------------------------------------------------------
//
TUid CMCSPluginSettings::Id() const
{
    return KUidScutSettingsPlugin;
}

// ---------------------------------------------------------------------------
// From CAknView
// Handles commands.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettings::HandleCommandL(TInt aCommand)
{
    switch (aCommand)
    {
    case EAiScutSettingsCmdChange:
        Container()->HandleChangeCommandL();
        break;

    case EAknCmdHelp:
        Container()->HandleHelpCommandL();
        break;

    case EAknSoftkeyBack:
        if (iAppUi->View(KGSMainViewUid))
        {
            // if we are in GS activate parent plugin view (standby view)...
            iAppUi->ActivateLocalViewL(KGSPrslnPluginUid);
        }
        else
        {
            iAppUi->ActivateLocalViewL(iPrevViewId.iViewUid);
        }
        break;

    case EAknSoftkeyExit:
        iAppUi->HandleCommandL(EAknCmdExit);
        break;

    default:
        iAppUi->HandleCommandL(aCommand);
        break;
    }
}

// ----------------------------------------------------------------------------
// From CAknView
// First method called by the Avkon framwork
// ----------------------------------------------------------------------------
//
void CMCSPluginSettings::DoActivateL(const TVwsViewId& aPrevViewId, TUid aCustomMessageId, const TDesC8& aCustomMessage)
{
    CEikButtonGroupContainer* cba = Cba();

    if (cba)
    {
        if (aCustomMessageId == KUidAiFwCommon)
        {
            cba->SetCommandSetL(R_SCUT_SOFTKEYS_OPTIONS_EXIT_CHANGE);
        }
        else
        {
            cba->SetCommandSetL(R_SCUT_SOFTKEYS_OPTIONS_BACK_CHANGE);
        }
        cba->DrawDeferred();
    }

    CGSBaseView::DoActivateL(aPrevViewId, aCustomMessageId, aCustomMessage);
    
    iModel->UpdateSettingsContainerL( aCustomMessage );
}

// ----------------------------------------------------------------------------
// From CAknView
// Called by the Avkon view framework when closing.
// ----------------------------------------------------------------------------
//
void CMCSPluginSettings::DoDeactivate()
{
    CGSBaseView::DoDeactivate();

    iModel->SetContainer(Container());
}

// ----------------------------------------------------------------------------
// From MEikMenuObserver
// ----------------------------------------------------------------------------
//
void CMCSPluginSettings::DynInitMenuPaneL(
    TInt aResourceId, CEikMenuPane* aMenuPane)
{
    if (aMenuPane && aResourceId == R_AI_MCS_SETTINGS_MENUPANE)
    {
        if (!FeatureManager::FeatureSupported(KFeatureIdHelp))
        {
            // Disable help if not supported
            aMenuPane->SetItemDimmed(EAknCmdHelp, ETrue);
        }
        if (iModel->MdcaCount() == 0)
        {
            aMenuPane->SetItemDimmed(EAiScutSettingsCmdChange, ETrue);
        }
    }
}

// ---------------------------------------------------------------------------
// From CGSPluginInterface. 256
// ---------------------------------------------------------------------------
//
void CMCSPluginSettings::GetCaptionL(TDes& aCaption) const
{
    iCoeEnv->ReadResourceL(aCaption, R_AI_MCS_SETTINGS_VIEW_CAPTION);
}

// ---------------------------------------------------------------------------
// From CGSPluginInterface
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettings::PluginProviderCategory() const
{
    return KGSPluginProviderInternal;
}

// ---------------------------------------------------------------------------
// From CGSPluginInterface
// ---------------------------------------------------------------------------
//
TBool CMCSPluginSettings::Visible() const
{
    return EFalse;
}

// ---------------------------------------------------------------------------
// From CGSBaseView
// Returns view id.
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsContainer* CMCSPluginSettings::Container()
{
    return static_cast(iContainer);
}

// ---------------------------------------------------------------------------
// From CGSBaseView
// ---------------------------------------------------------------------------
//
void CMCSPluginSettings::NewContainerL()
{
    delete iContainer;
    iContainer = NULL;
    
    iContainer = new (ELeave) CMCSPluginSettingsContainer();
    Container()->SetModel(iModel);
    iModel->SetContainer(Container());
}

// ---------------------------------------------------------------------------
// From CGSBaseView
// ---------------------------------------------------------------------------
//
void CMCSPluginSettings::HandleListBoxSelectionL()
{
    Container()->HandleChangeCommandL();
}

// ---------------------------------------------------------------------------
// Returns if container exists or not
// ---------------------------------------------------------------------------
//
TBool CMCSPluginSettings::Activated() const
    {
    return iContainer ? ETrue : EFalse;
    }

// End of File.
hs_app_mcspluginsettingsapplist.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Application list for settings listbox
*
*/


#include 
#include         // For KMsvRootIndexEntryIdValue
#include 
#include 
#include 
#include 
#include 
#include 

#include "hs_app_mcspluginsettingsapplist.h"
#include "hs_app_mcspluginsettingsmodel.h"
#include "hs_app_mcspluginwatcher.h"

_LIT( KMyMenuData, "matrixmenudata" );
_LIT( KMenuTypeShortcut, "menu:shortcut" );
_LIT( KMenuAttrRefcount, "ref_count" );
_LIT( KMenuParamMailbox, "mailbox:" );
_LIT( KMenuAttrParameter, "param" );
_LIT( KMenuAttrLocked, "locked" );
_LIT( KMenuIconFile, "aimcsplugin.mif" );
_LIT( KMenuIconId, "16388" );
_LIT( KMenuMaskId, "16389" );
_LIT( KMailboxUid, "0x100058c5" );
_LIT( KInitialRefCount, "1" );
_LIT( KMCSFolder, "mcsplugin_folder" );
_LIT8( KItemLocked, "locked");
_LIT8( KProperValueFolder, "folder" );

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
// First-phase construction
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsAppList::CMCSPluginSettingsAppList()
    {
    iMCSPluginFolderId = 0;
    }

// ---------------------------------------------------------------------------
// Second-phase construction
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsAppList::ConstructL()
    {
    iMsvSession = CMsvSession::OpenAsObserverL(*this);

    iMenu.OpenL( KMyMenuData );
    iSaveWatcher = CMCSPluginWatcher::NewL( CMCSPluginWatcher::EOperation );
    iUpdateWatcher = CMCSPluginWatcher::NewL( CMCSPluginWatcher::EOperation );
    iRemoveWatcher = CMCSPluginWatcher::NewL( CMCSPluginWatcher::EOperation );
    }

// ---------------------------------------------------------------------------
// Two-phased constructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsAppList* CMCSPluginSettingsAppList::NewL()
    {
    CMCSPluginSettingsAppList* self = new (ELeave) CMCSPluginSettingsAppList();
    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);
    return self;
    }

// ---------------------------------------------------------------------------
// Destructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsAppList::~CMCSPluginSettingsAppList()
    {
    delete iMsvSession;

    iListItems.ResetAndDestroy();
    iMenu.Close();
    delete iSaveWatcher;
    delete iUpdateWatcher;
    delete iRemoveWatcher;
    
    }

// ---------------------------------------------------------------------------
// From MDesCArray
// Returns the number of descriptor elements in a descriptor array.
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsAppList::MdcaCount() const
    {
    return iListItems.Count();
    }

// ---------------------------------------------------------------------------
// From MDesCArray
// Indexes into a descriptor array.
// ---------------------------------------------------------------------------
//
TPtrC CMCSPluginSettingsAppList::MdcaPoint( TInt aIndex ) const
    {
    if (aIndex < 0 || aIndex >= iListItems.Count())
        {
        TPtrC ret(KNullDesC);
        return ret;
        }
    CMenuItem* item = iListItems[aIndex];
    TBool attrExists;
    TPtrC itm; 
    TRAP_IGNORE( 
        itm.Set( item->GetAttributeL( KMenuAttrLongName, attrExists ) );
        )
    return itm;
    }

// ---------------------------------------------------------------------------
// From class MMsvSessionObserver.
// Handles an event from the message server.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsAppList::HandleSessionEventL(
                                                  TMsvSessionEvent /*aEvent*/, 
                                                  TAny* /*aArg1*/, 
                                                  TAny* /*aArg2*/,
                                                  TAny* /*aArg3*/ )
    {

    }

// ---------------------------------------------------------------------------
// Starts the asynchronous application list initialization.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsAppList::StartL()
    {
    iListItems.ResetAndDestroy();
    AddMailboxesL();
    AddStaticItemsL();
    }

// ---------------------------------------------------------------------------
// Iterates thru the application list and tries to find a menuitem which 
// matches given property map from HSPS
// ---------------------------------------------------------------------------
//
TSettingItem CMCSPluginSettingsAppList::FindItemL( 
        RPointerArray& aProperties )
    {
    TBool attrExists( EFalse );
    TSettingItem settingItem = { KErrNotFound, EApplication, EFalse };
    TBool isFolder = EFalse;

    // check if the item is folder
    for ( TInt j = 0; j < aProperties.Count(); j++ )
        {
        if( aProperties[j]->Name() == KType )
            {

            if ( aProperties[j]->Value() == KProperValueFolder )
                {
                isFolder = ETrue;
                }
            break;
            }
        }   

    TBool itemFound( EFalse );
    
    // compare name/value pairs with every menu item in the list
    for ( TInt i = 0; i < iListItems.Count() && !itemFound; i++ )
        {
        TBool match( ETrue );
        CMenuItem* item = iListItems[ i ];

        for ( TInt j = 0; j < aProperties.Count() && match; j++ )
            {
            // type and locked properties skipped
            if ( aProperties[j]->Name() != KType &&
                 aProperties[j]->Name() != KItemLocked )
                {
                HBufC* attrName( NULL );
                attrName = AiUtility::CopyToBufferL( attrName,
                        aProperties[j]->Name());
                CleanupStack::PushL( attrName );
                TPtrC attr = item->GetAttributeL( *attrName, attrExists );

                HBufC* attrValue( NULL );
                attrValue = AiUtility::CopyToBufferL( attrValue,
                        aProperties[j]->Value());
                CleanupStack::PushL( attrValue );

                // in case of folder, we just have to compare id
                // which is stored in param attribute
                if ( isFolder && *attrName == KMenuAttrParameter )
                    {
                    // convert id to integer
                    TInt id;
                    TLex16 lextmp( attrValue->Ptr() );
                    lextmp.Val( id );

                    if ( item->Id() != id )
                        {
                        match = EFalse;
                        }
                    CleanupStack::PopAndDestroy( attrValue );
                    CleanupStack::PopAndDestroy( attrName );
                    break;
                    }

                // otherwise, compare attributes from HSPS and from menuitem
                // if there is no match, move to the next item in the list
                if ( attr != *attrValue )
                    {
                    match = EFalse;
                    }
                CleanupStack::PopAndDestroy( attrValue );
                CleanupStack::PopAndDestroy( attrName );
                }
            }

        if ( match )
            {
            settingItem.id = i;
            settingItem.type = EApplication;
            itemFound = ETrue;
            }
        }
    return settingItem;
    }


// ---------------------------------------------------------------------------
// Returns menuitems at given index. Since this method is called during
// adding the item to the Desktop widget, we also have to increment
// ref_count attribute if the item is run-time generated (i.e. Mailbox)
// ---------------------------------------------------------------------------
//
CMenuItem& CMCSPluginSettingsAppList::ItemL( const TInt& aIndex )
    {

    CMenuItem* menuItem( NULL );
    
    // check if index in within the list boundaries
    if ( aIndex >= 0 && aIndex < iListItems.Count() )
        {

        menuItem = iListItems[ aIndex ];

        TBool hasParam = EFalse;
        CleanupStack::PushL( menuItem );
        TPtrC param = menuItem->GetAttributeL( KMenuAttrParameter, hasParam ); 
        CleanupStack::Pop( menuItem );

        // if item is a mailbox, add it to MCS
        // (if it is not already there)
        if ( hasParam && param.Find( KMenuParamMailbox ) != KErrNotFound )
            {

            // set up a filter for finding the mailbox
            // with given ID in MCS
            CMenuFilter* filter = CMenuFilter::NewL();
            CleanupStack::PushL( filter );

            filter->SetType( KMenuTypeShortcut );
            filter->HaveAttributeL( KMenuAttrParameter, param );

            // search menu from the Root folder with the filter
            const TInt rootId = iMenu.RootFolderL();
            RArray itemArray;
            CleanupClosePushL( itemArray );
            iMenu.GetItemsL( itemArray, rootId, filter, ETrue );
                
            // save the number of findings
            TInt count( itemArray.Count() );

            // if MenuItem does not exist in MCS
            if ( count == 0 )
                {
                // save the item into Matrixmenudata.xml
                // the "op" variable is cleaned up by iSaveWatcher when asynchronous 
                // operation finishes
                CleanupStack::PushL( menuItem );
                CMenuOperation* op = menuItem->SaveL( iSaveWatcher->iStatus );
                CleanupStack::Pop( menuItem );
                iSaveWatcher->Watch( op ); 
                }
            else
                {
                // Item already exists in MCS
                // If it has reference counter, increment it before returning.
                CMenuItem* itm = CMenuItem::OpenL( iMenu, itemArray[ 0 ] );

                TInt newRefCount = UpdateMenuItemsRefCountL( itm, 1 );
                if ( newRefCount > -1 )
                    {
                    CleanupStack::PushL( itm );
                    CMenuOperation* op = itm->SaveL( iSaveWatcher->iStatus );
                    CleanupStack::PopAndDestroy( itm );
                    iSaveWatcher->Watch( op );
                    }
                }
            CleanupStack::PopAndDestroy( &itemArray );
            CleanupStack::PopAndDestroy( filter );
            }
        }
    return *menuItem;
    }

// ---------------------------------------------------------------------------
// Helper method for comparing names of two menuitems. Used to sort the list
// of items.
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsAppList::CompareNameL( const CMenuItem& aFirst,
                                              const CMenuItem& aSecond )
    {
    TBool exists( EFalse );
    CMenuItem& first = const_cast(aFirst);
    CMenuItem& second = const_cast(aSecond);
    
    TPtrC name1 = first.GetAttributeL( KMenuAttrLongName, exists );
    TPtrC name2 = second.GetAttributeL( KMenuAttrLongName, exists );
    
    return name1.CompareC( name2 );
    }

// ---------------------------------------------------------------------------
// Adds the static list items to the application list.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsAppList::AddStaticItemsL()
    {
    TLinearOrder sortMethod( CMCSPluginSettingsAppList::CompareNameL );
    
    CMenuFilter* filter = CMenuFilter::NewL();
    CleanupStack::PushL( filter );

    // skip run-time generated items
    filter->DoNotHaveAttributeL( KMenuAttrRefcount );
    filter->DoNotHaveAttributeL( KMenuAttrLocked );
    const TInt rootId = iMenu.RootFolderL();
    RArray itemArray;
    CleanupClosePushL( itemArray );
    iMenu.GetItemsL( itemArray, rootId, filter, ETrue );
    
    TInt count( itemArray.Count() );
    
    for ( TInt i = 0; i < count; i++ )
        {
        TPtrC type = itemArray[ i ].Type();
        
        // we add applications, shortcuts and folders to the list
        if ( type == KMenuTypeApp || type == KMenuTypeShortcut || 
             type == KMenuTypeFolder )
            {
            CMenuItem* menuItem = CMenuItem::OpenL( iMenu, itemArray[ i ] );
            CleanupStack::PushL( menuItem );

            // only non-hidden and non-missing items should be offered to the user
            if ( ( menuItem->Flags() & TMenuItem::EHidden ) == EFalse &&
                 ( menuItem->Flags() & TMenuItem::EMissing ) == EFalse )
                {
                User::LeaveIfError( iListItems.InsertInOrderAllowRepeats( menuItem, sortMethod ) );
                CleanupStack::Pop( menuItem );
                }
            else 
                {
                CleanupStack::PopAndDestroy( menuItem );
                }
            menuItem = NULL;
            }
        }

    CleanupStack::PopAndDestroy( &itemArray );
    CleanupStack::PopAndDestroy( filter );
    }


// ---------------------------------------------------------------------------
// Returns the root entry containing mailboxes.
// ---------------------------------------------------------------------------
//
CMsvEntry* CMCSPluginSettingsAppList::GetRootEntryL()
    {
    return iMsvSession->GetEntryL(KMsvRootIndexEntryIdValue);
    }

// ---------------------------------------------------------------------------
// Adds remote mailboxes to the application list.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsAppList::AddMailboxesL()
    {
    
    iListItems.ResetAndDestroy();
    CMsvEntry* rootEntry = GetRootEntryL();
    CleanupStack::PushL(rootEntry);
    TBuf<255> mailboxId;
    
    for ( TInt i = rootEntry->Count() - 1; i >= 0; --i )
        {
        const TMsvEntry& tentry = (*rootEntry)[i];

        if (tentry.iMtm == KSenduiMtmImap4Uid || tentry.iMtm == KSenduiMtmPop3Uid)
            {
            mailboxId.Num( tentry.Id() );  
            AddMailboxL( tentry.iDetails, mailboxId );
            }
        }
    CleanupStack::PopAndDestroy(rootEntry);
    }

// ---------------------------------------------------------------------------
// Adds a mailbox to the list.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsAppList::AddMailboxL( const TDesC& aMailbox,
                                             const TDesC& aMailboxId )
    {
        // prepare param value
        HBufC* params = HBufC::NewLC( KMenuParamMailbox().Length() + aMailboxId.Length() );
        params->Des().Copy( KMenuParamMailbox );
        params->Des().Append( aMailboxId );
        TPtrC paramValue( params->Des() );

        TLinearOrder sortMethod( CMCSPluginSettingsAppList::CompareNameL );
        CMenuItem* newItem = CMenuItem::CreateL( iMenu, 
                                                 KMenuTypeShortcut, 
                                                 GetMCSPluginFolderIdL(), 
                                                 0 );
        CleanupStack::PushL( newItem );

        // mailbox is a shortcut item with "mailbox:mailboxID" parameter
        newItem->SetAttributeL( KMenuAttrUid, KMailboxUid );
        newItem->SetAttributeL( KMenuAttrLongName, aMailbox );
        newItem->SetAttributeL( KMenuAttrParameter, paramValue );
        newItem->SetAttributeL( KMenuAttrRefcount, KInitialRefCount );

        // setting icon for the shortcut
        newItem->SetAttributeL( KMenuAttrIconFile, KMenuIconFile );
        newItem->SetAttributeL( KMenuAttrIconId, KMenuIconId );
        newItem->SetAttributeL( KMenuAttrMaskId, KMenuMaskId );

        // append the item into iListItems lists
        User::LeaveIfError( iListItems.InsertInOrderAllowRepeats( newItem, sortMethod ) );
        CleanupStack::Pop( newItem );
        CleanupStack::PopAndDestroy( params );
    }

// ---------------------------------------------------------------------------
// Removes run-time generated menuitem (i.e. Mailbox) from MCS
// If the item at given index is not run-time generated, return
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsAppList::RemoveMenuItemL( TInt aIndex )
    {

    if ( aIndex < 0 || aIndex > iListItems.Count() - 1 )
        {
        return;
        }

    CMenuItem* menuItem = iListItems[ aIndex ];
    
    TBool hasParam = ETrue;
    TPtrC param = menuItem->GetAttributeL( KMenuAttrParameter, hasParam );

    if ( !hasParam )
        {
        // nothing to do
        return;
        }

    // set up a filter for finding the mailbox
    // with given ID in MCS
    CMenuFilter* filter = CMenuFilter::NewL();
    CleanupStack::PushL( filter );

    filter->SetType( KMenuTypeShortcut );
    filter->HaveAttributeL( KMenuAttrParameter, param );

    // search menu from the Root folder with the filter
    const TInt rootId = iMenu.RootFolderL();
    RArray itemArray;
    CleanupClosePushL( itemArray );
    iMenu.GetItemsL( itemArray, rootId, filter, ETrue );

    // save the number of findings
    TInt count( itemArray.Count() );
    
    if ( count > 0 )
        {
        // Item already exists in MCS
        // If it has reference counter, increment it before returning.
        CMenuItem* itm = CMenuItem::OpenL( iMenu, itemArray[ 0 ] );
        
        // decrement ref_count attribute 
        TInt newRefCount = UpdateMenuItemsRefCountL( itm, -1 );
        if ( newRefCount > 0 )
            {
            CleanupStack::PushL( itm ); 
            CMenuOperation* op = itm->SaveL( iUpdateWatcher->iStatus );
            CleanupStack::Pop( itm );
            iUpdateWatcher->Watch( op );
            }
        else if ( newRefCount == 0 )
            {
            // counter reached 0 -> item is not referenced by any shortcut
            // so remove it from MCS
            if ( iRemoveWatcher->IsActive() )
               {
               return;
               }
            CMenuOperation* op = iMenu.RemoveL( itm->Id(), iRemoveWatcher->iStatus );
            iRemoveWatcher->Watch( op );
            }
            delete itm;
        }
    CleanupStack::PopAndDestroy( &itemArray );
    CleanupStack::PopAndDestroy( filter );
    }

// ---------------------------------------------------------------------------
// Gets MCS Plugin folder ID. This hidden folder in matrixmenudata.xml is used 
// for storing run-time generated menuitems
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsAppList::GetMCSPluginFolderIdL()
    {
    
    if ( iMCSPluginFolderId == 0 )
        {
        CMenuItem* item( NULL );
        CMenuFilter* filter = CMenuFilter::NewL();
        CleanupStack::PushL( filter );
        filter->SetType( KMenuTypeFolder );
        filter->HaveAttributeL( KMenuAttrLongName, KMCSFolder );
        const TInt rootId = iMenu.RootFolderL();
        RArray itemArray;
        CleanupClosePushL( itemArray );
        iMenu.GetItemsL( itemArray, rootId, filter, ETrue );
        if ( itemArray.Count() > 0 )
            {
            item = CMenuItem::OpenL( iMenu, itemArray[ 0 ] );
            iMCSPluginFolderId = item->Id();
            }
        else 
            {
            iMCSPluginFolderId = iMenu.RootFolderL();
            }
        CleanupStack::PopAndDestroy( &itemArray );
        CleanupStack::PopAndDestroy( filter ); 
        delete item; 
        }
    return iMCSPluginFolderId;
    
    }

// ---------------------------------------------------------------------------
// Helper method for updating ref_count attribute of run-time generated 
// menuitems
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsAppList::UpdateMenuItemsRefCountL( CMenuItem* aItem, 
                                                          TInt aValueToAdd )
    {
    
    TBool exists = EFalse;
    CleanupStack::PushL( aItem ); 
    TPtrC param = aItem->GetAttributeL( KMenuAttrRefcount, exists );
    CleanupStack::Pop( aItem );
    if ( exists )
        {
        TInt references;
        TLex16 lextmp( param );
        lextmp.Val( references );
        references += aValueToAdd;
        TBuf<128> buf;
        buf.NumUC( references );
        // set new ref_count
        CleanupStack::PushL( aItem ); 
        aItem->SetAttributeL( KMenuAttrRefcount, buf );
        CleanupStack::Pop( aItem );
        // return new ref_count
        return references;
        }
    return -1;
    }


// End of File.
hs_app_mcspluginsettingsbkmlist.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Bookmark list for settings listbox
*
*/


#include 
#include  // For CActiveFavouritesDbNotifier
#include 
#include 
#include 
#include 
#include 

#include "hs_app_mcspluginsettingsmodel.h"
#include "hs_app_mcspluginsettingsapplist.h"
#include "hs_app_mcspluginsettingsbkmlist.h"
#include "hs_app_mcspluginwatcher.h"
#include "debug.h"

_LIT( KMyMenuData, "matrixmenudata" );
_LIT( KMenuUrl, "menu:url" );
_LIT( KMenuIconFile, "aimcsplugin.mif" );
_LIT( KMenuIconId, "16386" );
_LIT( KMenuMaskId, "16387" );
_LIT( KUrl, "url" );
_LIT8( KUid, "uid" );
_LIT( KMenuAttrRefcount, "ref_count" );
_LIT( KInitialRefCount, "1" );
_LIT( KMCSFolder, "mcsplugin_folder" );


// ======== MEMBER FUNCTIONS ========


// ---------------------------------------------------------------------------
// First-phase construction
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsBkmList::CMCSPluginSettingsBkmList()
    {
    iMCSPluginFolderId = 0;
    }

// ---------------------------------------------------------------------------
// Second-phase construction
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsBkmList::ConstructL()
    {
    User::LeaveIfError(iBookmarkSess.Connect());
    User::LeaveIfError(iBookmarkDb.Open(iBookmarkSess, KBrowserBookmarks));
    iMenu.OpenL( KMyMenuData );
    GetBookmarkListL();

    iSaveWatcher = CMCSPluginWatcher::NewL( CMCSPluginWatcher::EOperation );
    iUpdateWatcher = CMCSPluginWatcher::NewL( CMCSPluginWatcher::EOperation );
    iRemoveWatcher = CMCSPluginWatcher::NewL( CMCSPluginWatcher::EOperation );
    }

// ---------------------------------------------------------------------------
// Two-phased constructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsBkmList* CMCSPluginSettingsBkmList::NewL()
    {
    CMCSPluginSettingsBkmList* self = new (ELeave) CMCSPluginSettingsBkmList();
    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);
    return self;
    }

// ---------------------------------------------------------------------------
// Destructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsBkmList::~CMCSPluginSettingsBkmList()
    {
    iListItems.ResetAndDestroy();
    iMenuItems.ResetAndDestroy();
    iBookmarkDb.Close();
    iBookmarkSess.Close();
    iMenu.Close();
    delete iSaveWatcher;
    delete iUpdateWatcher;
    delete iRemoveWatcher;
    }

// ---------------------------------------------------------------------------
// From MDesCArray
// Returns the number of descriptor elements in a descriptor array.
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsBkmList::MdcaCount() const
    {
    return iListItems.Count();
    }

// ---------------------------------------------------------------------------
// From MDesCArray
// Indexes into a descriptor array.
// ---------------------------------------------------------------------------
//
TPtrC CMCSPluginSettingsBkmList::MdcaPoint(TInt aIndex) const
    {
    if (aIndex < 0 || aIndex >= iListItems.Count())
        {
        TPtrC ret(KNullDesC);
        return ret;
        }
    return iListItems[aIndex]->Caption();
    }

// ---------------------------------------------------------------------------
// Iterates thru the bookmark list and tries to find a menuitem which 
// matches given property map from HSPS
// ---------------------------------------------------------------------------
//
TSettingItem CMCSPluginSettingsBkmList::FindItemL( RPointerArray& aProperties )
    {
    TInt index( KErrNotFound );
    TSettingItem settingItem = { KErrNotFound, EBookmark };
    for( TInt i= 0; i < aProperties.Count(); i++ )
        {
        if( aProperties[i]->Name() == KUid )
            {
            HBufC* value( NULL );
            value = AiUtility::CopyToBufferL( value, aProperties[i]->Value());
            for( TInt j = 0; j < iListItems.Count(); j++ )
                {
                TPtrC uid = *iListItems[j]->iUid;
                if( uid.Compare( *value ) == 0 )
                    {
                    index = j;
                    break;
                    }
                }
            delete value;
            }
        if( index != KErrNotFound )
            {
            settingItem.id = index;
            settingItem.type = EBookmark;
            break;
            }
        }
    return settingItem;
    }

// ---------------------------------------------------------------------------
// Gets bookmark list.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsBkmList::GetBookmarkListL()
    {
    iListItems.ResetAndDestroy();

    GetBookmarksFromFavouritesL();
    GetBookmarksFromMCSL();
    }

// ---------------------------------------------------------------------------
// Gets bookmarks from Favourites server's bookmark database.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsBkmList::GetBookmarksFromFavouritesL()
    {
    CFavouritesItemList* favItems = new (ELeave) CFavouritesItemList();
    CleanupStack::PushL( favItems );
    TInt err = iBookmarkDb.GetAll( *favItems, KFavouritesNullUid, CFavouritesItem::EItem);
    if( err != KErrNone )
        {
        ASSERT(0);
        }
    TInt count = favItems->Count();
    for ( TInt i = count - 1; i >= 0; i-- ) // newest on top
        {
        TUid  uid  = TUid::Uid(favItems->At(i)->Uid());
        TPtrC name = favItems->At(i)->Name();
        TPtrC url = favItems->At(i)->Url();
        AddBookmarkL( uid.Name(), name, url, EFavBookmark );
        }
    CleanupStack::PopAndDestroy( favItems );
    }

// ---------------------------------------------------------------------------
// Gets bookmarks from Menu Content Service.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsBkmList::GetBookmarksFromMCSL()
    {
    TBool exists( EFalse );
    CMenuFilter* filter = CMenuFilter::NewL();
    CleanupStack::PushL( filter );
    filter->SetType( KMenuUrl );
    const TInt rootId = iMenu.RootFolderL();
    RArray itemArray;
    CleanupClosePushL( itemArray );
    iMenu.GetItemsL( itemArray, rootId, filter, ETrue );
    TInt count( itemArray.Count() );
    for ( TInt i = 0; i < count; i++ )
        {
        CMenuItem* menuItem = CMenuItem::OpenL( iMenu, itemArray[i] );
        CleanupStack::PushL( menuItem );
        TPtrC uid = menuItem->GetAttributeL( KMenuAttrUid, exists );
        TPtrC name = menuItem->GetAttributeL( KMenuAttrLongName, exists );
        TPtrC url = menuItem->GetAttributeL( KUrl, exists );

        // Check if bookmark is already present in Bookmark list.
        // This may happen in case of Favourite Bookmarks that were
        // previously added to MCS.
        // If it is, do not add it to Bookmark list anymore.
        
        TBool isRuntimeGenerated = EFalse;
        menuItem->GetAttributeL( KMenuAttrRefcount, isRuntimeGenerated );

        // if is not runtime generated and url exists, add it
        if ( !isRuntimeGenerated && exists )
            {
            AddBookmarkL( uid, name, url, EMCSBookmark );
            }

        CleanupStack::PopAndDestroy( menuItem );
        }

    CleanupStack::PopAndDestroy( &itemArray );
    CleanupStack::PopAndDestroy( filter );

    }

// ---------------------------------------------------------------------------
// If bookmark was selected amongst Favourites, new menu item is created into MCS.
// If predefined bookmark was selected, MCS menu item is retrieved
// ---------------------------------------------------------------------------
//
CMenuItem& CMCSPluginSettingsBkmList::ItemL( TInt aIndex )
    {
    CMenuItem* menuItem( NULL );
    CBkmListItem* listItem = iListItems[aIndex];
    if ( listItem->iType == EFavBookmark )
        {    
        TPtrC uid = *listItem->iUid;
        TPtrC name = *listItem->iCaption;
        TPtrC  url = *listItem->iUrl;
        menuItem = CreateMenuItemL( uid, name, url );
        }
    else
        {
        menuItem = MCSMenuItemL( *listItem->iUid, *listItem->iCaption, *listItem->iUrl );
        }
    return *menuItem;
    }

// ---------------------------------------------------------------------------
// Removes the menu item from MCS if it was created in runtime i.e. type is EFavBookmark.
// Favourite bookmarks have ref_count attribute, which is decremented everytime
// the bookmark is removed from some shortcut. When this counter reaches 0,
// its MenuItem is removed from MCS.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsBkmList::RemoveMenuItemL( TInt aIndex )
    {

    if ( aIndex < 0 || aIndex > iListItems.Count() - 1 )
        {
        return;
        }

    CBkmListItem* listItem = iListItems[aIndex];
    if( listItem->iType == EFavBookmark )
        {
        CMenuItem* menuItem = MCSMenuItemL( *listItem->iUid, *listItem->iCaption, *listItem->iUrl );
        if ( !menuItem )
            {
            return;
            }
        // decrement ref_count attribute 
        TInt newRefCount = UpdateMenuItemsRefCountL( menuItem, -1 );
        if ( newRefCount > 0 )
            {
            CleanupStack::PushL( menuItem ); 
            CMenuOperation* op = menuItem->SaveL( iUpdateWatcher->iStatus );
            CleanupStack::Pop( menuItem );
            iUpdateWatcher->Watch( op );
            }
        else if ( newRefCount == 0 )
            {
            // counter reached 0 -> item is not referenced by any shortcut
            // so remove it from MCS
            if ( iRemoveWatcher->IsActive() )
                {
                return;
                }
            CMenuOperation* op = iMenu.RemoveL( menuItem->Id(), iRemoveWatcher->iStatus );
            iRemoveWatcher->Watch( op );
            }
        }
    }

// ---------------------------------------------------------------------------
// Tries to find menuitem with given UID, Name and Url in MCS,
// If it does not exist, it is created and saved there.
// If it exists already, ref_count attribute is incremented.
// ---------------------------------------------------------------------------
//
CMenuItem* CMCSPluginSettingsBkmList::CreateMenuItemL( const TDesC& aUid,
                                                       const TDesC& aName,
                                                       const TDesC& aUrl )
    {
    // try to search item in MCS
    CMenuItem* item = MCSMenuItemL( aUid, aName, aUrl );
    
    if ( item == NULL )
        {
        // Item does not exist in MCS yet. 
        // We will add a new one with reference counter set to 1.
        CMenuItem* newItem = CMenuItem::CreateL( iMenu, 
                                                 KMenuTypeUrl, 
                                                 GetMCSPluginFolderIdL(), 0 );
        CleanupStack::PushL( newItem );

        newItem->SetAttributeL( KMenuAttrUid, aUid );
        newItem->SetAttributeL( KMenuAttrLongName, aName );
        newItem->SetAttributeL( KMenuAttrIconFile, KMenuIconFile );
        newItem->SetAttributeL( KMenuAttrIconId, KMenuIconId );
        newItem->SetAttributeL( KMenuAttrMaskId, KMenuMaskId );
        newItem->SetAttributeL( KMenuAttrRefcount, KInitialRefCount );
        newItem->SetAttributeL( KUrl , aUrl );
        
        CMenuOperation* op = newItem->SaveL( iSaveWatcher->iStatus );
        iSaveWatcher->Watch( op );
        iMenuItems.AppendL( newItem );
        CleanupStack::Pop( newItem );
        return newItem;
        }
    else
        {
        // Item already exists in MCS
        // If it has reference counter, increment it before returning.
        TInt newRefCount = UpdateMenuItemsRefCountL( item, 1 );
        if ( newRefCount > -1 )
            {
            CleanupStack::PushL( item );
            CMenuOperation* op = item->SaveL( iSaveWatcher->iStatus );
            CleanupStack::Pop( item );
            iSaveWatcher->Watch( op );
            }
        }
    return item;
    }

// ---------------------------------------------------------------------------
// Finds menuitem with given UID, Name and URL in MCS and returns it
// ---------------------------------------------------------------------------
//
CMenuItem* CMCSPluginSettingsBkmList::MCSMenuItemL( const TDesC& aUid,
                                                    const TDesC& aName,
                                                    const TDesC& aUrl )
    {
    CMenuItem* item( NULL );
    CMenuFilter* filter = CMenuFilter::NewL();
    CleanupStack::PushL( filter );
    
    filter->SetType( KMenuUrl );
    filter->HaveAttributeL( KMenuAttrUid, aUid );
    filter->HaveAttributeL( KMenuAttrLongName, aName );
    filter->HaveAttributeL( KUrl , aUrl );
    const TInt rootId = iMenu.RootFolderL();
    RArray itemArray;
    CleanupClosePushL( itemArray );
    iMenu.GetItemsL( itemArray, rootId, filter, ETrue );
    if( itemArray.Count() > 0 )
        {
        item = CMenuItem::OpenL( iMenu, itemArray[0] );
        CleanupStack::PushL( item );
        iMenuItems.AppendL( item );
        CleanupStack::Pop( item );
        }
    CleanupStack::PopAndDestroy( &itemArray );
    CleanupStack::PopAndDestroy( filter );
    return item;
    }

// ---------------------------------------------------------------------------
// Adds an bookmark to the list.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsBkmList::AddBookmarkL( const TDesC&  aUid, 
                                              const TDesC& aCaption, 
                                              const TDesC& aUrl, 
                                              TBookmarkType aType )
    {
    CBkmListItem* listItem = CBkmListItem::NewLC(aUid, aCaption);

    listItem->iType = aType;
    if( aUrl.Length() > 0 )
        {
        listItem->iUrl = aUrl.AllocL();
        }
    TLinearOrder sortMethod(CBkmListItem::CompareCaption);
    User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
    CleanupStack::Pop(listItem);
    }

// ---------------------------------------------------------------------------
// Updates the bookmark list.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsBkmList::UpdateBkmListL()
    {
    GetBookmarkListL();
    }

// ---------------------------------------------------------------------------
//Nested class to store individual bookmark list items
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsBkmList::CBkmListItem::CBkmListItem()
    {
    }

// ---------------------------------------------------------------------------
// Second-phase construction
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsBkmList::CBkmListItem::ConstructL( const TDesC&  aUid, 
                                                          const TDesC& aCaption )
    {
    iUid = aUid.AllocL();
    iCaption = aCaption.AllocL();
    }

// ---------------------------------------------------------------------------
// Two-phased constructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsBkmList::CBkmListItem* CMCSPluginSettingsBkmList::CBkmListItem::NewLC(
                                              const TDesC&  aUid, const TDesC& aCaption )
    {
    CBkmListItem* self = new (ELeave) CBkmListItem();
    CleanupStack::PushL(self);
    self->ConstructL( aUid, aCaption );
    return self;
    }

// ---------------------------------------------------------------------------
// Destructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsBkmList::CBkmListItem::~CBkmListItem()
    {
    delete iUid;
    delete iCaption;
    delete iUrl;
    }

// ---------------------------------------------------------------------------
// Compare method used to add the items to the list in sorted order.
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsBkmList::CBkmListItem::CompareCaption( const CBkmListItem& aFirst,
                                                              const CBkmListItem& aSecond )
{
    return aFirst.iCaption->Des().CompareC(*aSecond.iCaption);
}

// ---------------------------------------------------------------------------
// Returns the item target bookmark caption.
// ---------------------------------------------------------------------------
//
TPtrC CMCSPluginSettingsBkmList::CBkmListItem::Caption() const
{
    return TPtrC(*iCaption);
}

// ---------------------------------------------------------------------------
// Gets MCS Plugin folder ID. This hidden folder in matrixmenudata.xml is used 
// for storing run-time generated menuitems
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsBkmList::GetMCSPluginFolderIdL()
    {
    if ( iMCSPluginFolderId == 0 )
        {
        CMenuItem* item( NULL );
        CMenuFilter* filter = CMenuFilter::NewL();
        CleanupStack::PushL( filter );
        filter->SetType( KMenuTypeFolder );
        filter->HaveAttributeL( KMenuAttrLongName, KMCSFolder );
        const TInt rootId = iMenu.RootFolderL();
        RArray itemArray;
        CleanupClosePushL( itemArray );
        iMenu.GetItemsL( itemArray, rootId, filter, ETrue );
        if ( itemArray.Count() > 0 )
            {
            item = CMenuItem::OpenL( iMenu, itemArray[0] );
            iMCSPluginFolderId = item->Id();
            }
        else 
            {
            iMCSPluginFolderId = iMenu.RootFolderL();
            }
        CleanupStack::PopAndDestroy( &itemArray );
        CleanupStack::PopAndDestroy( filter ); 
        delete item; 
        }
    return iMCSPluginFolderId;
    }

// ---------------------------------------------------------------------------
// Helper method for updating ref_count attribute of run-time generated 
// menuitems
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsBkmList::UpdateMenuItemsRefCountL( CMenuItem* aItem, 
                                                          TInt aValueToAdd )
    {
    
    TBool exists = EFalse;
    CleanupStack::PushL( aItem ); 
    TPtrC param = aItem->GetAttributeL( KMenuAttrRefcount, exists );
    CleanupStack::Pop( aItem );
    if ( exists )
        {
        TInt references;
        TLex16 lextmp( param );
        lextmp.Val( references );
        references += aValueToAdd;
        TBuf<128> buf;
        buf.NumUC( references );

        // set new ref_count
        CleanupStack::PushL( aItem ); 
        aItem->SetAttributeL( KMenuAttrRefcount, buf );
        CleanupStack::Pop( aItem );
        // return new ref_count
        return references;
        }
    return -1;
    }

// End of File.
hs_app_mcspluginsettingscontainer.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut settings plug-in container.
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

#include 
#include 

// For CActiveFavouritesDbNotifier
#include  
#include 

#include "hs_app_mcspluginsettingscontainer.h"
#include "hs_app_mcspluginsettingsmodel.h"
#include "hs_app_mcspluginsettingsbkmlist.h"
#include "hs_app_mcspluginsettings.hrh"
#include "hs_app_mcspluginuids.hrh"

_LIT( KMyMenuData, "matrixmenudata" );

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
// First-phase construction
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsContainer::CMCSPluginSettingsContainer()
{
}

// ---------------------------------------------------------------------------
// Second-phase construction
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::ConstructL( const TRect& aRect )
    {
    iListBox = new (ELeave) CAknSettingStyleListBox;
    BaseConstructL(aRect, R_AI_MCS_SETTINGS_VIEW_TITLE, NULL);
    StartObservingL();
    CheckMiddleSoftkeyLabelL();
    }

// ---------------------------------------------------------------------------
// Tells the settings container to start observing for changes
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::StartObservingL()
    {
    // registering to bookmarks db. changes observing
    User::LeaveIfError( iBookmarkSession.Connect() );
    User::LeaveIfError( iBookmarkDb.Open( iBookmarkSession, KBrowserBookmarks ) );

    iBookmarkDbObserver = new (ELeave) CActiveFavouritesDbNotifier(
                                        iBookmarkDb, *this );
    iBookmarkDbObserver->Start();

    // registering to mailbox db. changes observing
    iMsvSession = CMsvSession::OpenAsObserverL( *this );
    
    // registering to matrix menu events observing
    iMenu.OpenL( KMyMenuData );
    TInt err = iNotifier.Open( iMenu ); 
    if ( err == KErrNone )
        {
        iNotifyWatcher = CMCSPluginWatcher::NewL( CMCSPluginWatcher::ENotify );
        iNotifier.Notify( 0,
            RMenuNotifier::EItemsAddedRemoved | RMenuNotifier::EItemsReordered,
        iNotifyWatcher->iStatus );
        iNotifyWatcher->WatchNotify( this );
        }
    }

// ---------------------------------------------------------------------------
// Tells the settings container to stop observing for changes
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::StopObserving()
    {
    if( iBookmarkDbObserver )
        {
        delete iBookmarkDbObserver;
        iBookmarkDbObserver = NULL;
        }
    iBookmarkDb.Close();
    iBookmarkSession.Close();

    if( iMsvSession )
        {
        delete iMsvSession;
        iMsvSession = NULL;
        }
    
    iNotifier.Close();
    iMenu.Close();
    
    if ( iNotifyWatcher )
        {
        if ( iNotifyWatcher->IsActive() )
        	{
            iNotifyWatcher->Cancel();
        	}
        delete iNotifyWatcher;
        iNotifyWatcher = NULL;
        }
    }

// ---------------------------------------------------------------------------
// Destructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsContainer::~CMCSPluginSettingsContainer()
    {
    StopObserving();
    }

// ---------------------------------------------------------------------------
// Sets pointer to settings plug-in model.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::SetModel( CMCSPluginSettingsModel* aModel )
{
    iModel = aModel;
}

// ---------------------------------------------------------------------------
// Handles a setting change command.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::HandleChangeCommandL()
{       
    TInt current = iListBox->CurrentItemIndex();
    TInt appListIndex = iModel->ItemId( current );
    if ( appListIndex < -1 )
    {
        appListIndex = -1;
    }

    if ( iModel->Item( current ).locked )
        {
        HBufC* text = iCoeEnv->AllocReadResourceLC( R_AI_MCS_SETTINGS_TXT_FIXED_ITEM );
        CAknInformationNote* note = new ( ELeave ) CAknInformationNote( ETrue );
        note->ExecuteLD( *text );
        CleanupStack::PopAndDestroy( text );
        }
    else
        {
        TInt selection( KErrNotFound );
        TBool changed( EFalse );
        CDesCArrayFlat* array = iCoeEnv->ReadDesC16ArrayResourceL(
            R_AI_MCS_CHANGE_TO_PAGE_LBX );
        CleanupStack::PushL( array );

        CAknListQueryDialog* dialog = new ( ELeave ) CAknListQueryDialog( &selection );
        CleanupStack::PushL( dialog );
        dialog->PrepareLC( R_AI_MCS_LISTQUERY_CHANGE_TO_PAGE );
        CleanupStack::Pop( dialog );
        dialog->SetItemTextArray( array );
        dialog->SetOwnershipType( ELbmDoesNotOwnItemArray );
        if ( dialog->RunLD() )
            {

            TSettingItem itm = iModel->Item( current );

            // user wants to select bookmark
            if ( selection == 1 )
                {

                // if the last selected item was application, set selected item to -1
                if ( itm.type == EApplication )
                    {
                        appListIndex = -1;
                    }

                changed = HandleBookmarkChangeCommandL( appListIndex, current );

                }
            // user wants to select application
            else if ( selection == 0 )
                {

                // if the last selected item was bookmark, set selected item to -1
                if ( itm.type == EBookmark )
                    {
                        appListIndex = -1;
                    }

                changed = HandleAppListChangeCommandL( appListIndex, current );

                }
            if ( changed )
                {
                    ResetCurrentListL( current );
                }

            }
        CleanupStack::PopAndDestroy( array );
        }
    }

// ---------------------------------------------------------------------------
// Handles a help command.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::HandleHelpCommandL()
{
    CArrayFixFlat* array = 
        new ( ELeave ) CArrayFixFlat( 1 );
    CleanupStack::PushL( array );
    array->AppendL( GetHelpContext() );
    HlpLauncher::LaunchHelpApplicationL( CCoeEnv::Static()->WsSession(), array );
    CleanupStack::Pop( array );
}

// ---------------------------------------------------------------------------
// Helper method which indicates if the Applist or Bkmlist is showing
// ---------------------------------------------------------------------------
//
TBool CMCSPluginSettingsContainer::IsChangeDialogShowing()
{
    return ( iAppListDialog || iBkmListDialog );
}

// ---------------------------------------------------------------------------
// Method for closing change dialog (app or bkm) if it is beeing shown
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::CloseChangeDialog()
{
    TKeyEvent keyEvent;

    keyEvent.iCode      = EKeyEscape;
    keyEvent.iScanCode  = EStdKeyEscape;
    keyEvent.iModifiers = 0;
    keyEvent.iRepeats   = 0;

    CCoeControl* dialog = NULL;

    if ( iAppListDialog )
    {
        dialog = static_cast< CCoeControl* >( iAppListDialog );
    }
    else if ( iBkmListDialog )
    {
        dialog = static_cast< CCoeControl* >( iBkmListDialog );
    }

    if ( dialog )
    {
        TRAP_IGNORE( dialog->OfferKeyEventL( keyEvent, EEventKey ) );
    }
}

// ---------------------------------------------------------------------------
// Refreshes current list..
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::ResetCurrentListL( TInt aIndex )
{
    if (iModel->MdcaCount() == 0)
    {
        iListBox->HandleItemRemovalL();
    }
    else
    {
        iListBox->HandleItemAdditionL();
    }

    iListBox->SetCurrentItemIndex( aIndex );
    CheckMiddleSoftkeyLabelL();
}

// ---------------------------------------------------------------------------
// From class MMsvSessionObserver.
// Handles an event from the message server.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::HandleSessionEventL(
                                                     TMsvSessionEvent aEvent,
                                                     TAny* /*aArg1*/,
                                                     TAny* /*aArg2*/,
                                                     TAny* /*aArg3*/ )
    {
    switch ( aEvent )
        {
    case EMsvEntriesCreated:
        // fall-through intended here
    case EMsvEntriesDeleted:
        // fall-through intended here
    case EMsvEntriesChanged:
        {
        if ( IsChangeDialogShowing() )
            {
            CloseChangeDialog();
            }
        iModel->UpdateAppListL();
        }
        break;
    default:
        break;
        }
    }

// ---------------------------------------------------------------------------
// From CGSBaseContainer
// Constructs the settings listbox.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::ConstructListBoxL(TInt /*aResLbxId*/)
{
    iListBox->ConstructL(this, EAknListBoxSelectionList);

    // Set empty listbox's text.
    HBufC* text = iCoeEnv->AllocReadResourceLC(R_AI_MCS_SETTINGS_TXT_ALL_FIXED);
    iListBox->View()->SetListEmptyTextL(*text);
    CleanupStack::PopAndDestroy(text);

    iListBox->Model()->SetItemTextArray(iModel);
    iListBox->Model()->SetOwnershipType(ELbmDoesNotOwnItemArray);
}

// ---------------------------------------------------------------------------
// Chandles a setting change command to select application from a list.
// ---------------------------------------------------------------------------
//
TBool CMCSPluginSettingsContainer::HandleAppListChangeCommandL( const TInt& aIndex,
                                                                const TInt& aSettingIndex )
{
    
    TBool changed = EFalse;

    TInt index = aIndex;
    TInt oldIndex = index;

    iAppListDialog = new (ELeave) CAknRadioButtonSettingPage(
        R_AI_MCS_SETTINGS_APPLIST_PAGE, index, iModel->AppList());

    HBufC* title = StringLoader::LoadLC( R_AI_MCS_SETTINGS_TXT_LINKN, aSettingIndex + 1, iCoeEnv );
    iAppListDialog->SetSettingTextL( title->Des() );
    iAppListDialog->ConstructL();

    if (iAppListDialog->ExecuteLD(CAknSettingPage::EUpdateWhenChanged) &&
        index != oldIndex)
        {
        changed = iModel->ReplaceItemL( iListBox->CurrentItemIndex(), index , EApplication );
        }

    CleanupStack::PopAndDestroy( title );
    iAppListDialog = NULL;

    return changed;
}

// ---------------------------------------------------------------------------
// Chandles a setting change command to select bookmark from a list.
// ---------------------------------------------------------------------------
//
TBool CMCSPluginSettingsContainer::HandleBookmarkChangeCommandL( const TInt& aIndex, 
                                                                 const TInt& aSettingIndex )
    {
    TBool changed = EFalse;

    TInt index = aIndex;
    TInt oldIndex = index;

    iBkmListDialog = new (ELeave) CAknRadioButtonSettingPage(
        R_AI_MCS_SETTINGS_APPLIST_PAGE, index, iModel->BkmList());

    HBufC* title = StringLoader::LoadLC( R_AI_MCS_SETTINGS_TXT_LINKN, aSettingIndex + 1, iCoeEnv );
    iBkmListDialog->SetSettingTextL( title->Des() );
    iBkmListDialog->ConstructL();

    if (iBkmListDialog->ExecuteLD(CAknSettingPage::EUpdateWhenChanged) &&
        index != oldIndex)
        {
        changed = iModel->ReplaceItemL( iListBox->CurrentItemIndex(), index , EBookmark );
        }

    CleanupStack::PopAndDestroy( title );
    iBkmListDialog = NULL;
    return changed;
    }

// ---------------------------------------------------------------------------
// Gets Help
// ---------------------------------------------------------------------------
//
TCoeHelpContext CMCSPluginSettingsContainer::GetHelpContext() const
{
    TUid uid = TUid::Uid( AI_UID_ECOM_DLL_SETTINGS_MCSPLUGIN );
    TCoeContextName helpString;

    helpString.Copy( KSET_HLP_HOME_SCREEN_SHORTCUTS );

    // set UID and topic of Help to display
    return TCoeHelpContext( uid, helpString );
}

// ---------------------------------------------------------------------------
// Offers a key event.
// ---------------------------------------------------------------------------
//
TKeyResponse CMCSPluginSettingsContainer::OfferKeyEventL(
    const TKeyEvent& aKeyEvent, TEventCode aType)
{
    switch (aKeyEvent.iCode)
    {
    case EKeyLeftArrow:
    case EKeyRightArrow:
        // Listbox takes all event even if it doesn't use them:
        return EKeyWasNotConsumed;

    default:
        break;
    }
    // Now it's iListBox's job to process the key event
    return iListBox->OfferKeyEventL(aKeyEvent, aType);
}

// ---------------------------------------------------------------------------
// Checks if there is a need to update the middle softkey label.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::CheckMiddleSoftkeyLabelL()
{
    CEikButtonGroupContainer* cba = CEikButtonGroupContainer::Current();
    if (cba)
    {
        cba->MakeCommandVisible(EAiScutSettingsCmdChange, (iModel->MdcaCount() != 0));
    }
}

// -----------------------------------------------------------------------------
// From class MFavouritesDbObserver.
// Handles database event.
// -----------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::HandleFavouritesDbEventL(RDbNotifier::TEvent aEvent)
    {
    switch ( aEvent )
        {
        case RDbNotifier::ECommit   :
            // fall-through intended here
        case RDbNotifier::ERecover  :
            // fall-through intended here
        case RDbNotifier::ERollback :
            {
            if ( IsChangeDialogShowing() )
                {
                CloseChangeDialog();
                }
            iModel->UpdateBkmListL();
            }
            break;
        default:
            break;
        }
    }

// -----------------------------------------------------------------------------
// From class MMCSPluginWatcherObserver.
// Handles matrix menu event.
// -----------------------------------------------------------------------------
//
void CMCSPluginSettingsContainer::HandleNotifyL()
    {
    if ( IsChangeDialogShowing() )
        {
        CloseChangeDialog();
        }
    iModel->UpdateAppListL();
    
    // Notification must be activated again
    iNotifyWatcher->Cancel();
    iNotifier.Notify( 0,
        RMenuNotifier::EItemsAddedRemoved | RMenuNotifier::EItemsReordered,
        iNotifyWatcher->iStatus );
    iNotifyWatcher->WatchNotify( this );
    }

// End of File.
hs_app_mcspluginsettingsmodel.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  MCS settings plug-in model.
*
*/

#include 
#include 
#include 

#include 
#include 
#include 
#include 


#include "hs_app_mcspluginsettings.h"
#include "hs_app_mcspluginsettingsmodel.h"
#include "hs_app_mcspluginsettingscontainer.h"


#include "debug.h"

#include 

/**
 * Line format for the settings list box
 */
_LIT(KSettingListboxLineFormat, " \t%S\t\t%S");
_LIT( KMenuAttrParam, "param");
_LIT( KMenuAttrLocked, "locked");
_LIT8( KTrue, "true" );
_LIT8( KAppUid, "271012080" );
_LIT8( KProperNameType, "type" );
_LIT8( KProperNameParam, "param" );
_LIT8( KProperNameUid, "uid" );
_LIT8( KProperNameView, "view" );
_LIT8( KProperNameLocked, "locked" );
_LIT8( KProperValueFolder, "folder" );
_LIT8( KProperValueSuite, "suite" );
_LIT8( KProperValueBookmark, "bookmark" );
_LIT8( KProperValueAppl, "application" );



using namespace HSPluginSettingsIf;

// -----------------------------------------------------------------------------
// Creates a formatted listbox line.
// -----------------------------------------------------------------------------
//
TPtrC CMCSPluginSettingsModel::ListBoxLineL( const TDesC& aCaption, TInt aIndex ) const
{
    HBufC* title = StringLoader::LoadLC(
            R_AI_MCS_SETTINGS_TXT_LINKN, aIndex + 1, iEnv );

   TPtrC caption;
   caption.Set(aCaption);

   TUriParser parser;
   TInt err = parser.Parse(aCaption);
   if (err == KErrNone)
   {
       // Remove scheme from the url.
       const TDesC& host = parser.Extract(EUriHost);
       if (host.Length())
       {
           caption.Set(host);
       }
   }

   // Format (" \t%S\t\t%S") without %S characters.
   TInt formatLength = KSettingListboxLineFormat().Length();

   HBufC* listBoxLine =
       HBufC::NewLC(title->Length() + caption.Length() + formatLength);

   TPtr ptr = listBoxLine->Des();
   ptr.Format(KSettingListboxLineFormat, title, &caption);

   delete iListBoxLine;
   iListBoxLine = NULL;
   iListBoxLine = listBoxLine;
   CleanupStack::Pop(listBoxLine);
   CleanupStack::PopAndDestroy(title);
   return *iListBoxLine;
}

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
// Two phased constructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsModel* CMCSPluginSettingsModel::NewL( CMCSPluginSettings& aPlugin,
                                                        CCoeEnv* aEnv)
{
    CMCSPluginSettingsModel* self = new (ELeave) CMCSPluginSettingsModel(aPlugin, aEnv);

    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);

    return self;
}

// ---------------------------------------------------------------------------
// First phase construction
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsModel::CMCSPluginSettingsModel( CMCSPluginSettings& aPlugin, 
                                                  CCoeEnv* aEnv )
                                                  : iPlugin( aPlugin ), 
                                                    iEnv( aEnv )
{
}

// ---------------------------------------------------------------------------
// Destructor
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsModel::~CMCSPluginSettingsModel()
{
    delete iAppList;
    delete iBkmList;
    iSettings.Reset();
    delete iPluginSettings;
    delete iPluginId;
    delete iListBoxLine;
}

// ---------------------------------------------------------------------------
// Second phase construction
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsModel::ConstructL()
{
    iAppList = CMCSPluginSettingsAppList::NewL();
    iAppList->StartL();
    iBkmList = CMCSPluginSettingsBkmList::NewL();
}


// ---------------------------------------------------------------------------
// Gets the latest settings from HSPS and updates
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsModel::UpdateSettingsL( const TDesC8& aPluginId )
    {
    if( !iPlugin.Activated() )
        {
        return;
        }
    if( !iPluginSettings )
        {
        // AILaunch uid in decimal format
        iPluginSettings = CHomescreenSettings::NewL( KAppUid, aPluginId, this );
        iPluginId = aPluginId.AllocL();
        }

    iSettings.Reset();
    RPointerArray settingItems;
    CleanupClosePushL( settingItems );

    iPluginSettings->GetSettingsL( *iPluginId, settingItems );

    TInt count = settingItems.Count();
    for ( TInt i = 0; i < count; i++ )
        {
        CItemMap* itemMap = settingItems[i];
        RPointerArray properties;
        properties = itemMap->Properties();
        TSettingItem item = ItemL( properties );
        iSettings.AppendL( item );
        }
    CleanupStack::Pop( &settingItems );
    settingItems.ResetAndDestroy();
    }

// ---------------------------------------------------------------------------
// Tries to find menuitem which matches given HSPS entry
// ---------------------------------------------------------------------------
//
TSettingItem CMCSPluginSettingsModel::ItemL( 
                 RPointerArray& aProperties )
    {
    TSettingItem setting = { KErrNotFound, EApplication , EFalse };

    TSettingType type = SettingTypeL( aProperties );
    if( type == EApplication )
        {
        setting = iAppList->FindItemL( aProperties );
        }
    else if( type == EBookmark )
        {
        setting = iBkmList->FindItemL( aProperties );
        }
    
    setting.locked = SettingLockedL( aProperties );

    return setting;
    }

// ---------------------------------------------------------------------------
// Gets Type (application or bookmark) of given HSPS entry
// ---------------------------------------------------------------------------
//
TSettingType CMCSPluginSettingsModel::SettingTypeL( 
                RPointerArray& aProperties )
    {
    TSettingType type( EApplication );

    for( TInt i = 0; i < aProperties.Count(); i++ )
        {
        TPtrC8 name = aProperties[i]->Name();
        if( name == KProperNameType )
            {
            TPtrC8 value = aProperties[i]->Value();
            if( value == KProperValueBookmark )
                {
                type = EBookmark;
                }
            else
                {
                type = EApplication;
                }
            }
        }

    return type;
    }

// ---------------------------------------------------------------------------
// Gets locking status of given HSPS entry
// ---------------------------------------------------------------------------
//
TBool CMCSPluginSettingsModel::SettingLockedL( 
                RPointerArray& aProperties )
    {
        
    for( TInt i = 0; i Name();
        if( name == KProperNameLocked )
            {
            TPtrC8 value = aProperties[i]->Value();
            if( value == KTrue )
                {
                return ETrue;
                }
            }
        }   
    
    return EFalse;
    }


// ---------------------------------------------------------------------------
// Saves menuitem to HSPS to the given shortcut index
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsModel::SaveSettingsL( const TInt& aIndex, 
                                             CMenuItem& aMenuItem )
    {

    if ( !iPluginSettings )
        {
        return;
        }
    RPointerArray settingItems;
    CleanupClosePushL( settingItems );
    iPluginSettings->GetSettingsL( *iPluginId, settingItems );
    if ( aIndex >= 0 && aIndex < settingItems.Count() )
        {
        TBool exists( EFalse );
        CItemMap* itemMap = settingItems[ aIndex ];
        RPointerArray properties;
        properties = itemMap->Properties();
        for ( TInt i = 0; i < properties.Count(); i++ )
            {
            if ( properties[ i ]->Name() == KProperNameType )
                {
                TPtrC type = aMenuItem.Type();
                if ( type == KMenuTypeUrl )
                    {
                    properties[ i ]->SetValueL( KProperValueBookmark );
                    }
                else if ( type == KMenuTypeFolder )
                    {
                    properties[ i ]->SetValueL( KProperValueFolder );
                    }
                else if ( type == KMenuTypeSuite )
                    {
                    properties[ i ]->SetValueL( KProperValueSuite );
                    }
                else
                    {
                    properties[ i ]->SetValueL( KProperValueAppl );
                    }
                }
            else if ( properties[ i ]->Name() == KProperNameUid )
                {
                TPtrC uid = aMenuItem.GetAttributeL( KMenuAttrUid, exists );
                if ( exists )
                    {
                    HBufC8* uid8( NULL );
                    uid8 = AiUtility::CopyToBufferL( uid8, uid );
                    CleanupStack::PushL( uid8 );
                    properties[ i ]->SetValueL( *uid8 );
                    CleanupStack::PopAndDestroy( uid8 );
                    }
                else
                    {
                    properties[ i ]->SetValueL( KNullDesC8 );
                    }
                }
            else if ( properties[ i ]->Name() == KProperNameView )
                {
                TPtrC view = aMenuItem.GetAttributeL( KMenuAttrView, exists );
                if( exists )
                    {
                    HBufC8* view8( NULL );
                    view8 = AiUtility::CopyToBufferL( view8, view );
                    CleanupStack::PushL( view8 );
                    properties[i]->SetValueL( *view8 );
                    CleanupStack::PopAndDestroy( view8 );
                    }
                else
                    {
                    properties[ i ]->SetValueL( KNullDesC8 );
                    }
                }
            else if ( properties[ i ]->Name() == KProperNameParam )
                {
                TPtrC param = aMenuItem.GetAttributeL( KMenuAttrParam, exists );
                TBool isFolder = EFalse;
                TPtrC type = aMenuItem.Type();

                // is the item folder or suite?

                if ( type == KMenuTypeFolder )
                    {
                    isFolder = ETrue;
                    }

                if ( exists || isFolder )
                    {
                    // the folder id is stored 
                    // in param attribute in HSPS
                    if ( isFolder )
                        {
                        TBuf<8> number;
                        number.Num( aMenuItem.Id() );
                        param.Set( number );
                        }

                    HBufC8* param8( NULL );
                    param8 = AiUtility::CopyToBufferL( param8, param );
                    CleanupStack::PushL( param8 );
                    properties[ i ]->SetValueL( *param8 );
                    CleanupStack::PopAndDestroy( param8 );
                    }
                else
                    {
                    properties[ i ]->SetValueL( KNullDesC8 );
                    }
                }
            else if ( properties[ i ]->Name() == KProperNameLocked )
                {
                TPtrC locked = aMenuItem.GetAttributeL( KMenuAttrLocked, exists );
                if ( exists )
                    {
                    HBufC8* locked8( NULL );
                    locked8 = AiUtility::CopyToBufferL( locked8, locked );
                    CleanupStack::PushL( locked8 );
                    properties[ i ]->SetValueL( *locked8 );
                    CleanupStack::PopAndDestroy( locked8 );
                    }
                else
                    {
                    properties[i]->SetValueL( KNullDesC8 );
                    }
                }
            }
        }
 // ETrue tells that modified settings are stored also to plugin reference
    iPluginSettings->SetSettingsL( *iPluginId, settingItems, ETrue );
    CleanupStack::Pop( &settingItems );
    settingItems.ResetAndDestroy();

    }

// ---------------------------------------------------------------------------
// Updates settings container.
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsModel::UpdateSettingsContainerL( const TDesC8& aPluginId )
{
    if (iContainer)
    {
        if (iContainer->IsChangeDialogShowing())
        {
            iContainer->CloseChangeDialog();
        }
    }

    UpdateSettingsL( aPluginId );

    if (iContainer)
    {
        iContainer->ResetCurrentListL(0);
    }
}

// ---------------------------------------------------------------------------
// From MHomeScreenSettingsObserver - handler for HSPS setting change
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsModel::SettingsChangedL( const TDesC8& /*aEvent*/,  
                                                const TDesC8& /*aPluginName*/,
                                                const TDesC8& /*aPluginUid*/, 
                                                const TDesC8& /*aPluginId*/ )
    {
    return KErrNone;
    }

// ---------------------------------------------------------------------------
// From MDesCArray
// Returns the number of descriptor elements in a descriptor array.
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsModel::MdcaCount() const
{
    return iSettings.Count();
}

// ---------------------------------------------------------------------------
// From MDesCArray
// Indexes into a descriptor array.
// ---------------------------------------------------------------------------
//
TPtrC CMCSPluginSettingsModel::MdcaPoint( TInt aIndex ) const
{
    if (aIndex < 0 || aIndex >= iSettings.Count())
    {
        TPtrC ret(KNullDesC);
        return ret;
    }
    if ( iSettings[aIndex].type == EApplication )
        {
        const TDesC& caption = iAppList->MdcaPoint( iSettings[aIndex].id );
        TPtrC line; 
        TRAP_IGNORE( line.Set( ListBoxLineL( caption, aIndex ) ) )
        return line; 
        }
    else
        {
        const TDesC& caption = iBkmList->MdcaPoint( iSettings[aIndex].id );
        TPtrC line;
        TRAP_IGNORE( line.Set( ListBoxLineL( caption, aIndex ) ) )
        return line;
        }
}

// ---------------------------------------------------------------------------
// Returns a setting ID for the given index.
// ---------------------------------------------------------------------------
//
TInt CMCSPluginSettingsModel::ItemId( TInt aIndex ) const
{
    if ( aIndex >= 0 && aIndex < iSettings.Count() )
    {
        return iSettings[ aIndex ].id;
    }

    return KErrNotFound;
}

// ---------------------------------------------------------------------------
// Returns a pointer to setting item for the given index
// ---------------------------------------------------------------------------
//
const TSettingItem CMCSPluginSettingsModel::Item( TInt aIndex ) const
    {
    TSettingItem setting = { KErrNotFound, EApplication, EFalse };

    if ( aIndex >= 0 && aIndex < iSettings.Count() )
        {
        setting = iSettings[ aIndex ];
        }

    return setting;
    }

// ---------------------------------------------------------------------------
// Replaces shortcut item at given index by a new one.
// ---------------------------------------------------------------------------
//
TBool CMCSPluginSettingsModel::ReplaceItemL( const TInt& aSettingIndex, 
                                             TInt aId,
                                             TSettingType aType )
    {
    if (aSettingIndex >= 0 && aSettingIndex < iSettings.Count())
        {
        // Old setting type is bookmark. Remove bookmark item from MCS 
        // if it was created in runtime.
        if( iSettings[aSettingIndex].type == EBookmark )
            {
                iBkmList->RemoveMenuItemL( iSettings[aSettingIndex].id );
            }

        // Old setting type is application.
        // Remove app item from MCS if it was created in runtime (mailbox).
        if ( iSettings[ aSettingIndex ].type == EApplication )
            {
                iAppList->RemoveMenuItemL( iSettings[ aSettingIndex ].id );
            }

        iSettings[aSettingIndex].id = aId;
        iSettings[aSettingIndex].type = aType;

        if ( aType == EApplication )
            {
            CMenuItem& item = iAppList->ItemL( aId );
            SaveSettingsL( aSettingIndex, item );
            }
        else
            {
            CMenuItem& item = iBkmList->ItemL( aId );
            SaveSettingsL( aSettingIndex, item );
            }

        return ETrue;
        }
    return EFalse;
    }

// ---------------------------------------------------------------------------
// Sets a container
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsModel::SetContainer(CMCSPluginSettingsContainer* aContainer)
{
    iContainer = aContainer;
}

// ---------------------------------------------------------------------------
// Returns application list
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsAppList* CMCSPluginSettingsModel::AppList()
{
    return iAppList;
}

// ---------------------------------------------------------------------------
// Returns bookmarklist
// ---------------------------------------------------------------------------
//
CMCSPluginSettingsBkmList* CMCSPluginSettingsModel::BkmList()
{
    return iBkmList;
}

// ---------------------------------------------------------------------------
// Updates application list
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsModel::UpdateAppListL()
{
    iAppList->StartL();
}

// ---------------------------------------------------------------------------
// Updates bookmark list
// ---------------------------------------------------------------------------
//
void CMCSPluginSettingsModel::UpdateBkmListL()
{
    delete iBkmList;
    iBkmList = NULL;
    iBkmList = CMCSPluginSettingsBkmList::NewL();
}

// End of File.
todo.txt
TODO
publisher:
-HSPS settings API is in use, but TInt CMCSPluginData::SettingsChangedL callback is never called. BUG?
   -Listen setting changes in plug-in, and publish changed items.
-Plug-ins' state machine will change in 9.1, check that plug-in's Resume-function handles all the states properly
-Prevent item launching in backup state. Some apps except that we handle it.
-Check if there is a need to publish to secondary observer. Plugin does not publish currently.

settings:
-All the resources use shortcut naming, because copied from shortcut settings, must be changed
-Clean resources, there is some unused stuff.
-Icon resource must be renamed also
-Help in options menu (CMCSPluginSettings::HandleCommandL)
-Leaks memory (for sure, other components might also leak)
-HandleBookmarkChangeCommandL aIndex is not handled, is used to highlight previously selected item in listbox
-HSPS setting must be able to tell if item is locked ( see CMCSPluginSettingsContainer::HandleChangeCommandL)
-Mailboxes are not supported, some old implementation exists
-Check if runtime observing of changes in MCS, bookmarks, or mailboxes is needed.
-Hardcoded default icon for bookmark

widget:
-Must be finalized, other variants.

Common:
-Hardcoded literals
-Obsolete header cleanup
-Obsolete library cleanup
-Test cases missing
-@since
-Comments in headers
-SaveSettingsL is in two classes, move to common? Make common dll?
-Compile warnings

Missing feature
-Add folders and suites, problem in current design is that it relies on uid, which is not assigned for folder and suites
-Launch folders and suites, handler improvement
-Launch files based on mimetype, handler improvement

FOR SOME REASON
Our settings plug-in is GeneralSettings ECOM plug-in. For some reason when we launch (ShowSettingsL)
our plugin General Settings fw loads all the plugins and in addition it reloads our plugin. That has 
to be resolved with settings team. Settings is nowadays part of MyPex.
Main contact Lakshmeshwar Shreekanth.P (Nokia-D-MSW/Bangalore)

Matrixmenudata.xml contains desktop widget specific additions. In order to get those into use you have to
copy file into X:\epoc32\release\winscw\udeb\z\private\200113DD\content and replace existing.
Also you need to delete runtime generated file from X:\epoc32\winscw\c\private\200113dd\content and launch the emulator.
hs_app_aiprofileplugin.rss
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Registry info
 *
*/


// INCLUDES
#include 
#include 


// -----------------------------------------------------------------------------
//   
// registry_info
// Registry information required for identifying the ECOM component
//
// -----------------------------------------------------------------------------
//

RESOURCE REGISTRY_INFO registry_info
{
    resource_format_version = RESOURCE_FORMAT_VERSION_2;

    dll_uid = AI_UID_ECOM_DLL_CONTENTPUBLISHER_PROFILEPLUGIN; 

    // Declare array of interface info
    interfaces = 
    {
        INTERFACE_INFO
        {
            // UID of interface that is implemented
            interface_uid = AI_UID_ECOM_INTERFACE_CONTENTPUBLISHER; 

            implementations = 
            {
                IMPLEMENTATION_INFO
                {
                    implementation_uid = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_PROFILEPLUGIN;
                    version_no         = 1;
                    display_name       = "Profile plug-in";
                    default_data       = "";
                    opaque_data        = "";
                }
            };
        }
    };
}


// End of File
hs_app_aiprofilepluginres.rss
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Resource file for ProfilePlugin.
*
*/


// ========== RESOURCE IDENTIFIER =============================================

NAME    AIPP // 4 letter ID

// ========== INCLUDE FILES ===================================================


#include 
#include 
#include 
#include 
#include 
#include 

#include 


// ========== CONSTANTS =======================================================

// ========== RESOURCE DEFINITIONS ============================================

RESOURCE RSS_SIGNATURE
    {
    }

RESOURCE TBUF
    {
    buf = "";
    }

// ----------------------------------------------------------------------------
//
// "Activate: %U"
//
// ----------------------------------------------------------------------------
//
RESOURCE TBUF r_ai_pers_prof_toggle
    {
    buf = qtn_ai_pers_prof_toggle;
    }

// -----------------------------------------------------------------------------
//
// "Insert SIM card"
//
// -----------------------------------------------------------------------------
//
RESOURCE TBUF r_su_note_insert_sim
    {
    buf = qtn_su_note_insert_sim;
    }

// -----------------------------------------------------------------------------
//
// "Are you sure that you want to switch GSM network on?"
//
// -----------------------------------------------------------------------------
//
RESOURCE DIALOG r_ai_leave_offline_mode_query
     {
     flags = EGeneralQueryFlags;
     buttons = R_AVKON_SOFTKEYS_YES_NO;
     items =
         {
         DLG_LINE
             {
             type = EAknCtQuery;
             id = EGeneralQuery;
             control = AVKON_CONFIRMATION_QUERY
                 {
                 layout = EConfirmationQueryLayout;
                 label = qtn_leave_offline_mode_query;
                 };
             }
         };
     }
 
// End of File.
aiprofileplugin.mmp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project definition file for project ProfilePlugin
*
*/

#include 
#include 

#include 

TARGET          hs_app_aiprofileplugin.dll
TARGETTYPE      PLUGIN
UID             0x10009D8D  AI_UID_ECOM_DLL_CONTENTPUBLISHER_PROFILEPLUGIN

CAPABILITY      CAP_ECOM_PLUGIN
VENDORID        VID_DEFAULT

SOURCEPATH      ../src
SOURCE          hs_app_caiprofileplugin.cpp
SOURCE          hs_app_caiprofileengine.cpp

USERINCLUDE     ../inc

APP_LAYER_SYSTEMINCLUDE

SOURCEPATH      ../data
START RESOURCE  hs_app_aiprofileplugin.rss
TARGET          hs_app_aiprofileplugin.rsc
END

START RESOURCE  hs_app_aiprofilepluginres.rss
HEADER
TARGETPATH      RESOURCE_FILES_DIR
LANGUAGE_IDS
END

LIBRARY         euser.lib
LIBRARY         cone.lib
LIBRARY         ecom.lib
LIBRARY         hs_app_aiutils.lib
LIBRARY         sssettings.lib
LIBRARY         profileeng.lib
LIBRARY         bafl.lib
LIBRARY         avkon.lib
LIBRARY         eikcore.lib
LIBRARY         efsrv.lib
LIBRARY         commonengine.lib
LIBRARY         ws32.lib
LIBRARY         apgrfx.lib

// End of File

bld.inf
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  The build information file of Profile Plugin
*
*/


#ifdef RD_CUSTOMIZABLE_AI

PRJ_PLATFORMS
DEFAULT

PRJ_EXPORTS
../loc/hs_app_ai3profileplugin.loc                MW_LAYER_LOC_EXPORT_PATH(hs_app_ai3profileplugin.loc)

../rom/hs_app_aiprofileplugin_resources.iby      LANGUAGE_MW_LAYER_IBY_EXPORT_PATH(hs_app_aiprofileplugin_resources.iby)
../rom/hs_app_aiprofileplugin.iby                CORE_MW_LAYER_IBY_EXPORT_PATH(hs_app_aiprofileplugin.iby)


PRJ_MMPFILES
aiprofileplugin.mmp

#endif // RD_CUSTOMIZABLE_AI

// End of File.
hs_app_caiprofileengine.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Header file for the CAiProfileEngine class
*
*/


#ifndef CAIPROFILEENGINE_H
#define CAIPROFILEENGINE_H

// INCLUDE FILES
#include 
#include 
#include 
#include 
#include 
#include "hs_app_maiprofilepluginnotifier.h"

class MProfileEngine;
class CProfileChangeNotifyHandler;
class MProfilesNamesArray;
class RSSSettings;

/**
 *  @ingroup group_profileplugin
 *
 *  CAiProfileEngine
 *
 *  @since S60 v3.2
 */
class CAiProfileEngine : public CBase, 
						 public MSSSettingsObserver,
						 public MProfileChangeObserver					 
{

public:  // Constructors and destructor

    /**
    * Constructor to use in the object creation. Initializes the necessary data.
    *
    * @param MAiProfilePluginNotifier* aNotifier a pointer to a object implementing MAiProfilePluginNotifier
            (the object ordering a notification of the content status change)
    * @return none
    */
    CAiProfileEngine( MAiProfilePluginNotifier* aProfilePluginNotifier );

    /**
    * Part of the two phased constuction
    *
    * @param MAiProfilePluginNotifier* aNotifier a pointer to a object implementing MAiProfilePluginNotifier
            (the object ordering a notification of the content status change)
    * @return Pointer to the created CAiProfileEngine object
    */
    static CAiProfileEngine* NewL( MAiProfilePluginNotifier* aProfilePluginNotifier );

    /**
    * Destructor
    *
    * @param none
    * @return none
    */
    ~CAiProfileEngine();
    
    /**
    * Resumes the engine
    *
    * @param void
    * @return void
    */
    void ResumeL();

    /**
    * Suspends the engine
    *
    * @param void
    * @return void
    */
    void Suspend();

public:

	const TDesC& ActiveProfileName() const;
	
	const TDesC& SwapProfileName() const;
		
	TInt NumberOfProfiles();
	
	const TDesC& ProfileNameByIndex( TInt aIndex ) const;
	
	void HandleAiEventL( TInt aEvent, const TDesC& aParam );
	
	void SetActiveProfileL( const TInt aProfileId );
	
	TBool IsActiveProfileSilentL();
	
	TBool IsActiveProfileTimedL();
	
	void UpdateProfileNamesL();
	
	TBool IsOffline();
   
private:

    void ConstructL();
    
    void SetActiveProfileNameL( const TDesC& aName );
    
    void SetSwapProfileNameL( const TDesC& aName );
    
    void SetProfileNameListL( const MProfilesNamesArray& aArray );
    
    void HandleSwitchByNameL( const TDesC& aParam );
    
    void HandleSwitchByIndexL( const TDesC& aParam );
    
    void HandleSwapL( const TDesC& aParam );
    
    void HandleEditActiveProfileL();
    
    TBool ShowOfflineMessageL();
           
  
protected:

// from base class MSSSettingsObserver

    /**
     * Called when SS Settings changes.
     */
    void PhoneSettingChanged( TSSSettingsSetting aSetting, TInt aNewValue );


// from base class MProfileChangeObserver

    /**
     * Called when active profile changes.
     */
    void HandleActiveProfileEventL( TProfileEvent aProfileEvent, TInt aProfileId );
    
private:
    /**
     * Pointer to the class implementing the MAiProfilePluginNotifier interface
     */
    MAiProfilePluginNotifier* iProfilePluginNotifier;
    
    /**
     * Client to listen SS setting changes.
     */
    RSSSettings iSSSettings;

    /**
     * Profile engine.
     * Own.
     */
    MProfileEngine* iProfileEngine;

    /**
     * Profile change notifier.
     * Own
     */
    CProfileChangeNotifyHandler* iProfileNotifier;
    
    /*
     * Active profile name
     * Own
     */    
    HBufC* iActiveProfileName;
    
    /*
     * Swap profile name
     * Own
     */    
    HBufC* iSwapProfileName;
    
    /**
     * Array of Profile Name Pointer.
     * Own.
     */
    RPointerArray iProfileNamePointerArray;
    
    /**
     * Resource loader for own resources.
     */
    RConeResourceLoader iResourceLoader;

};

#endif // CAIPROFILEENGINE_H


hs_app_caiprofileplugin.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#ifndef CAIPROFILEPLUGIN_H
#define CAIPROFILEPLUGIN_H

#include 
#include 
#include 
#include 
#include "hs_app_maiprofilepluginnotifier.h"

class MAiContentObserver;
class MAiContentItemIterator;
class CAiProfileEngine;

/**
 *  @ingroup group_profileplugin
 *
 *  Plug-in main class
 *
 *  @since S60 v3.2
 */
class CAiProfilePlugin : public CAiContentPublisher,
                     	 public MAiPropertyExtension,
                     	 public MAiProfilePluginNotifier,
                     	 public MAiEventHandlerExtension
                     	 
                    
    {

public:

    /**
    * Part of the two phased constuction
    *
    * @param none
    * @return none
    */
    static CAiProfilePlugin* NewL();
    
    /**
    * Constructor
    *
    * @param none
    * @return none
    */
    CAiProfilePlugin();
    
    /**
    * Destructor
    *
    * @param none
    * @return none
    */
    ~CAiProfilePlugin();
    
    /**
    * Publishes profile names
    *
    * @param void
    * @return void
    */
    void PublishL();

// from base class CAiContentPublisher
  
    /**
    * From CAiContentPublisher
    * The method is called by the framework to request the plug-in free all
    * memory and CPU resources and close all its open files, e.g. the plug-in 
    * should unload its engines due backup operation. The method transits the 
    * plug-in to "Idle" state.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */
    void Stop( TAiTransitionReason aReason );

    /**
    * From CAiContentPublisher
    * The method is called by the framework to instruct plug-in that it is
    * allowed to consume CPU resources, e.g plug-in is able to run timers,
    * perform asynchronous operations, etc. The method transits the plug-in
    * to "Alive" state.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */
    void Resume( TAiTransitionReason aReason );

    /**
    * From CAiContentPublisher
    * The method is called by the framework to instruct plug-in that it is
    * not allowed to consume CPU resources, e.g plug-in MUST stop each
    * timers, cancel outstanding asynchronous operations, etc. The method
    * transits the plug-in to "Suspendend" state.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */
    void Suspend( TAiTransitionReason aReason );

    /**
    * From CAiContentPublisher
    * Adds the content observer / subscriber to plug-in. The plug-in MUST
    * maintain a registry of subscribers and send notification to all them
    * whenever the plug-in changes state or new content available.
    *
    * @param aObserver content observer to register.
    * @return void
    */
    void SubscribeL( MAiContentObserver& aObserver );
    
    /**
    * From CAiContentPublisher
    * Configures the plug-in.
    * Plug-ins take ownership of the settings array, so it must either
    * store it in a member or free it. Framework has put the array in cleanup
    * stack so the plugin shouldn't do that.
    * If this leaves, the plug-in will be destroyed by AI FW.
    * Plug-in must support LaunchByValue-event even if normal shortcuts don't
    * work. The only allowed serious enough leave is KErrNotFound from CenRep.
    *
    * @param aSettings setting items defined in the UI definition.
    * @return void
    */
    void ConfigureL( RAiSettingsItemArray& aSettings );

    /**
    * From CAiContentPublisher
    * Returns interface extension. In Series 60 3.1 only event & property
    * extensions are supported. See MAiEventExtension & MAiPropertyExtension
    * interfaces.
    *
    * @param  aUid - UID of the extension interface to access.
    * @return the extension interface. Actual type depends on the passed aUid 
    *         argument.
    */
    TAny* Extension( TUid aUid );  

// from base class MAiPropertyExtension

    /**
    * From MAiPropertyExtension.
    * Read property of publisher plug-in.
    *
    * @param aProperty - identification of property.
    * @return pointer to property value.
    */
    TAny* GetPropertyL( TInt aProperty );

    /**
    * From MAiPropertyExtension.
    * Write property value.
    *
    * @param aProperty - identification of property.
    * @param aValue - contains pointer to property value.
    */
    void SetPropertyL( TInt aProperty, TAny* aValue );
  
 // from base class MAiEventHandlerExtension
   
     /**
     * From MAiEventHandlerExtension
     * Invoked by the framework when plug-in must handle an event.
     *
     * @param aEvent - unique identifier of event from plug-in content model.
     * @param aParam - parameters associated with event. Each UI Definition
     *        declares events in the format: (),
     *        where  is mapped by the framework to unique
     *        identifier supplied in aEvent,  are provided to
     *        plug-in as-is in the descriptor.
     * @since S60 3.2
     */
    void HandleEvent(TInt aEvent, const TDesC& aParam);
 
// from base class MAiProfilePluginNotifier  
  
    /**
    * Receives a notification of the content update event
    *
    * @param void
    * @return void
    */
	void NotifyContentUpdate();
	
protected:

private:

    /**
    * Part of the two phased construction
    *
    * @param void
    * @return void
    */
    void ConstructL();
    
    /**
    * Resume the plug-in.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */    
    void DoResumeL(TAiTransitionReason aReason);
    
    /**
    * Free the engine
    *
    * @param void
    * @return void
    */  
    void FreeEngine();

    /**
    * Clean profile names from published content
    *
    * @param void
    * @return void
    */  
    void CleanPublishedProfileNames();

private: // data

    // Iterator for plugin content
    // Own
    MAiContentItemIterator* iContent;

    // Iterator for plugin events
    // Own
    MAiContentItemIterator* iEvents;
    
    // Iterator for plug-in resources.
    // Own
    MAiContentItemIterator* iResources;
     
    // Plugin engine
    // Own
    CAiProfileEngine* iEngine;

    // Array of content observers
    // Own
    RPointerArray iObservers;
    
    // Information about the content publisher (this plug-in)
    TAiPublisherInfo iInfo;
    
    // Current profile count
    TInt iCurrentCount;

    // Profile count that is used as reference when profile list is updated
    TInt iPreviousCount;
	
	//Plug-in state, suspended or alive. 
    TBool iAlive;
	
	// Boolean, which expresses whether the content has been updated
	TBool iIsUpdated;
	
	HBufC *iActiveProfileAndChar;
	
	HBufC *iPreviousProfileNameAndChar;
    };

#endif // CAIPROFILEPLUGIN_H


hs_app_maiprofilepluginnotifier.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Profile plugin private interface 
*
*/


#ifndef MAIPROFILEPLUGINNOTIFIER_H
#define MAIPROFILEPLUGINNOTIFIER_H

// CLASS DECLARATION
/** 
*  @ingroup group_profileplugin
*
* It defines interface for the plugin, contains virtual method which offers plugin 
* a way to notify the client e.g. P&S data changes
*
* @since S60 v3.2
*/
class MAiProfilePluginNotifier 
    {
    public: 

        /**
        * Virtual method, which the plugin class has to implement.
		* Method is used to send notification of P&S data's change event
		* from engine to plugin.
        *
        */
	inline virtual void NotifyContentUpdate() = 0;  
    };

#endif //MAIPROFILEPLUGINNOTIFIER_H  
hs_app_ai3profileplugin.loc
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Localization strings for project Active Idle
*
*/


// d: Activate profile shortcut 
// l: list_ai2_gene_pane_t1/opt1
// w:
// r: 3.2
//
#define qtn_ai_pers_prof_toggle "Activate %U"
hs_app_aiprofileplugin.iby
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  IBY file for Profile plug-in
*
*/


#ifndef AIPROFILEPLUGIN_IBY
#define AIPROFILEPLUGIN_IBY
#include 

#ifdef RD_CUSTOMIZABLE_AI

ECOM_PLUGIN(hs_app_aiprofileplugin.dll, hs_app_aiprofileplugin.rsc)

#endif // RD_CUSTOMIZABLE_AI

#endif // AIPROFILEPLUGIN_IBY

hs_app_aiprofileplugin_resources.iby
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  IBY file for Profile plug-in
*
*/


#ifndef AIPROFILEPLUGIN_RESOURCES_IBY
#define AIPROFILEPLUGIN_RESOURCES_IBY

#include 

#ifdef RD_CUSTOMIZABLE_AI

// AI profile plug-in localizable resources
data=DATAZ_\RESOURCE_FILES_DIR\aiprofilepluginres.rsc  RESOURCE_FILES_DIR\aiprofilepluginres.rsc

#endif // RD_CUSTOMIZABLE_AI

#endif // AIPROFILEPLUGIN_RESOURCES_IBY
hs_app_caiprofileengine.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  The engine class of profile plugin. 
*
*/


// INCLUDE FILES
#include "hs_app_caiprofileengine.h"
#include "hs_app_maiprofilepluginnotifier.h"
#include "aiprofileplugincontentmodel.h"

#include  
#include 
#include 
#include 
#include 
#include 
#include 
#include  
#include 
#include 
#include 
#include 
#include 
#include 
#include 


#include 

#include 

const TInt KMaxProfileNameLength( 64 );
const TInt KGeneralProfileId( 0 );
const TInt KSilentProfileId( 1 );
const TInt KOfflineProfileId( 5 );

const TInt KMaxActiveProfileLength( 64 );
const TUid KUidProfileApp = { 0x100058F8 }; 
const TUid KProfileAppSettingViewId = { 2 };

_LIT( KAiProfilePluginResourceFileName, "z:aiprofilepluginres.rsc");

// ============================ MEMBER FUNCTIONS ===============================
// ---------------------------------------------------------
// Default constructor
// ---------------------------------------------------------
//
CAiProfileEngine::CAiProfileEngine( MAiProfilePluginNotifier* aProfilePluginNotifier ) :
    iProfilePluginNotifier ( aProfilePluginNotifier ),
    iResourceLoader( *CCoeEnv::Static() )
    {
    }
    
// ---------------------------------------------------------
// Two-phased constructor.
// Create instance of concrete ECOM interface implementation
// ---------------------------------------------------------
//
CAiProfileEngine* CAiProfileEngine::NewL( MAiProfilePluginNotifier* aProfilePluginNotifier )
    {
    CAiProfileEngine* self = new( ELeave ) CAiProfileEngine( aProfilePluginNotifier );
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );

    return self;
    }

// ---------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------
//
void CAiProfileEngine::ConstructL()
    {
    TParse parse;
    parse.Set( KAiProfilePluginResourceFileName, &KDC_RESOURCE_FILES_DIR, NULL );
    TFileName fileName( parse.FullName() );

    // Get language of resource file.
    BaflUtils::NearestLanguageFile( CCoeEnv::Static()->FsSession(), fileName );

    // Open resource file.
    TRAP_IGNORE( iResourceLoader.OpenL( fileName ) );
    
    User::LeaveIfError( iSSSettings.Open() );

    iProfileEngine = CreateProfileEngineL();    
   }
    
    
// ---------------------------------------------------------
// Destructor.
// ---------------------------------------------------------
//
CAiProfileEngine::~CAiProfileEngine()
    {
    iSSSettings.CancelAll( *this );
    iSSSettings.Close();
    delete iProfileNotifier;
	delete iActiveProfileName;
	delete iSwapProfileName;
	
	if( iProfileNamePointerArray.Count() )
    	{
        iProfileNamePointerArray.ResetAndDestroy();
        }

    if( iProfileEngine )
        {
        iProfileEngine->Release();
        }
    
    iResourceLoader.Close();            	 
    }
    
// ---------------------------------------------------------
// Updates profiles
// ---------------------------------------------------------
//
void CAiProfileEngine::UpdateProfileNamesL()
	{
	//update active profile name
	HBufC* activeProfileName = NULL;
	
	MProfile* profile = iProfileEngine->ActiveProfileLC();	
	const MProfileName& name = profile->ProfileName();	
	activeProfileName = name.Name().AllocLC();

	SetActiveProfileNameL( *activeProfileName );
      
    //update profile name list	
	MProfilesNamesArray* profileNamesArray = iProfileEngine->ProfilesNamesArrayLC();
    
    SetProfileNameListL( *profileNamesArray );
    
    //update swap profile name
    HBufC* swapProfileName = NULL;
    
    TInt activeProfileId = iProfileEngine->ActiveProfileId();
    
    if( activeProfileId == KSilentProfileId )
    	{
        const MProfileName* generalProfileName = profileNamesArray->ProfileName( KGeneralProfileId );	
		swapProfileName = generalProfileName->Name().AllocLC();	
    	}
    else
        {
        const MProfileName* silentProfileName = profileNamesArray->ProfileName( KSilentProfileId );	
		swapProfileName = silentProfileName->Name().AllocLC();	
        }
    
    TPtrC swapProfileNamePtr( *swapProfileName );
	HBufC* activateProfileString = NULL;
    activateProfileString = StringLoader::LoadLC( R_AI_PERS_PROF_TOGGLE, swapProfileNamePtr );    	
    
    SetSwapProfileNameL( *activateProfileString );

    CleanupStack::PopAndDestroy( 5 ); //profile, profileName, profileNamesArray, swapProfileName, activateProfileString 
	}

// ---------------------------------------------------------
// Checks SIM card status
// ---------------------------------------------------------
//
TBool CAiProfileEngine::ShowOfflineMessageL()
	{
	TInt result = ETrue;
	
    TInt simCardStatus( ESimNotPresent );
        
    RProperty simStatus;
    User::LeaveIfError( simStatus.Attach( KPSUidStartup, KPSSimStatus ) );
    User::LeaveIfError( simStatus.Get( simCardStatus ) );
    simStatus.Close();

 	if( simCardStatus == ESimNotPresent )
		{
		// SIM card does not exist.
	    HBufC* infoNoteText = StringLoader::LoadLC( R_SU_NOTE_INSERT_SIM );
	    CAknInformationNote* note = new( ELeave ) CAknInformationNote( ETrue );
	    note->ExecuteLD( *infoNoteText );
	    CleanupStack::PopAndDestroy( infoNoteText );
	    result = EFalse;	
		}
	else
		{
		CAknQueryDialog* dlg = CAknQueryDialog::NewL();
		result = dlg->ExecuteLD( R_AI_LEAVE_OFFLINE_MODE_QUERY );	
		}
       
	return result;
	}

									  
// ---------------------------------------------------------
// 
// ---------------------------------------------------------
//
void CAiProfileEngine::SetActiveProfileNameL( const TDesC& aName )
    {
    HBufC* temp = aName.AllocL();
    delete iActiveProfileName;
    iActiveProfileName = NULL;
    TPtr profileNamePtr = temp->Des();
    AknTextUtils::DisplayTextLanguageSpecificNumberConversion( profileNamePtr );
    iActiveProfileName = temp;  
    }
    
// ---------------------------------------------------------
// 
// ---------------------------------------------------------
//
const TDesC& CAiProfileEngine::ActiveProfileName() const
    {
    if( iActiveProfileName )
        {
        return *iActiveProfileName;
        }
    
    return KNullDesC();
    }

// ---------------------------------------------------------
// 
// ---------------------------------------------------------
//
void CAiProfileEngine::SetSwapProfileNameL( const TDesC& aName )
    {
    HBufC* temp = aName.AllocL();
    delete iSwapProfileName;
    iSwapProfileName = NULL;
    TPtr profileNamePtr = temp->Des();
    AknTextUtils::DisplayTextLanguageSpecificNumberConversion( profileNamePtr );
    iSwapProfileName = temp;  
    }
    
// ---------------------------------------------------------
// 
// ---------------------------------------------------------
//
const TDesC& CAiProfileEngine::SwapProfileName() const
    {
    if( iSwapProfileName )
        {
        return *iSwapProfileName;
        }
    
    return KNullDesC();
    }


// ---------------------------------------------------------
// Set profile names
// ---------------------------------------------------------
//
void CAiProfileEngine::SetProfileNameListL( const MProfilesNamesArray& aArray )
    {
    if( iProfileNamePointerArray.Count() )
    	{
        iProfileNamePointerArray.ResetAndDestroy();
        }
      
    const TInt count = aArray.MdcaCount();
    TBufC profileName;
         
    for( TInt i = 0; i < count; i++ )
    	{
    	profileName = aArray.MdcaPoint( i );
    	TPtr profileNamePtr = profileName.Des();
    	AknTextUtils::DisplayTextLanguageSpecificNumberConversion( profileNamePtr );
    	HBufC* profile = profileNamePtr.AllocLC();
    	User::LeaveIfError( iProfileNamePointerArray.Append( profile ));
    	CleanupStack::Pop( profile );
    	}
    }
    

// ---------------------------------------------------------
// 
// ---------------------------------------------------------
//
const TDesC& CAiProfileEngine::ProfileNameByIndex( TInt aIndex ) const
    {
 	if( iProfileNamePointerArray.Count() )
 		{
 		return *iProfileNamePointerArray[aIndex];
 		}
 	
 	return KNullDesC();
    }

// ---------------------------------------------------------
// 
// ---------------------------------------------------------
//
TBool CAiProfileEngine::IsActiveProfileSilentL()
	{
	TBool isSilent = EFalse;
	MProfile* profile = iProfileEngine->ActiveProfileLC();
	isSilent = profile->IsSilent();
	CleanupStack::PopAndDestroy();
	return isSilent; 
	}

// ---------------------------------------------------------
// 
// ---------------------------------------------------------
//
TBool CAiProfileEngine::IsActiveProfileTimedL()
	{
	return iProfileEngine->IsActiveProfileTimedL();
	}

// ---------------------------------------------------------
// Number of profiles
// ---------------------------------------------------------
//
TInt CAiProfileEngine::NumberOfProfiles()
	{	
	return iProfileNamePointerArray.Count();
	}


// ---------------------------------------------------------
// 
// ---------------------------------------------------------
//
void CAiProfileEngine::HandleAiEventL( TInt aEvent, const TDesC& aParam )
	{
	switch ( aEvent )
        {
        case EAiProfileEventSwitchByIndex:
            HandleSwitchByIndexL( aParam );
            break;

        case EAiProfileEventSwitchByName:
            HandleSwitchByNameL( aParam );
            break;

        case EAiProfileEventSwap:
            HandleSwapL( aParam );
            break;
            
        case EAiProfileEditActive:
            HandleEditActiveProfileL();
            break;
        default:
            break;
        }
	}


// -----------------------------------------------------------------------------
// Handles profile switch by index event
// -----------------------------------------------------------------------------
//
void CAiProfileEngine::HandleSwitchByIndexL( const TDesC& aParam )
	{
    if ( aParam.Length() > 0 )
    	{
        TInt profileId = KErrNotFound;
		TPtrC ptr( aParam );
		TLex lexer( ptr );
			
    	TInt err = lexer.Val( profileId );  
		if ( err == KErrNone )
			{
			MProfilesNamesArray* profileNamesArray = iProfileEngine->ProfilesNamesArrayLC();
			const MProfileName* profileName = profileNamesArray->ProfileName( profileId );
		 
		    if( profileName )
        		{
	            profileId = profileName->Id();
		    	SetActiveProfileL( profileId );
        		}
		    
		    CleanupStack::PopAndDestroy();
		   	}
    	}
	}

// -----------------------------------------------------------------------------
// Handles profile switch by name event
// -----------------------------------------------------------------------------
//
void CAiProfileEngine::HandleSwitchByNameL( const TDesC& aParam )
	{
    if ( aParam.Length() > 0 )
    	{
    	TInt profileId = KErrNotFound;
        MProfilesNamesArray* profileNamesArray = iProfileEngine->ProfilesNamesArrayLC();
        profileId = profileNamesArray->FindByName( aParam );
        if( profileId != KErrNotFound )
        	{
        	SetActiveProfileL( profileId );
        	}
    	
    	CleanupStack::PopAndDestroy();
    	}
	}

// -----------------------------------------------------------------------------
// Handles profile swap event
// -----------------------------------------------------------------------------
//
void CAiProfileEngine::HandleSwapL( const TDesC& aParam )
	{
	if ( aParam.Length() > 0 )
		{
		TInt profileId = KErrNotFound;
		TPtrC ptr( aParam );
		TLex lexer( ptr );
			
    	TInt err = lexer.Val( profileId );  
		if ( err == KErrNone )
			{
			TInt activeProfile = iProfileEngine->ActiveProfileId();
			
			if( activeProfile != profileId )
				{
				MProfilesNamesArray* profileNamesArray = iProfileEngine->ProfilesNamesArrayLC();
        		profileId = profileNamesArray->FindById( profileId );
		    
		    	if( profileId != KErrNotFound )
        			{
		    		TRAP_IGNORE( SetActiveProfileL( profileId ) );
        			}
        		
        		CleanupStack::PopAndDestroy();	
				}
			else
				{
				SetActiveProfileL( KGeneralProfileId );	
				}
		   	}
		}
	}

// -----------------------------------------------------------------------------
// Handles edit active profile event
// -----------------------------------------------------------------------------
//
void CAiProfileEngine::HandleEditActiveProfileL()
    {
    RWsSession ws;
    User::LeaveIfError(ws.Connect());
    CleanupClosePushL(ws);

    // Find the task with uid
    TApaTaskList taskList(ws);
    TApaTask task = taskList.FindApp( KUidProfileApp );

    if ( task.Exists() )
        {
        task.EndTask();
        User::After( 500000 );
        }
    CleanupStack::PopAndDestroy(&ws);
    
    TVwsViewId viewid( KUidProfileApp, KProfileAppSettingViewId );
    TInt profileId = iProfileEngine->ActiveProfileId();
    TBuf8 buf;
    buf.AppendNum(profileId);
    CEikonEnv::Static()->AppUi()->ActivateViewL( viewid ,KProfileAppSettingViewId,buf);
    

    }

// -----------------------------------------------------------------------------
//  Set active profile
// -----------------------------------------------------------------------------
//
void CAiProfileEngine::SetActiveProfileL( const TInt aProfileId )
	{
	TInt activeProfileId = iProfileEngine->ActiveProfileId();
	
	if ( activeProfileId == KOfflineProfileId && aProfileId != KOfflineProfileId )
   		{
    	if( !ShowOfflineMessageL() )
    		{
    		// User doesn't want to activate RF or
    		// SIM card does not exist.
    		return;
    		}
    	}
    	
   	iProfileEngine->SetActiveProfileL( aProfileId );   	
 	}
		
// ---------------------------------------------------------------------------
// Resumes the engine
// ---------------------------------------------------------------------------
//
void CAiProfileEngine::ResumeL()
    {
    User::LeaveIfError( iSSSettings.Open() );
 
    //Register to listen ALS activation, if ALS status changes,
	//profile must be republished.
    TInt err = iSSSettings.Register( ESSSettingsAls, *this );

    if( err == KErrNotSupported || err == KErrAlreadyExists )
        {
        //ALS not supported or already registered, that's fine
        err = KErrNone;
        }

    User::LeaveIfError( err );

	//Start to listen profile changes.
	delete iProfileNotifier;
    iProfileNotifier = NULL;	
		
    iProfileNotifier = CProfileChangeNotifyHandler::NewL( this );
   	}

// ---------------------------------------------------------------------------
// Suspends the engine
// ---------------------------------------------------------------------------
//
void CAiProfileEngine::Suspend()
    {
 	iSSSettings.CancelAll( *this );
    iSSSettings.Close();
   	delete iProfileNotifier;
   	iProfileNotifier = NULL;	
    }

// ---------------------------------------------------------------------------
// From class MProfileChangeObserver
// ---------------------------------------------------------------------------
//

void CAiProfileEngine::HandleActiveProfileEventL(
							TProfileEvent aProfileEvent,
							TInt /*aProfileId*/ )
    {
	//Profile activated or modified.
    if( ( aProfileEvent == EProfileNewActiveProfile ) ||
    	( aProfileEvent == EProfileActiveProfileModified ) )
        {
        UpdateProfileNamesL();
        iProfilePluginNotifier->NotifyContentUpdate();
        }
    }
    
// ---------------------------------------------------------------------------
// From class MSSSettingsObserver.
// ---------------------------------------------------------------------------
//
void CAiProfileEngine::PhoneSettingChanged( 
								TSSSettingsSetting aSetting,
								TInt /*aNewValue*/ )
    {
    if( aSetting == ESSSettingsAls )
        {
        TRAP_IGNORE( UpdateProfileNamesL() );
        iProfilePluginNotifier->NotifyContentUpdate();
        }
    }


TBool CAiProfileEngine::IsOffline()
	{
	return iProfileEngine->ActiveProfileId() == KOfflineProfileId;
	}

hs_app_caiprofileplugin.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Profile plug-in publisher
*
*/


#include 
#include 
#include 
#include 
#include 
#include 

#include "aiprofileplugincontentmodel.h"
#include 
#include "hs_app_caiprofileplugin.h"
#include "hs_app_caiprofileengine.h"
#include "aipluginsettings.h"

// PUA code for the timed profile, missing from PUAcodes.hrh
#define KAiTimedProfilePUA 0xF815
#define KAiRTL 0x200F

// CONST CLASS VARIABLES
const TImplementationProxy KImplementationTable[] =
    {
    IMPLEMENTATION_PROXY_ENTRY( KImplUidProfilePlugin, CAiProfilePlugin::NewL ) 
    };

// ======== LOCAL FUNCTIONS ========

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
CAiProfilePlugin* CAiProfilePlugin::NewL()
    {
    CAiProfilePlugin* self = new (ELeave) CAiProfilePlugin;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
 
    return self;
    }
    
// ---------------------------------------------------------------------------
// Default constructor
// ---------------------------------------------------------------------------
//
CAiProfilePlugin::CAiProfilePlugin()
    {
    }
    
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
void CAiProfilePlugin::ConstructL()
    { 
    iInfo.iUid.iUid = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_PROFILEPLUGIN; 
   
    iContent = AiUtility::CreateContentItemArrayIteratorL( KAiProfileContent );
    iEvents = AiUtility::CreateContentItemArrayIteratorL( KAiProfileEvents );
    iResources = AiUtility::CreateContentItemArrayIteratorL( KAiProfileResources );
    
    iIsUpdated = ETrue;
    iAlive = EFalse;        
    }
    
// ---------------------------------------------------------------------------
// Destructor
// Deletes all data created to heap
// ---------------------------------------------------------------------------
//
CAiProfilePlugin::~CAiProfilePlugin()
    {
    CleanPublishedProfileNames();
    Release( iContent );
    Release( iEvents );
    Release( iResources );   
    delete iActiveProfileAndChar;
    delete iPreviousProfileNameAndChar;
    delete iEngine;
    iObservers.Close();
    }

// ---------------------------------------------------------------------------
// Publishes the profiles
// ---------------------------------------------------------------------------
//
void CAiProfilePlugin::PublishL()
    {
    TInt err( KErrNone );
    TInt observers( iObservers.Count() );        
    TInt transactionId = reinterpret_cast( this );

    iCurrentCount = iEngine->NumberOfProfiles();
    for ( int i = 0; i < observers; i++ )
        {
        MAiContentObserver* observer = iObservers[i];
        err = observer->StartTransaction( transactionId );
		
		if ( err == KErrNotSupported )
            {
            // The observer does not support transactions, check for real errors.
            return;
            }
        
        //Active Profile name    
        if ( observer->CanPublish( *this, EAiProfileContentActiveProfileName, EAiProfileContentActiveProfileName ) )
        	{        	
       		observer->Publish( *this, EAiProfileContentActiveProfileName, iEngine->ActiveProfileName(), EAiProfileContentActiveProfileName );
        	}
        
        if ( observer->CanPublish( *this, EAiProfileActiveProfileNameAndIconChar, 0 ) )
            {
            delete iActiveProfileAndChar;
            iActiveProfileAndChar = NULL;
            // silent/non-silent icon + timed icon + space + possible RTL*2 = 5
            TInt maxChars = iEngine->ActiveProfileName().Length() + 5;
            
            iActiveProfileAndChar = HBufC::NewL( maxChars );
            TPtr profileNamePtr = iActiveProfileAndChar->Des();
           
            if( AknLayoutUtils::LayoutMirrored() )
                {
                profileNamePtr.Append( KAiRTL );
                }

            if ( iEngine->IsActiveProfileTimedL() )
                {
                profileNamePtr.Append( KAiTimedProfilePUA );                
                }
            if( iEngine->IsActiveProfileSilentL() )
                {                
                profileNamePtr.Append( KPuaCodeSilentSymbol );
                }
            else
                {
                profileNamePtr.Append( KPuaCodeAprofSound );
                }
            _LIT( KSpace, " " );   
            profileNamePtr.Append( KSpace );
            
            if( AknLayoutUtils::LayoutMirrored() )
                {
                profileNamePtr.Append( KAiRTL );
                }
            
            profileNamePtr.Append( iEngine->ActiveProfileName() );
                        
            if ( !iPreviousProfileNameAndChar || 
                    iPreviousProfileNameAndChar->CompareC( *iActiveProfileAndChar ) != 0 )
                {
                delete iPreviousProfileNameAndChar;
                iPreviousProfileNameAndChar = NULL;
                observer->Publish( *this, EAiProfileActiveProfileNameAndIconChar, profileNamePtr, 0 );
                
                iPreviousProfileNameAndChar = iActiveProfileAndChar->AllocL();
                }
            }
        
        //Swap Profile name ( 1.phase: General or Silent )
       	if ( observer->CanPublish( *this, EAiProfileContentSwapProfileName, EAiProfileContentSwapProfileName ) )
        	{
        	observer->Publish( *this, EAiProfileContentSwapProfileName, iEngine->SwapProfileName(), EAiProfileContentSwapProfileName );
        	}      
          
		//All profile names
       	// clean profiles that are already deleted.
       	// Cleans the array blindly from the end, because in the next
       	// step all the profiles are republished
        if( iPreviousCount > iCurrentCount )
            {
            for( TInt k = iCurrentCount; k < iPreviousCount; k++ )
                {
                observer->Clean( *this, EAiProfileContentProfileName, k + 1 );
                }
            }
		for ( TInt j = 0; j < iCurrentCount; j++ )
			{
			if ( observer->CanPublish( *this, EAiProfileContentProfileName, j + 1 ) )
				{
				observer->Publish(*this, EAiProfileContentProfileName, iEngine->ProfileNameByIndex( j ), j + 1 );
				}
			}
      	
      	//Active Profile silent indicator char
        if ( observer->CanPublish( *this, EAiProfileActiveProfileSilentChar, EAiProfileActiveProfileSilentChar ) )
        	{
        	if ( iEngine->IsActiveProfileSilentL() )
        		{
        		TBuf<1> silent; // one character
        		silent.Append( KPuaCodeSilentSymbol );
        		observer->Publish( *this, EAiProfileActiveProfileSilentChar, silent, EAiProfileActiveProfileSilentChar );
        		}
        	else
        		{
        		observer->Clean( *this, EAiProfileActiveProfileSilentChar, EAiProfileActiveProfileSilentChar );
        		}
        	}
        
        //Active Profile silent indicator resource
        if ( observer->CanPublish( *this, EAiProfileActiveProfileIcon, EAiProfileActiveProfileIcon ) )
        	{
    		observer->Clean( *this, EAiProfileActiveProfileIcon, EAiProfileActiveProfileSilentIconResource );
    		observer->Clean( *this, EAiProfileActiveProfileIcon, EAiProfileActiveProfileGeneralIconResource );
    		observer->Clean( *this, EAiProfileActiveProfileIcon, EAiProfileActiveProfileTimedIconResource );
        	if ( iEngine->IsActiveProfileTimedL() )
        		{
        		observer->Publish( *this, 
        							EAiProfileActiveProfileIcon, 
        							EAiProfileActiveProfileTimedIconResource, 
        							EAiProfileActiveProfileTimedIconResource );
        		}
        	else if ( iEngine->IsActiveProfileSilentL() )
        		{
        		observer->Publish( *this, 
        							EAiProfileActiveProfileIcon, 
        							EAiProfileActiveProfileSilentIconResource, 
        							EAiProfileActiveProfileSilentIconResource );
        		}
        	else
        		{
        		observer->Publish( *this, 
        							EAiProfileActiveProfileIcon, 
        							EAiProfileActiveProfileGeneralIconResource, 
        							EAiProfileActiveProfileGeneralIconResource );
        		}
        	}

		// in case of Offline profile profile indicator is not shown
        if ( observer->CanPublish( *this, EAiProfileContentActiveProfileName, EAiProfileContentActiveProfileName ) &&
        		iEngine->IsOffline() )
        	{
    		observer->Clean( *this, EAiProfileActiveProfileSilentChar, EAiProfileActiveProfileSilentChar );
    		observer->Clean( *this, EAiProfileActiveProfileIcon, 1 );
    		observer->Clean( *this, EAiProfileActiveProfileIcon, 2 );
            // uncomment also this and respective policy lines in profiles.xml if whole widget needs to be hidden in AI3 
    		//observer->Clean( *this, EAiProfileContentActiveProfileName, EAiProfileContentActiveProfileName );        		    		
    		}
        if ( err == KErrNone )
            {
            err = observer->Commit( transactionId );
            
            if ( err == KErrNotSupported)
                {
                return;
                }
            }
        
        iIsUpdated = EFalse;
        }
    iPreviousCount = iCurrentCount;
    }
    
// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is requested to unload its engines due backup operation
// ---------------------------------------------------------------------------
//
void CAiProfilePlugin::Stop( TAiTransitionReason /*aReason*/ )
    {
    FreeEngine();
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is instructed that it is allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CAiProfilePlugin::Resume( TAiTransitionReason aReason )
    {
    TRAP_IGNORE( DoResumeL( aReason ) ); 
    }
    
// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is instructed that it is not allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CAiProfilePlugin::Suspend( TAiTransitionReason /*aReason*/ )
    {
    if ( iEngine && iAlive )
        {
        iEngine->Suspend();
        }
        
    iAlive = EFalse;
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// The plug-in MUST maintain a registry of subscribers and send 
// notification to all of them whenever the state changes or new content
// is available
// ---------------------------------------------------------------------------
//
void CAiProfilePlugin::SubscribeL( MAiContentObserver& aObserver )
    { 
    iObservers.AppendL( &aObserver );
    }
    
// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-ins take ownership of the settings array, so it must either
// store it in a member or free it.
// ---------------------------------------------------------------------------
//
void CAiProfilePlugin::ConfigureL( RAiSettingsItemArray& aSettings )
    {
    aSettings.ResetAndDestroy();
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Returns the extension interface. Actual type depends on the passed 
// aUid argument.
// ---------------------------------------------------------------------------
//
TAny* CAiProfilePlugin::Extension( TUid aUid )
    {    
    if (aUid == KExtensionUidProperty)
   		{
        return static_cast(this);
    	}
    else if (aUid == KExtensionUidEventHandler)
    	{
        return static_cast(this);
    	}
    else
    	{	
        return NULL;
    	}
    }

// ---------------------------------------------------------------------------
// From class MAiPropertyExtension
// Read property of publisher plug-in.
// ---------------------------------------------------------------------------
//
TAny* CAiProfilePlugin::GetPropertyL( TInt aProperty )
    {
    TAny* property = NULL;
    
    switch ( aProperty )
        {
    case EAiPublisherInfo:
        {
         property = static_cast( &iInfo );
        break;  
        }       

    case EAiPublisherContent:
        {
        property = static_cast( iContent );
        break;    
        }        

    case EAiPublisherEvents:
        {
        property = static_cast( iEvents );
        break;
        }
    
    case EAiPublisherResources:
        property = static_cast( iResources );
        break;
       
    default:
        break;
        }

    return property;
    }

// ---------------------------------------------------------------------------
// From class MAiPropertyExtension
// Write property value to optimize the content model.
// ---------------------------------------------------------------------------
//
void CAiProfilePlugin::SetPropertyL( TInt aProperty, TAny* aValue )
    {  
    if( aProperty == EAiPublisherInfo )
        {
        ASSERT( aValue );
        
        const TAiPublisherInfo* info( 
                static_cast( aValue ) );
        
        iInfo = *info;
        }
    }
 
// ---------------------------------------------------------------------------
// From class MAiEventHandlerExtension.
// Handles an event sent by the AI framework.
// ---------------------------------------------------------------------------
//
void CAiProfilePlugin::HandleEvent(TInt aEvent, const TDesC& aParam)
	{
    if ( iEngine )
    	{
        // We have no way of reporting errors to framework so just ignore them.
        TRAP_IGNORE( iEngine->HandleAiEventL( aEvent, aParam ) );
    	}
	} 
    
// ---------------------------------------------------------
// This method is called from the engine, when the profile
// data content has been changed. Method call is made through
// the MAiProfilePluginNotifier interface.
// ---------------------------------------------------------
//
void CAiProfilePlugin::NotifyContentUpdate()
    {
    iIsUpdated = ETrue;
    
    TRAP_IGNORE( PublishL() );
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// framework instructs plug-in that it is allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CAiProfilePlugin::DoResumeL( TAiTransitionReason aReason )
    {
    if ( !iEngine )
        {
        iEngine = CAiProfileEngine::NewL( this );
        }
    
	//update in startup phase and idle is on foreground.
    if( aReason != EAiBacklightOff && aReason != EAiIdleBackground )
    	{
    	// force republish in case layout has changed
      if ( aReason == EAiScreenLayoutChanged )
          {
          delete iPreviousProfileNameAndChar;
          iPreviousProfileNameAndChar = NULL;
          }

    	if ( !iAlive )
    	    {
            iEngine->ResumeL();
    	    }
    	
	    iEngine->UpdateProfileNamesL();
	    
        PublishL();
	    iAlive = ETrue;     
    	}   
    }
    
// ---------------------------------------------------------------------------
// Frees engine resources
// ---------------------------------------------------------------------------
//    
void CAiProfilePlugin::FreeEngine()
    {
    delete iEngine;
    iEngine = NULL;
    iAlive = EFalse;   
    }

// ---------------------------------------------------------------------------
// Clean profile names from content
// ---------------------------------------------------------------------------
//    
void CAiProfilePlugin::CleanPublishedProfileNames()
    {
    TInt obsCount( iObservers.Count() );
    for ( TInt i( 0 ); i < obsCount; i++ )
        {
        MAiContentObserver* observer = iObservers[i];
        for( TInt j( 0 ); j < iCurrentCount && observer; j++ )
            {
            observer->Clean( *this, EAiProfileContentProfileName, j + 1 );
            }
        }
    }

// ======== GLOBAL FUNCTIONS ========
// ---------------------------------------------------------------------------
// Constructs and returns an application object.
// ---------------------------------------------------------------------------
//
EXPORT_C const TImplementationProxy* ImplementationGroupProxy( 
    TInt& aTableCount )
    {
    aTableCount = sizeof( KImplementationTable ) / 
        sizeof( TImplementationProxy );
    return KImplementationTable;
    }
hs_app_pslnactiveidleplugin.rss
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  ECOM plugin resource file for Active Idle Skinning plugin.
*
*/


#include 
#include "hs_app_pslnactiveidlepluginuids.h"

RESOURCE REGISTRY_INFO theInfo
{
    dll_uid     = KPslnActiveIdlePluginDllUID3;
    interfaces  =
    {
        INTERFACE_INFO
        {
            interface_uid   = KPslnPluginInterfaceUID;
            implementations =
            {
                IMPLEMENTATION_INFO
                {
                    implementation_uid  = KPslnActiveIdlePluginImplementationUID;
                    version_no          = 1;
                    display_name        = "Psln AI Plugin";
                    default_data        = "0";
                    opaque_data         = "0";
                }
            };
        }
        ,
        INTERFACE_INFO
        {
            interface_uid   = KGSPluginInterfaceUID;
            implementations =
            {
                IMPLEMENTATION_INFO
                {
                    implementation_uid  = KGSActiveIdlePluginImplementationUID;
                    version_no          = 1;
                    display_name        = "GS AI Plugin";
                    default_data        = "0x1020743F"; // parent uid: Standby plugin
                    opaque_data         = "11"; // Order number
                }
            };
        }
    };
}

// End of File.
hs_app_pslnactiveidlepluginrsc.rss
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Resource file for PslnActiveIdlePlugin.
*
*/


// ========== RESOURCE IDENTIFIER =============================================

NAME    PSAI // 4 letter ID

#include  // Avkon localized strings
#include 
#include 
#include 
#include 
#include 
#include 
#include 

#include 
#include 

// ========== RESOURCE DEFINITIONS ============================================

RESOURCE RSS_SIGNATURE
{
}

RESOURCE TBUF
{
    buf = "";
}

// ----------------------------------------------------------------------------
//
// Active Idle application specific view.
//
// ----------------------------------------------------------------------------
//
RESOURCE AVKON_VIEW r_psln_active_idle_view
{
    menubar = r_psln_ai_view_menubar;
    //cba = R_AVKON_SOFTKEYS_OPTIONS_BACK;
    cba = r_softkeys_options_back_empty;
}

// ----------------------------------------------------------------------------
//
// Options menu with 'Download', 'Activate', 'Help' and 'Exit' items.
//
// ----------------------------------------------------------------------------
//
RESOURCE MENU_BAR r_psln_ai_view_menubar
{
    titles =
    {
        MENU_TITLE { menu_pane = r_psln_ai_basic_menupane; },
        MENU_TITLE { menu_pane = R_PSLN_GEN_VIEW_MENUPANE; }
    };
}

// ----------------------------------------------------------------------------
//
// Menu pane for view.
//
// ----------------------------------------------------------------------------
//
RESOURCE MENU_PANE r_psln_ai_basic_menupane
{
    items =
    {
#ifdef __SERIES60_HELP
        MENU_ITEM
        {
            command = EPslnCmdAppHelp;
            txt = qtn_options_help;
        },
#endif  // __SERIES60_HELP
        MENU_ITEM
        {
            command = EAknCmdExit;
            txt = qtn_options_exit;
        }
    };
}

// ----------------------------------------------------------------------------
//
// Shortcuts view caption for plugin. max 128
//
// ----------------------------------------------------------------------------
//
RESOURCE TBUF r_psln_ai_list_view_caption
{
    buf = qtn_apps_idle_skin_gs;
}

// ----------------------------------------------------------------------------
//
// Active Idle specific skin tab title. max 128
//
// ----------------------------------------------------------------------------
//
RESOURCE TBUF r_psln_ai_tab_name
{
    buf = qtn_skins_tabs_activeidle;
}

// ----------------------------------------------------------------------------
//
// View title for GS Active Idle plugin.
//
// ----------------------------------------------------------------------------
//
RESOURCE TITLE_PANE r_psln_gs_list_view_title
{
    txt = qtn_apps_idle_skin_gs;
}

// ----------------------------------------------------------------------------
//
// View caption for GS Active Idle plugin. max 256
//
// ----------------------------------------------------------------------------
//
RESOURCE TBUF r_psln_gs_list_view_caption
{
    buf = qtn_apps_idle_skin_gs;
}

// ----------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------
RESOURCE CBA r_softkeys_options_back_empty
{
    buttons =
    {
        CBA_BUTTON {id = EAknSoftkeyOptions;  txt = text_softkey_option; },
        CBA_BUTTON {id = EAknSoftkeyBack;     txt = text_softkey_back;   },
        CBA_BUTTON {id = EPslnCmdAppActivate; txt = ""; }
    };
}

// ----------------------------------------------------------------------------
//
// ----------------------------------------------------------------------------
//
RESOURCE CBA r_softkeys_options_exit_empty
{
    buttons =
    {
        CBA_BUTTON {id = EAknSoftkeyOptions;  txt = text_softkey_option; },
        CBA_BUTTON {id = EAknSoftkeyExit;     txt = text_softkey_exit;   },
        CBA_BUTTON {id = EPslnCmdAppActivate; txt = ""; }
    };
}

// End of File.
bld.inf
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  This file provides the information required for building
*                PslnActiveIdlePlugin.
*
*/


PRJ_PLATFORMS
DEFAULT

PRJ_EXPORTS
#include 
../loc/hs_app_pslnactiveidle3plugin.loc             MW_LAYER_LOC_EXPORT_PATH(hs_app_pslnactiveidle3plugin.loc)

//../rom/hs_app_pslnactiveidleplugin_resources.iby   LANGUAGE_MW_LAYER_IBY_EXPORT_PATH(hs_app_pslnactiveidleplugin_resources.iby)
//../rom/hs_app_pslnactiveidleplugin.iby             CORE_MW_LAYER_IBY_EXPORT_PATH(hs_app_pslnactiveidleplugin.iby)

		


PRJ_MMPFILES
pslnactiveidleplugin.mmp

PRJ_EXTENSIONS
START EXTENSION s60/mifconv
OPTION TARGETFILE pslnactiveidleplugin.mif
OPTION HEADERFILE pslnactiveidleplugin.mbg
OPTION SOURCES \
        -c8,8 qgn_prop_psln_ai_sub
END

PRJ_TESTMMPFILES

// End of File.
pslnactiveidleplugin.mmp
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project specification file.
*
*/


#include 
#include     // For RESOURCE_FILES_DIR
#include "../inc/hs_app_pslnactiveidlepluginuids.h"

//MACRO MY_DEBUG

TARGET          hs_app_pslnactiveidleplugin.dll
TARGETTYPE      PLUGIN
UID             0x10009D8D KPslnActiveIdlePluginDllUID3

CAPABILITY      CAP_ECOM_PLUGIN
VENDORID        VID_DEFAULT

SOURCEPATH      ../src
SOURCE          hs_app_pslnactiveidlepluginimplementationtable.cpp
SOURCE          hs_app_pslnactiveidleplugincontainer.cpp
SOURCE          hs_app_pslnactiveidlepluginengine.cpp
SOURCE          hs_app_pslnactiveidleplugin.cpp
SOURCE          hs_app_gsactiveidleplugincontainer.cpp
SOURCE          hs_app_gsactiveidleplugin.cpp

USERINCLUDE     ../inc
USERINCLUDE     ../loc
USERINCLUDE     ../data // For *.rh

MW_LAYER_SYSTEMINCLUDE
SYSTEMINCLUDE   /epoc32/include/ecom

SOURCEPATH      ../data

START RESOURCE  hs_app_pslnactiveidleplugin.rss
TARGET          hs_app_pslnactiveidleplugin.rsc
END

START RESOURCE  hs_app_pslnactiveidlepluginrsc.rss
DEPENDS pslncommon.rsg
HEADER
TARGETPATH      RESOURCE_FILES_DIR
LANGUAGE_IDS
END

LIBRARY         apgrfx.lib
LIBRARY         euser.lib
LIBRARY         ecom.lib
LIBRARY         efsrv.lib
LIBRARY         avkon.lib
LIBRARY         bafl.lib
LIBRARY         cone.lib
LIBRARY         eikcoctl.lib
LIBRARY         eikcore.lib
LIBRARY         centralrepository.lib

LIBRARY         commonengine.lib    // For RConeResourceLoader
LIBRARY         aknskins.lib        // For enhanced skinning
LIBRARY         aknnotify.lib       // Global note
LIBRARY         featmgr.lib         // For feature manager

LIBRARY         pslnframework.lib   // For Psln FW base classes
LIBRARY         xn3odt.lib           // For XUIKON

LIBRARY         gsframework.lib     // For GS FW base classes
LIBRARY         gsecomplugin.lib

// End of File.
pslnactiveidlepluginicons.mk
#
# Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
# All rights reserved.
# This component and the accompanying materials are made available
# under the terms of "Eclipse Public License v1.0"
# which accompanies this distribution, and is available
# at the URL "http://www.eclipse.org/legal/epl-v10.html".
#
# Initial Contributors:
# Nokia Corporation - initial contribution.
#
# Contributors:
#
# Description: 
#

ifeq (WINS,$(findstring WINS, $(PLATFORM)))
ZDIR=\epoc32\release\$(PLATFORM)\$(CFG)\Z
else
ZDIR=\epoc32\data\z
endif

TARGETDIR=$(ZDIR)\resource\apps
HEADERDIR=\epoc32\include
ICONTARGETFILENAME=$(TARGETDIR)\pslnactiveidleplugin.mif
HEADERFILENAME=$(HEADERDIR)\pslnactiveidleplugin.mbg

do_nothing :
	@rem do_nothing

MAKMAKE : do_nothing

BLD : do_nothing

CLEAN : do_nothing

LIB : do_nothing

CLEANLIB : do_nothing

# ----------------------------------------------------------------------------
#
# NOTE 1: DO NOT DEFINE MASK FILE NAMES! They are included automatically by
# MifConv if the mask detph is defined.
#
# NOTE 2: Usually, source paths should not be included in the bitmap
# definitions. MifConv searches for the icons in all icon directories in a
# predefined order, which is currently \s60\icons, \s60\bitmaps2, \s60\bitmaps.
# The directory \s60\icons is included in the search only if the feature flag
# __SCALABLE_ICONS is defined.
# ----------------------------------------------------------------------------

RESOURCE :
	mifconv $(ICONTARGETFILENAME) /h$(HEADERFILENAME) \
		/c8,8 qgn_prop_psln_ai_sub.svg


FREEZE : do_nothing

SAVESPACE : do_nothing

RELEASABLES :
	@echo $(HEADERFILENAME)&& \
	@echo $(ICONTARGETFILENAME)

FINAL : do_nothing
hs_app_gsactiveidleplugin.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Psln Active Idle settings plugin.
*
*/


#ifndef C_GSACTIVEIDLEPLUGIN_H
#define C_GSACTIVEIDLEPLUGIN_H

#include 
#include 

class CGSActiveIdlePluginContainer;
class CPslnFWPluginInterface;
class CPslnFWPluginHandler;


/**
 *  CGSActiveIdlePlugin view class for Psln Active Idle settings.
 *  @since S60 3.2
 *
 */
class CGSActiveIdlePlugin : public CGSPluginInterface
{

public: // Constructors and destructor

    /**
     * Symbian OS two-phased constructor
     *
     * @param aInitParams param not used.
     * @return GS connection view.
     */
    static CGSActiveIdlePlugin* NewL(TAny* aInitParams);

    /**
     * Destructor
     */
    ~CGSActiveIdlePlugin();

// From CGSPluginInterface

    /**
     * @see CGSPluginInterface header file.
     */
    void GetCaptionL(TDes& aCaption) const;

    /**
     * @see CGSPluginInterface header file.
     */
    TInt PluginProviderCategory() const;

    /**
     * @see CGSPluginInterface header file.
     */
    TBool Visible() const;

// from base classes

    /**
     * Returns view id.
     * @return TUid
     */
    TUid Id() const;

    /**
     * Handles commands.
     * @param aCommand Command to be handled.
     *
     */
    void HandleCommandL(TInt aCommand);

protected: // From CAknView

    /**
     * @see CAknView.
     */
    void DoActivateL(
        const TVwsViewId& aPrevViewId,
        TUid aCustomMessageId,
        const TDesC8& aCustomMessage);

    /**
     * @see CAknView.
     */
    void DoDeactivate();

// Construction

    /**
     * C++ default constructor.
     */
    CGSActiveIdlePlugin();

    /**
     * Symbian OS default constructor.
     *
     */
    void ConstructL();

private: // data

    /// Resource loader.
    RConeResourceLoader             iResourceLoader;

    /// Container. Owned.
    CGSActiveIdlePluginContainer*   iContainer;

    /// Previous view id.
    TVwsViewId                      iPrevViewId;

    /// Plugin loader. Owned.
    CPslnFWPluginHandler*           iPluginLoader;

};

#endif // C_GSACTIVEIDLEPLUGIN_H

// End of File.
hs_app_gsactiveidleplugincontainer.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Psln Active Idle settings plugin.
*
*/


#ifndef C_GSACTIVEIDLEPLUGINCONTAINER_H
#define C_GSACTIVEIDLEPLUGINCONTAINER_H

#include 

/**
 *  CGSActiveIdlePluginContainer container class
 *
 *  @since S60 3.2
 */
class CGSActiveIdlePluginContainer : public CCoeControl
{
public: // Constructors and destructor

    /**
     * Symbian OS constructor.
     * @param aRect Listbox's rect.
     *
     */
    void ConstructL(const TRect& aRect);

    ~CGSActiveIdlePluginContainer();

    CGSActiveIdlePluginContainer();

// From CCoeControl

    TInt CountComponentControls() const;

    CCoeControl* ComponentControl(TInt aIndex) const;

    void SizeChanged();

};

#endif // C_GSACTIVEIDLEPLUGINCONTAINER_H

// End of File.
hs_app_pslnactiveidleplugin.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  View for Active Idle skinning.
*
*/


#ifndef C_PSLNACTIVEIDLEPLUGIN_H
#define C_PSLNACTIVEIDLEPLUGIN_H

#include 
#include 
#include 
#include 
#include 


class CAknViewAppUi;
class CPslnActiveIdlePluginContainer;
class CPslnActiveIdlePluginEngine;

enum TAiUIControllers
{
    EAiUICUnknown = -1,
    EAiUICNative = 0,
    EAiUICXML
};

// View item text length
const TInt KPslnItemMaxTextLength = 128;


/**
 *  CPslnActiveIdlePlugin view class for Active Idle Theme settings
 *
 *  @since S60 3.2
 */
class CPslnActiveIdlePlugin :
    public CPslnFWBaseView,
    public MPslnFWMSKObserver
{
public: // Constructors and destructor

    /**
     * Symbian OS two-phased constructor
     *
     * @param aAppUi pointer to app ui, TAny static cast'd.
     * @return Psln AI skinning view.
     */
    static CPslnActiveIdlePlugin* NewL(TAny* aAppUi);

    /**
     * Destructor
     */
    ~CPslnActiveIdlePlugin();

// From CPslnFWnInterface

    /**
     * @see CPslnFWPluginInterface.
     */
    void GetCaptionL(TDes& aCaption) const;


    /**
     * @see CPslnFWPluginInterface.
     */
    void GetTabTextL(TDes& aCaption) const;

    /**
     * @see CPslnFWPluginInterface.
     */
    CGulIcon* CreateIconL();

    /**
     * @see CPslnFWPluginInterface.
     */
    void GetLocationTypeAndIndex(TPslnFWLocationType& aType, TInt& aIndex) const;

// from AknView

    /**
     * Returns view id.
     * @return TUid
     */
    TUid Id() const;

    /**
     * Handles commands.
     * @param aCommand Command to be handled.
     */
    void HandleCommandL(TInt aCommand);

// new methods

    /**
     * Get CPslnActiveIdlePlugin's ccontainer.
     * @return pointer to container.
     */
    CPslnActiveIdlePluginContainer* Container();

    /**
     * From MPslnFWMSKObserver.
     * Checks if the MSK label needs to be adjusted.
     */
    void CheckMiddleSoftkeyLabelL();
    
    /**
     * Return engine instance.
     */
    CPslnActiveIdlePluginEngine* Engine();

protected: // From CAknView

    void DoActivateL(
        const TVwsViewId& aPrevViewId,
        TUid aCustomMessageId,
        const TDesC8& aCustomMessage);

    void DoDeactivate();

// Construction

    CPslnActiveIdlePlugin(CAknViewAppUi* aAppUi);

    void ConstructL();

private: // From MEikMenuObserver

    /**
     * Changes MenuPane dynamically
     */
    void DynInitMenuPaneL(TInt aResourceId, CEikMenuPane* aMenuPane);

// from CPslnFWBaseView

    void NewContainerL();

    void HandleListBoxSelectionL();

    /**
     * Remove command and label from MSK
     */
    void RemoveCommandFromMSK();
    
    /**
     * @see CPslnFWBaseView.
     */
    void SetTitlePaneL( TInt& aResourceId );

private: // data

    /// Resource loader for own resources.
    RConeResourceLoader         iResourceLoader;

    /// Resource loader for common psln resources.
    RConeResourceLoader         iResourceLoaderCommon;

    /// Resource loader for Psln app resources.
    RConeResourceLoader         iResourceLoaderPsln;

    /// Application UI pointer. Not owned.
    CAknViewAppUi*              iAppUi;

    /// Navi pane. Not owned.
    CAknNavigationDecorator*    iNaviPaneContext;
    
    /// Ai2 perso engine
    CPslnActiveIdlePluginEngine* iEngine;

};

#endif // C_PSLNACTIVEIDLEPLUGIN_H

// End of File.
hs_app_pslnactiveidleplugin.hrh
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Contains common definitions for menu id:s.
*
*/


#ifndef INC_PSLNACTIVEIDLEPLUGIN_HRH
#define INC_PSLNACTIVEIDLEPLUGIN_HRH

// commands
enum TPslnAIMenuCommands
    {
    EPslnAICmdAppOpen = 1,
    EPslnAICmdAppHelp,
    EPslnAICmdAppChange,
    EPslnAIAppCmdChange
    };

#endif // INC_PSLNACTIVEIDLEPLUGIN_HRH

// End of File.
hs_app_pslnactiveidleplugincontainer.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Container for Application shell theme view.
*
*/


#ifndef C_PSLNACTIVEIDLEPLUGINCONTAINER_H
#define C_PSLNACTIVEIDLEPLUGINCONTAINER_H

// INCLUDES
#include 

// CONSTANTS
// Download item index
const TInt KPslnDownloadItemIndex = 0;
// View item text length
const TInt KPslnAsItemMaxTextLength = 128;

// FORWARD DECLARATION
class CXnODT;
class CPslnActiveIdlePlugin;

// CLASS DECLARATION

/**
*  CPslnActiveIdlePluginContainer container class
*  @since S60 v3.1
*/
NONSHARABLE_CLASS( CPslnActiveIdlePluginContainer ) :
    public CPslnFWBaseContainer
    {
    public:

        CPslnActiveIdlePluginContainer(
                    TBool aGSCalling,
                    CPslnActiveIdlePlugin* aPlugin);
        /**
        * Symbian OS constructor.
        * @param aRect Listbox's rect.
        */
        void ConstructL( const TRect& aRect );

        /**
        * Destructor.
        */
        ~CPslnActiveIdlePluginContainer();

        /**
        * Return currently active selection from list.
        * @return currently selected skin index from list view.
        */
        TInt GetCurrentlySelectedIndex() const;

        /**
        * Adds new item to the listbox.
        * @param aItemIndex index to add.
        * @param ODT of the theme to add.
        * @since 3.2
        */
        void AddNewItemToListL(
            const TInt aItemIndex,
            CXnODT* aSkinODT, TInt aUiController );

        /*
        * Removes number of themes from listbox.
        * @param aDeleteFrom start point index where to start deleting.
        *        All themes from this on are deleted.
        * @since 3.2
        */
        void RemoveThemes( const TInt aDeleteFrom );
        
        /**
         * Method for telling to update the listing.
         */
        void RefreshList();
        
    private:

        /* From CPslnFWBaseContainer. */
        void ConstructListBoxL( TInt aResLbxId );

        /**
        * Required for help.
        */
        void GetHelpContext( TCoeHelpContext& aContext ) const;

        /**
        * Adds icons to setting item list.
        */
        void AddIconsToListL();

    private: // data

        /**
        * Listbox array for items.
        * Not own.
        */
        CDesCArray* iItemArray;

        /**
        * List of items from resources.
        * Own.
        */
        CDesCArrayFlat* iItems;

        /**
        * Index of currently selected item.
        */
        TInt iCurrentlySelected;
        
        /**
         * Pointer to psln plugin.
         * Not own.
         */
        CPslnActiveIdlePlugin* iPlugin;

        /**
         * Indicate if gs started us
         */
        TBool iGSCalling;
    
    };

#endif //C_PSLNACTIVEIDLEPLUGINCONTAINER_H

// End of File
hs_app_pslnactiveidlepluginengine.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Container for Psln Active Idle settings view.
*
*/

#ifndef C_PSLNACTIVEIDLEPLUGINENGINE_H
#define C_PSLNACTIVEIDLEPLUGINENGINE_H

#include 
#include 

// UID of Active Idle.
const TUid KUidActiveIdle = { 0x102750F0 };


class CPslnFWAppThemeHandler;
class CXnODT;
class CPslnActiveIdlePlugin; // for notifying MSK chech need
class CPeriodic;


/**
 *  CPslnActiveIdlePluginEngine container class
 *
 *  @since S60 3.2
 */
class CPslnActiveIdlePluginEngine :
    public CBase,
    public MPslnFWAppThemeObserver
{
public: // Constructors and destructor

    void ConstructL(const TRect& aRect);

    CPslnActiveIdlePluginEngine(CPslnActiveIdlePlugin* aPlugin);

    ~CPslnActiveIdlePluginEngine();

// new methods

    /**
     * Activates currently highlighted theme.
     */
    void ActivateThemeL();
    
// from MPslnFWAppThemeObserver

    void HandleMessage(TXnServiceCompletedMessage aMessage);

    void HandleMessage(
        TXnServiceCompletedMessage aMessage,
        CArrayPtrFlat& aAppThemeList);
        
    TInt CurrentUIController()
        {
        return iCurrentUIController;
        };
        
    void AddThemesToContainerL();

    void ManualGetSkinsRestartL(TBool aForceStart = EFalse);

private: // new methods

    /**
     * Adds new theme(s) to the listbox. Multiple themes are
     * only added when list updation is required (icons need
     * to be updated). Otherwise latest theme info is inquired
     * from XUIKON.
     */
    void AddNewThemeL(TXnServiceCompletedMessage aMessage);
    TInt GetExtStandbyScreenState(TInt& aValue);

    /**
     * Add HS items to list.
     */
    void AddHomeScreenThemesL();

    void CheckCurrentUIControllerL();
    
    void CheckCurrentAi1PluginL();
    
    void UpdateUIControllersInCenrepL(TInt aControllerId);
    
    void UpdateStatusPaneVisibilityCenrepL(TBool aPaneHidden);
    
    void UpdateAi1PluginLoadCenrepL(TInt aNewUid);
    
    TInt RestartAifw();

    TBool IsAiRunning();

    void UiTimerRestart();
        
private:

    static TInt RestartTimerCallback( TAny* aSelf );

    static TInt UiRefreshTimerCallback( TAny* aSelf );
    
private: // data

    /**
     * Application specific skin handler.
     * Own.
     */
    CPslnFWAppThemeHandler* iPslnFWThemeHandler;

    /**
     * List of themes. Each theme is described within an ODT.
     * Own.
     */
    CArrayPtrFlat*  iMySkinList;

    /**
     * Indicates that skin list should be updated.
     */
    TBool                   iThemeListUpdated;

    /**
     * HomeScreen items start index in iMySkinList.
     */
    TInt                    iHSStartIndex;

    /**
     * HomeScreen items end index in iMySkinList.
     */
    TInt                    iHSEndIndex;

    /**
     * Flag to indicate if we are avaiting the first restart event.
     */
    TBool                   iFirstUpdateRound;

    /**
     * Flag to indicate if we have injected first round data.
     */
    TBool                   iFirstUpdateRoundInjected;

    /**
     * Current AI2 UI Controller id.
     */
    TInt                    iCurrentUIController;
    
    /**
     * Current AI1 plugin id.
     */
    TInt                    iCurrentAi1Plugin;

    /**
     * Flag to indicate if we have injected first round data.
     * Not owned.
     */
    CPslnActiveIdlePlugin*  iPlugin;

    /**
     * Restart timer. To restart AI2.
     * Own.
     */
    CPeriodic*              iRestartTimer;

    /**
     * UI Refresh timer.
     * Own.
     */
    CPeriodic*              iUiRefreshTimer;

    /**
     * Restart timer. To restart AI2.
     * Own.
     */
    TInt                    iRestartRetryCount;

    /**
     * Kepp track what has been added to list.
     * Own.
     */
    TInt                    iAddIndex;
    
};

#endif // C_PSLNACTIVEIDLEPLUGINENGINE_H

// End of File.
hs_app_pslnactiveidlepluginuids.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Uid's of Psln Active Idle settings.
*
*/


#ifndef INC_PSLNACTIVEIDLEPLUGINUIDS_H
#define INC_PSLNACTIVEIDLEPLUGINUIDS_H

// =======================
// Psln Active Idle plugin
// =======================

// PslnActiveIdlePlugin DLL UID
#define KPslnActiveIdlePluginDllUID3                0x102750A4

// PslnActiveIdlePlugin Interface UID
#define KPslnPluginInterfaceUID                     0x102750A9

// PslnActiveIdlePlugin Implementation UID
#define KPslnActiveIdlePluginImplementationUID      0x102750A7

// ==============================
// GS Active Idle Settings plugin
// ==============================

// GS Plugin interface uid
#define KGSPluginInterfaceUID                       0x10207236

// GSActiveIdlePlugin Implementation UID
#define KGSActiveIdlePluginImplementationUID        0x102750F5

#endif // INC_PSLNACTIVEIDLEPLUGINUIDS_H

// End of File.
hs_app_pslnconst.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Constants for psln plugin.
*
*/

#ifndef INC_PSLNCONST_H
#define INC_PSLNCONST_H

// (from psln\inc\pslnconst.h, required by pslnmodel.h)
// Maximum number of characters in Screen saver txt.
const TInt KPslnMaxNumberOfScreenSaverText = 15;

#endif // INC_PSLNCONST_H

// End of File
hs_app_pslnactiveidle3plugin.loc
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Localization strings for PslnActiveIdlePlugin.
*
*/


// LOCALISATION STRINGS

// d:Text of a list item in home screens settings list
// d:Item opens home screen theme settings
// l:list_single_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_idle_skin_gs "Change Idle theme"

// d:Text of a list item for home screen app in Themes selection list 
// d:Item opens home screen theme settings
// l:list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_idle_skin_hs "Change Idle theme"

// d:Title of home screen theme settings view.
// d:
// l:title_pane_t2/opt9
// w:
// r: 3.2
//
#define qtn_apps_idle_skin_title "Change Idle theme"

// End of File.
hs_app_pslnactiveidleplugin.iby
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Image description file for project pslnactiveidleplugin
*
*/


#ifndef PSLNACTIVEIDLEPLUGIN_IBY
#define PSLNACTIVEIDLEPLUGIN_IBY

#include 

// Psln ActiveIdle plugin
data=DATAZ_\BITMAP_DIR\pslnactiveidleplugin.mif BITMAP_DIR\pslnactiveidleplugin.mif
ECOM_PLUGIN( hs_app_pslnactiveidleplugin.dll, hs_app_pslnactiveidleplugin.rsc )

// Central repository file, temporarily here
//data=\S60\ActiveIdle2\plugins\shortcutplugin\src\10275104.txt "private\10202BE9\10275104.txt"

#endif // PSLNACTIVEIDLEPLUGIN_IBY
hs_app_pslnactiveidleplugin_resources.iby
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Image description file for project pslnactiveidleplugin localizable resources
*
*/


#ifndef PSLNACTIVEIDLEPLUGIN_RESOURCES_IBY
#define PSLNACTIVEIDLEPLUGIN_RESOURCES_IBY

#include 

// Psln ActiveIdle settings plugin localizable resources
data=DATAZ_\RESOURCE_FILES_DIR\pslnactiveidlepluginrsc.rsc  RESOURCE_FILES_DIR\pslnactiveidlepluginrsc.rsc

#endif // PSLNACTIVEIDLEPLUGIN_RESOURCES_IBY
hs_app_gsactiveidleplugin.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Psln Active Idle settings plugin.
*
*/


#include "hs_app_gsactiveidleplugin.h"
#include "hs_app_gsactiveidleplugincontainer.h"

#include 
#include 
#include 
#include "hs_app_pslnactiveidlepluginuids.h"

#include 
#include 
#include 
#include 
#include 
#include 

#include 
#include 

// GS Active Idle Plugin impl. UID
const TUid KGSActiveIdlePluginUid = { KGSActiveIdlePluginImplementationUID };

// Psln Active Idle Plugin impl. UID
const TUid KPslnAIPluginUid       = { KPslnActiveIdlePluginImplementationUID };

_LIT(KGSActiveIdlePluginResourceFileName, "z:pslnactiveidlepluginrsc.rsc");


// ----------------------------------------------------------------------------
// CGSActiveIdlePlugin::CGSActiveIdlePlugin()
//
// Constructor
// ----------------------------------------------------------------------------
//
CGSActiveIdlePlugin::CGSActiveIdlePlugin() : iResourceLoader(*iCoeEnv), iPrevViewId()
{
}

// ---------------------------------------------------------------------------
// CGSActiveIdlePlugin::NewL()
//
// Symbian OS default constructor
// ---------------------------------------------------------------------------
CGSActiveIdlePlugin* CGSActiveIdlePlugin::NewL(TAny* /*aInitParams*/)
{
    CGSActiveIdlePlugin* self = new (ELeave) CGSActiveIdlePlugin();

    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);

    return self;
}

// ---------------------------------------------------------------------------
// CGSActiveIdlePlugin::ConstructL()
//
// Symbian OS two-phased constructor
// ---------------------------------------------------------------------------
void CGSActiveIdlePlugin::ConstructL()
{
#ifdef _MY_DEBUG
    RDebug::Print(_L("XAI: CGSActiveIdlePlugin::ConstructL"));
#endif

    // Find the resource file.
    TParse parse;
    parse.Set(KGSActiveIdlePluginResourceFileName, &KDC_RESOURCE_FILES_DIR, NULL);
    TFileName fileName(parse.FullName());

    // Open resource file.
    iResourceLoader.OpenL(fileName);

    BaseConstructL();

    // Psln first finds and loads all plugins that implement Psln plugin interface.
    iPluginLoader = CPslnFWPluginHandler::NewL(AppUi());
    CPslnFWPluginInterface* plugin = iPluginLoader->LoadPluginL(KPslnAIPluginUid);
    if (plugin)
    {
        // Add Psln Active Idle plugin to appui views. Plugin is deleted
        // when appui is destroyed.
        if (plugin->Id() == KPslnAIPluginUid)
        {
            CAknView* view = static_cast(plugin);
            AppUi()->AddViewL(view);
        }
    }
}

// ----------------------------------------------------------------------------
// CGSActiveIdlePlugin::~CGSActiveIdlePlugin
//
// Destructor
// ----------------------------------------------------------------------------
CGSActiveIdlePlugin::~CGSActiveIdlePlugin()
{
    if (iContainer)
    {
        AppUi()->RemoveFromStack(iContainer);
        delete iContainer;
        iContainer = NULL;
    }

    iResourceLoader.Close();

    delete iPluginLoader;
}

// ---------------------------------------------------------------------------
// TUid CGSActiveIdlePlugin::Id()
//
// Returns view's ID.
// ---------------------------------------------------------------------------
TUid CGSActiveIdlePlugin::Id() const
{
    return KGSActiveIdlePluginUid;
}

// ----------------------------------------------------------------------------
// CGSActiveIdlePlugin::GetCaption
//
// Return application/view caption. 256
// ----------------------------------------------------------------------------
//
void CGSActiveIdlePlugin::GetCaptionL(TDes& aCaption) const
{
    iCoeEnv->ReadResourceL(aCaption, R_PSLN_GS_LIST_VIEW_CAPTION);
}

// ----------------------------------------------------------------------------
// CGSActiveIdlePlugin::PluginProviderCategory
//
// A means to identify the location of this plug-in in the framework.
// ----------------------------------------------------------------------------
//
TInt CGSActiveIdlePlugin::PluginProviderCategory() const
{
    // To identify internal plug-ins.
    return KGSPluginProviderInternal;
}

// ----------------------------------------------------------------------------
// CGSActiveIdlePlugin::Visible
//
// Provides the visibility status of self to framework.
// ----------------------------------------------------------------------------
//
TBool CGSActiveIdlePlugin::Visible() const
{
#ifdef _MY_DEBUG
    RDebug::Print(_L("XAI: CGSActiveIdlePlugin::Visible"));
#endif

    return ETrue;
}

// ---------------------------------------------------------------------------
// CGSActiveIdlePlugin::HandleCommandL(TInt aCommand)
//
// Handles commands directed to this class.
// ---------------------------------------------------------------------------
void CGSActiveIdlePlugin::HandleCommandL(TInt aCommand)
{
    // shouldn't get any commands to handle, but forward them to appui anyway...
    AppUi()->HandleCommandL(aCommand);
}

// ----------------------------------------------------------------------------
// CGSActiveIdlePlugin::DoActivateL
//
// First method called by the Avkon framwork to invoke a view.
// ----------------------------------------------------------------------------
//
void CGSActiveIdlePlugin::DoActivateL(
    const TVwsViewId& aPrevViewId,
    TUid /*aCustomMessageId*/,
    const TDesC8& /*aCustomMessage*/)
{
#ifdef _MY_DEBUG
    RDebug::Print(_L("XAI: CGSActiveIdlePlugin::DoActivateL"));
#endif

    if (!iContainer)
    {
        iContainer = new (ELeave) CGSActiveIdlePluginContainer();
        iContainer->SetMopParent(this);
        iContainer->ConstructL(ClientRect());
    }

    AppUi()->AddToStackL(*this, iContainer);

    if (iPrevViewId.iViewUid.iUid == 0)
    {
        iPrevViewId = aPrevViewId;
    }

	iContainer->MakeVisible(ETrue);
    AppUi()->ActivateLocalViewL(KPslnAIPluginUid);
}

// ----------------------------------------------------------------------------
// CGSActiveIdlePlugin::DoDeactivate
//
// Called by the Avkon view framework when closing.
// ----------------------------------------------------------------------------
//
void CGSActiveIdlePlugin::DoDeactivate()
{
    AppUi()->RemoveFromStack(iContainer);
    iContainer->MakeVisible(EFalse);
    iPrevViewId.iViewUid.iUid = 0;
}

// End of File.
hs_app_gsactiveidleplugincontainer.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Psln Active Idle settings plugin.
*
*/


#include "hs_app_gsactiveidleplugincontainer.h"

// ---------------------------------------------------------------------------
// CGSActiveIdlePluginContainer::ConstructL()
//
// Symbian OS two phased constructor.
// ---------------------------------------------------------------------------
//
void CGSActiveIdlePluginContainer::ConstructL(const TRect& aRect)
{
    CreateWindowL(); // Makes the control a window-owning control
    SetRect(aRect);
    ActivateL();
}

// ---------------------------------------------------------------------------
// CGSActiveIdlePluginContainer::~CGSActiveIdlePluginContainer()
//
// Destructor.
// ---------------------------------------------------------------------------
//
CGSActiveIdlePluginContainer::~CGSActiveIdlePluginContainer()
{
}

CGSActiveIdlePluginContainer::CGSActiveIdlePluginContainer()
{
}

void CGSActiveIdlePluginContainer::SizeChanged()
{
}

TInt CGSActiveIdlePluginContainer::CountComponentControls() const
{
    return 0;
}

CCoeControl* CGSActiveIdlePluginContainer::ComponentControl(TInt /*aIndex*/ ) const
{
    return NULL;
}

// End of File.
hs_app_pslnactiveidleplugin.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  View for Active Idle skinning.
*
*/


// This plugin specific.
#include 
#include 
#include "hs_app_pslnactiveidleplugin.h"
#include "hs_app_pslnactiveidleplugincontainer.h"
#include "hs_app_pslnactiveidlepluginengine.h"
#include "hs_app_pslnactiveidlepluginuids.h"

// General services.
#include 
#include 
#include 

// Psln Framework specific.
#include 
#include 
#include 
#include 


// Path to mbm file.
_LIT(KPslnActiveIdleIconFileName, "pslnactiveidleplugin.mbm");

// Path to compiled resource file.
_LIT(KPslnActiveIdlePluginResourceFileName, "z:pslnactiveidlepluginrsc.rsc");

// Path to common personalization resources. This resource file is meant for
// shared resources between application and plugins.
_LIT(KPslnCommonResourceFileName, "z:pslncommon.rsc");

// Path to Psln application resource file. Plugin uses some localized texts
// from Psln's resources.
_LIT(KPslnApplicationResourceFileName, "z:psln.rsc");

// Location of this plugin view within Psln's tab group.
const TInt KPslnActiveIdlePluginLocation = 2;

const TUid KPslnActiveIdlePluginUid = { KPslnActiveIdlePluginImplementationUID };

// Middle Softkey control ID.
const TInt KPslnMSKControlId = 3;

// ----------------------------------------------------------------------------
// CPslnActiveIdlePlugin::CPslnActiveIdlePlugin()
//
// Constructor
// ----------------------------------------------------------------------------
//
CPslnActiveIdlePlugin::CPslnActiveIdlePlugin(CAknViewAppUi* aAppUi)
    :
    iResourceLoader(*iCoeEnv),
    iResourceLoaderCommon(*iCoeEnv),
    iResourceLoaderPsln(*iCoeEnv),
    iAppUi(aAppUi)
{
}

// ---------------------------------------------------------------------------
// CPslnActiveIdlePlugin::NewL
//
// Symbian OS default constructor
// ---------------------------------------------------------------------------
CPslnActiveIdlePlugin* CPslnActiveIdlePlugin::NewL(TAny* aAppUi)
{
    CAknViewAppUi* appUi = reinterpret_cast(aAppUi);
    CPslnActiveIdlePlugin* self = new(ELeave) CPslnActiveIdlePlugin (appUi);

    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);

    return self;
}

// ---------------------------------------------------------------------------
// CPslnActiveIdlePlugin::ConstructL
//
// Symbian OS two-phased constructor
// ---------------------------------------------------------------------------
void CPslnActiveIdlePlugin::ConstructL()
{
#ifdef _MY_DEBUG
    RDebug::Print(_L("XAI: CPslnActiveIdlePlugin::ConstructL"));
#endif

    // Find the resource file:
    TParse* parse = new (ELeave) TParse;
    CleanupStack::PushL(parse);
    parse->Set(KPslnCommonResourceFileName, &KDC_APP_RESOURCE_DIR, NULL);
    TFileName* fileName = new (ELeave) TFileName(parse->FullName());
    CleanupStack::PushL(fileName);

    // Open resource file:
    iResourceLoaderCommon.OpenL(*fileName);
    CleanupStack::PopAndDestroy(fileName);

    // Find the resource file:
    parse->Set(KPslnApplicationResourceFileName, &KDC_APP_RESOURCE_DIR, NULL);
    fileName = new (ELeave) TFileName(parse->FullName());
    CleanupStack::PushL(fileName);

    // Open resource file:
    iResourceLoaderPsln.OpenL(*fileName);
    CleanupStack::PopAndDestroy(fileName);
    CleanupStack::PopAndDestroy(parse);

    // Open own resources for reading.
    OpenLocalizedResourceFileL(
        KPslnActiveIdlePluginResourceFileName,
        iResourceLoader);

    BaseConstructL(R_PSLN_ACTIVE_IDLE_VIEW);

    iEngine = new (ELeave) CPslnActiveIdlePluginEngine(this);
    iEngine->ConstructL( TRect() );
    iEngine->ManualGetSkinsRestartL(ETrue); // Force start

}

// ----------------------------------------------------------------------------
// CPslnActiveIdlePlugin::~CPslnActiveIdlePlugin
//
// Destructor
// ----------------------------------------------------------------------------
CPslnActiveIdlePlugin::~CPslnActiveIdlePlugin()
{
    iResourceLoaderCommon.Close();
    iResourceLoaderPsln.Close();
    iResourceLoader.Close();
    delete iEngine;
}

// ---------------------------------------------------------------------------
// TUid CPslnActiveIdlePlugin::Id()
//
// Returns view's ID.
// ---------------------------------------------------------------------------
TUid CPslnActiveIdlePlugin::Id() const
{
    return KPslnActiveIdlePluginUid;
}

// ----------------------------------------------------------------------------
// CPslnActiveIdlePlugin::GetCaption
//
// Return application/view caption. 128
// ----------------------------------------------------------------------------
//
void CPslnActiveIdlePlugin::GetCaptionL(TDes& aCaption) const
{
    // the resource file is already opened.
    HBufC* result = StringLoader::LoadL(R_PSLN_AI_LIST_VIEW_CAPTION);
    if (aCaption.MaxLength() >= result->Length())
    {
        aCaption.Copy(*result);
    }
    delete result;
    }

// ----------------------------------------------------------------------------
// CPslnActiveIdlePlugin::GetTabTextL
//
// Return tab text. 128
// ----------------------------------------------------------------------------
//
void CPslnActiveIdlePlugin::GetTabTextL(TDes& aCaption) const
{
    // the resource file is already opened.
    HBufC* result = StringLoader::LoadL(R_PSLN_AI_TAB_NAME);
    if (aCaption.MaxLength() >= result->Length())
        {
        aCaption.Copy(*result);
        }
    delete result;
    }

// ----------------------------------------------------------------------------
// CPslnActiveIdlePlugin::CreateIconL
//
// Creates Main view icon.
// ----------------------------------------------------------------------------
//
CGulIcon* CPslnActiveIdlePlugin::CreateIconL()
{
    // Find the resource file:
    TParse* parse = new (ELeave) TParse;
    CleanupStack::PushL(parse);
    parse->Set(KPslnActiveIdleIconFileName, &KDC_APP_BITMAP_DIR, NULL);
    HBufC* fileName = parse->FullName().AllocLC();
    TPtr fileNamePtr = fileName->Des();

    CGulIcon* icon = AknsUtils::CreateGulIconL(
        AknsUtils::SkinInstance(),
        KAknsIIDQgnPropPslnAiSub,
        fileNamePtr,
        EMbmPslnactiveidlepluginQgn_prop_psln_ai_sub,
        EMbmPslnactiveidlepluginQgn_prop_psln_ai_sub_mask);

    CleanupStack::PopAndDestroy(2, parse); // fileName, parse

    return icon;
}

// -----------------------------------------------------------------------------
// CPslnActiveIdlePlugin::GetLocationTypeAndIndex()
//
//
// -----------------------------------------------------------------------------
//
void CPslnActiveIdlePlugin::GetLocationTypeAndIndex(
    TPslnFWLocationType& aType,
    TInt& aIndex) const
{
    aType = CPslnFWPluginInterface::EPslnFWSpecified;
    aIndex = KPslnActiveIdlePluginLocation;
}

// ---------------------------------------------------------------------------
// CPslnActiveIdlePlugin::HandleCommandL(TInt aCommand)
//
// Handles commands directed to this class.
// ---------------------------------------------------------------------------
void CPslnActiveIdlePlugin::HandleCommandL(TInt aCommand)
{
    switch (aCommand)
    {
    case EPslnCmdAppActivate:
        iEngine->ActivateThemeL();
        break;

    case EAknSoftkeyBack:
        RemoveCommandFromMSK();
        if (iAppUi->View(KPslnMainViewUid))
        {
            // if we are in Psln activate Psln main view...
            iAppUi->ActivateLocalViewL(KPslnMainViewUid);
        }
        else if (iAppUi->View(KGSMainViewUid))
        {
            // ... else if we are in GS activate parent plugin view (standby view)...
            iAppUi->ActivateLocalViewL(KGSStandbyPluginUid);
        }
        else
        {
            iAppUi->HandleCommandL(aCommand);
        }
        break;

    case EAknSoftkeyExit:
        // This is here because we use different softkey setups
        iAppUi->HandleCommandL(EAknCmdExit);
        break;

    case EPslnCmdAppHelp:
    case EAknCmdHelp:// Fall trough
        CPslnFWBaseView::HandleCommandL(aCommand);
        break;

    default:
        iAppUi->HandleCommandL(aCommand);
        break;
    }
}

// ----------------------------------------------------------------------------
// CPslnActiveIdlePlugin::Container
//
// Return handle to container class.
// ----------------------------------------------------------------------------
//
CPslnActiveIdlePluginContainer* CPslnActiveIdlePlugin::Container()
{
    return static_cast(iContainer);
}

// -----------------------------------------------------------------------------
// Checks is there a need to update the middle softkey label.
// This method should do nothing but MSK issues, since it is still called
// if the framework does not support MSK.
// -----------------------------------------------------------------------------
//
void CPslnActiveIdlePlugin::CheckMiddleSoftkeyLabelL()
{
    CPslnActiveIdlePluginContainer* container = Container();
    TInt highlightedItem = iContainer->iListBox->CurrentItemIndex();

#ifdef _MY_DEBUG
    RDebug::Print(_L("XAI: CPslnActiveIdlePlugin::CheckMiddleSoftkeyLabelL highl = %d, curr = %d"), highlightedItem, container->GetCurrentlySelectedIndex());
#endif

    // First remove any previous commands.
    RemoveCommandFromMSK();

    if (highlightedItem >= 0 &&
        highlightedItem != container->GetCurrentlySelectedIndex())
    {
        // Activate:
        CPslnFWBaseView::SetMiddleSoftKeyLabelL(
            R_PSLN_MSK_ACTIVATE,
            EPslnCmdAppActivate);
    }
    else
    {
        CPslnFWBaseView::SetMiddleSoftKeyLabelL(
            R_PSLN_MSK_DUMMY,
            EPslnCmdEmptyCommand );
    }
}

// -----------------------------------------------------------------------------
// Return engine instance.
// -----------------------------------------------------------------------------
//
CPslnActiveIdlePluginEngine* CPslnActiveIdlePlugin::Engine()
    {
    return iEngine;
    }

// ----------------------------------------------------------------------------
// CPslnActiveIdlePlugin::DoActivateL
//
// First method called by the Avkon framwork to invoke a view.
// ----------------------------------------------------------------------------
//
void CPslnActiveIdlePlugin::DoActivateL(
    const TVwsViewId& aPrevViewId,
    TUid aCustomMessageId,
    const TDesC8& aCustomMessage)
{
#ifdef MY_DEBUG
    RDebug::Print(_L("XAI: CPslnActiveIdlePlugin::DoActivateL"));
    RDebug::Print(_L("XAI:   aCustomMessageId = 0x%08x"), aCustomMessageId.iUid);
    RDebug::Print(_L("XAI:   aPrevViewId      = 0x%08x"), aPrevViewId.iAppUid.iUid);
#endif

    // If called from Psln - set tab group location.
    if (iAppUi->View(KPslnMainViewUid))
    {
        CPslnFWBaseView::SetNaviPaneL(KPslnActiveIdlePluginLocation);
    }

    CEikButtonGroupContainer* cba = Cba();

    if (cba)
    {
        if (aCustomMessageId == KUidActiveIdle)
        {
            cba->SetCommandSetL(R_SOFTKEYS_OPTIONS_EXIT_EMPTY);
        }
        else
        {
            cba->SetCommandSetL(R_SOFTKEYS_OPTIONS_BACK_EMPTY);
        }
        cba->DrawDeferred();
    }

    CPslnFWBaseView::DoActivateL(aPrevViewId, aCustomMessageId, aCustomMessage);

    CheckMiddleSoftkeyLabelL();
    
    iEngine->ManualGetSkinsRestartL();
}

// ----------------------------------------------------------------------------
// CPslnActiveIdlePlugin::DoDeactivate
//
// Called by the Avkon view framework when closing.
// ----------------------------------------------------------------------------
//
void CPslnActiveIdlePlugin::DoDeactivate()
{
#ifdef _MY_DEBUG
    RDebug::Print(_L("XAI: CPslnActiveIdlePlugin::DoDeactivate"));
#endif
    CPslnFWBaseView::DoDeactivate();
    RemoveCommandFromMSK();
}

// ----------------------------------------------------------------------------
// CPslnActiveIdlePlugin::DynInitMenuPaneL
//
//
// ----------------------------------------------------------------------------
//
void CPslnActiveIdlePlugin::DynInitMenuPaneL(
    TInt aResourceId, CEikMenuPane* aMenuPane)
{
    if (aResourceId == R_PSLN_GEN_VIEW_MENUPANE &&
        aMenuPane)
    {
        // Since this is common resource it contains download,
        // set it off.
        aMenuPane->SetItemDimmed(EPslnCmdAppDownload, ETrue);

        CPslnActiveIdlePluginContainer* container = Container();
        TInt highlightedItem = iContainer->iListBox->CurrentItemIndex();
        // Remove Activate command, if highlighted item is already active.
        if (highlightedItem == container->GetCurrentlySelectedIndex())
        {
            aMenuPane->SetItemDimmed(EPslnCmdAppActivate, ETrue);
        }
    }
    else if (aResourceId == R_PSLN_AI_BASIC_MENUPANE &&
             aMenuPane)
    {
        if (!FeatureManager::FeatureSupported(KFeatureIdHelp))
        {
            // Disable help if not supported
            aMenuPane->SetItemDimmed(EPslnCmdAppHelp, ETrue);
        }
    }
}

// ---------------------------------------------------------------------------
// CPslnActiveIdlePlugin::NewContainerL()
//
// Creates new iContainer.
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePlugin::NewContainerL()
{
    if( !iContainer )
        {
        TBool isGSCalling = (NULL != iAppUi->View(KGSMainViewUid));
        iContainer = new (ELeave) CPslnActiveIdlePluginContainer(isGSCalling, this);
        iContainer->SetMiddleSoftkeyObserver(this);
        }

    RemoveCommandFromMSK();
}

// ---------------------------------------------------------------------------
// CPslnActiveIdlePlugin::HandleListBoxSelectionL()
//
// Handles events raised through a rocker key.
// ---------------------------------------------------------------------------
void CPslnActiveIdlePlugin::HandleListBoxSelectionL()
{
    TInt currentItem = iContainer->iListBox->CurrentItemIndex();
    CPslnFWBaseView::SetCurrentItem(currentItem);

    CPslnActiveIdlePluginContainer* container = Container();

    if (currentItem != container->GetCurrentlySelectedIndex())
    {
        HandleCommandL(EPslnCmdAppActivate);
    }
}

// -----------------------------------------------------------------------------
// Remove MSK command mappings.
// This method should do nothing but MSK issues.
// -----------------------------------------------------------------------------
//
void CPslnActiveIdlePlugin::RemoveCommandFromMSK()
{
    CEikButtonGroupContainer* cba = Cba();

    if (cba && iContainer)
    {
        cba->RemoveCommandFromStack(KPslnMSKControlId, EPslnCmdEmptyCommand);
        cba->RemoveCommandFromStack(KPslnMSKControlId, EPslnCmdAppActivate);
    }
}

// ---------------------------------------------------------------------------
// CPslnActiveIdlePlugin::SetTitlePaneL()
// 
// Gives resource ID to be used as plugin view title.
// ---------------------------------------------------------------------------
//  
void CPslnActiveIdlePlugin::SetTitlePaneL( TInt& aResourceId )
    {
#ifdef RD_CONTROL_PANEL
    aResourceId = R_PSLN_AI_LIST_VIEW_CAPTION;
#endif // RD_CONTROL_PANEL
    }

// End of File.
hs_app_pslnactiveidleplugincontainer.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Container for the Application Shell plugin
*
*/


// INCLUDE FILES

// From this plugin.
#include "hs_app_pslnactiveidleplugincontainer.h"
#include "hs_app_pslnactiveidlepluginengine.h"
#include "hs_app_pslnactiveidleplugin.h"

// From Psln application.
#include 

// From PSLN framework
#include 
#include 

// Resources
#include 
#include 

// General services
#include 

// XUIKON
#include 

// CONSTANTS
// UID of Personlisation application
const TUid KPslnAppUid = { 0x10005A32 };

// ========================= MEMBER FUNCTIONS ================================

CPslnActiveIdlePluginContainer::CPslnActiveIdlePluginContainer(
                    TBool aGSCalling,
                    CPslnActiveIdlePlugin* aPlugin )
    :
    iPlugin( aPlugin ),
    iGSCalling( aGSCalling )
    {
    }
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave.
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginContainer::ConstructL( const TRect& aRect )
    {
    iListBox = new( ELeave ) CAknSingleGraphicStyleListBox;
    TInt titleResId = 0;

    if (iGSCalling)
    {
        titleResId = R_PSLN_GS_LIST_VIEW_TITLE;
    }
    BaseConstructL(aRect, titleResId, R_PSLN_PLUGIN_DEFAULT_VIEW_LBX);
    // Do not show container immediately - to avoid seeing "No Data" first.
    iListBox->MakeVisible( EFalse );
    }

// ---------------------------------------------------------------------------
// Destructor 
// ---------------------------------------------------------------------------
//
CPslnActiveIdlePluginContainer::~CPslnActiveIdlePluginContainer()
    {
    if( iItemArray )
        {
        TInt count = iItemArray->Count();
        iItemArray->Delete(0, count);
        }

    delete iItems;
    }

// -----------------------------------------------------------------------------
// CPslnActiveIdlePluginContainer::GetCurrentlySelectedIndex
// -----------------------------------------------------------------------------
//
TInt CPslnActiveIdlePluginContainer::GetCurrentlySelectedIndex() const
    {
    return iCurrentlySelected;
    }

// ---------------------------------------------------------------------------
// Adds new item to the listbox.
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginContainer::AddNewItemToListL( 
    const TInt aItemIndex, CXnODT* aSkinODT, TInt aUiController )
    {
    HBufC* item = HBufC::NewLC( KPslnItemMaxTextLength );
    TPtr itemPtr = item->Des();
    TBool newActiveItem = EFalse;

    // Get theme ODT and full name. 
    // Index aItemIndex has been verified in view.
    itemPtr = aSkinODT->ThemeFullName();
    if ( aSkinODT->Flags() & EXnThemeStatusActive &&
        iPlugin->Engine()->CurrentUIController() == aUiController )
        {
        itemPtr.Insert( 0, KPslnFWActiveListItemFormat );

        // Set selected active.
        iCurrentlySelected = aItemIndex;
        newActiveItem = ETrue;
        }
    else
        {
        itemPtr.Insert( 0, KPslnFWNonActiveListItemFormat );
        }
    iItemArray->AppendL( itemPtr );
    CleanupStack::PopAndDestroy( item );

    if ( newActiveItem )
        {
        // Set highlight.
        iListBox->SetCurrentItemIndex( iCurrentlySelected );
        // Since we now have content, show container.
        iListBox->MakeVisible( ETrue );
        if ( iPlugin )
            {
            iPlugin->CheckMiddleSoftkeyLabelL();
            }
        }
    }

// ---------------------------------------------------------------------------
// Removes themes from listbox.
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginContainer::RemoveThemes( const TInt aDeleteFrom )
    {
    // Validate parameter first.
    if ( iItemArray &&
         ( aDeleteFrom >= 0 ) &&
         ( aDeleteFrom < iItemArray->Count() ) )
        {
        iItemArray->Delete( aDeleteFrom, iItemArray->Count() - aDeleteFrom );
        }
    }

// ---------------------------------------------------------------------------
// Construct the listbox from resource array.
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginContainer::ConstructListBoxL( TInt aResLbxId )
    {
    iListBox->ConstructL( this, EAknListBoxSelectionList );

    iItemArray = static_cast
        ( iListBox->Model()->ItemTextArray() );

    iItems = iCoeEnv->ReadDesC16ArrayResourceL( aResLbxId );

    // Create pre- and post-text icons.
    AddIconsToListL();
    }

// ---------------------------------------------------------------------------
// Gets Help context.
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginContainer::GetHelpContext( 
    TCoeHelpContext& aContext ) const
    {
    aContext.iMajor = KPslnAppUid;
    aContext.iContext = KSKINS_HLP_APPSKINS_LIST;
    }

// ---------------------------------------------------------------------------
// Adds icons to setting list items.
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginContainer::AddIconsToListL()
    {
    CPslnFWIconHelper* iconHelper = CPslnFWIconHelper::NewL();
    CleanupStack::PushL( iconHelper );
    iconHelper->AddIconsToSettingItemsL(
        ETrue,
        KErrNotFound, // none, selected
        iListBox );
    CleanupStack::PopAndDestroy( iconHelper );
    }

void CPslnActiveIdlePluginContainer::RefreshList()
    {
    TRAP_IGNORE(iListBox->HandleItemAdditionL());
    iListBox->SetCurrentItemIndex(iCurrentlySelected);
    TRAP_IGNORE(iPlugin->CheckMiddleSoftkeyLabelL());
    DrawDeferred();
    // Since we now have content, show container.
    iListBox->MakeVisible( ETrue );
    }

// End of File
hs_app_pslnactiveidlepluginengine.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Container for the Active Idle plugin.
*
*/


// From this plugin.
#include 

#include "hs_app_pslnactiveidlepluginengine.h"
#include "hs_app_pslnactiveidleplugincontainer.h"
#include "hs_app_pslnactiveidleplugin.h"
#include "activeidle2domainpskeys.h"
#include "activeidle2internalpskeys.h"

// from plugin side
#include  // for KExtrStandbyScrFullScreenMode

// From PSLN framework.
#include 
#include 

// General services.
#include 
#include 
#include 

// Application specific skins.
#include 

// XUIKON.
#include 

// ECOM.
#include 
#include 

#include 
#include 

#include 

// Granularity of plugin array.
const TInt KPslnPluginArrayGranularity = 4;

// ActiveIdle1 plugin ECOM interface uid
const TInt KAI1PluginInterfaceUid = 0x101F8700;
const TInt KAIThemeStatusPaneHidden = 0x00000001;

// AI1 cenrep
const TInt KCRUidActiveIdle =  0x10207467;
const TInt KCRPluginCountKey = 0x00000002;
const TInt KCRFirstPluginKey = 0x00000003;

const TInt KPSLNOneSecondInMicroSeconds = 1000*1000;

// ========== LOCAL FUNCTIONS =================================================

template
void CleanupResetAndDestroy(TAny* aObj)
{
    if(aObj)
    {
        static_cast(aObj)->ResetAndDestroy();
    }
}

template
void CleanupResetAndDestroyPushL(Array& aPointerArray)
{
    CleanupStack::PushL(TCleanupItem(&CleanupResetAndDestroy, &aPointerArray));
}

// ========== MEMBER FUNCTIONS ================================================

// ---------------------------------------------------------------------------
// CPslnActiveIdlePluginEngine::ConstructL()
//
// Symbian OS two phased constructor
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::ConstructL(const TRect& /*aRect*/)
{
#ifdef _MY_DEBUG
    RDebug::Print(_L("XAI: CPslnActiveIdlePluginEngine::ConstructL"));
#endif

    // Create application theme handler and list for application themes.
    iMySkinList = new (ELeave)
        CArrayPtrFlat(KPslnPluginArrayGranularity);
    iPslnFWThemeHandler = CPslnFWAppThemeHandler::NewL(
        *this,
        *iMySkinList);

    CheckCurrentUIControllerL();
    CheckCurrentAi1PluginL();
    iRestartTimer = CPeriodic::NewL(EPriorityNormal);
    iUiRefreshTimer = CPeriodic::NewL(EPriorityNormal);
}

// ---------------------------------------------------------------------------
// CPslnActiveIdlePluginEngine::CPslnActiveIdlePluginEngine
//
// Constructor
// ---------------------------------------------------------------------------
//
CPslnActiveIdlePluginEngine::CPslnActiveIdlePluginEngine(
    CPslnActiveIdlePlugin* aPlugin)
  :
    iFirstUpdateRound(ETrue),
    iFirstUpdateRoundInjected(EFalse),
    iCurrentUIController(EAiUICUnknown),
    iPlugin(aPlugin)
{
}

// ---------------------------------------------------------------------------
// CPslnActiveIdlePluginEngine::~CPslnActiveIdlePluginEngine()
//
// Destructor
// ---------------------------------------------------------------------------
//
CPslnActiveIdlePluginEngine::~CPslnActiveIdlePluginEngine()
{
    if (iRestartTimer)
    {
        iRestartTimer->Cancel();
    }
    delete iRestartTimer;
    if (iUiRefreshTimer)
    {
        iUiRefreshTimer->Cancel();
    }
    delete iUiRefreshTimer;

    if (iMySkinList)
    {
        iMySkinList->ResetAndDestroy();
    }
    delete iMySkinList;
    delete iPslnFWThemeHandler;
}

// -----------------------------------------------------------------------------
// CPslnActiveIdlePluginEngine::ActivateThemeL
// -----------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::ActivateThemeL()
{
    TInt skinIndex = 0;
    if( iPlugin->Container() )
        {
        skinIndex = iPlugin->Container()->iListBox->CurrentItemIndex();
        }
    else
        {
        // No selection possible yet
        return;
        }

    if (skinIndex >= 0 && skinIndex < iMySkinList->Count() &&
        !iRestartTimer->IsActive())
    {
        if (skinIndex >= iHSStartIndex &&
            skinIndex < iHSEndIndex)
        {
            CXnODT* selectedSkinODT = iMySkinList->At(skinIndex);
            UpdateStatusPaneVisibilityCenrepL(
                selectedSkinODT->Flags() & KAIThemeStatusPaneHidden);

            if (iCurrentAi1Plugin != selectedSkinODT->ThemeUid())
            {
                UpdateAi1PluginLoadCenrepL(selectedSkinODT->ThemeUid());
                CheckCurrentAi1PluginL();
            }
            if (iCurrentUIController == EAiUICXML)
            {
                UpdateUIControllersInCenrepL(EAiUICNative);
                CheckCurrentUIControllerL();

                iRestartTimer->Cancel();
                iRestartRetryCount = 0;
                iRestartTimer->Start(
                    KPSLNOneSecondInMicroSeconds,
                    KPSLNOneSecondInMicroSeconds,
                    TCallBack(RestartTimerCallback, this));
            }
            else
            {
            if( IsAiRunning() )
                {
                // Recycle this method to bring to foreground
                RestartTimerCallback( this );
                }
            }
            ManualGetSkinsRestartL();
        }
        else
        {
            if (iCurrentUIController == EAiUICNative)
            {
                UpdateStatusPaneVisibilityCenrepL(EFalse); // Always visible status pane
                UpdateUIControllersInCenrepL(EAiUICXML);
                CheckCurrentUIControllerL();
                }

            RProperty::Set( KPSUidAiInformation, KActiveIdleRestartAI2, KActiveIdleRestartCode );
            iRestartTimer->Cancel();
            iRestartRetryCount = 0;
            iRestartTimer->Start(
                KPSLNOneSecondInMicroSeconds,
                KPSLNOneSecondInMicroSeconds,
                TCallBack(RestartTimerCallback, this));
            CXnODT* selectedSkinODT = iMySkinList->At(skinIndex);
            TXnServiceCompletedMessage ret;

            ret = iPslnFWThemeHandler->SetApplicationSkinL(
                *selectedSkinODT );

            if (ret == EXnSetActiveThemeFailed)
            {
                // Show error note.
                HBufC* errorBuf = StringLoader::LoadLC(
                    R_PSLN_QTN_SKINS_ERROR_CORRUPTED);
                // Display global note.
                CAknGlobalNote* errorNote = CAknGlobalNote::NewLC();
                errorNote->ShowNoteL(EAknGlobalErrorNote, *errorBuf);
                CleanupStack::PopAndDestroy(2, errorBuf); // errorNote also
            }
            else
            {
                iRestartTimer->Cancel();
                iRestartRetryCount = 0;
                iRestartTimer->Start(
                    KPSLNOneSecondInMicroSeconds,
                    KPSLNOneSecondInMicroSeconds,
                    TCallBack(RestartTimerCallback, this));
            }
        }
    }
}

// -----------------------------------------------------------------------------
// CPslnActiveIdlePluginEngine::HandleMessage
// -----------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::HandleMessage(
    TXnServiceCompletedMessage aMessage)
{
    switch (aMessage)
    {
    case EXnGetListHeadersEmpty:
        // Just destroy everything and use default items only.
    case EXnGetListHeadersFailed: // fallthrough
        if (iMySkinList)
        {
            iMySkinList->ResetAndDestroy();
        }
        break;
    case EXnServiceRequestCanceled: // fallthrough
    case EXnServiceRequestError: // fallthrough
        {
            TRAP_IGNORE(ManualGetSkinsRestartL();)
        }
        break;
    default:
        break;
    }
}

// -----------------------------------------------------------------------------
// CPslnActiveIdlePluginEngine::HandleMessage
// -----------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::HandleMessage(
    TXnServiceCompletedMessage aMessage,
    CArrayPtrFlat& /*aAppThemeList*/)
{
    switch (aMessage)
    {
    case EXnGetListHeadersRestart:
    case EXnGetListHeadersUpdate: // fallthrough
        {
            TRAP_IGNORE(AddNewThemeL(aMessage));
            break;
        }
    default:
        {
            break;
        }
    }
}

// ---------------------------------------------------------------------------
// Adds new theme to the container / listbox.
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::AddThemesToContainerL()
    {
    TInt value  = 0;

    GetExtStandbyScreenState(value);

    /* value == 0  Only AI2 themes
       value != 0
         bit 31    AI2 themes
         bit 30-0  External themes
    */
    value |= 0x80000000;                               // Force AI2 themes on
    if ((value == 0) || ((value & 0x80000000) != 0))
        {
        if( iPlugin->Container() && iMySkinList )
            {
            // Remove themes. All.
            iPlugin->Container()->RemoveThemes( 0 );
            for ( TInt i = 0; i < iMySkinList->Count(); ++i )
                {
                if( i >= iHSStartIndex &&
                    i < iHSEndIndex )
                    {
                    iPlugin->Container()->AddNewItemToListL( i,
                                                             iMySkinList->At(i),
                                                             EAiUICNative );
                    }
                else
                    {
                    iPlugin->Container()->AddNewItemToListL( i,
                                                             iMySkinList->At(i),
                                                             EAiUICXML );
                    }
                }
            }
        }
    }

// ---------------------------------------------------------------------------
// Adds new theme to the listbox.
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::AddNewThemeL(
    TXnServiceCompletedMessage aMessage)
{
    // No themes available - do not add anything.
    if (!iMySkinList)
    {
        return;
    }

    // Theme activation causes restart of theme headers list.
    if (aMessage == EXnGetListHeadersRestart)
    {
    iFirstUpdateRound = EFalse;
    }

    TInt value  = 0;

    GetExtStandbyScreenState(value);

    /* value == 0  Only AI2 themes
       value != 0
         bit 31    AI2 themes
         bit 30-0  External themes
    */
    value |= 0x80000000;                               // Force AI2 themes on

    if ((value & 0x7FFFFFFF) > 0)
        {
    if ((iFirstUpdateRound && !iFirstUpdateRoundInjected) ||
        aMessage == EXnGetListHeadersRestart)
    {
        iFirstUpdateRoundInjected = ETrue;
        AddHomeScreenThemesL();
    }
        }

    UiTimerRestart();
}

//
// Get external Standby Screen state from Cenrep
//
TInt CPslnActiveIdlePluginEngine::GetExtStandbyScreenState(TInt& aValue )
    {
    TInt ret = 0;
    TUid uid    = { KCRUidActiveIdleLV }; // {0x10275102}; //

    //TRAP_IGNORE: leaving function called in non-leaving function
    TRAP_IGNORE
        (
        CRepository* cenRep = CRepository::NewLC( uid );

        ret = cenRep->Get(KAIExternalStatusScreen, aValue );

        CleanupStack::PopAndDestroy( cenRep );
        )

    return ret;
    }

// ---------------------------------------------------------------------------
// Add EXT HS themes to listing
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::AddHomeScreenThemesL()
{
    iHSStartIndex = iHSEndIndex = iMySkinList->Count();
    // Resolve AI1 plugins in ECOM
    RImplInfoPtrArray eComPlugins;
    CleanupResetAndDestroyPushL(eComPlugins);

    REComSession::ListImplementationsL(TUid::Uid(KAI1PluginInterfaceUid), eComPlugins);
    for (TInt i = 0; i < eComPlugins.Count(); ++i)
    {
        CXnODT* skinODT = CXnODT::NewL();
        skinODT->SetThemeUid(eComPlugins[i]->ImplementationUid().iUid);
        if (eComPlugins[i]->OpaqueData() == KExtrStandbyScrFullScreenMode)
        {
            skinODT->SetFlags(KAIThemeStatusPaneHidden);
        }
        else
        {
            skinODT->SetFlags(0);
        }
        CleanupStack::PushL(skinODT);
        iMySkinList->AppendL(skinODT);
        CleanupStack::Pop(skinODT);

        HBufC* item = HBufC::NewLC(KPslnItemMaxTextLength);
        TPtr itemPtr = item->Des();
        if (eComPlugins[i]->DisplayName().Length())
        {
            itemPtr = eComPlugins[i]->DisplayName();
        }
        else
        {
            itemPtr = _L("OperatorHomeScreen1");
        }
        skinODT->SetThemeFullNameL( itemPtr );
        if (iCurrentAi1Plugin == eComPlugins[i]->ImplementationUid().iUid &&
            iCurrentUIController == EAiUICNative)
        {
            itemPtr.Insert(0, KPslnFWActiveListItemFormat);
            TInt flags = skinODT->Flags();
            skinODT->SetFlags(flags | EXnThemeStatusActive );
        }
        else
        {
            itemPtr.Insert(0, KPslnFWNonActiveListItemFormat);
        }
        CleanupStack::PopAndDestroy(item);
        ++iHSEndIndex;
    }
    CleanupStack::PopAndDestroy();
}

// ---------------------------------------------------------------------------
// Check active AI2 UI Controller in cenrep keys
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::CheckCurrentUIControllerL()
{
    CRepository* cenRep = CRepository::NewL(TUid::Uid(KCRUidActiveIdleLV)); // KCRUidActiveIdleLV AI2 Cenrep!
    TInt value = 0;
    if (cenRep->Get(KAiMainUIController, value) == KErrNone)
    {
        if ((value == AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE)
            || (value == AI3_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE))
        {
            iCurrentUIController = EAiUICNative;
        }
        else if ((value == AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_XML)
            || (value == AI3_UID_ECOM_IMPLEMENTATION_UICONTROLLER_XML))
        {
            iCurrentUIController = EAiUICXML;
        }
    }
    delete cenRep;
}

// ---------------------------------------------------------------------------
// Update active AI2 UI Controller in cenrep keys
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::UpdateUIControllersInCenrepL(TInt aControllerId)
{
    if (iCurrentUIController != aControllerId)
    {
        TUid uid = { KCRUidActiveIdleLV }; // KCRUidActiveIdleLV AI2 Cenrep!
        CRepository* cenRep = CRepository::NewL(uid);
        if (aControllerId == EAiUICNative)
        {
            cenRep->Delete(KAiFirstUIController);
            cenRep->Delete(KAiFirstUIController + 1);
            cenRep->Set(KAiMainUIController, AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE);
        }
        else if (aControllerId ==  EAiUICXML)
        {
            cenRep->Create(KAiFirstUIController, AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE);
            cenRep->Set(KAiFirstUIController, AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE);
            cenRep->Delete(KAiFirstUIController + 1);
            cenRep->Set(KAiMainUIController, AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_XML);
        }
        delete cenRep;
    }
}

// ---------------------------------------------------------------------------
// Update status pane visibility for status pane cenrep key
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::UpdateStatusPaneVisibilityCenrepL(
    TBool aPaneHidden)
{
    TInt value = EAiStatusPaneLayoutIdleNormal;
    if (aPaneHidden)
    {
        value = EAiStatusPaneLayoutIdleHidden;
    }
    TUid uid = { KCRUidActiveIdleLV }; // KCRUidActiveIdleLV AI2 Cenrep!
    CRepository* cenRep = CRepository::NewL(uid);
    cenRep->Set(KAiStatusPaneLayout, value);
    delete cenRep;
}

// ---------------------------------------------------------------------------
// Update active AI1 plugin in cenrep
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::UpdateAi1PluginLoadCenrepL(TInt aNewUid)
{
    TUid uid = { KCRUidActiveIdle }; // KCRUidActiveIdle AI1 Cenrep!
    CRepository* cenRep = CRepository::NewL(uid);
    TInt currentCount = 0;
    cenRep->Get(KCRPluginCountKey, currentCount);

    // Delete old keys if any
    for (TInt i = 0; i < currentCount; ++i)
    {
        cenRep->Delete(KCRFirstPluginKey+i);
    }

    cenRep->Delete(KCRPluginCountKey);
    cenRep->Create(KCRPluginCountKey, 1);
    // Set only 1 new key, the selected one
    cenRep->Create(KCRFirstPluginKey, aNewUid);

    delete cenRep;
}

// ---------------------------------------------------------------------------
// Check the current AI1 plugin (ref. External opretor homescreen feature)
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::CheckCurrentAi1PluginL()
{
    TUid uid = { KCRUidActiveIdle }; // KCRUidActiveIdle AI1 Cenrep!
    TInt value = 0;
    TInt currentCount = 0;

    CRepository* cenRep = CRepository::NewL(uid);
    cenRep->Get(KCRPluginCountKey, currentCount);

    if (currentCount) // count must be set
    {
        cenRep->Get(KCRFirstPluginKey, value);
    }
    delete cenRep;

    if (value != 0)
    {
        iCurrentAi1Plugin = value;
    }
}

// ---------------------------------------------------------------------------
// Manually start updating theme/skin listing
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::ManualGetSkinsRestartL(TBool aForceStart)
{
    if( !aForceStart && iMySkinList->Count() > 0 &&
        iUiRefreshTimer->IsActive() )
        {
        return;
        }
        
    // Restart get skins manually!
    if( iPlugin->Container() )
        {
        iPlugin->Container()->RemoveThemes(0);
        }
    iMySkinList->ResetAndDestroy();
    iFirstUpdateRound = ETrue;
    iFirstUpdateRoundInjected = EFalse;
    iPslnFWThemeHandler->CancelGetApplicationSkins();
    iAddIndex = 0;
    iPslnFWThemeHandler->GetApplicationSkinsL(KUidActiveIdle);
}

// ---------------------------------------------------------------------------
// Restart AI2 process
// ---------------------------------------------------------------------------
//
TInt CPslnActiveIdlePluginEngine::RestartAifw()
{
    if (!IsAiRunning())
    {
        _LIT(KAiExeName, "z:\\sys\\bin\\hs_app_ailaunch.exe");
        RProcess process;
        TInt ret = process.Create(KAiExeName, KNullDesC);
        process.Resume();
        process.Close();
        return ret;
    }
    return KErrNone;
}

// ---------------------------------------------------------------------------
// Checks if AI2 process is running
// ---------------------------------------------------------------------------
//
TBool CPslnActiveIdlePluginEngine::IsAiRunning()
{
    TApaTaskList taskList(CCoeEnv::Static()->WsSession());
    TApaTask startTask = taskList.FindApp(TUid::Uid(0x100058f4));

    if (!startTask.Exists()) // if first boot queries are done continue bringing ai2 to foreground.
    {
        TApaTask aiTask = taskList.FindApp(TUid::Uid(AI_UID3_AIFW_EXE));
        if (aiTask.Exists())  // App open
        {
            return ETrue;
        }
    }
    return EFalse;
}

// ---------------------------------------------------------------------------
// start ui refresh timer
// ---------------------------------------------------------------------------
//
void CPslnActiveIdlePluginEngine::UiTimerRestart()
    {
    iUiRefreshTimer->Cancel();
    iUiRefreshTimer->Start(
        KPSLNOneSecondInMicroSeconds/4, // quarter second delay
        KPSLNOneSecondInMicroSeconds/4,
        TCallBack(UiRefreshTimerCallback, this));
    }
    
// ---------------------------------------------------------------------------
// Call back for restart timer
// ---------------------------------------------------------------------------
//
TInt CPslnActiveIdlePluginEngine::RestartTimerCallback(TAny* aSelf)
{
    CPslnActiveIdlePluginEngine* self =
        static_cast(aSelf);

    if (self)
    {
        ++(self->iRestartRetryCount);
        if ( self->RestartAifw() == KErrNone)
        {
            self->iRestartTimer->Cancel();
            TApaTaskList taskList(CCoeEnv::Static()->WsSession());
            TApaTask startTask = taskList.FindApp(TUid::Uid(0x100058f4));

            if (!startTask.Exists()) // if first boot queries are done continue bringing ai2 to foreground.
            {
                TApaTask aiTask = taskList.FindApp(TUid::Uid(AI_UID3_AIFW_EXE));
                if (aiTask.Exists())  // App open
                {
                    //aiTask.BringToForeground();
                    CAknSgcClient::MoveApp(aiTask.WgId(), ESgcMoveAppToForeground);
                }
            }
            CAknEnv::RunAppShutter();
            return 0;
        }
        if (self->iRestartRetryCount > 3)
        {
            self->iRestartTimer->Cancel();
            TRAP_IGNORE(self->ManualGetSkinsRestartL());
            return 0;
        }
    }
    return 1;
}

// ---------------------------------------------------------------------------
// Call back for UI refresh timer timer
// ---------------------------------------------------------------------------
//
TInt CPslnActiveIdlePluginEngine::UiRefreshTimerCallback(TAny* aSelf)
{
    CPslnActiveIdlePluginEngine* self =
        static_cast(aSelf);

    if (self)
    {
        self->iUiRefreshTimer->Cancel();
        TRAP_IGNORE(self->AddThemesToContainerL());
        if( self->iPlugin->Container() )
            {
            self->iPlugin->Container()->RefreshList();
            }
    }
    return 0;
}

// End of File.
hs_app_pslnactiveidlepluginimplementationtable.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  ECOM proxy table for PslnActiveIdlePlugin.
*
*/

#include 
#include 

#include "hs_app_pslnactiveidleplugin.h"
#include "hs_app_gsactiveidleplugin.h"
#include "hs_app_pslnactiveidlepluginuids.h"

const TImplementationProxy KPslnActiveIdlePluginImplementationTable[] =
{
    IMPLEMENTATION_PROXY_ENTRY(KPslnActiveIdlePluginImplementationUID, CPslnActiveIdlePlugin::NewL)
    ,
    IMPLEMENTATION_PROXY_ENTRY(KGSActiveIdlePluginImplementationUID,   CGSActiveIdlePlugin::NewL)
};

EXPORT_C const TImplementationProxy* ImplementationGroupProxy(TInt& aTableCount)
{
    aTableCount = sizeof(KPslnActiveIdlePluginImplementationTable) / sizeof(TImplementationProxy);
    return KPslnActiveIdlePluginImplementationTable;
}

// End of File.
hs_app_sapidataplugin.rss
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Registry info
 *
*/


// INCLUDES
#include 
#include "hs_app_sapidatapluginuids.hrh"

 

// -----------------------------------------------------------------------------
//   
// registry_info
// Registry information required for identifying the ECOM component
//
// -----------------------------------------------------------------------------
//

RESOURCE REGISTRY_INFO registry_info
{
    resource_format_version = RESOURCE_FORMAT_VERSION_2;

    dll_uid = SAPIDP_UID_ECOM_DLL_CONTENTPUBLISHER_DATAPLUGIN; 

    // Declare array of interface info
    interfaces = 
    {
        INTERFACE_INFO
        {
            // UID of interface that is implemented
            interface_uid = AI_UID_ECOM_INTERFACE_CONTENTPUBLISHER; 

            implementations = 
            {
                IMPLEMENTATION_INFO
                {
                    implementation_uid = SAPIDP_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DATAPLUGIN;
                    version_no         = 1;
                    display_name       = "Data plug-in";
                    default_data       = "";
                    opaque_data        = "";
                }
            };
        }
    };
}


// End of File
bld.inf
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  The build information file of Data Plugin
*
*/


#ifdef RD_CUSTOMIZABLE_AI

#include 

PRJ_PLATFORMS
DEFAULT

PRJ_EXPORTS


../rom/hs_app_sapidataplugin.iby                CORE_MW_LAYER_IBY_EXPORT_PATH(hs_app_sapidataplugin.iby)

PRJ_MMPFILES
sapidataplugin.mmp

//#include "../internal/testpublisher/group/bld.inf"
//#include "../internal/templatedwidget/group/bld.inf"

#endif // RD_CUSTOMIZABLE_AI

// End of File.
sapidataplugin.mmp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project definition file for project sapidataplugin
*
*/

#include 
#include 

#include "../inc/hs_app_sapidatapluginuids.hrh"

TARGET          hs_app_sapidataplugin.dll
TARGETTYPE      PLUGIN
UID             0x10009D8D  SAPIDP_UID_ECOM_DLL_CONTENTPUBLISHER_DATAPLUGIN

CAPABILITY      CAP_ECOM_PLUGIN
VENDORID        VID_DEFAULT


USERINCLUDE     ../inc


APP_LAYER_SYSTEMINCLUDE


SOURCEPATH      ../data
START RESOURCE  hs_app_sapidataplugin.rss
TARGET          hs_app_sapidataplugin.rsc
END


LIBRARY         euser.lib
LIBRARY    	    bafl.lib
LIBRARY         efsrv.lib
LIBRARY    	    liwservicehandler.lib 
LIBRARY         ecom.lib
LIBRARY         hs_app_aiutils.lib
LIBRARY         cone.lib
LIBRARY         avkon.lib
LIBRARY         fbscli.lib
LIBRARY         egul.lib
LIBRARY         aknskins.lib  
LIBRARY         charconv.lib 
// End of File
SOURCEPATH ../src

SOURCE hs_app_sapidataplugin.cpp
SOURCE hs_app_sapidata.cpp 
SOURCE hs_app_sapidataobserver.cpp
hs_app_sapidata.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#ifndef SAPIDATA_H
#define SAPIDATA_H

// INCLUDE FILES
#include  
#include 
#include 
#include "hs_app_sapidatapluginconst.h"
#include "aicontentpublisher.h"

class MLiwInterface;
class CLiwServiceHandler;
class CSapiDataObserver;
class CSapiDataPlugin;


class CContentItem :  public CBase
	{
	public :

	/**
	* Part of the two phased constuction
	*
	* @param none
	* @return none
	*/
	static CContentItem* NewL();

	
	/*
	* Destructor  
	*/
	~CContentItem();

	private :
		
	/* 
	* Constructor  
	*/
		CContentItem();   
	
	/**
	* Part of the two phased construction
	*
	* @param none
	* @return void
	*/
	void ConstructL();

	public :

    TInt iId;
	/* item id */
	HBufC* iName;
	/* type (image/text) */
    HBufC* iType;
    
	HBufC* iContentType;
	};

/**
 *  @ingroup group_sapidataplugin
 *
 *  Sapi data
 *
 *  @since S60 v3.2
 */
class CSapiData : public CBase
   {
   public:
 
    /**
    * Part of the two phased construction
    *
    * @param aPlugin refrence of the plugin
    * @return none
    */
    static CSapiData* NewL(CSapiDataPlugin* aPlugin);
    
    /**
    * Destructor
    *
    * @param none
    * @return none
    */
    ~CSapiData();
    
   private :


    /**
    * Constructor
    *
    * @param none
    * @return none
    */
    CSapiData();
   
    
    /**
    * Part of the two phased construction
    *
    * @param aPlugin reference of the plugin
    * @return void
    */
    void ConstructL(CSapiDataPlugin* aPlugin);
   
    /**
    * Change the publisher status
    *
    * @param aStatus new status of the publisher
    * @return void
    */
    void ChangePublisherStatusL(const TDesC& aStatus);
    
    /**
    * Gets the menu item from the publisher
    *
    * @param none
    * @return void
    */
    void GetMenuItemsL();
    
   public :
    
    /**
    * Configures the subscriber and data to subscribe.
    *  
    * @param aConfigurations  Information about the subscriber 
    *  and the data to subscribe.
    * @return void
    */
    void ConfigureL(RAiSettingsItemArray& aConfigurations);
    
    void SetContentIdL(const TDesC8& aId);
    
    /**
	* Execute the command to get the data from CPS
	*
	* @param aRegistry type of registry (publisher/cp_data) 
	* @param aInFilter input filter for the command
	* @param outParamList output data map 
	* @return void 
	*/
    void ExecuteCommandL(const TDesC& aRegistry ,
    		CLiwDefaultMap* aInFilter, CLiwGenericParamList* outParamList  );
   
    /**
	* Checks Can Update for this publisher 
	* 
	* @param aPublisher  publisher.
    * @param aContentType  content type.
    * @param aContentId content Id.
    * @return bool
	*/
    TBool CanUpdate( TDesC& aPublisher, TDesC& aContentType, TDesC& aContentId );
    
    /**
   	* Removes all the data from the widget which matches to 
   	* this publisher, contentype, contentid values
   	*
    * @param aObserver to publish data
    * @param aContentType content type 
    * @return void
   	*/
    void RemoveL( MAiContentObserver* aObserver,  TDesC& aContentType );
   
    /**
	* Checks is this menu item is supported by the publisher
	* 
	* @param aMenuItem  menu item name.
	* @return  boolean (ETrue/EFalse) 
	*/
    TBool HasMenuItem(const TDesC& aMenuItem );
    
    /**
    * Publish the data to widget.
    *   
    * @param aObserver to publish data
    * @param aContentType content type
    * @return void
    */
    void PublishL( MAiContentObserver* aObserver, const TDesC& aContentType );
    
    /**
    * Publish the updated data to widget.
    *   
    * @param aObserver to publish data
    * @param aDataMap data map with updated data
    * @return void
    */
    void PublishDataL(MAiContentObserver* aObserver, CLiwDefaultMap* aDataMap );
    
    /**
    * Tigger for execution of a action for a specific content id.
    * 
    * @param aObjectId object Id.
    * @param aTrigger name of the trigger.
    * @return void
    */
    void ExecuteActionL(const TDesC& aObjectId, const TDesC& aTrigger);
     
    /**
    * Register to publisher registry for all (update) action
    * 
    * @param none
    * @return void
    */
    void RegisterPublisherObserverL();
    
    /**
    * Register to content registry for all (add/delete/update) action
    * 
    * @param none
    * @return void
    */
    void RegisterContentObserverL();
     
    /**
    * Called by the observer to refresh the changed content
    *   
    * @param aPublisher  publisher.
    * @param aContentType  content type.
    * @param aContentId content Id.
    * @param aOperation operation (add/delete/update/execute).
    * @return void
    */
    void RefreshL( TDesC& aPublisher, TDesC& aContentType, 
            TDesC& aContentId, TDesC& aOperation );
     
    /**
    * Createts the filter map and push it in the stack
    * 
    * @return filter map
    */
    CLiwDefaultMap* CreateFilterLC();
    
    /**
    * Createts the filter map and push it in the stack
    * 
    * @param aConType content type
    * @return filter map
    */
    CLiwDefaultMap* CreateFilterLC(const TDesC& aConType);
    
    /**
    * Createts the filter map and push it in the stack
    * 
    * @param aConType content type
    * @param aContentId cotent Id
    * @return filter map
    */
    CLiwDefaultMap* CreateFilterLC(const TDesC& aContentType,
    		const TDesC& aContentId);
    		
    /**
    * Is the pugin is active to publish the data.
    * 
    * @param None
    * @return boolean (ETrue/EFalse).
    */
    TBool IsPluginActive();
     
    /**
    * Resume the publisher
    * 
    * @param None
    * @return void
    */
    void ResumeL();
    
    /**
	* Suspend the publisher
	* 
	* @param None
	* @return void
	*/
    void SuspendL();
    
    /**
	* Activate the publisher
	* 
	* @param None
	* @return void
	*/
    void ActivateL();
    
    /**
	* Deactivate the publisher
	* 
	* @param None
	* @return void
	*/
    void DeActivateL();
    
    /**
	* OnLineL 
	* 
	* @param None
	* @return void
	*/
    void OnLineL();
    
    /**
	* OffLineL 
	* 
	* @param None
	* @return void
	*/
    void OffLineL();
    
    /**
	* InActiveL 
	* 
	* @param None
	* @return void
	*/
	void InActiveL();
	
    /**
	* Update the publisher status 
	* 
	* @param aPublisher publisher name
	* @return void
	*/
    void UpdatePublisherStatusL(TDesC& aPublisher);
    
    /**
    * Resolves skin item id and Mif id from pattern 
    * skin(   () 
    * mif(  )
    * 
    * @param aPath  skin pattern / mif pattern value
    * @param aItemId skin item id  
    * @param aMifId  mif id 
    * @param aMaskId  mask id 
    * @param aFilename mif file name
    * @return boolean (ETrue/EFalse)  
    */
    TBool ResolveSkinIdAndMifId( const TDesC& aPath, TAknsItemID& aItemId,
    		TInt& aMifId, TInt& aMaskId, TDes& aFilename );

    /**
	* Sets the on resume update needed status  
	* 
	* @param aStatus update needed status (ETrue/EFalse)
	* @return void  
	*/
    void SetUpdateNeeded(TBool aStatus);
    
    private :   
    
    // Subscriber interface
    // own
    MLiwInterface* iInterface;
      
    // Data Observer to CPS content registry
    // Own // iConObserver;
    CSapiDataObserver* iContentObserver;
    
    // Data Observer to CPS publisher registry
    // Own // iConObserver;
    CSapiDataObserver* iPubObserver;
   
    // Service handler 
    // Own
    CLiwServiceHandler* iServiceHandler;
    
    // Array of configurations
    // Own
    RPointerArray iItemList;

    // Number of configurations 
    TInt iItemCount;
    
    // Command name in configuration Array
    HBufC8* iCommandName;
	/* publisher id */
	HBufC* iPublisher;
	/* content type */
	HBufC* iContentType;
	/* content id */
	HBufC* iContentId;

    // Reference of the sapi data plugin
    // Not owned
    CSapiDataPlugin* iPlugin;
    
    // Menu item names
    // Own
    RPointerArray iMenuItems; 
    
    // Trigger names for the menu items
    // Own
    RPointerArray iMenuTriggers;
    
    // Store the status of update needed on resume
    TBool iUpdateNeeded;
    };

#endif /*SAPIDATA_H*/
hs_app_sapidataobserver.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#ifndef SAPIDATAOBSERVER_H
#define SAPIDATAOBSERVER_H

// INCLUDE FILES
#include 

class CSapiData;

class CSapiDataObserver : public CBase, public MLiwNotifyCallback
    {
public:

    /**
    * Part of the two phased constuction
    *
    * @param aInterface reference of the interface 
    * @param aData reference of the sapi data object
    * @return none
    */
    static CSapiDataObserver* NewL( MLiwInterface* aInterface, CSapiData* aData );
    
    /**
    * Destructor
    *
    * @param none
    * @return none
    */   
    ~CSapiDataObserver();

private :
    
    /**
    * Constructor
    *
    * @param none
    * @return none
    */
    CSapiDataObserver();
    
    /**
    * Part of the two phased construction
    *
    * @param aInterface reference of the interface
    * @param aData reference of the sapi data object
    * @return void
    */
    void ConstructL( MLiwInterface* aInterface, CSapiData* aData );
       
public:  //from MLiwNotifyCallbackc
    
    /**
    * Handles notifications caused by an asynchronous Execute*CmdL call
    * or an event.
    *
    * @param aCmdId The service command associated to the event.
    * @param aEventId occurred event, see LiwCommon.hrh.
    * @param aEventParamList Event parameters, if any, as defined per
    *        each event.
    * @param aInParamList Input parameters, if any, given in the
    *        related HandleCommmandL.
    * @return Error code for the call back.
    */
    virtual TInt HandleNotifyL(
        TInt aCmdId,
        TInt /*aEventId*/,
        CLiwGenericParamList& aEventParamList,
        const CLiwGenericParamList& /*aInParamList*/);

public:
    
    /**
    * Registers to CPS for add, delete , update and execute notifications
    * @aFilter - filter for input parameter list
    * @return void.
    */
    void RegisterL( CLiwDefaultMap* aFilter, const TDesC& aRegistry );

    /**
    * Cancel all the registered notifications. 
    * @return void.
    */
    void ReleaseL();
        
private:
        
    // Reference of 
    // Not owned
    MLiwInterface* iInterface;
    
    // Reference of the sapi data
    // Not owned
    CSapiData* iData;
    
    // Call back error code
    TInt iError;
        
    };

#endif /*SAPIDATAOBSERVER_H*/
hs_app_sapidataplugin.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#ifndef SAPIDATAPLUGIN_H
#define SAPIDATAPLUGIN_H

#include 
#include 
#include 
#include 

class MAiContentObserver;
class MAiContentItemIterator;
class MAiPSPropertyObserver;
class CSapiData;
class CDesC16Array;
class CGulIcon;

/**
 *  @ingroup group_sapidataplugin
 *
 *  Plug-in main class
 *
 *  @since S60 v3.2
 */
class CSapiDataPlugin : public CAiContentPublisher,
                     	public MAiPropertyExtension,
                     	public MAiEventHandlerExtension
                    
    {
    
public :
	 /**
	 * Plugin's network state.
	 */
	enum TPluginNetworkStatus 
		{
		EUnknown, 
		EOffline,
		EOnline
		};
	
	/**
	 * Plugin's state.
	 */
	enum TPluginStates
		{
		ENone,
		EResume,
		ESuspend,
		EInActive,
		};
public:

    /**
    * Part of the two phased constuction
    *
    * @param none
    * @return none
    */
    static CSapiDataPlugin* NewL();
    
    /**
    * Destructor
    *
    * @param none
    * @return none
    */
    ~CSapiDataPlugin();

private:
    
    /**
    * Constructor
    *
    * @param none
    * @return none
    */
    CSapiDataPlugin();
	
    /**
    * Part of the two phased construction
    *
    * @param void
    * @return void
    */
    void ConstructL();

    /**
    * Resume the plug-in.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */    
    void DoResumeL(TAiTransitionReason aReason);
    
public: // from base class CAiContentPublisher
    
    /**
    * From CAiContentPublisher
    * The method is called by the framework to request the plug-in free all
    * memory and CPU resources and close all its open files, e.g. the plug-in 
    * should unload its engines due backup operation. The method transits the 
    * plug-in to "Idle" state.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */
    void Stop( TAiTransitionReason aReason );

    /**
    * From CAiContentPublisher
    * The method is called by the framework to instruct plug-in that it is
    * allowed to consume CPU resources, e.g plug-in is able to run timers,
    * perform asynchronous operations, etc. The method transits the plug-in
    * to "Alive" state.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */
    void Resume( TAiTransitionReason aReason );

    /**
    * From CAiContentPublisher
    * The method is called by the framework to instruct plug-in that it is
    * not allowed to consume CPU resources, e.g plug-in MUST stop each
    * timers, cancel outstanding asynchronous operations, etc. The method
    * transits the plug-in to "Suspendend" state.
    *
    * @param aReason reason for state change, see TAiTransitionChange.
    * @return void
    */
    void Suspend( TAiTransitionReason aReason );

    /**
    * From CAiContentPublisher
    * Adds the content observer / subscriber to plug-in. The plug-in MUST
    * maintain a registry of subscribers and send notification to all them
    * whenever the plug-in changes state or new content available.
    *
    * @param aObserver content observer to register.
    * @return void
    */
    void SubscribeL( MAiContentObserver& aObserver );
    
    /**
    * From CAiContentPublisher
    * Configures the plug-in.
    * Plug-ins take ownership of the settings array, so it must either
    * store it in a member or free it. Framework has put the array in cleanup
    * stack so the plugin shouldn't do that.
    * If this leaves, the plug-in will be destroyed by AI FW.
    * Plug-in must support LaunchByValue-event even if normal shortcuts don't
    * work. The only allowed serious enough leave is KErrNotFound from CenRep.
    *
    * @param aSettings setting items defined in the UI definition.
    * @return void
    */
    void ConfigureL( RAiSettingsItemArray& aSettings );
    
    /**
    * From CAiContentPublisher
    * Returns interface extension. In Series 60 3.1 only event & property
    * extensions are supported. See MAiEventExtension & MAiPropertyExtension
    * interfaces.
    *
    * @param  aUid - UID of the extension interface to access.
    * @return the extension interface. Actual type depends on the passed aUid 
    *         argument.
    */
    TAny* Extension( TUid aUid );  

// from base class MAiPropertyExtension

    /**
    * From MAiPropertyExtension.
    * Read property of publisher plug-in.
    *
    * @param aProperty - identification of property.
    * @return pointer to property value.
    */
    TAny* GetPropertyL( TInt aProperty );

    /**
    * From MAiPropertyExtension.
    * Write property value.
    *
    * @param aProperty - identification of property.
    * @param aValue - contains pointer to property value.
    */
    void SetPropertyL( TInt aProperty, TAny* aValue );
  
 // from base class MAiEventHandlerExtension
   
     /**
     * From MAiEventHandlerExtension
     * Invoked by the framework when plug-in must handle an event.
     * @param aEvent - unique identifier of event from plug-in content model.
     * @param aParam - parameters associated with event. Each UI Definition
     *        declares events in the format: (),
     *        where  is mapped by the framework to unique
     *        identifier supplied in aEvent,  are provided to
     *        plug-in as-is in the descriptor.
     * @since S60 3.2
     */
     void HandleEvent(TInt aEvent, const TDesC& aParam);
    
     /**
     * From MAiEventHandlerExtension
     * Invoked by the framework when plug-in must handle an event.
     *
     * @param aEventName - name of the event from plug-in content model.
     * @param aParam - parameters associated with event. Each UI Definition
     *        declares events in the format: (),
     *        where   mapping to unique identifier supplied by event 
     *        is failed by the frame work then the   and  
     *          are provided to plug-in as-is in the descriptor.
     */
     void HandleEvent(const TDesC& aEventName, const TDesC& aParam);

    /**
 	* Invoked by the framework for querying if plugin has menu item
 	*
 	* @param aMenuItem  menu item name.
 	* @return ETrue if plugin has specific menu item, EFalse otherwise 
	*/
    TBool HasMenuItem(const TDesC16& aMenuItem);
     
public : // new functions
	
    /**
    * Publishes widget's texts and images
    *
    * @param void
    * @return void
    */
    void PublishL();	
	
	/**
	* Gets the id of a content  
	*
	* @param aObjectId image or text id
	* @return id of the content
	*/
	TInt GetIdL(TDesC& aObjectId);
	
    /**
    * Gets the type of a specific content
    *
    * @param aObjectId image or text id
    * @return void
    */
	const TDesC& GetTypeL( TDesC& aObjectId );
	
    /**
    * RefereshL a specific image of text in the widget
    *
    * @param aContentType content type
    * @param aOperation operation performed
    * @return void
    */
    void RefreshL(TDesC& aContentType, TDesC& aOperation);
    
    /**
    * Is plugin active to publish the data 
    *
    * @param void 
    * @return boolean (ETrue/EFalse)
    */
    TBool IsActive();
    
    /**
	* Publish a specific text of the widget  
	*
	* @param aObserver observer
	* @param aContentId content model id
	* @param aContentValue content value
	* @return void
	*/
	void PublishTextL(MAiContentObserver* aObserver, 
			TInt& aContentId, TDesC& aContentValue);

	/**
    * Publish a specific image of the widget  
    *
    * @param aObserver observer
    * @param aContentId content model id
    * @param aHandle image handle 
    * @param aMaskHandle handle of the mask image
    * @return void
    */
    void PublishImageL(MAiContentObserver* aObserver, 
            TInt& aContentId, TInt aHandle, TInt aMaskHandle);

    /**
    * Publish a specific image of the widget  
    *
    * @param aObserver observer
    * @param aContentId content model id
    * @param aPath image path / skin id pattern / mif id Pattern 
    * @return void
    */
    void PublishImageL(MAiContentObserver* aObserver,
            TInt aContentId, TDesC& aPath );
    
    /**
    * Cleans a data from the widget
    *
    * @param aObserver observer
    * @param aContentId content model id
    * @return void
    */
    void Clean(MAiContentObserver* aObserver, 
            TInt& aContentId );
    
    /**
     * CSapiData getter
     * @return Pointer to CSapiData
     */
    inline CSapiData* Data() const
        {
        return iData;
        }

	/*
	 * Plugin's network status getter
	 * @return Pointer to Harvester status observer
	 */
	inline TPluginNetworkStatus NetworkStatus() const
		{
		return iNetworkStatus;
		}
	
private: // data

    // Iterator for plugin content
    // Own
    MAiContentItemIterator* iContent;

    // Array of content observers
    // Own
    RPointerArray iObservers;
    
    // Information about the content publisher (this plug-in)
    TAiPublisherInfo iInfo;
	
	// Number of data in the content model.
	TInt iDataCount;
	 
	// Dynamic content model
	// Own
	TAiContentItem* iContentModel;
	
	// Reference array for Published text
	// Own
	RPointerArray iDataArray;
	
	// Service API Data Subscriber.
	// Own
	CSapiData* iData;
    
    // References array for published images 
    // Own
    RArray iIconArray;
    
    // File Server
    // Reference
    RFs iRfs;
    
    // Plugin's network status
    TPluginNetworkStatus iNetworkStatus;
    
    // Is Homescreen foreground.
    TBool iHSForeGround;
    
    // Is KeyLockON.
    TBool iKeyLockOn;

	// Plugin state    
    TPluginStates iPluginState;
    };

#endif // SAPIDATAPLUGIN_H


hs_app_sapidatapluginconst.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Content model for data plug-in.
*
*/


#ifndef SAPIDATAPLUGINCONST_H
#define SAPIDATAPLUGINCONST_H

#include 
#include "hs_app_sapidatapluginuids.hrh"

// AI Data Plug-in ECOM implementation UID.
const TInt KImplUidDataPlugin = SAPIDP_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DATAPLUGIN;
const TUid KUidDataPlugin = { KImplUidDataPlugin };

// ================================= CONTENT ===================================

/**
 * Content Model type identifier
 */
_LIT(KText ,"text");
_LIT(KImage, "image");
_LIT(KPlugin, "plugin");

_LIT(KNewsTicker ,"newsticker");


// CPS Constants
_LIT(KService,         "service");
_LIT(KInterface,       "interface");
_LIT(KCommand,         "command");
_LIT8( KType,          "type");
_LIT( KCpData,         "cp_data");
_LIT( KPubData,        "publisher" );
_LIT( KCpData_PubData, "cp_data:publisher");

_LIT8( KFilter,        "filter" );
_LIT8( KDataMap,       "data_map");
_LIT8( KActionTrigger, "action_trigger" );
_LIT8( KGetList ,      "GetList" );
_LIT8( KExecuteAction, "ExecuteAction" );
_LIT8( KRequestNotification, "RequestNotification" );
_LIT8( KChangeInfo, "change_info" );
_LIT8( KListMap, "list_map" );
_LIT8( KPublisherId, "publisher" );
_LIT ( KPublisher16,  "publisher" );
_LIT8( KContentType,   "content_type" );
_LIT ( KContentType16, "content_type" );
_LIT8( KContentId,   "content_id" );
_LIT8( KResults,      "results");

_LIT( KDataKey,      "data_key");
_LIT8( KMenuItems,     "menuitems");
_LIT( KMenuItem16,     "menuitem");
_LIT( KAll, "all");
_LIT8( KOperation, "operation" );
_LIT8( KFLAG,      "flag");

_LIT( KOperationAdd, "add" );
_LIT( KOperationUpdate, "update" );
_LIT( KOperationDelete, "delete" );
_LIT( KOperationExecute, "execute" );
_LIT( KAddUpdateDelete, "add:update:delete" );
_LIT( KUpdate, "update" );

_LIT(KWidget, "hswidget");
_LIT( KDeActive, "deactive");
_LIT( KActive, "active");
_LIT( KSuspend , "suspend");
_LIT( KResume, "resume");
_LIT( KOnLine, "online");
_LIT( KOffLine, "offline");
_LIT( KInActive, "inactive");
// reserved extension for retrieving mask handle 
_LIT8( KMask, "_mask");

_LIT( KSkin, 		 "skin" );
_LIT( KMif, 		 "mif" );
_LIT( KMIFExtension, ".mif" );
_LIT( KColon,		 ":");

const TUint KLeftParenthesis = '(';


// Sapi Data Plugin Constants
const TUint KPluginNameSeprator =  '/';

/**
 * Maximum length for the content name
 */
const TInt KMaxTypeLength = 8;

/**
 * Maximum length for the content name
 */
const TInt KSAPIContentNameMaxLength = 255;

/**
 * Maximum length for the content value
 */
const TInt KSAPIContentValueMaxLength = 255;

/**
 * Maximum length for the plugin name
 */
const TInt KAiPluginNameMaxLength = 255;


#endif /* SAPIDATAPLUGINCONST_H */
hs_app_sapidatapluginuids.hrh
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  UIDs for the Active Idle subsystem components.
*
*/


#ifndef SAPIDATAPLUGINUIDS_HRH
#define SAPIDATAPLUGINUIDS_HRH

#include 

/**
 * Ecom dll uid for AI Data plug-in.
 */
#define SAPIDP_UID_ECOM_DLL_CONTENTPUBLISHER_DATAPLUGIN 0x20019593

/**
 * Ecom implementation uid for AI Data plug-in.
 */     
#define SAPIDP_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DATAPLUGIN 0x20019594

#endif //SAPIDATAPLUGINUIDS_HRH
hs_app_sapidataplugin.iby
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  IBY file for Data plug-in
*
*/


#ifndef SAPIDATAPLUGIN_IBY
#define SAPIDATAPLUGIN_IBY
#include 

#ifdef RD_CUSTOMIZABLE_AI

ECOM_PLUGIN(hs_app_sapidataplugin.dll, hs_app_sapidataplugin.rsc)

#endif // RD_CUSTOMIZABLE_AI

#endif // SAPIDATAPLUGIN_IBY

hs_app_sapidata.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Homescreen Data plug-in publisher
*
*/

#include 
#include 
#include 
#include 

#include "hs_app_sapidata.h"
#include "hs_app_sapidatapluginconst.h"
#include "hs_app_sapidataobserver.h"
#include "hs_app_sapidataplugin.h"
// ======== MEMBER FUNCTIONS ========
	
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
CContentItem* CContentItem::NewL()
    {
    CContentItem* self = new (ELeave) CContentItem();
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }
    
// ---------------------------------------------------------------------------
// Default constructor
// ---------------------------------------------------------------------------
//
CContentItem::CContentItem()
    {
    }
    
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
void CContentItem::ConstructL()
    { 
    iId = KErrNotFound;
    iName = NULL;
	iContentType = NULL;
	iType = NULL;
    }

// ---------------------------------------------------------------------------
// Destructor
// Deletes all data created to heap
// ---------------------------------------------------------------------------
//
CContentItem::~CContentItem()
	{
	delete iName;
	delete iContentType;
	delete iType;
	}
	
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
CSapiData* CSapiData::NewL(CSapiDataPlugin* aPlugin)
    {
    CSapiData* self = new (ELeave) CSapiData();
    CleanupStack::PushL( self );
    self->ConstructL(aPlugin);
    CleanupStack::Pop( self );
    return self;
    }
    
// ---------------------------------------------------------------------------
// Default constructor
// ---------------------------------------------------------------------------
//
CSapiData::CSapiData()
    {
    }
    
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
void CSapiData::ConstructL(CSapiDataPlugin* aPlugin)
    { 
     iPlugin = aPlugin;
     iCommandName = NULL;
	 iContentId = NULL;
	 iContentType = NULL;
	 iUpdateNeeded = EFalse;
    }
    
// ---------------------------------------------------------------------------
// Destructor
// Deletes all data created to heap
// ---------------------------------------------------------------------------
//
CSapiData::~CSapiData()
    {
    delete iCommandName;
	delete iPublisher;
	delete iContentType;
	delete iContentId;

	
	if(iPubObserver)
		{
		TRAP_IGNORE(iPubObserver->ReleaseL() );
		delete iPubObserver;
		iPubObserver = NULL;
		}
    if(iContentObserver)
        {
        TRAP_IGNORE(iContentObserver->ReleaseL() );
        delete iContentObserver;
        iContentObserver = NULL;
        }
    if( iInterface )
         {
         iInterface->Close();
         iInterface = NULL;
         }
    if( iServiceHandler )
         {
         iServiceHandler->Reset();
         delete iServiceHandler;
         iServiceHandler = NULL;
         }
    iMenuItems.ResetAndDestroy();
    iMenuTriggers.ResetAndDestroy();
    iItemList.ResetAndDestroy();
    // not owned
    iPlugin = NULL;
    }

// ---------------------------------------------------------------------------
// ConfigureL
// ---------------------------------------------------------------------------
//
void CSapiData::ConfigureL(RAiSettingsItemArray& aConfigurations )
    {
    HBufC8* serviceName = NULL;
    HBufC8* interfaceName = NULL;

    TInt count = aConfigurations.Count();
    
    for(TInt i = 0;iAiPluginConfigurationItem();
       // if owner is plugin then it (key,value) is for plugin configurations items
       if(confItem.Owner() == KPlugin())
           {
           if(confItem.Name() ==  KService())
               {
               serviceName = CnvUtfConverter::ConvertFromUnicodeToUtf8L(confItem.Value());
               }
           else if( confItem.Name() == KInterface() )
                 {
                 interfaceName = CnvUtfConverter::ConvertFromUnicodeToUtf8L(confItem.Value());
                 }
           else if( confItem.Name() == KCommand() )
                 {
                 iCommandName  = CnvUtfConverter::ConvertFromUnicodeToUtf8L(confItem.Value());
                 }
           else if( confItem.Name()  == KPublisher16() ) 
				  {
				  iPublisher = confItem.Value().AllocL();
				  }
           }
       else if ( confItem.Name() == KContentType16() )
           { 
           HBufC* objectId = confItem.Owner().AllocLC();
           objectId->Des().Delete(0, objectId->LocateReverse(KPluginNameSeprator) + 1);
           
           CContentItem *conItem = CContentItem::NewL();
           conItem->iName = objectId->AllocL();
           conItem->iContentType =  confItem.Value().AllocL();
           conItem->iType = iPlugin->GetTypeL( *objectId ).AllocL();
           conItem->iId = iPlugin->GetIdL(*objectId  );
           iItemList.AppendL( conItem );
           
           CleanupStack::PopAndDestroy(objectId);
           }
       }
    
    iItemCount = iItemList.Count();  
    
    if( !serviceName || !interfaceName || !iCommandName  
    		|| !iContentId || !iPublisher || !iItemCount )
        {
        // No service to offer without plugin configurations 
        User::Leave( KErrNotSupported );
        }
    iServiceHandler = CLiwServiceHandler::NewL(); 

    // for convenience keep pointers to Service Handler param lists 
    CLiwGenericParamList* inParamList  = &iServiceHandler->InParamListL();
    CLiwGenericParamList* outParamList = &iServiceHandler->OutParamListL();

    CLiwCriteriaItem* criteriaItem = CLiwCriteriaItem::NewLC( KLiwCmdAsStr, *interfaceName , *serviceName );
    criteriaItem->SetServiceClass( TUid::Uid( KLiwClassBase ) );
    // Interface name 
    RCriteriaArray criteriaArray;
    criteriaArray.AppendL( criteriaItem );
    // attach Liw criteria
    iServiceHandler->AttachL( criteriaArray );
    iServiceHandler->ExecuteServiceCmdL( *criteriaItem, *inParamList, *outParamList );

    CleanupStack::PopAndDestroy(criteriaItem);
    criteriaArray.Reset();

    // extract CPS interface from output params
    TInt pos( 0 );
    outParamList->FindFirst( pos, *interfaceName );
    if( pos != KErrNotFound )
        {
        //iInterface is MLiwInterface*
        iInterface = (*outParamList)[pos].Value().AsInterface(); 
        User::LeaveIfNull( iInterface );
        }
    else
        {
        User::Leave( KErrNotFound );
        }
    inParamList->Reset();
    outParamList->Reset();
    delete interfaceName;
    delete serviceName;

	//Gets the menu items from the publisher registry    
    GetMenuItemsL();
 
    iContentObserver = CSapiDataObserver::NewL( iInterface, this );   
    iPubObserver = CSapiDataObserver::NewL( iInterface, this );
    }

void CSapiData::SetContentIdL(const TDesC8& aId)
	{
	iContentId = CnvUtfConverter::ConvertToUnicodeFromUtf8L(aId);
	}
// ---------------------------------------------------------------------------
// GetMenuItemsL
// ---------------------------------------------------------------------------
//
void CSapiData::GetMenuItemsL()
	{
	if(iInterface && iItemCount > 0)
		{
		CLiwGenericParamList* outParamList = &iServiceHandler->OutParamListL();
		CLiwDefaultMap* filter = CLiwDefaultMap::NewLC();
		filter->InsertL( KPublisherId, TLiwVariant(iPublisher ));
		//append filter to input param
        ExecuteCommandL( KPubData, filter, outParamList );
        CleanupStack::PopAndDestroy( filter );
    	//extracts data map
    	TInt pos = 0;
    	outParamList->FindFirst( pos, KResults );
    	if( pos != KErrNotFound )
    		// results present
    		{
    		//extract iterator on results list
    		TLiwVariant variant = (*outParamList)[pos].Value();
    		variant.PushL();
    		CLiwIterable* iterable = variant.AsIterable();
    		iterable->Reset();
    		
    	    CLiwDefaultMap *map = CLiwDefaultMap::NewLC();
    		//considering publisher is unique reading only first entry
    		if( iterable->NextL( variant ) )
    			{
    			//extract content map
    			variant.Get( *map );
    			if( map->FindL( KDataMap, variant) )
    				{
    				 variant.Get( *map );
    				}
    			}
    		iterable->Reset();
    		variant.Reset();
    		if (  map->FindL( KMenuItems, variant ) )
				{
				CLiwDefaultMap *menuMap = CLiwDefaultMap::NewLC();
				variant.Get( *menuMap );
				for ( TInt i = 0; i < menuMap->Count(); i++)
					{
					menuMap->FindL(menuMap->AtL(i), variant );
					HBufC8* menuItem = variant.AsData().AllocLC();
					if ( menuItem->Length()> 0 )
						{
						iMenuTriggers.AppendL( menuItem );
						CleanupStack::Pop( menuItem );
						HBufC* triggerName = CnvUtfConverter::ConvertToUnicodeFromUtf8L(menuMap->AtL(i));
						CleanupStack::PushL( triggerName );
						iMenuItems.AppendL( triggerName );
						CleanupStack::Pop( triggerName );
						}
					else
						{
						CleanupStack::PopAndDestroy( menuItem );	
						}
					variant.Reset();
					}
				CleanupStack::PopAndDestroy( menuMap );
				}
    		CleanupStack::PopAndDestroy( map );
    		CleanupStack::PopAndDestroy( &variant );
    		}
    	outParamList->Reset();
		}
	}

// ---------------------------------------------------------------------------
// CreateFilterL
// ---------------------------------------------------------------------------
//
CLiwDefaultMap* CSapiData::CreateFilterLC(const TDesC& aContentType,
		const TDesC& aContentId)
    {
    CLiwDefaultMap* filter = CLiwDefaultMap::NewLC();
    filter->InsertL( KPublisherId, TLiwVariant(iPublisher ));
    filter->InsertL( KContentId, TLiwVariant(aContentId ));
    filter->InsertL( KContentType, TLiwVariant(aContentType ));
    return filter;
    }

// ---------------------------------------------------------------------------
// CreateFilterL
// ---------------------------------------------------------------------------
//
CLiwDefaultMap* CSapiData::CreateFilterLC(const TDesC& aContentType)
    {
    CLiwDefaultMap* filter = CLiwDefaultMap::NewLC();
    filter->InsertL( KPublisherId, TLiwVariant(iPublisher ));
    filter->InsertL( KContentId, TLiwVariant(iContentId ));
    filter->InsertL( KContentType, TLiwVariant(aContentType ));
    return filter;
    }

// ---------------------------------------------------------------------------
// CreateFilterL
// ---------------------------------------------------------------------------
//
CLiwDefaultMap* CSapiData::CreateFilterLC()
    {
    CLiwDefaultMap* filter = CLiwDefaultMap::NewLC();
    filter->InsertL( KPublisherId, TLiwVariant(iPublisher ));
    filter->InsertL( KContentId, TLiwVariant(iContentId ));
    filter->InsertL( KContentType, TLiwVariant(KAll));
    return filter;
    }


// ---------------------------------------------------------------------------
// Update
// ---------------------------------------------------------------------------
//
TBool CSapiData::CanUpdate( TDesC& aPublisher, TDesC& aContentType,
    		TDesC& aContentId)
	{
    TBool res = EFalse;
    if( aPublisher == *iPublisher  
	   && aContentId == *iContentId  )
	   {
	   if ( aContentType != KAll )
		   {
		   for (TInt i = 0; i < iItemCount ; i++)
			   {
			   if ( aContentType == iItemList[i]->iContentType )
				   {
				   res = ETrue;
				   break;
				   }
			   }
		   }
	   else
		   {
		   res = ETrue;
		   }
	   }
    else
	   {
	   res = EFalse;
	   }
    return res;
	}

// ---------------------------------------------------------------------------
// RemoveL
// ---------------------------------------------------------------------------
//
void CSapiData::RemoveL( MAiContentObserver* aObserver, TDesC& aContentType  )
	{
	for(TInt index = 0; index < iItemCount; index++)
		{
		if ( aContentType == iItemList[index]->iContentType )
			{
			iPlugin->Clean( aObserver, iItemList[index]->iId );
			}
		}
	}


// ---------------------------------------------------------------------------
// HasMenuItem
// ---------------------------------------------------------------------------
//
TBool CSapiData::HasMenuItem(const TDesC& aMenuItem )
	{
	TBool found = EFalse;
	for (TInt i = 0; i < iMenuItems.Count(); i++ )
		{
		if( aMenuItem == iMenuItems[i] )
			{
			found =  ETrue;
			break;
			}
		}
	return found;
	}

// ---------------------------------------------------------------------------
// PublishL
// ---------------------------------------------------------------------------
//
void CSapiData::PublishL( MAiContentObserver* aObserver, const TDesC& aContentType ) 
    {
	CLiwGenericParamList* outParamList = &iServiceHandler->OutParamListL();
    //Create filter criteria for requested entries in form of LIW map:
    CLiwDefaultMap* filter = CreateFilterLC( aContentType );
    ExecuteCommandL( KCpData, filter, outParamList );
    CleanupStack::PopAndDestroy( filter );
    
	TInt pos = 0;
	outParamList->FindFirst( pos, KResults );
	if( pos != KErrNotFound )
		// results present
		{
		//extract iterator on results list
		TLiwVariant variant = (*outParamList)[pos].Value();
		variant.PushL();
		CLiwIterable* iterable = variant.AsIterable();
		iterable->Reset();
		CLiwDefaultMap *map = CLiwDefaultMap::NewLC();
		
		while( iterable->NextL( variant ) )
			{
			//extract content map
			if( variant.Get( *map ) &&
					// Find the data map 
					map->FindL( KDataMap, variant) )
				{
				 CLiwDefaultMap *datamap = CLiwDefaultMap::NewLC();
				 if ( variant.Get( *datamap ) )
					 {
					 PublishDataL(aObserver, datamap);
					 }
				 CleanupStack::PopAndDestroy( datamap );
				}
			}
		CleanupStack::PopAndDestroy( map );
		CleanupStack::PopAndDestroy( &variant );
		}
	outParamList->Reset();
    }

void CSapiData::PublishDataL(MAiContentObserver* aObserver, CLiwDefaultMap* aDataMap )
	{
    for(TInt pIndex = 0; pIndex < iItemCount; pIndex++)
	    {
	    // result name to find
		TLiwVariant variant;
		HBufC8* itemName = CnvUtfConverter::ConvertFromUnicodeToUtf8L(*iItemList[pIndex]->iName);
		CleanupStack::PushL( itemName );
		if ( aDataMap->FindL( *itemName, variant ) )
		    {
			TPtrC valPtr;
			if(  iItemList[pIndex]->iType->Des() == KText )
				{
				valPtr.Set( variant.AsDes() );
				iPlugin->PublishTextL( aObserver, iItemList[pIndex]->iId, valPtr  );
				}
			else if( iItemList[pIndex]->iType->Des() == KImage )
				{
				TInt handle = KErrBadHandle;
                TUint uintHandle = 0;
                if ( variant.Get( uintHandle ) )
                    {
                    handle = uintHandle;
                    }
                else if ( !variant.Get( handle ) )
                    {
                    handle = KErrBadHandle;
                    }				
				// read as a image handle
				if( handle == KErrBadHandle )
					{
					// no handle, so read as image path
					variant.Get( valPtr );
					iPlugin->PublishImageL(aObserver, iItemList[pIndex]->iId, valPtr );
					}
				else
					{
					TInt maskHandle = KErrBadHandle;
					TUint uintmaskHandle = 0;
					//Look for image mask
					HBufC8* maskKey = HBufC8::NewLC( itemName->Length() + KMask().Length() );
					TPtr8 maskKeyPtr = maskKey->Des();
					maskKeyPtr.Append( *itemName );
					maskKeyPtr.Append( KMask );
					if ( aDataMap->FindL( maskKeyPtr, variant ) )
						{
                        if ( variant.Get( uintmaskHandle ) )
                            {
                            maskHandle = uintmaskHandle;
                            }
                        else if ( !variant.Get( maskHandle ) )
                            {
                            maskHandle = KErrBadHandle;
                            }                           
						}
					CleanupStack::PopAndDestroy( maskKey );
					iPlugin->PublishImageL(aObserver, iItemList[pIndex]->iId, handle, maskHandle );
					}
				}
		    }
			variant.Reset();
			CleanupStack::PopAndDestroy( itemName );
	    }
    }
// ---------------------------------------------------------------------------
// ExecuteCommandL
// ---------------------------------------------------------------------------
//
void CSapiData::ExecuteCommandL(const TDesC& aRegistry, CLiwDefaultMap* aInFilter, 
		CLiwGenericParamList* aOutParamList)
	{
	CLiwGenericParamList* inParamList  = &iServiceHandler->InParamListL();
	
	TLiwGenericParam type( KType, TLiwVariant( aRegistry ) );
	inParamList->AppendL( type );
	
	//append filter to input param
	 TLiwGenericParam item( KFilter, TLiwVariant( aInFilter ));
	 inParamList->AppendL( item );
	 
	// execute service.It is assumed that iInterface is already initiated
	if(iInterface)
		{
		iInterface->ExecuteCmdL( *iCommandName, *inParamList, *aOutParamList);
		}
	else
		{
		User::Leave( KErrNotSupported );
		}
	type.Reset();
	item.Reset();
	inParamList->Reset();
	}

// ---------------------------------------------------------------------------
// ExecuteActionL
// ---------------------------------------------------------------------------
//
void CSapiData::ExecuteActionL(const TDesC& aObjectId, const TDesC& aTrigger )
   {
   HBufC8* triggerName = HBufC8::NewLC( KSAPIContentNameMaxLength );
  
   CLiwGenericParamList* inParamList  = &iServiceHandler->InParamListL();
   CLiwGenericParamList* outParamList = &iServiceHandler->OutParamListL();
   CLiwDefaultMap* filter = NULL;

   triggerName->Des().Copy(aTrigger);
   if ( aObjectId == KPubData )
	   {
	   // this trigger belongs to publisher registery.
	   // in such case it is assumed that all the items in the widgets
	   // belongs to same publisher, type and id.
	   TLiwGenericParam cptype( KType, TLiwVariant( KPubData ) );
	   inParamList->AppendL( cptype );
	   cptype.Reset();
	   // use the first item configuration to create the filter
	   filter = CreateFilterLC( KWidget() );
	   }
   else
	   {
	   if ( aObjectId == KMenuItem16 )
		   {
		   TInt pos = KErrNotFound;
		   for (TInt i = 0; i < iMenuItems.Count(); i++)
			   {
			   if ( aTrigger == iMenuItems[i] )
				   {
				   pos = i;
				   break;
				   }
			   }
		   if( pos == KErrNotFound )
			   {
			   // No such menu items
			   CleanupStack::PopAndDestroy( triggerName );
			   return; 
			   }
			  triggerName->Des().Copy( iMenuTriggers[pos]->Des() );
			  filter = CreateFilterLC( KWidget() );
		   }
	   else
		   {
		   //Create filter criteria for requested entries in form of LIW map:
		   filter = CreateFilterLC( aObjectId );
		   }
	   //append type to inparam list
	   TLiwGenericParam cptype( KType, TLiwVariant( KCpData ) );
	   inParamList->AppendL( cptype );
	   cptype.Reset();
	   }

    filter->InsertL( KActionTrigger, TLiwVariant( triggerName->Des() ) );
   //append filter to input param
    TLiwGenericParam item( KFilter, TLiwVariant( filter ) );
    inParamList->AppendL( item );
    iInterface->ExecuteCmdL( KExecuteAction,  *inParamList, *outParamList );
    
    CleanupStack::PopAndDestroy( filter );
    CleanupStack::PopAndDestroy( triggerName );
    item.Reset();

    inParamList->Reset();
    outParamList->Reset();  
    
    }

// ---------------------------------------------------------------------------
// RegisterPublisherObserverL
// ---------------------------------------------------------------------------
//
void CSapiData::RegisterPublisherObserverL()
    {
    if ( iItemCount > 0)
    	{
		CLiwDefaultMap* pubRegFilter = CreateFilterLC( KAll(), KAll() );
		pubRegFilter->InsertL( KOperation, TLiwVariant( KUpdate ) );
		iPubObserver->RegisterL( pubRegFilter, KPubData() );
		CleanupStack::PopAndDestroy( pubRegFilter );
		}
    }

// ---------------------------------------------------------------------------
// RegisterContentObserverL
// ---------------------------------------------------------------------------
//
void CSapiData::RegisterContentObserverL()
    {
    if ( iItemCount > 0)
    	{
		CLiwDefaultMap* conRegFilter = CreateFilterLC();
		conRegFilter->InsertL( KOperation, TLiwVariant( KAddUpdateDelete ) );
		iContentObserver->RegisterL( conRegFilter, KCpData() );
		CleanupStack::PopAndDestroy( conRegFilter );
		}
    }

// ---------------------------------------------------------------------------
// RefreshL
// ---------------------------------------------------------------------------
//
void CSapiData::RefreshL( TDesC& aPublisher, TDesC& aContentType, 
                TDesC& aContentId, TDesC& aOperation )
    {
     if ( CanUpdate( aPublisher, aContentType, aContentId ) )
    	 {
    	 iPlugin->RefreshL( aContentType, aOperation);
    	 }
    }

// ---------------------------------------------------------------------------
// IsPluginActive
// ---------------------------------------------------------------------------
//
TBool CSapiData::IsPluginActive()
    {
    return iPlugin->IsActive();
    }

// ---------------------------------------------------------------------------
// PublisherStatusL
// ---------------------------------------------------------------------------
//
void CSapiData::ChangePublisherStatusL(const TDesC& aStatus)
    {
    CLiwGenericParamList* inParamList  = &iServiceHandler->InParamListL();
    CLiwGenericParamList* outParamList = &iServiceHandler->OutParamListL();
    HBufC8* triggerName = CnvUtfConverter::ConvertFromUnicodeToUtf8L(aStatus);
    CleanupStack::PushL( triggerName );

    TLiwGenericParam type( KType, TLiwVariant( KPubData ) );
    inParamList->AppendL( type );
			  
    CLiwDefaultMap* filter = CreateFilterLC( KWidget() );
    filter->InsertL(KActionTrigger, TLiwVariant(triggerName->Des()) );
   
    TLiwGenericParam item( KFilter, TLiwVariant( filter ));
    inParamList->AppendL( item );
           
    if(iInterface)
	   {
	   iInterface->ExecuteCmdL( KExecuteAction, *inParamList, *outParamList);
	   }
    else
	   {
	   User::Leave( KErrNotSupported );
	   }
    
    CleanupStack::PopAndDestroy( filter );
    CleanupStack::PopAndDestroy( triggerName );
    inParamList->Reset();
    outParamList->Reset();
   }

// ---------------------------------------------------------------------------
// ResumeL
// ---------------------------------------------------------------------------
//
void CSapiData::ResumeL()
    {
    if ( iUpdateNeeded )
     	{
     	iPlugin->PublishL();
     	iUpdateNeeded = EFalse;
     	}
    ChangePublisherStatusL( KResume );
    }

// ---------------------------------------------------------------------------
// SuspendL
// ---------------------------------------------------------------------------
//
void CSapiData::SuspendL()
    {
    ChangePublisherStatusL( KSuspend );
    }

// ---------------------------------------------------------------------------
// ActivateL
// ---------------------------------------------------------------------------
//
void CSapiData::ActivateL()
    {
    ChangePublisherStatusL( KActive );
    }

// ---------------------------------------------------------------------------
// DeActivateL
// ---------------------------------------------------------------------------
//
void CSapiData::DeActivateL()
    {
    ChangePublisherStatusL( KDeActive );
    }

// ---------------------------------------------------------------------------
// OnLineL
// ---------------------------------------------------------------------------
//
void CSapiData::OnLineL()
    {
    ChangePublisherStatusL( KOnLine );
    }

// ---------------------------------------------------------------------------
// offLineL
// ---------------------------------------------------------------------------
//
void CSapiData::OffLineL()
    {
    ChangePublisherStatusL( KOffLine );
    }

// ---------------------------------------------------------------------------
// InActiveL
// ---------------------------------------------------------------------------
//
void CSapiData::InActiveL()
    {
    ChangePublisherStatusL( KInActive );
    }

// ---------------------------------------------------------------------------
// UpdatePublisherStatusL
// ---------------------------------------------------------------------------
//
void CSapiData::UpdatePublisherStatusL( TDesC& aPublisher )
	{
	 if ( aPublisher == iPublisher )
		 {
		 // Resend the plugin status to publisher
		 ActivateL();
		 if ( iPlugin->IsActive() )
			 {
			 ResumeL();
			 }
		 else
			 {
			 SuspendL();
			 }
		  // forward the network status if it uses.
		if ( iPlugin->NetworkStatus() == CSapiDataPlugin::EOnline )
			{
			OnLineL();
			}
		else if ( iPlugin->NetworkStatus() == CSapiDataPlugin::EOffline )
			{
			OffLineL();
			}
		 }
	}

// ---------------------------------------------------------------------------
// ResolveSkinItemId
// ---------------------------------------------------------------------------
//
TBool CSapiData::ResolveSkinIdAndMifId( const TDesC& aPath, TAknsItemID& aItemId,
		TInt& abitmapId, TInt& aMaskId, TDes& aFilename )
   {
   // Syntax: skin(   ):mif(filename bimapId maskId) 
   TInt error = KErrNotFound;
   TInt pos = aPath.FindF( KSkin );
   if( pos != KErrNotFound )
	   {
	   // Skip skin token
	   pos += KSkin().Length();
	   
	   // Initialize lexer
	  TLex lex( aPath.Mid( pos ) );
	  lex.SkipSpace();
	   
	   // Check left parenthesis
	  if (lex.Get() == KLeftParenthesis )
		   {
		   //lex.SkipSpace();
		   
		   TInt majorId( 0 );        
		   TInt minorId( 0 );

		   // Resolve major id        
		   error = lex.Val( majorId );
		   
		   // Resolve minor id
		   lex.SkipSpace();
		   error |= lex.Val( minorId );
		   
		   // initilize skin item id object
		   aItemId.Set( majorId, minorId );
		   }
	   }

   if( (error == KErrNone && aPath.FindF( KColon ) != KErrNotFound ) 
		 || ( error == KErrNotFound ) )
	   {
	   error = KErrNotFound;
	   pos = aPath.FindF( KMif );
	   if ( pos != KErrNotFound )
		   {
		   pos += KMif().Length();
		   // Initialize lexer
		   TLex lex( aPath.Mid( pos ) );
		   lex.SkipSpace();
		   
		   // Check left parenthesis
		   if (lex.Get() == KLeftParenthesis )
			   {
			   lex.SkipSpaceAndMark();
			   lex.SkipCharacters();
			   // Resolve MifFile name
			   aFilename.Copy(lex.MarkedToken());
			   if( aFilename.Length()!= 0)
				   {
				   // Resolve major id  
				   lex.SkipSpace();
				   error = lex.Val( abitmapId );
				   
				   // Resolve minor id
				   lex.SkipSpace();
				   error |= lex.Val( aMaskId );
				   }
			   else
				   {
				   error = KErrNotFound;
				   }
			   }
		   }
	   }
   return (error == KErrNone );
   }

// ---------------------------------------------------------------------------
// SetUpdateNeeded
// ---------------------------------------------------------------------------
//
void CSapiData::SetUpdateNeeded(TBool aStatus)
	{
	iUpdateNeeded = aStatus;
	}
hs_app_sapidataobserver.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#include 
#include 
#include 
#include "hs_app_sapidata.h"
#include "hs_app_sapidataobserver.h"
#include "hs_app_sapidatapluginconst.h"
// ---------------------------------------------------------------------------
// Constructor
// ---------------------------------------------------------------------------
//
CSapiDataObserver::CSapiDataObserver ()
    {

    }
        
// ---------------------------------------------------------------------------
// Destructor
// ---------------------------------------------------------------------------
//
CSapiDataObserver ::~CSapiDataObserver ()
    {
    iInterface = NULL;
    iData = NULL;
    }

// ---------------------------------------------------------------------------
// Register for notifications
// ---------------------------------------------------------------------------
//
void CSapiDataObserver::RegisterL( CLiwDefaultMap* aFilter, const TDesC& aRegistry )
    {
    CLiwGenericParamList* inParamList = CLiwGenericParamList::NewL();
    CleanupStack::PushL( inParamList );
    CLiwGenericParamList* outParamList = CLiwGenericParamList::NewL();
    CleanupStack::PushL( outParamList );
        
    // Fill in input list for RequestNotification command
    inParamList->AppendL(TLiwGenericParam(KType,TLiwVariant(aRegistry)));
    inParamList->AppendL(TLiwGenericParam(KFilter ,TLiwVariant(aFilter)));
        
    iError = KErrNone;
    TRAP( iError, iInterface->ExecuteCmdL( 
                KRequestNotification,
                *inParamList,
                *outParamList,
                0,
                this ) );
    
    CleanupStack::PopAndDestroy( outParamList );
    CleanupStack::PopAndDestroy( inParamList ); 
    }

// ---------------------------------------------------------------------------
// Sing off to notification
// ---------------------------------------------------------------------------
//
void CSapiDataObserver ::ReleaseL()
    {
    if( iInterface )
        {
        CLiwGenericParamList* inParamList = CLiwGenericParamList::NewL();
        CleanupStack::PushL( inParamList );
        CLiwGenericParamList* outParamList = CLiwGenericParamList::NewL();
        CleanupStack::PushL( outParamList );
        
        TInt err(KErrNone);
        TRAP(err, iInterface->ExecuteCmdL( 
                KRequestNotification,
                *inParamList,
                *outParamList,
                KLiwOptCancel,
                this ));
        
        CleanupStack::PopAndDestroy( outParamList );
        CleanupStack::PopAndDestroy( inParamList );
        }
    }

// ---------------------------------------------------------------------------
// Factory method construction
// ---------------------------------------------------------------------------
//
CSapiDataObserver * CSapiDataObserver::NewL( MLiwInterface* aInterface, CSapiData* aData )
    {
    CSapiDataObserver * self = new (ELeave) CSapiDataObserver();
    CleanupStack::PushL( self );
    self->ConstructL( aInterface, aData );
    CleanupStack::Pop( self );
    return self;    
    }
        
// ---------------------------------------------------------------------------
// 2n phase constructor
// ---------------------------------------------------------------------------
//
void CSapiDataObserver::ConstructL( MLiwInterface* aInterface, CSapiData* aData )
    {
    iData = aData;
    iInterface = aInterface;
    }

// ---------------------------------------------------------------------------
// Handles Published content notification
// ---------------------------------------------------------------------------
//
TInt CSapiDataObserver::HandleNotifyL(
        TInt aErrorCode,
        TInt /*aEventId*/,
        CLiwGenericParamList& aEventParamList,
        const CLiwGenericParamList& /*aInParamList*/ )
    {
     
    // Is plugin active to refresh the published data
	iError = aErrorCode;        
	TInt count(0);
	TInt pos(0);
	const TLiwGenericParam* param(NULL);
	CLiwDefaultList* listOfMaps = CLiwDefaultList::NewLC();
	param = aEventParamList.FindFirst(pos,KChangeInfo);
	if( param )
		{
		 User::LeaveIfError( param->Value().Get( *listOfMaps ) );
		 count = listOfMaps->Count();
		}
	TLiwVariant variant;
	// Extract the data from the map 
	for(TInt i = 0;i < count; i++)
		{
		listOfMaps->AtL(i,variant);
		HBufC* operation = NULL;

		CLiwDefaultMap *map = CLiwDefaultMap::NewLC();
		variant.Get( *map );
		TBool found;
		found = map->FindL( KOperation, variant );
		if (found)
		   {
		   operation = variant.AsDes().AllocLC();
		   }
		variant.Reset();
		if( operation && ( operation->Des() != KOperationExecute ) )
		   {
		   // Nothing to update for execute action
		   HBufC* publisher = NULL; 
		   HBufC* contentType = NULL;
		   HBufC* contentId = NULL;
		   found = map->FindL( KPublisherId, variant );
		   if (found)
			   {
			   publisher = variant.AsDes().AllocLC();
			   }
		   variant.Reset();
		   found = map->FindL( KFLAG, variant );
		   if ( found)
			   {
			   // notification from publisher registry
			  if ( operation->Des() !=  KOperationDelete )
				  {
				  iData->UpdatePublisherStatusL( *publisher );
				  }
			   }
		   else if ( iData->IsPluginActive() ) 
			   { 
			   // notification from content registry
			   found = map->FindL( KContentType, variant );
			   if (found)
				  {
				  contentType = variant.AsDes().AllocLC();
				  }
			   variant.Reset();
			   found = map->FindL( KContentId, variant );
			   if (found)
				  {
				  contentId = variant.AsDes().AllocLC();
				  }
			   variant.Reset();
			   iData->RefreshL( *publisher, *contentType, *contentId, *operation );
			   
			   if ( contentId )
				   {
				   CleanupStack::PopAndDestroy( contentId );
				   }
			  if ( contentType )
				   {
				   CleanupStack::PopAndDestroy( contentType );
				   }
			   }
		   else
			   {
			   // remember update if plugin is in suspend mode
			   iData->SetUpdateNeeded( ETrue );
			   }
			variant.Reset();
			 if ( publisher )
			   {
			   CleanupStack::PopAndDestroy( publisher );
			   }
		   }
		if ( operation )
			{
			CleanupStack::PopAndDestroy( operation );
			}
		CleanupStack::PopAndDestroy( map );
		}
	CleanupStack::PopAndDestroy( listOfMaps );
	
    return aErrorCode;
    }

hs_app_sapidataplugin.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Profile plug-in publisher
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include  
#include  
#include 
#include 
#include 

#include "hs_app_sapidatapluginconst.h"
#include "hs_app_sapidatapluginuids.hrh"
#include "hs_app_sapidataplugin.h"
#include "hs_app_sapidata.h"

// CONST CLASS VARIABLES
const TImplementationProxy KImplementationTable[] =
    {
    IMPLEMENTATION_PROXY_ENTRY( KImplUidDataPlugin, CSapiDataPlugin::NewL ) 
    };

// ======== MEMBER FUNCTIONS ========
// ---------------------------------------------------------------------------
// Constructs and returns an application object.
// ---------------------------------------------------------------------------
//
EXPORT_C const TImplementationProxy* ImplementationGroupProxy(TInt& aTableCount )
    {
    aTableCount = sizeof( KImplementationTable ) /
        sizeof( TImplementationProxy );
    return KImplementationTable;
    }

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
CSapiDataPlugin* CSapiDataPlugin::NewL()
    {
    CSapiDataPlugin* self = new (ELeave) CSapiDataPlugin;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }
    
// ---------------------------------------------------------------------------
// Default constructor
// ---------------------------------------------------------------------------
//
CSapiDataPlugin::CSapiDataPlugin()
    {
    }
    
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::ConstructL()
    { 
    iInfo.iUid.iUid = SAPIDP_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DATAPLUGIN; 
    iPluginState = ENone;
    iHSForeGround = EFalse;
    iKeyLockOn = EFalse;
    iNetworkStatus = EUnknown;
    iData = CSapiData::NewL(this);

    }
    
// ---------------------------------------------------------------------------
// Destructor
// Deletes all data created to heap
// ---------------------------------------------------------------------------
//
CSapiDataPlugin::~CSapiDataPlugin()
    {
    // deactivate the publishers
    if( iData )
        {
        TRAP_IGNORE(iData->DeActivateL());
        delete iData;
        }
    iObservers.Close();
    Release( iContent );
    iDataArray.ResetAndDestroy();

    if( iContentModel)
        {
        for( TInt i = iDataCount-1;i>=0  ; i-- )
            {
            User::Free((TAny*)iContentModel[i].cid);   
            }
        delete []iContentModel;
        }
    iIconArray.Reset();
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-ins take ownership of the settings array, so it must either
// store it in a member or free it.
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::ConfigureL( RAiSettingsItemArray& aSettings )
    {
    if( iDataCount > 0 )
        {
        // We own the array so destroy it
         aSettings.ResetAndDestroy();
         return;
        }
    
    RAiSettingsItemArray contentItemsArr;
    RAiSettingsItemArray configurationItemsArr;
    
    TInt count = aSettings.Count();
    for(TInt i = 0; i < count; i++ )
        {
        MAiPluginSettings* pluginSetting = aSettings[i];
        if( pluginSetting->AiPluginItemType() == EAiPluginContentItem )
            {
            contentItemsArr.Append(pluginSetting);
            }
        else if( pluginSetting->AiPluginItemType() == EAiPluginConfigurationItem )
            {
            configurationItemsArr.Append(pluginSetting);
            }
        }
    iDataCount = contentItemsArr.Count();
    if(iDataCount > 0 )
        {
        // Create the content Model
        HBufC* contentId = HBufC::NewLC( KAiContentIdMaxLength + KAiPluginNameMaxLength );
        iContentModel = new TAiContentItem[iDataCount];
        for(TInt i = 0; i < iDataCount; i++)
            {
            MAiPluginContentItem& contentItem = (contentItemsArr[i])->AiPluginContentItem();
            iContentModel[i].id = i;
            if( contentItem.Type() == KText() || contentItem.Type() == KNewsTicker() )
                {
                // text
                iContentModel[i].type = KAiContentTypeText;
                }
            if( contentItem.Type() == KImage() )
                {
                // image
                iContentModel[i].type = KAiContentTypeBitmap;
                }
            
            contentId->Des().Copy(contentItem.Name());
            contentId->Des().Delete(0, contentId->Des().LocateReverse(KPluginNameSeprator) +1);
  
            TInt sizeOfContentId = contentId->Des().Size()+sizeof(wchar_t);
            iContentModel[i].cid = static_cast( User::Alloc( sizeOfContentId ) );
            Mem::Copy((TAny*)iContentModel[i].cid, contentId->Des().PtrZ(), sizeOfContentId);
            
            contentId->Des().Delete( 0, contentId->Des().Length());
            }    
        
        CleanupStack::PopAndDestroy( contentId );
        iContent = AiUtility::CreateContentItemArrayIteratorL( iContentModel, iDataCount );
        // Configurations 
        iData->ConfigureL(configurationItemsArr);
        
        // Activate the publisher
        iData->ActivateL();
                
        // Register for notifications
        iData->RegisterPublisherObserverL();
      
        PublishL();
        
        iPluginState = ESuspend;
        iData->RegisterContentObserverL();
        }
    contentItemsArr.Reset();
    configurationItemsArr.Reset();
       // We own the array so destroy it
    aSettings.ResetAndDestroy();
    // publish the initial data
    }

// ---------------------------------------------------------------------------
// Publishes widget's texts and images
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::PublishL()
    {
    User::LeaveIfError( iRfs.Connect() );

    TInt observers( iObservers.Count() );        
    TInt transactionId = reinterpret_cast( this );

    for ( int i = 0; i < observers; i++ )
        {
        MAiContentObserver* observer = iObservers[i];
        
		if ( observer->StartTransaction( transactionId ) == KErrNone ) 				
            {
            // Publish all the data
    		iData->PublishL(observer, KAll );
    	    observer->Commit( transactionId );
            }

		// Release memory of the published text
        iDataArray.ResetAndDestroy();
        // Release memory of the published icons
        iIconArray.Reset();
        
        }
    iRfs.Close();
    }

// ---------------------------------------------------------------------------
// Publish a specific text of the widget  
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::PublishTextL(MAiContentObserver* aObserver, 
        TInt& aContentId, TDesC& aContentValue)
    {
    if ( aObserver->CanPublish( *this,  aContentId  ,  aContentId  ) )
        {
        if( aContentValue.Length() > 0 )
            {
            HBufC* contentText = HBufC::NewLC(aContentValue.Size());
            TPtr cDes = contentText->Des();
            cDes.Copy(aContentValue);
            aObserver->Publish( *this, aContentId, cDes, aContentId );  
            iDataArray.AppendL( contentText );
            CleanupStack::Pop( contentText );
            }
        else
            {
            aObserver->Clean( *this, aContentId, aContentId );
            }
        }
    }

// ---------------------------------------------------------------------------
// Publish a specific image of the widget  
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::PublishImageL(MAiContentObserver* aObserver,
        TInt aContentId, TDesC& aPath )
    {
    TInt err = KErrNone;
    TAknsItemID iconId;
    iconId.iMajor=0;
    iconId.iMinor=0;
    TInt bitmapId(0);
    TInt maskId(0);
    TFileName fileName;
    CGulIcon* icon = NULL;
    CFbsBitmap* bitmap = NULL;
    CFbsBitmap* mask = NULL;
    
    if ( aObserver->CanPublish( *this, aContentId , aContentId ) )
      {
      TBool inSkin = iData->ResolveSkinIdAndMifId( aPath, iconId, bitmapId, maskId, fileName  );
      if ( inSkin )
          {
          // Load from skin 
          MAknsSkinInstance* skin = AknsUtils::SkinInstance();
          if ( iconId.iMajor != 0 && iconId.iMajor!=0 )
              {
              // Create icon with fall back 
              TRAP_IGNORE(AknsUtils::CreateIconL(
                      skin,
                      iconId,
                      bitmap,
                      mask,
                      fileName,  /* backup filename */
                      bitmapId,  /* backup bit map id */
                      maskId));   /* backup mask id */
              }
          else if( bitmapId !=0 )
              {
              if ( maskId!=0 )
                  {
                  // Create icon from Mif filename , bitmap id and mask id
                  TRAP_IGNORE(icon = AknsUtils::CreateGulIconL(
                          skin,
                          iconId,
                          fileName,
                          bitmapId,
                          maskId) );
                  }
              else
                  {
                  TRAP_IGNORE(AknsUtils::CreateIconL(
                          skin,
                          iconId,
                          bitmap,
                          fileName,  /* backup filename */
                          bitmapId)); /* backup bit map id */
                  }
              }
          
          if ( icon == NULL && bitmap !=  NULL )
              {
              icon = CGulIcon::NewL( bitmap, mask );
              }

          if ( icon != NULL ) // Syntax correct but icon not found
              {
              aObserver->PublishPtr( *this, aContentId, icon , aContentId );
              iIconArray.Append(icon);
              } 
          else
              {
              err = KErrNotFound;   
              aObserver->Clean( *this, aContentId, aContentId );
              }
          }
      else  // Interpret as File path
          {
          RFile* iconFile = new (ELeave) RFile();
          err = iconFile->Open( iRfs, aPath, EFileShareReadersOnly |  EFileRead );
          if( err == KErrNone )
            {
             aObserver->Publish( *this, aContentId, *iconFile, aContentId );
            }
          else
              {
              aObserver->Clean( *this, aContentId, aContentId );
              }
          iconFile->Close();
          delete iconFile;
          iconFile = NULL;
          }
        }
    }

// ---------------------------------------------------------------------------
// Publish a image of the widget  
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::PublishImageL(MAiContentObserver* aObserver, 
        TInt& aContentId, TInt aHandle, TInt aMaskHandle )
    {
    if ( aObserver->CanPublish( *this, aContentId , aContentId ) )
        {
        if( aHandle != KErrBadHandle  )
            {
            CFbsBitmap* bitmap = new (ELeave) CFbsBitmap();
            if( KErrNone == bitmap->Duplicate( aHandle) )
                {
                // Take the ownership
                CGulIcon* icon = CGulIcon::NewL(bitmap);
                if( aMaskHandle != KErrBadHandle )
                    {
                    CFbsBitmap* mask = new (ELeave) CFbsBitmap();
                    if (KErrNone == mask->Duplicate( aMaskHandle) )
                        {
                        icon->SetMask( mask );            
                        }
                    }
                aObserver->PublishPtr( *this, aContentId, icon , aContentId );
                iIconArray.Append(icon);
                }
            else
                {
                delete bitmap;
                bitmap = NULL;
                aObserver->Clean( *this, aContentId, aContentId );
                }
            }
          }
    }

// ---------------------------------------------------------------------------
// Gets the id of a content  
// ---------------------------------------------------------------------------
//
TInt CSapiDataPlugin::GetIdL( TDesC& aObjectId)
	{
    TInt id = KErrNotFound;
	for( TInt i = 0;i<  iDataCount; i++ )
		{
		 if( aObjectId == ContentCid(iContentModel[i] ) )
			 {
			 id = iContentModel[i].id;
			 break;
			 }
		}
	return id;
	}
 

// ---------------------------------------------------------------------------
// Gets type of a content
// ---------------------------------------------------------------------------
//
const TDesC& CSapiDataPlugin::GetTypeL(TDesC& aObjectId )
	{
	for( TInt i = 0;i<  iDataCount; i++ )
		{
		 if( aObjectId ==  ContentCid(iContentModel[i]) )
			 {
			 if( iContentModel[i].type ==  KAiContentTypeText)
				 {
				 return KText();
				 }
			 else if( iContentModel[i].type == KAiContentTypeBitmap)
				 {
				 return KImage();
				 }
			 }
		}
	
	return KNullDesC();
	}

// ---------------------------------------------------------------------------
//Refresh a specific image of text in the widget
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::RefreshL(TDesC& aContentType, TDesC& aOperation)
    {
     User::LeaveIfError( iRfs.Connect() );
	 TInt observers( iObservers.Count() );        
	 TInt transactionId = reinterpret_cast( this );
	 
	 for ( TInt obsIndex = 0; obsIndex < observers; obsIndex++ )
		{
		MAiContentObserver* observer = iObservers[obsIndex];
		
		if ( observer->StartTransaction( transactionId ) == KErrNone ) 				
			{
			if ( aOperation != KOperationDelete )
				{
				iData->PublishL( observer, aContentType );
				}
			else
				{
				iData->RemoveL( observer, aContentType  );	
				}
			
			observer->Commit( transactionId );
			}
		
		 // Relese memory of the published text
         iDataArray.ResetAndDestroy();
		 iIconArray.Reset();
		}
	 iRfs.Close();
    }

// ---------------------------------------------------------------------------
// Cleans a data from the widget
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::Clean(MAiContentObserver* aObserver, 
        TInt& aContentId )
	{
	 if ( aObserver->CanPublish( *this, aContentId, aContentId ) )
		{
		aObserver->Clean( *this, aContentId, aContentId );		
		}

	}
// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is requested to unload its engines due backup operation
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::Stop( TAiTransitionReason aReason )
    {
    if( iPluginState == EResume )
        {
        Suspend( aReason );
        }
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is instructed that it is allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::Resume( TAiTransitionReason aReason )
    {
    TRAP_IGNORE( DoResumeL( aReason ) ); 
    }
    
// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is instructed that it is not allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::Suspend( TAiTransitionReason aReason )
    {
    switch( aReason )
		{
		case EAiKeylockDisabled:
        case EAiKeylockEnabled:
        	{
        	// handled in resume 
        	TRAP_IGNORE( DoResumeL( aReason ) ); 
        	break;
        	}
        default :
        	{
        	iPluginState = ESuspend;
        	TRAP_IGNORE ( iData->SuspendL() );
        	}
		}
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// The plug-in MUST maintain a registry of subscribers and send 
// notification to all of them whenever the state changes or new content
// is available
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::SubscribeL( MAiContentObserver& aObserver )
    { 
    iObservers.AppendL( &aObserver );
    }
 

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Returns the extension interface. Actual type depends on the passed 
// aUid argument.
// ---------------------------------------------------------------------------
//
TAny* CSapiDataPlugin::Extension( TUid aUid )
    {    
    if ( aUid == KExtensionUidProperty )
   		{
        return static_cast( this );
    	}
    else if (aUid == KExtensionUidEventHandler)
    	{
        return static_cast( this );
    	}
    else
    	{	
        return NULL;
    	}
    }

// ---------------------------------------------------------------------------
// From class MAiPropertyExtension
// Read property of publisher plug-in.
// ---------------------------------------------------------------------------
//
TAny* CSapiDataPlugin::GetPropertyL( TInt aProperty )
    {
    TAny* property = NULL;
    
    switch ( aProperty )
        {
    case EAiPublisherInfo:
        {
         property = static_cast( &iInfo );
        break;  
        }       

    case EAiPublisherContent:
        {
        property = static_cast( iContent );
        break;    
        }        
    default:
        break;
        }

    return property;
    }

// ---------------------------------------------------------------------------
// From class MAiPropertyExtension
// Write property value to optimize the content model.
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::SetPropertyL( TInt aProperty, TAny* aValue )
    {  
    if( aProperty == EAiPublisherInfo )
        {
        ASSERT( aValue );
        
        const TAiPublisherInfo* info( 
                static_cast( aValue ) );
        
        iInfo = *info;
        
        iData->SetContentIdL( info->iNamespace );
        }
    }
 
// ---------------------------------------------------------------------------
// From class MAiEventHandlerExtension.
// Handles an event sent by the AI framework.
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::HandleEvent( TInt /*aEvent*/, const TDesC& /*aParam*/ )
	{
    // This is not as there is no event id to retrieve in this dynamic plugin. 
	} 
    
// ---------------------------------------------------------------------------
// From class MAiEventHandlerExtension.
// Handles an event sent by the AI framework.
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::HandleEvent( const TDesC& aEventName, const TDesC& aParam )
    {
    // We have no way of reporting errors to framework so just ignore them.
    TRAP_IGNORE(iData->ExecuteActionL( aEventName , aParam ) );
    }

// ---------------------------------------------------------------------------
// From class MAiEventHandlerExtension.
// Invoked by the framework for querying if plugin has menu item
// ---------------------------------------------------------------------------
//
TBool CSapiDataPlugin::HasMenuItem( const TDesC& aMenuItem )
	{ 
	return iData->HasMenuItem ( aMenuItem );  
	}

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// framework instructs plug-in that it is allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CSapiDataPlugin::DoResumeL( TAiTransitionReason aReason )
    {
	//update in startup phase and idle is on foreground.
    switch ( aReason )
    	{
        case EAiIdleOnLine:
        	{
        	iNetworkStatus = EOnline;
			iData->OnLineL();
			break;
        	}
        case EAiIdleOffLine:
        	{
			iNetworkStatus = EOffline;
			iData->OffLineL();
			break;
			}
        case EAiIdlePageSwitch:
        	{
        	if ( iPluginState == EResume )
				{
				iData->SuspendL();
				}
        	iPluginState = EInActive;
        	iData->InActiveL();
        	}
        	break;
        case EAiSystemStartup:
    	case EAiIdleForeground:
    		{
			iHSForeGround = ETrue;
    		}
    	case EAiBacklightOn:    		
    		{
    		if ( iPluginState == ESuspend  && !iKeyLockOn )
				{
				iPluginState = EResume;
				iData->ResumeL();
				}
    		break;
			}
    	case EAiKeylockDisabled:
        	{
        	iKeyLockOn = EFalse;
        	// Key lock events considered only if HS is in foreground  
        	if ( iHSForeGround && iPluginState == ESuspend )
        		{
        		iPluginState = EResume;
				iData->ResumeL();
        		}
        	break;
        	}
    	case EAiKeylockEnabled:
        	{
        	iKeyLockOn = ETrue;
        	// Key lock events considered only if HS is in foreground
        	if ( iHSForeGround && iPluginState == EResume )
        		{
				iPluginState = ESuspend ;
				iData->SuspendL();
        		}
        	break;
        	}
    	case EAiScreenLayoutChanged:
        	{
        	// ignore events
        	break;
        	}
      case EAiGeneralThemeChanged:
          {
          // ignore event
          break;
          }
    	case EAiIdleBackground: 
        	{
			iHSForeGround = EFalse;
        	}
        default :
        	{
			if ( iPluginState == EResume )
				{
				iPluginState = ESuspend;
				iData->SuspendL();
				}
        	break;
        	}
    	}
    }

// ---------------------------------------------------------------------------
// Is plugin active to publish the data 
// ---------------------------------------------------------------------------
//
TBool CSapiDataPlugin::IsActive()
    {
    return (iPluginState == EResume );
    }
hs_app_aiscutextservu.def
EXPORTS
	?Connect@RAiScutExtServ@@QAEHXZ @ 1 NONAME ; int RAiScutExtServ::Connect(void)
	?IsInShortcuts@RAiScutExtServ@@QBEHAAH@Z @ 2 NONAME ; int RAiScutExtServ::IsInShortcuts(int &) const
	?IssuePutInShortcuts@RAiScutExtServ@@QAEHXZ @ 3 NONAME ; int RAiScutExtServ::IssuePutInShortcuts(void)
	?ResetIcon@RAiScutExtServ@@QAEHXZ @ 4 NONAME ; int RAiScutExtServ::ResetIcon(void)
	?ResetPopupText@RAiScutExtServ@@QAEHXZ @ 5 NONAME ; int RAiScutExtServ::ResetPopupText(void)
	?UpdateIconL@RAiScutExtServ@@QAEHABVCGulIcon@@@Z @ 6 NONAME ; int RAiScutExtServ::UpdateIconL(class CGulIcon const &)
	?UpdatePopupTextL@RAiScutExtServ@@QAEHABVMDesC16Array@@@Z @ 7 NONAME ; int RAiScutExtServ::UpdatePopupTextL(class MDesC16Array const &)
	?Version@RAiScutExtServ@@QBE?AVTVersion@@XZ @ 8 NONAME ; class TVersion RAiScutExtServ::Version(void) const
	?Connect@RAiScutExtServ@@QAEHABVTDesC16@@@Z @ 9 NONAME ; int RAiScutExtServ::Connect(class TDesC16 const &)

keys_scutplugin.xls
????±?>??	!???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? 	

????EP#$%&'F)*+5-./01234(6789:;<=>?@ABCD????RGHIJKLMNOQ????S????TU????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????Root Entry???????? ?F?á?ØªØ0í?Üd?Ø"?&Workbook????????;_VBA_PROJECT_CUR"?ê?Üd?Ø0í?Üd?ØVBA??????????èÜd?Ø`ﬂÜd?Ø	a?…??∞??\pJari Laaksonen                                                                                               B∞a?=”?ThisWorkbook?ùº= ???A¢08?@?"∑?1‹?êArial1‹?êArial1‹?êArial1‹?êArial1ØêArial1Ø$êArial1$??ê
Nokia Sans1$?	º
Nokia Sans1$??º
Nokia Sans1 ?êTahoma3#,##0\ "¨ ";\-#,##0\ "¨ "=#,##0\ "¨ ";[Red]\-#,##0\ "¨ "?#,##0.00\ "¨ ";\-#,##0.00\ "¨ "I"#,##0.00\ "¨ ";[Red]\-#,##0.00\ "¨ "q*6_-* #,##0\ "¨ "_-;\-* #,##0\ "¨ "_-;_-* "-"\ "¨ "_-;_-@_-k)3_-* #,##0\ _¨ _-;\-* #,##0\ _¨ _-;_-* "-"\ _¨ _-;_-@_-Å,>_-* #,##0.00\ "¨ "_-;\-* #,##0.00\ "¨ "_-;_-* "-"??\ "¨ "_-;_-@_-{+;_-* #,##0.00\ _¨ _-;\-* #,##0.00\ _¨ _-;_-* "-"??\ _¨ _-;_-@_- §#,##0\ "EUR";\-#,##0\ "EUR"%? #,##0\ "EUR";[Red]\-#,##0\ "EUR"&¶!#,##0.00\ "EUR";\-#,##0.00\ "EUR"+ß&#,##0.00\ "EUR";[Red]\-#,##0.00\ "EUR"Aç<_-* #,##0\ "EUR"_-;\-* #,##0\ "EUR"_-;_-* "-"\ "EUR"_-;_-@_-D©?_-* #,##0\ _E_U_R_-;\-* #,##0\ _E_U_R_-;_-* "-"\ _E_U_R_-;_-@_-I?D_-* #,##0.00\ "EUR"_-;\-* #,##0.00\ "EUR"_-;_-* "-"??\ "EUR"_-;_-@_-L´G_-* #,##0.00\ _E_U_R_-;\-* #,##0.00\ _E_U_R_-;_-* "-"??\ _E_U_R_-;_-@_-¨"$"#,##0_);\("$"#,##0\)!≠"$"#,##0_);[Red]\("$"#,##0\)"Æ"$"#,##0.00_);\("$"#,##0.00\)'ù""$"#,##0.00_);[Red]\("$"#,##0.00\)7∞2_("$"* #,##0_);_("$"* \(#,##0\);_("$"* "-"_);_(@_).±)_(* #,##0_);_(* \(#,##0\);_(* "-"_);_(@_)?≤:_("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)6≥1_(* #,##0.00_);_(* \(#,##0.00\);_(* "-"??_);_(@_)¥dd\-mm\-yyyyµ0.0∂"Yes";"Yes";"No"∑"True";"True";"False"è"On";"On";"Off"π0.00_ ;[Red]\-0.00\ ?ı? ? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ?ı? ?? ? ? ?+ı? ∏? ?)ı? ∏? ?,ı? ∏? ?*ı? ∏? ????? ????? ?	ı? ∏? ?	 ?	 ? ? ?!‹ ?	®	 ?® ?‹ ? ?	 ?	®	 ? ?	 ?!‹	 ?	 ?	 ?	®	 ?	®	 ?π!‹	 ?)‹	 ?(∏  ?(? ?1 ? ?(? ?(∏ ? ?? ?		!‹	 ?)∏  ?)? ?(Z∏  ?P!?	 ? ?	 ? ` 
 ?(p 
 ?(t 
 ?)t 
 ?1 t 
 ? @) ?(P) ?(T) ?)T) ?1 T) ? @/ ?(P/ ?(T/ ?)T/ ?1 T/ ? `  ?(p  ?(t  ?)t  ?1 t  ?P ?	 ìÄ?ìÄ?ìÄ?ìÄ?ìÄ	?ìÄ?ìÄ?ìÄ?í?8????????????ÄÄÄÄÄÄÄÄÄ???ÄÄÄôô?ô3f??????ff?ÄÄf????Ä??????ÄÄÄÄÄ???????????ôô???ô??ô???ô3f?3??ô????ô?fffôñññ3f3ôf333ô3ô3f33ô333\???`Ö˛MainÖÆ$
Key values?Æ????!
=
#	Key_names;?? ;??"æ?Z?R?3??ÅA?@@?
˜¸??dCommentsDateVersionTypeAuthorPurposeOwnerEntityLocationVersion HistoryYesNoTemplate version]DO NOT DELETE THIS SHEET. THE FUTURE CONVERSION SCRIPTS NEED THE TEMPLATE VERSION INFORMATIONRemovedCenRep keys RFSIntMustKey IntUid NameKey TypeBackupCust ConfigRelated FeaturesRealStrBinReadDeviceDataWriteDeviceDataNetworkServices
LocalServicesReadUserData
WriteUserDataProtServDRMSwEvent	PowerMgmtAllFiles	DiskAdminNetworkControlMultiMediaDDCommDDTCB	TrustedUIRWPlatform ReleaseKey NameRWelafapacthaijapangsmlow_costRDo not delete AN1 -> BC1, since they are used in the multichoise column validation
Read  Only	Uid ValueShared Data NameVariant Name	Def Value
Range FromRange ToSurroundingsDDSID Read
AlwaysPass	SID WriteUserEnvironment2.0
0x102750F9dmitry.kolesnikov@nokia.comActive Idle / Shortcut plugin
0x00000001Dmitry KolesnikovProposal
0x10275104fAI Shortcut plug-in settings. The interface provides access to the default and user-defined shortcuts.KCRUidShortcutItems
0x0000FFFF.User-defined "always visible" shortctut items.
0x80000001
0x8000FFFF/Theme-default "always visible" shortctut items.
0x01000000
0x0100FFFF
0x81000000
0x8100FFFF2User-defined "optionally visible" shortctut items.3Theme-default "optionally visible" shortctut items.
0x02000000
0x82000000
0x0200FFFF
0x8200FFFF3User-defined "non-visible visible" shortctut items.4Theme-default "non-visible visible" shortctut items.Comment: AI Shortcut Items APIjari.j.laaksonen@nokia.comChanged RFS valuesS60 3.2?jGﬁSB?Q˜ºT?o?≠?a??æ?o∂{ccf
	a?…? "
d¸©??MbP?_*+ÇÄ%?Å??ÑM¢\\trprn003\trh5c3c1‹ƒS?Ä	?
o6,,LetterPRIV?0''''ƒ\K\K
?¥???"	6,,????U}}@}@
 }`} } ]}	êColumn B,??J?!J?"?????	§?#
?Ä!??
?æ?
%
?
?
,Eæ?
æ?
ææ
?
?
 H?
?
0G?
#$RèÖ?Q???N¸
%??Bæ
	?
		æ	
?

?

?

?

?

Ω1 ‰?@ ???
K?
JΩ1Ä??@ @Y@?
K?
FaΩ
1 ?@ ÄY@?

K?

Fa?

b◊ Ö6**&&?*P22>∂@?7è∂?…?y????Ç?K©dmitry.kolesnikov@nokia.com?…?y????Ç?K©Fmailto:dmitry.kolesnikov@nokia.comè≤?…?y????Ç?K©jari.j.laaksonen@nokia.com?…?y????Ç?K©Dmailto:jari.j.laaksonen@nokia.comè≤

?…?y????Ç?K©jari.j.laaksonen@nokia.com?…?y????Ç?K©Dmailto:jari.j.laaksonen@nokia.com?	Sheet1
	a?…?) 9
d¸©??MbP?_*+ÇÄ%íÅA?ÑM¢\\trprn001\trpspb3b01‹ƒS?	?
o5XXLetterPRIV?0''''ƒ\KhCïê÷E???"	5XX????U}?}Ä} }@}?}@}@+'} 	'}		@	)}

 )} .}}

Ä'}'} '}`)}Ä}
)}'@}((?}))@}**Ä}++},,'}--Ä'}.. '}//@'}08 (}99Ä	(}::Ä};;?}<<
}=?Ä'}@@?@@?@@í?2@:Ä7@í?7@í?<@í?A@í?<@í?A	@í?<
@í?A@í?<@í?A
@í?<@í?A@í?<@í?A?
&?
&:?
&>?
&??
&0?
&?
&;?
&?
*?
	&/?

&<?
-=?
&9?

*?
&?
&?
&?
&?
&?
/B?
/?
/?
/ ?
/!?
/?
/?
/?
/"?
/#?
/$?
/%?
/&?
 /'?
!/(?
"/)?
#/*?
$/+?
%/,?
&/D?
'/@?
(/A?
)/C?
*+
?
++?
,'?
-'?
.'?
/'?
0(?
1(-?
2(.?
3(1?
4(2?
5(3?
6(4?
7(5?
8(6?
9(7?
:+8?
2`æ33445æ
33344æ",333366666666669æ=333??
7N?
7L?
8Mæ899:æ
88899æ",8888;;;;;;;;;;9æ=888?æ
88?
	9cæ

9:
8?
8
?
8
9?
7F9?
9-?
7.æ",8888;;;;;;;;;;9æ=888??
<I?
<O?
=Pæ=>>?æ
===>>æ",====@@@@@@@@@@9æ====?æ
BB?
	Ccæ

CD
B?
B
?
B
CC?
A-?
A.æ",BBBBEEEEEEEEEE9æ=BBB??
<Q?
<R?
=Sæ=>>?æ
===>>æ",====@@@@@@@@@@9æ====?æ
BB?
	Ccæ

CD
B?
B
?
B
CC?
A-?
A.æ",BBBBEEEEEEEEEE9æ=BBB??
	<T?
	<U?
	=Xæ	=>>?æ	
===>	>æ"	,====@@@@@@@@@@9æ	====?æ

BB?

	Ccæ


CD

B?

B
?

B

C
C?

A-?

A.æ"
,BBBBEEEEEEEEEE9æ
=BBB??
<V?
<W?
=Yæ=>>?æ
===>>æ",====@@@@@@@@@@9æ====?æ
BB?
	Ccæ

CD
B?
B
?
B
CC?
A-?
A.æ",BBBBEEEEEEEEEE9æ=BBB??

<Z?

<\?

=^æ
=>>?æ

===>
>æ"
,====@@@@@@@@@@9æ
====?æ
BB?
	Ccæ

CD
B?
B
?
B
CC?
A-?
A.æ",BBBBEEEEEEEEEE9æ=BBB??
<[?
<]?
=_æ=>>?æ
===>>æ",====@@@@@@@@@@9æ====?æ
BB?
	Ccæ

CD
B?
B
?
B
CC?
A-?
A.æ",BBBBEEEEEEEEEE9æ=BBB?◊$®
,:tﬁƒﬁ∂ﬁ∂ﬁ∂ﬁ∂ﬁ∂ﬁ?P?H??0?(	?
?P>∂@ ?7≤=J????æ7	%*+?(??æ/	%*,?(ïæ/	%13?(?'æ/	%-0?(?

æ/	%49?(?

?	Sheet4
ThisWorkbook?????Sheet1	?????????Sheet4???? ?Module1????????????,È9	

????????!"#$%&'()*+,-./????123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno????qrstuvwxyz{|????~????Ä?ƒ??????=&?[??#?∂????????????????????????x??ME??????????ﬂ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????(SL????S????Sî????<??????N0{00020819-0000-0000-C000-000000000046}????8Ä????????(??????????%????H????????????????????????????????????????????????????????????????????????????????????????????ﬂ??????????x????∞∞Attribute VB_Name = "ThisWorkbook"

?Bas?0{00020P819-0C$0046}Å
|Global?SpacíFalsedCreatablPredêeclaId±Tru
BExposeTemplateDerivíBustomizD2?ƒ??????=&vK??#?∂????????????????????????x??ME??????????ﬂ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????(SL????S????Sî????<??????N0{00020820-0000-0000-C000-000000000046}????8Ä????????(??????????%????H????????????????????????????????????????????????????????????????????????????????????????????ﬂ??????????x????ç∞Attribute VB_Name = "She@et1"

?Bast0{000?20820- C$0046}
|Global!ƒSpacíFalsedCreatablPre declaId´Tru
BExposeTemplateDeriv$íBustomizD2?ƒ??????=&?:??#?∂????????????????????????x??ME??????????ﬂ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????(SL????S????Sî????<??????N0{00020820-0000-0000-C000-000000000046}????8Ä????????(??????????%????H????????????????????????????????????????????????????????????????????????????????????????????ﬂ??????????x????ç∞Attribute VB_Name = "She@et4"

?Bast0{000?20820- C$0046}
|Global!ƒSpacíFalsedCreatablPre declaId´Tru
BExposeTemplateDeriv$íBustomizD2]?X]?x? ,.*  ? ∑?0 .B@? ,.&]??∂not defined'2 &∂Main$4?∂Main &%6B@8∂C2 :%<!>'2k??è]?∞ &$B'@ 2∂1.*? & * @A@Dd??h]?? H J'F∂RUnsupported cenrep sheet template selected as source. Only supporting versions 1.* FA@Lk????B******************************************************************?H Set the validation as specified in the template (the copy overrides the? validation settings)?B******************************************************************? variant name column∂K2:K @¨2∂
Key values *%6%<!NB@P¶ T?l X?V∂=$BA$1:$BF$1?Z∂K2:K @¨2∂
Key values *%6%<!NB@R∑∂K2:K @¨2∂
Key values *%6%<!N(\∑∂K2:K @¨2∂
Key values *%6%<!N(^? Key type column∂N2:N @¨2∂
Key values *%6%<!NB@P¶ T?l X?V∂=$AT$1:$AW$1?Z∂N2:N @¨2∂
Key values *%6%<!NB@R∑∂N2:N @¨2∂
Key values *%6%<!N(\∑∂N2:N @¨2∂
Key values *%6%<!N(^? Read Only column∂M2:M @¨2∂
Key values *%6%<!NB@P¶ T?l X?V∂=$AQ$1:$AR$1?Z∂M2:M @¨2∂
Key values *%6%<!NB@R∑∂M2:M @¨2∂
Key values *%6%<!N(\∑∂M2:M @¨2∂
Key values *%6%<!N(^? Backup and RFS columns∂O2:P @¨2∂
Key values *%6%<!NB@P¶ T?l X?V∂=$AQ$1:$AR$1?Z∂O2:P @¨2∂
Key values *%6%<!NB@R∑∂O2:P @¨2∂
Key values *%6%<!N(\∑∂O2:P @¨2∂
Key values *%6%<!N(^? customer config column∂Q2:Q @¨2∂
Key values *%6%<!NB@P¶?\?∞????f?+=&???∂????????????????????????x??ME??????????ﬂ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????(<??(<??h
<??<<?????????? ?????????????????????????????QQÑ@Ñ ?????????? Ñ&????????p% Ñ*????????êx%`Ñ2??????????`Ñ@??????????@ÑF??????????+4????????????????? ???????)?b????????@HÄ'2%i?d??????????????Ä∂ Ñf????????Ä *%Dè???????????????????????22?)?&??????????Ä%)?*????????Ä%i?@??????????????Ä Ñt????????P% Ñv????????p% Ñx????????ê% Ñz????????∞%+|ê????????????????∏@????Ñ)?Ü???????? Ä%i????????????????Ä%`Ñ–??????????`Ñ???????????`Ñê??????????B???????????????????????????++?)?b?????????????Ä% Ñî????????x% Ññ????????0% Ñ?????????P% Ñ????????p% Ñ?????????ê% Ñ˛????????∞% Ñ ?????????% Ñ§?????????%?????è?ê?????????????????????????????????ê????????????????????????????????????????????????????????????????∏?(QCﬂ???Ä	@"Å@ÄHÅ0PÄ	????ÅÄÄêÄ?Ä	????Å
 Å∞Å
?Ä	????Ä®Å?Å∏ÅÅ(Å@Ä	????ÄHÅPÅ`ÅxÅêÄ?Å Å`∞Å	Ä		????Ä	HÄ	N`Ä	∞Ä	H?Ä	????Ä	Å<8ÅhxÅ<?Å< Ä		????Ä	`Å<xÅhèÅ< Å<`Ä		????Ä	 Å<èÅh∏Å<`Å< Ä		????Ä	?Å<Åh@Å<çÅ<?Ä		????Ä	(Å<HÅh?Å<?Å<0	Ä		????Ä	p	Å>ê	Åj?	Å>@
Å>Ä
Ä		????Ä		????Å	?
Å	?
Å	∏
Å
Å Å(Ä	V0Ä	F?Ä	B?Ä	VBÅpÄ	????ÅxÄÄÅ?Å ÅèÅ?Å
?Å®Ä	????Ä	V?Ä	28
Ä	Vp
BÅ?
Ä	????Ä	6®
Ä	Ä	6(Ä	`Ä	ÄÅbêÅb∏Åb`Åd?Ä	????Ä	*0Å2`Å2?Å2?Å2Å4@Å4xÅ4∞Å4?Ä	????Ä	" ÄHÄPÄXÄ`Ä	????Å0hÅ8?Å0?Å8Ä	????Å8ÅHÄ	????Ä	XÅxÅTêÅ
?Ä	????Ä	6∏ÅR0ÅV?Å?Ä	????Ä	????Ä	V?Ä	T@Ä	V?BÅ?Å∏ÄÄÅ Å0ÅHÅ*PÅÄÅ?Ä?Å  Å?Å*?ÅÅÅ
Å Ä	????BÅ(Ä0Ä8Ä@ÄHÄPÄXÄ`Ä	????ÅhÄ	????Ä	:?Å?Å?ÅÅ(ÅHÅhÅ$?Ä	????Å∞Ä	????ÅèÄ?Å?Å0??ÅÄÅ?Å>?Å®Å?Å?Å?ÅÅÄ	????ÅÅ(Å0Å
8ÅHÄ	????Ä	????????X?:/ Function to import for previous interface sheet versionsñ]?@∂Excel Workbook (*.xls), *.xls "%$'   ∂? T?l X?V∂=$AQ$1:$AS$1?Z∂Q2:Q @¨2∂
Key values *%6%<!NB@R∑∂Q2:Q @¨2∂
Key values *%6%<!N(\∑∂Q2:Q @¨2∂
Key values *%6%<!N(^? capabilities columns∂T2:AN @¨2∂
Key values *%6%<!NB@P¶ T?l X?V∂=$AX$1:$AZ$1?Z∂T2:AN @¨2∂
Key values *%6%<!NB@R∑∂T2:AN @¨2∂
Key values *%6%<!N(\∑∂T2:AN @¨2∂
Key values *%6%<!N(^∂
Key values *%`B@8∂A2 :%<B@H∂Main *%`B@8 &B@Bk??®o????P\ ******************************************************************************??\ Checks if the given id exists as sheet in the given workbook.?;\ There migth be a function for this, but I do not know it.?P\ ******************************************************************************ñ?∑'4]?h? f? b!6ì f! d?∑'4k??8? f??i?? ?P\ ******************************************************************************?,/ Copy the information from source to target?P\ ******************************************************************************¶ñ??0************************************************? Key values-tab?0************************************************? Copy the data columns.?	
& rowCount¶∂A2∂
Key values *%6%<?l∂A2:B @∂
Key values &%6%<B@j¶∂E2∂
Key values *%6%<?l∂C2:O @∂
Key values &%6%<B@j¶∂S2∂
Key values *%6%<?l∂P2:Q @∂
Key values &%6%<B@j¶∂U2∂
Key values *%6%<?l∂T2:AK @∂
Key values &%6%<B@j?$ Copy the formats to the new columns∂A2:A @∂
Key values *%6%<B@j r?p∂C2∂
Key values *%6%<B@n r?p∂D2∂
Key values *%6%<B@n r?p∂R2∂
Key values *%6%<B@n r?p∂AM2∂
Key values *%6%<B@n r?p∂AN2∂
Key values *%6%<B@n r?p∂AO2∂
Key values *%6%<B@n r?p∂AP2∂
Key values *%6%<B@n? setting some column widths]?8]?X]?x]???∂
Key values *%6∂Key Int$|.t?∂
Key values *%6∂Shared Data Name$|.v?∂
Key values &%6∂Key Int$|.x?∂
Key values &%6∂Shared Data Name$|.z x!~ t(~ z!~ v(~? setting the row heigth? Ä?¨ @í¶ Ä∂
Key values &%6%Ç!Ñ Ä∂
Key values *%6%Ç(Ñ? Ä???/ copy the version history and owner information¶
∂C6∂Main *%6%<?l∂C6:C7∂Main &%6%<B@j¶
∂B12∂Main *%6%<?l∂B12:F50∂Main &%6%<B@ji???P\ ******************************************************************************?N/ function gets a column range from the given sheet based on the "column name"?P\ ******************************************************************************ñè? d?¨¨2í]?H]?` d¨	?¨A d$ﬁ'–d??∞	∂A¨A d¨$ﬁ∂1'–k??x	 –∂1'?]?x¨ ? Ü%<%í!>'ê ? ê?? –∂2 –∂3000 Ü%<.|y??∏k???? d??i??®ñê]?∏]?]?8]?X]?x]??]?è∂
Key values b%6B@8?4\ The column order for the sheet is hard coded here.? :∂Uid Name$|.î? :∂	Uid Value$|.ñ? :∂Range To$|.?? :∂
Range From$|.? :∂Key Name$|.?? :∂Key Int$|.˛? :∂Platform Release$|. ¨'B¨'¢]?®? §? î!íì¶
#.8 B î%í!>∂ B ñ%í!>∂ B ?%í!>∂ B ˛%í!>∂ B  %í!>∂?¨'¢ ?∞e¶
 B ?%í!>∂ B %í!>∂?¨'¢k??d?? ¢¨'¢k??∏ B¨'B ¢¨

?y???k???? §??i??∞????ç????µAttribute VB_Name = "Module1"
'/ Function to import for previous interface shee@t vers\s 
Subb()
 Dim ?file?"vÄApplicak.GetOpen
F+nî("Excel Workbook (*.@xls), "^RIfc <> "" ThenÑsource`Wb As*ãt`argetëáS#wÜ= AÄìvegÖQÖs.ÅiN:=~, ReadOnly:=Tr¸ueã0ÜU?0Å¨Ç?ñV?lS?ngá–Ûnot de?finedÄzÅF?ÅÄO(doesSAs@Exist(E ,ÅÄÜain"))?T?
	.Å;Çs("?MÇ.BFat6BA≈+7Ç.Range("C2").ValâDEnd8 IfG5G?@ro@wCount??I1@¶ger= ??vRÑ
Ü7DëÅ&A–KLike "1.?*"?>?≈A´1 KÖÜ, á"Els?LCBptyl
IÅ@?vbOKA? + @vbCritÄ?l?-MsgBoxÄ "Unsup?ed cenreÇpÑøtemplÄaÄ selectÄdas‰. Çingøx Å, s?L?0 g'*<?	 ¢lhe va0lidaBë?pe?cifi`i@ì?	Ü(t copy o`ërides @I
H	sett??s???º**á
1?ria`SA cpolum?í?E?gKƒey?uesaÑbÄK2:K" &ÜJô B50?dƒ#.D?;âm__#/.add _g?NType0:=xl?t?eL Ü, AlertSaFfDop, Formula1:="=$BA$?1:$BF$??Xa__DIgnoÄreBlank?h?´ﬂﬂ≈nCellDropdow÷n.
Èc ?:t?&?@ÜtÄçë@N2:N?@w?@?Kù ¸%O O s˛tO ?;O C ATA ¸AWO 0x/1!a(1/?-O G,O O?hon?O πkJ 1SWù@≥á?|M2:M_ sù@?ì5??≤ùΩ_ _ ù_ bB_ T QR R_ o_ ?Q/?gù@s ? ????Ü+n_ _ r' Backup aP?RFS?A?≥o	∞ùeïA("?O2:P? ? /o&?l&ù? ? ? ? haˆA? Oe?Qì£/-?A???O?xI? ? ¥ customÑerP nfigƒ áo	o	l	Q2:Q? ?? ùùùù? ? ˜? ? ? SAAAﬂ?? A88zôon? ? µ apabilopæ?´b_Ab??T2:A?Ç˜?¥on.Delete
 targetWb.Worksheets("Key values").Range("T2:AN" & rowCount + 50).Va@lidati∂a0dd _¥?Ty@pe:=xlHeList, AlÄertStylop, Formula1:="=$AX$1:$ AZ$1"S≥IgnoreBlanÄk = Tru??InCellDr@opdown5 õÜ?Së?Actçivaâø 	eÇ)‹A2?S?ctaô,Main
?s ource@?ClosDGEnd If
?Sub
?
'\ *?HÇChecks if the given id eÇxÄës as ¨( in?w?±book.BThere migth be a funÅ@Mon for@
is, but I do not know itáC4I
Pr?kÑ F!doeskEÅ4(wb As6 A?A0,?:?St ring)ÅBoÄolean
Cr#ãïFalÖhDi?m ws≈J
?k  Each?In wI#A?If (ws.Name??
id) @)ae??gÖD?Nex?t#F≈?G?0*Å?>/ CopybB$in?<?◊A2:B	◊).l+Destin?a!E:=?1Ä´_?ﬁÈC2:O__?1@∑ıE_o("P®2:Q/	¸| /	??Ω??S/	e/á/áK?	o?	?????U:	7'?C£Cs?B?gnew?≈)??"?ì?ìP(A??/'??CÄ.PasteSpecixal ?añÇ?ìa‹ts???D?aﬂ?Ö9???R????o©˛4AMùùù?ùùNùùùùùæOùùùùùPùù©ó"' setPPg`rpìX width∏$ëÖkey??ÅInT??Qk?G∑QsharedDxata?p!?&S?ß/ /In??)ôáSe ?º
= ?ô?
s(,,, ????u"?ua?
ë??íﬂW?7î7?S2 A ?Qmm?/pﬂ±^ﬂê≥´tﬂ/'&'ﬂe??W6”"?w!~Wq%???'ﬂ??MC
?KßW/QØ ï t£Üê?If (id < 2Ä6) Thená?¢ÇUÑ= Chr(65 + id!H?ElseY
"AH" &… -B&x "1Ä`Å?êI?fÇÇ-=J9?
A??t
InS?áRL=?ÜD?F).Cells(1).?Valuç?$d 1?´	?&Set?> "?G…
d*Ä2",?300 sß?#xit `Aß	&Next9 2
Å…p≤QowCount(wb?a%ÅQbookD:*∏uid"/ J(Q$B#?L?(@T?"Fas1okeyT
 Int
platRel(?"w+ÆKey? v?8s ?Aì?r#£î ^%?ord`h?π?ÑCuis h(ard@d@?heère.C?;Ö$=(|Ö?e?P, "U k?ÅÂ≥§(?bÈb(? +◊?1`ÑÆ"/?Å?)Â2˜?+≠d6õ :∑)
≈9óP>??  >?e π?c1?R$Z m1?£empty?ÑßYs@≠leItem,L?VEacƒh In ?Bo”a9ÅA?(?dD <> "" Or? õ~pbTG??!¸  ¥ó
 ”?ooj{l?£
{QR ?vó?dQN?otsQ@/Is ??h?qNj??1/
ù
?
??	≤?/ﬂ?o?ù?YZ?ﬂrΩ?+ ?-?@ñ9r(# /?já	±?> 10?
∏  E?f??f2g
_VBA_PROJECT????????????0?dir????????????p
PROJECTwm????????????}kPROJECT
????/?ay?		‰?*\G{000204EF-0000-0000-C000-000000000046}#4.0#9#C:\PROGRA~1\COMMON~1\MICROS~1\VBA\VBA6\VBE6.DLL#Visual Basic For Applications*\G{00020813-0000-0000-C000-000000000046}#1.5#0#C:\Program Files\Microsoft Office\OFFICE11\EXCEL.EXE#Microsoft Excel 11.0 Object Libraryè*\G{00020430-0000-0000-C000-000000000046}#2.0#0#C:\WINNT\System32\STDOLE2.TLB#OLE Automation
*\G{2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}#2.3#0#C:\Program Files\Microsoft Office\Office\MSO9.DLL#Microsoft Office 9.0 Object Library?*\G{0D452EE1-E08F-101A-852E-02608C4D0BB4}#2.0#0#C:\WINNT\system32\FM20.DLL#Microsoft Forms 2.0 Object Library?*\G{B6FEFBBD-BDE8-42C4-AE1E-D8CA472AAF02}#2.0#0#C:\Temp\VBE\MSForms.exd#Microsoft Forms 2.0 Object Library?.E
??Ö.`?M¥
?????????(QC????????????????????????????????????????????????????????=&ThisWorkbook01465ea1c4??ThisWorkbook???[%??Sheet102465ea1c4??Sheet1??vK%??Sheet403465ea1c4??Sheet4???:0%??Module104465ea1c4??Module1???H?+??????h????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????0????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????H6jπz?E??©?[4????/≥ﬁp?C≤CãO??>????i?i'bıA?
?˛U?≤????
ı?t???I§…?|uì?
????????ÄRS?h0ExcelÄ+VBA˜?Win16?~Win32Mac≥≤VBA6≠#
VBAProjectæ?stdoleì`OfficeuMSFormsCThisWorkbook|?	Ä?_Evaluate?Sheet1?Sheet4?Module1bimporti≈fileNamej?Application?*GetOpenFilename]?sourceWbQÈWorkbookktargetWb??ActiveWorkbook¢	WorkbooksB?ReadOnly4<sheetVersion	doesSheetExist§?
Worksheetsº∏Activateó|ActiveSheet%NRange?Value‰KrowCountugetRowCount?importFile1Qîstyle≈pvbOKOnlyı≤
vbCritical+}MsgBoxóR
Validation
æDeleteèxadd˜rxlValidateListƒ§
AlertStyle7xlValidAlertStop?’Formula1í?IgnoreBlankRëInCellDropdown9…Sheets
wbÖ_id¶]wsñ_	Worksheet??CopyØ?Destination?ªPasteSpecialæKPaste?xlPasteFormatsõ?keyNameInTarget?"sharedDataNameInTarget%?keyNameInSource^ísharedDataNameInSourceÅH	getRangesAóColumnWidthõﬂrowNbr≥ORows?U	RowHeight”sheet[÷colNameÄërangeLetter	rangeName’ChrK~colNameInSheet?yCells?uidName;øuidValuen?rangeTo?	rangeFrom?keyName??keyIntplatRel9
emptyRowCount?m
singleItem¸??x????????????????????????????	??????????????????????????????????????????????
H≥Ä0*ê	pHÇd‰
VBAProje?ct4@j
=
r	?(QCîJ<
rÄstdole>stdoÄle
f%\*\G{00Ä020430-C
0046}#2.0#0#C:\WINNT\System32\STDOLÄE2.TLB# Automat8ion^?DOf(ficÑDOÄ>fçicÇD?ÄÖÄÅD2DF8D04C-5BFA-101B-BDE5©ÄDAAÄB4Ä2?DÄógram Files\Micr@osoft 6\MSO9.DLL#
 9.0 Obπ LibraryÄCÄMSForms>SFÄ˛rms3	ÄÇ?D452EE1-E08FÅXA-8-02608C4D0BB4?Ns≈NFM260?&? [L&/?;Ä!1?Ç?eâlAA?l00}#0Çl#G?Ä50?Ä	j?AB6FEFBBD`8-42C4-AE1E-D8CA472AAF0âbTemp\VBE\DM.exd\U5Ä?.E
??Ö. `?M¥????=&±ThisWorkÄbookG??ThÄísWgkb?ok*?2??
HB1’%B,?!?["B+B?ShePet1G?S@#eqÄµt1@ Å?£2ßÆ?
Å?vK?
4?
?4È
4?
4?
?
?:?
?`odul÷e?`o ?u¢?A?2e	ù?@'≠*(?!ç*bThisWorkbookThisWorkbookSheet1Sheet1Sheet4Sheet4Module1Module1ID="{1B5B3A46-2CB4-4D7D-8C5B-E71D5E0D7526}"
Document=ThisWorkboÅÇ?ÑÖÜá????â–ã?????ﬁ?êëíìîïñó?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????ok/&H00000000
Document=Sheet1/&H00000000
Document=Sheet4/&H00000000
Module=Module1
Package={AC9F2F90-E877-11CE-9F68-00AA00574A4F}
Name="VBAProject"
HelpContextID="0"
VersionCompatible32="393222000"
CMG="0507F2FBF204F604F604F604F6"
DPB="0A08FDFA03FB03FB03"
GC="0F0DF801F803FC04FC0403"

[Host Extender Info]
&H00000001={3832D640-CF90-11CF-8E43-00A0C911005A};VBE;&H00000000

[Workspace]
ThisWorkbook=0, 0, 0, 0, C
Sheet1=0, 0, 0, 0, C
Sheet4=0, 0, 0, 0, C
Module1=0, 0, 0, 0, C
SummaryInformation(????
??????DocumentSummaryInformation8?????????????CompObj????????????ôm???????????????Ö???Oh´ë+'≥?0ƒHPhÄ?§
∞º‰Jukka RantakariJari LaaksonenMicrosoft Excel@ºWDaÄƒ@Ä&§óq?@$?Üd?Ø??’?’?.ìó+,?ÆD’?’?.ìó+,?ÆP	PXhpxÄ?
ê?‰NokiadMainKey values'Key values'!Print_AreaWorksheets
Named Rangesè 8@_PID_HLINKS‰ApQ}"mailto:jari.j.laaksonen@nokia.comQ}"mailto:jari.j.laaksonen@nokia.com_ #mailto:dmitry.kolesnikov@nokia.com??
???? ?F!Microsoft Office Excel WorksheetBiff8Excel.Sheet.8?9≤q
scutplugin.confml
??<?xml version="1.0" encoding="UTF-16"?>

<configuration xmlns="http://www.s60.com/xml/confml/1" name="scutplugin">

  <feature ref="KCRUidShortcutItems" name="KCRUidShortcutItems">

    <desc>AI Shortcut plug-in settings. The interface provides access to the default and user-defined shortcuts.</desc>

  </feature>

</configuration>

scutplugin_10275104.crml
??<?xml version="1.0" encoding="UTF-16"?>

<repository xmlns="http://www.s60.com/xml/cenrep/1" uidName="KCRUidShortcutItems" uidValue="0x10275104" owner="0x102750F9" backup="true" rfs="true">

  <access type="R" capabilities="AlwaysPass"/>

  <access type="W" capabilities="WriteDeviceData"/>

  <access type="R" capabilities="AlwaysPass"/>

  <keyRange firstInt="0x00000001" lastInt="0x0000FFFF" backup="true">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </keyRange>

  <keyRange firstInt="0x80000001" lastInt="0x8000FFFF" backup="true">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </keyRange>

  <keyRange firstInt="0x01000000" lastInt="0x0100FFFF" backup="true">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </keyRange>

  <keyRange firstInt="0x81000000" lastInt="0x8100FFFF" backup="true">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </keyRange>

  <keyRange firstInt="0x02000000" lastInt="0x0200FFFF" backup="true">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </keyRange>

  <keyRange firstInt="0x82000000" lastInt="0x8200FFFF" backup="true">

    <access type="R" capabilities="AlwaysPass"/>

    <access type="W" capabilities="WriteDeviceData"/>

  </keyRange>

</repository>

hs_app_aiscutextservu.def
EXPORTS
	_ZN14RAiScutExtServ11UpdateIconLERK8CGulIcon @ 1 NONAME
	_ZN14RAiScutExtServ14ResetPopupTextEv @ 2 NONAME
	_ZN14RAiScutExtServ16UpdatePopupTextLERK12MDesC16Array @ 3 NONAME
	_ZN14RAiScutExtServ19IssuePutInShortcutsEv @ 4 NONAME
	_ZN14RAiScutExtServ7ConnectEv @ 5 NONAME
	_ZN14RAiScutExtServ9ResetIconEv @ 6 NONAME
	_ZNK14RAiScutExtServ13IsInShortcutsERi @ 7 NONAME
	_ZNK14RAiScutExtServ7VersionEv @ 8 NONAME
	_ZN14RAiScutExtServ7ConnectERK7TDesC16 @ 9 NONAME

aiscutextserv.mmp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project definition file for AI Shortcut xSP Extension API
*
*/

#include 

TARGET                  hs_app_aiscutextserv.dll
TARGETTYPE              DLL
UID                     0x1000008D 0x10282CDD

CAPABILITY              ALL -TCB
VENDORID                VID_DEFAULT

SOURCEPATH              ../src
SOURCE                  hs_app_aiscutextserv.cpp

APP_LAYER_SYSTEMINCLUDE

LIBRARY                 euser.lib
LIBRARY                 efsrv.lib
LIBRARY                 bafl.lib
LIBRARY                 estor.lib
LIBRARY                 egul.lib 
LIBRARY                 fbscli.lib 

// End of File.
aiscutplugin.mmp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project definition file for project ShortcutPlugin
*
*/

#include 
#include 
#include 

//MACRO MY_DEBUG

//#include "../../../inc/common/debug.h"
//#define AI_ENABLE_RD_LOGGING
#define AI_RD_LOG_TO_DEBUG_OUTPUT

// Master flag for enabling xSP extensions
#define AI_SCUTPLUGIN_XSP_EXTENSIONS

TARGET                  hs_app_aiscutplugin.dll
TARGETTYPE              PLUGIN
UID                     0x10009D8D AI_UID_ECOM_DLL_CONTENTPUBLISHER_SCUTPLUGIN

CAPABILITY              CAP_ECOM_PLUGIN
VENDORID                VID_DEFAULT

SOURCEPATH              ../src

// xSP extension
#ifdef AI_SCUTPLUGIN_XSP_EXTENSIONS
SOURCE                  hs_app_caiscutengineext.cpp
SOURCE                  hs_app_caiscutextserver.cpp
SOURCE                  hs_app_caiscutextsession.cpp
SOURCE                  hs_app_caiscutshortcutext.cpp
SOURCE                  hs_app_PopupFSM.cpp
SOURCE                  hs_app_cpopupeventhandler.cpp
SOURCE                  hs_app_caiscutextdata.cpp
SOURCE                  hs_app_caiscutextdatamodel.cpp
SOURCE                  hs_app_aiscutfactoryext.cpp
USERINCLUDE             .
LIBRARY                 estor.lib
#else
SOURCE                  hs_app_aiscutfactory.cpp
#endif

SOURCE                  hs_app_caiscutplugin.cpp
SOURCE                  hs_app_caiscutengine.cpp
SOURCE                  hs_app_caiscutshortcut.cpp
SOURCE                  hs_app_caiscutshortcutinfo.cpp
SOURCE                  hs_app_caiscuttarget.cpp
SOURCE                  hs_app_caiscuttargetapp.cpp
SOURCE                  hs_app_caiscuttargetbkm.cpp
SOURCE                  hs_app_caiscuttargethttp.cpp
SOURCE                  hs_app_caiscuttargetkeylock.cpp
SOURCE                  hs_app_caiscuttargetmessagingview.cpp
SOURCE                  hs_app_caiscuttargetnewmsg.cpp
SOURCE                  hs_app_caiscuttargetempty.cpp
SOURCE                  hs_app_aiscuttargetshutter.cpp

SOURCE                  hs_app_taiscutparser.cpp
SOURCE                  hs_app_aidefaultshortcut.cpp
SOURCE                  hs_app_aiscutappuidparser.cpp
SOURCE                  hs_app_aiscutrepositorywatcher.cpp

START RESOURCE          hs_app_aiscutplugin.rss
TARGET                  hs_app_aiscutplugin.rsc
END

START RESOURCE          hs_app_aiscutpluginres.rss
HEADER
TARGET                  hs_app_aiscutpluginres.rsc
TARGETPATH              RESOURCE_FILES_DIR
LANGUAGE_IDS
END

START RESOURCE          hs_app_aiscuttexts.rss
HEADER
TARGET                  hs_app_aiscuttexts.rsc
TARGETPATH              RESOURCE_FILES_DIR
LANGUAGE_IDS
END

USERINCLUDE   ../../../inc/common
USERINCLUDE             ../inc

APP_LAYER_SYSTEMINCLUDE

LIBRARY                 euser.lib
LIBRARY                 cone.lib
LIBRARY                 ecom.lib
LIBRARY                 apparc.lib              // TApaTask
LIBRARY                 apgrfx.lib              // CApaAppListNotifier
LIBRARY                 viewcli.lib             // CVwsSessionWrapper
LIBRARY                 ws32.lib                // RWsSession
LIBRARY                 inetprotutil.lib        // TUriParser
LIBRARY                 centralrepository.lib   // CRepository
LIBRARY                 cenrepnotifhandler.lib  // CCenRepNotifyHandler
LIBRARY                 msgs.lib                // Message Server
LIBRARY                 muiu.lib                // MsvUiServiceUtilities
LIBRARY                 sendui.lib              // Send UI
LIBRARY                 egul.lib                // CGulIcon
LIBRARY                 aknskins.lib            // AknsUtils
LIBRARY                 charconv.lib            // CnvUtfConverter
LIBRARY                 avkon.lib
LIBRARY                 aknnotify.lib
LIBRARY                 featmgr.lib
LIBRARY                 hs_app_aiutils.lib
LIBRARY                 fbscli.lib
LIBRARY                 aknicon.lib
LIBRARY                 favouritesengine.lib
LIBRARY                 commonengine.lib        // For RConeResourceLoader
LIBRARY                 platformenv.lib         // For PathInfo
LIBRARY                 efsrv.lib
LIBRARY                 bafl.lib
LIBRARY                 imcm.lib 
LIBRARY 				akncapserverclient.lib 	// Fastswap  
#ifdef __WEB_WIDGETS
LIBRARY                 widgetregistryclient.lib
#endif
LIBRARY                 keylockpolicyapi.lib
LIBRARY			gfxtrans.lib
LIBRARY			akntransitionutils.lib
LIBRARY			gslauncher.lib

// Debugging dependencies
LIBRARY    flogger.lib

// End of File.
aiscutsettings.mmp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project definition file for project ShortcutPlugin settings
*
*/


#include 

#include 

#include 

//#include "../../../inc/common/debug.h"
//#define AI_ENABLE_RD_LOGGING
#define AI_RD_LOG_TO_DEBUG_OUTPUT

//MACRO MY_DEBUG

TARGET                  hs_app_aiscutsettings.dll
TARGETTYPE              PLUGIN
UID                     0x10009D8D AI_UID_ECOM_DLL_SETTINGS_SCUTPLUGIN

CAPABILITY              CAP_ECOM_PLUGIN
VENDORID                VID_DEFAULT

SOURCEPATH              ../src
SOURCE                  hs_app_caiscutsettings.cpp
SOURCE                  hs_app_caiscutsettingsimplementationtable.cpp
SOURCE                  hs_app_caiscutsettingscontainer.cpp
SOURCE                  hs_app_caiscutsettingsmodel.cpp
SOURCE                  hs_app_caiscutsettingsitem.cpp
SOURCE                  hs_app_caiscutsettingsapplist.cpp
SOURCE                  hs_app_caiscutsettingsbkmlist.cpp

SOURCE                  hs_app_taiscutparser.cpp
SOURCE                  hs_app_aidefaultshortcut.cpp
SOURCE                  hs_app_aiscutappuidparser.cpp
SOURCE                  hs_app_aiscutrepositorywatcher.cpp

START RESOURCE          hs_app_aiscutsettings.rss
TARGET                  hs_app_aiscutsettings.rsc
END

START RESOURCE          hs_app_aiscutsettingsres.rss
HEADER
TARGET                  hs_app_aiscutsettingsres.rsc
TARGETPATH              RESOURCE_FILES_DIR
LANGUAGE_IDS
END

USERINCLUDE       ../../../inc/common
USERINCLUDE             ../inc
USERINCLUDE       ../../../inc

APP_LAYER_SYSTEMINCLUDE

LIBRARY                 euser.lib
LIBRARY                 ecom.lib
LIBRARY                 avkon.lib
LIBRARY                 bafl.lib
LIBRARY                 cone.lib
LIBRARY                 efsrv.lib
LIBRARY                 eikcoctl.lib
LIBRARY                 eikcore.lib
LIBRARY                 cdlengine.lib
LIBRARY                 centralrepository.lib
LIBRARY                 cenrepnotifhandler.lib  // CCenRepNotifyHandler
LIBRARY                 gsframework.lib         // For base classes
LIBRARY                 gslistbox.lib           // For CGSListBoxItemTextArray
LIBRARY                 gsecomplugin.lib
LIBRARY                 commonengine.lib        // For RConeResourceLoader
LIBRARY                 inetprotutil.lib        // For TUriParser
LIBRARY                 apgrfx.lib              // For RApaLsSession
LIBRARY                 apparc.lib              // For TApaAppInfo
LIBRARY                 msgs.lib                // For Message Server
LIBRARY                 platformenv.lib         // For PathInfo
LIBRARY                 hlplch.lib              // for HlpLauncher
LIBRARY                 featmgr.lib             // For feature manager
LIBRARY                 favouritesengine.lib
LIBRARY                 javaregistryclient.lib  // For JavaRegistry
#ifdef __WEB_WIDGETS
LIBRARY                 widgetregistryclient.lib
#endif

// Debugging dependencies
LIBRARY           flogger.lib

// End of File.
backup_registration.xml
 

    
    

bld.inf
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Bld.inf for Shortcut Plugin.
*
*/


#include 

PRJ_PLATFORMS
DEFAULT

PRJ_EXPORTS
../loc/hs_app_ai3scutsettings.loc             MW_LAYER_LOC_EXPORT_PATH(hs_app_ai3scutsettings.loc)
../loc/hs_app_ai3scutplugin.loc               MW_LAYER_LOC_EXPORT_PATH(hs_app_ai3scutplugin.loc)

../rom/hs_app_aiscutplugin_resources.iby	  LANGUAGE_MW_LAYER_IBY_EXPORT_PATH(hs_app_aiscutplugin_resources.iby)
../rom/hs_app_aiscutplugin.iby			      CORE_MW_LAYER_IBY_EXPORT_PATH(hs_app_aiscutplugin.iby)


// Backup registration
backup_registration.xml  /epoc32/data/z/private/102750f9/backup_registration.xml
backup_registration.xml  /epoc32/release/winscw/udeb/z/private/102750f9/backup_registration.xml
backup_registration.xml  /epoc32/release/winscw/urel/z/private/102750f9/backup_registration.xml

// Generic configuration interface for component cenrep settings
../conf/scutplugin.confml                  APP_LAYER_CONFML(scutplugin.confml)
../conf/scutplugin_10275104.crml           APP_LAYER_CRML(scutplugin_10275104.crml)

PRJ_EXTENSIONS

START EXTENSION s60/mifconv
OPTION TARGETFILE aiscutplugin.mif
OPTION HEADERFILE aiscutplugin.mbg
OPTION SOURCES -c8,8 qgn_prop_ai_shortcut -c8,8 qgn_menu_url \
               -c8,8 qgn_menu_mce_sel_mes -c8,8 qgn_menu_mce_syncmail \
               -c8,8 qgn_menu_am -c8,8 qgn_prop_cp_conn_shortcut \
               -c8,8 qgn_prop_psln_ai_sub
END

PRJ_MMPFILES
aiscutsettings.mmp
aiscutplugin.mmp
aiscutextserv.mmp

// End of File.
hs_app_aidefaultshortcut.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Platform default shortcuts.
*
*/


#ifndef AIDEFAULTSHORTCUT_H
#define AIDEFAULTSHORTCUT_H

#include  // for TInt
#include  // for TUid, TDes


class TAiDefaultShortcut
{
public:
    /**
     * Get S60 platform default shortcut uid and definition for index aIndex.
     *
     */
    static void GetDefaultShortcut(TInt aIndex, TUid& aUid, TDes& aDefinition);

};

#endif
hs_app_aiscutapptitle.rh
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in app title structs.
*
*/


#ifndef AISCUTAPPTITLE_RH
#define AISCUTAPPTITLE_RH

STRUCT AI_APP_TITLE_ITEM
{
    LONG    appuid;
    LONG    viewid = -1;
    LTEXT   longtitle  = "";
    LTEXT   shorttitle = "";
    LTEXT   skeytitle  = "";
    LTEXT   msktitle   = "";
}

STRUCT AI_APP_TITLE_LIST
{
    STRUCT items[]; // AI_APP_TITLE_ITEM items.
}

#endif // AISCUTAPPTITLE_RH

// End of File.
hs_app_aiscutappuidparser.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut definition parser.
*
*/


#ifndef AISCUTAPPUIDPARSER_H
#define AISCUTAPPUIDPARSER_H

// INCLUDES
#include 

// CLASS DECLARATIONS

/**
 * Parser class that interpretes the given text as a description of
 * application position data.
 */
class TAiScutAppUidParser
{
public: // Construction

    /**
     * Standard C++ constructor.
     * @param aData Data which will be parsed
     * @param aAppPositions This array will be filled with parsed
     *                      application positions.
     */
    TAiScutAppUidParser(const TDesC& aData, RArray& aAppPositions);

public: // Interface

    /**
     * Parses the data that was given in constructor and fills the
     * application position array with parsed data.
     */
    void ParseL();

private: // Implementation
    /**
     * Skips the given char.
     * Skipping can be done conditionally or unconditionally.
     * If conditional skipping is used, next character in data will be
     * skipped only if it is the same as given character.
     * If unconditional skipping is used the next character in data must
     * be the given character, otherwise the data is invalid and parsing
     * will be stopped.
     * @param aChar Character that will be skipped.
     * @param aConditionalSkip If ETrue, use conditional skipping,
     *                         otherwise unconditional skipping will be
     *                         used.
     */
    void SkipChar(TChar aChar, TBool aConditionalSkip);

    /**
     * Reads app UID from data. If data doesn't contain app UID in the
     * point in which this function is called, data is considered invalid.
     * @return App UID that was read from data.
     */
    TUid ReadAppUid();

private:

    /// Ref: Application positions array that will be filled when parsing
    RArray&   iUidArray;

    /// Lexer for data
    TLex            iLex;

    /// Is the data that has been read so far valid.
    TBool           iLexIsValid;
};

#endif // AISCUTAPPUIDPARSER_H

// End of File
hs_app_aiscutfactory.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in factory class.
*
*/


#ifndef AISCUTENGINEFACTORY_H
#define AISCUTENGINEFACTORY_H

#include 

class CAiScutEngine;
class CAiScutPlugin;
class CAiScutShortcut;

/**
 *  AiScutEngineFactory
 *
 *  Creates various classes used in AiScutPlugin.
 *
 *  @since S60 v3.2
 */
class AiScutFactory
    {
    public:
        /**
         * Creates CAiScutEngine
         * @since S60 v3.2
         */
        static CAiScutEngine* CreateAiScutEngineL( CAiScutPlugin& aPlugin );

        /**
         * Creates CAiScutShortcut
         * @since S60 v3.2
         */
        static CAiScutShortcut* CreateAiScutShortcutL( TInt aId, 
            const TDesC& aTarget, CAiScutEngine& aEngine );

        /**
         * Creates CAiScutShortcut
         * @since S60 v3.2
         */
        static CAiScutShortcut* CreateAiScutShortcutLC( TInt aId, 
            const TDesC& aTarget, CAiScutEngine& aEngine );
    };

#endif // AISCUTENGINEFACTORY_H

// End of File.
hs_app_aiscutpluginprivatecrkeys.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut Plug-in private CenRep keys.
*
*/


#ifndef AISCUTPLUGINPRIVATECRKEYS_H
#define AISCUTPLUGINPRIVATECRKEYS_H

#include 

#endif // AISCUTPLUGINPRIVATECRKEYS_H

// End of File.
hs_app_aiscutrepositorywatcher.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut definition parser.
*
*/


#ifndef AISCUTREPOSITORYWATCHER_H
#define AISCUTREPOSITORYWATCHER_H

// INCLUDES
#include 
#include         // For CCenRepNotifyHandler

// CLASS DECLARATIONS

class CAiScutRepositoryWatcher : public CBase, public MCenRepNotifyHandlerCallback
{
public:
    static CAiScutRepositoryWatcher* NewL(
        const TUid aUid,
        const TUint32 aKey,
        CCenRepNotifyHandler::TCenRepKeyType aKeyType,
        TCallBack aCallBack,
        CRepository* aRepository);

    static CAiScutRepositoryWatcher* NewL(
        const TUid aUid,
        TCallBack aCallBack,
        CRepository* aRepository);

    ~CAiScutRepositoryWatcher();

    void StartListeningL();

    void StopListening();

    TUint32 ChangedKey();

public: // from MCenRepNotifyHandlerCallback
    void HandleNotifyInt    (TUint32 aKey, TInt aNewValue);
    void HandleNotifyString (TUint32 aKey, const TDesC16& aNewValue);
    void HandleNotifyGeneric(TUint32 aKey);
    void HandleNotifyError  (TUint32 aKey, TInt aError, CCenRepNotifyHandler* aHandler);

private:
    CAiScutRepositoryWatcher(
        const TUid aUid,
        const TUint32 aKey,
        TCallBack aCallBack,
        CRepository* aRepository);

    void ConstructL(CCenRepNotifyHandler::TCenRepKeyType aKeyType);

    void ConstructL();

private:
    TUid                    iUid;
    TUint32                 iKey;
    TUint32                 iChangedKey;
    TCallBack               iCallBack;
    CRepository*            iRepository;
    CCenRepNotifyHandler*   iNotifyHandler;

};

#endif // AISCUTREPOSITORYWATCHER_H

// End of File
hs_app_aiscutsettings.hrh
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Resource headers for Shortcut plug-in
*
*/


#ifndef AISCUTSETTINGS_HRH
#define AISCUTSETTINGS_HRH

/**
 * Menu command ids for the Shortcut plug-in Settings
 */
enum TAiScutSettingsMenuCommands
{
    EAiScutSettingsCmdChange = 0x6000,

    EAiScutSettingsCmdChangeToApps,
    EAiScutSettingsCmdChangeToUrl,
    EAiScutSettingsCmdChangeToBookmark,
    EAiScutSettingsCmdChangeShortcutType
};

/**
 * Shortcut setting types
 */
enum TAiScutSettingType
{
    EAiScutSettingTypeUndefined = -1,
    EAiScutSettingTypeApplication,
    EAiScutSettingTypeBookmark,
    EAiScutSettingTypeUrl
};

#endif // AISCUTSETTINGS_HRH

// End of File.
hs_app_aiscuttargetshutter.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#ifndef CAISCUTTARGET_H
#define CAISCUTTARGET_H

#include 
#include 

class TApaTask;
class CPeriodic; 

/**
 *  Base class for shortcut targets
 *
 *  @since S60 v3.2
 */
class CAiScutTargetShutter : public CActive
{

public:
	
	static CAiScutTargetShutter* NewL( CCoeEnv* aEnv, TUid aAppUid, TBool aIsRunning, TBool aIsDialog );

    virtual ~CAiScutTargetShutter();
    
     void StartL();
 
private:

	CAiScutTargetShutter( CCoeEnv* aEnv, TUid aAppUid );
    
    void ConstructL( TBool aIsRunning, TBool aIsDialog );

    // from base class CActive

    /**
     * From CActive
     *
     * @since S60 v3.2
     */
    void DoCancel();

    /**
     * From CActive
     *
     * @since S60 v3.2
     */
    void RunL();

    /**
     * From CActive
     * Handles an error situation
     *
     * @since S60 v3.2
     * @param aError Error code received from system
     * @return Error code after error handling
     */
    TInt RunError( TInt aError );
    
    static TInt TaskExistsCallback( TAny* aPtr );
    
    static TInt TaskNotExistsCallback( TAny* aPtr );
    
    void Run();
    
private: //data

	/**
     * Pointer to the control environment
     * Not own.
     */
    CCoeEnv*	iEnv;
	
	/**
     * Target application uid
     */
    TUid		iAppUid;
    
    /**
     * Window Server session
     */
    RWsSession 	iWsSession;
    
    /**
     * Task exsit or not
     */
    TBool iTaskExists;
    
    /**
     * Periodic timer
     * Own
     */
    CPeriodic* iPeriodic;
    
    /**
     * Count retry times
     */
    TInt iCounter;
    
    /**
     * Target application is running
     */
    TBool iIsRunning;
    
    /**
     * Target app is dialog
     */
    TBool iIsDialog;
    
    
    /**
     * 
     */
    TBool iTaskKilled;
};

#endif // CAISCUTTARGET_H

// End of File.
hs_app_caiscutengine.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in engine class.
*
*/


#ifndef CAISCUTENGINE_H
#define CAISCUTENGINE_H

#include                    // For MApaAppListServObserver
#include                      // For MMsvSessionObserver
#include                // For RFavouritesDb
#include        // For MFavouritesDbObserver
#include 
#ifdef __WEB_WIDGETS
#include 
#endif

#include 

#include "aiscutdefs.h"
#include "hs_app_taiscutparser.h"
#include "aicontentpublisher.h"

class CCoeEnv;
class CVwsSessionWrapper;
class CActiveFavouritesDbNotifier;
class CAiScutPlugin;
class CAiScutShortcut;
class CRepository;
class CAiScutRepositoryWatcher;
class CAiScutTargetShutter;
class CKeyLockPolicyApi;

/**
 * Defines the different scenarios of shortcut access checking.
 */
enum TScutAccessCheckType
{
    EScutCheckMailbox,
    EScutCheckApp,
    EScutCheckBkm,
    EScutCheckAll
};

/**
 * Defines which default can be used, when daulting is needed (uninstall/mem card removed)
 */
enum TScutDefault
{
    EScutUserDefined = 0,
    EScutDefaultToPlatform,
    EScutDefaultToTheme
};

enum TScutLockKey
    {
    EScutFirstLockKey,
    EScutSecondLockKey
};

/**
 *  Shortcut plug-in engine class.
 *
 *  Handles most of plug-in activity.
 *
 *  @since S60 v3.2
 */
class CAiScutEngine : public CBase
                    , public MMsvSessionObserver
                    , public MApaAppListServObserver
                    , public MFavouritesDbObserver
{

public:

    /**
     * First phase contructor.
     *
     * @since S60 v3.2
     * @param aPlugin Reference to the main plug-in class
     */
    static CAiScutEngine* NewL(CAiScutPlugin& aPlugin);

    virtual ~CAiScutEngine();

    // from base class MMsvSessionObserver

    /**
     * Handles an event from the message server
     *
     * @since S60 v3.2
     * @param aEvent Indicates the event type.
     * @param aArg1 Event type-specific argument value
     * @param aArg2 Event type-specific argument value
     * @param aArg3 Event type-specific argument value
     */
    void HandleSessionEventL(
        TMsvSessionEvent aEvent, TAny* aArg1, TAny* aArg2, TAny* aArg3);

    // from base class MApaAppListServObserver

    /**
     * From MApaAppListServObserver.
     * Handles a change in the application list
     *
     * @since S60 v3.2
     * @param aEvent Event id
     */
    void HandleAppListEvent(TInt aEvent);

    /**
     * Resumes the engine
     *
     * @since S60 v3.2
     */
    virtual void ResumeL(TBool aPublishAll, TAiTransitionReason aReason);

    /**
     * Suspends the engine
     *
     * @since S60 v3.2
     */
    void Suspend();

    /**
     *
     */
    static TInt HandleShortcutsChanged(TAny* aPtr);

    /**
     *
     */
    static TInt HandleHiddenAppsChanged(TAny* aPtr);

    /**
     *
     */
    TBool IsHidden(const TUid& aAppUid) const;

    /**
     * Handles an event sent by the AI framework
     *
     * @since S60 v3.2
     * @param aEvent Event (service) id
     * @param aParam Event parameter(s)
     */
    virtual void HandleAiEventL(TInt aEvent, const TDesC& aParam);

    /**
     * Called by the timer. Retries the access check for shortcuts.
     *
     * @since S60 v3.2
     */
    void RetryAccessCheck();

    /**
     * Checks if application is midlet or widget.
     * @param aUid Application uid
     * @since S60 v3.2
     */
    TBool IsNonNative(const TUid& aUid);
    
    TBool IsHiddenFromFSW( const TUid& aAppUid );
#ifdef __WEB_WIDGETS
    /**
     * Ask client session if given UID is widget.
     */
    TBool IsWidget(const TUid& aUid);
#endif

    /**
     * Handles call state changes (non-static version).
     *
     * @since S60 v3.2
     */
    void HandleCallStateChange();

    /**
     * Merges the user defined shortcuts with the defaults.
     * @param aType  shortcut type
     * @param aRecreateAll forces the recreation of shortcuts
     * @since S60 v3.2
     */
    void MergeShortcuts(TShortcutType aType, TBool aRecreateAll);

    /**
     *Get Application title
     */
    TBool GetAppTitle(
        const TUid&         aAppUid,
        const TUid&         aViewId,
        TDes&               aTitle,
        TAiScutAppTitleType aType);

    /**
     * Returns the application architecture server session owned by the engine
     *
     * @since S60 v3.2
     * @return Reference to RApaLsSession
     */
    inline RApaLsSession& ApaSession();

    /**
     * Returns reference to the bookmark database owned by the engine
     *
     * @since S60 v3.2
     * @return Reference to RFavouritesDb
     */
    inline RFavouritesDb& FavouritesDb();

    /**
     * Returns the message server session owned by the engine
     *
     * @since S60 v3.2
     * @return Pointer to CMsvSession
     */
    inline CMsvSession* MsvSession();

    /**
     * Returns a pointer to view server session wrapper.
     *
     * @since S60 v3.2
     * @return Pointer to view server session wrapper
     */
    inline CVwsSessionWrapper* VwsSession();

    /**
     * Returns a pointer to the coe environment
     *
     * @since S60 v3.2
     * @return Pointer to coe environment
     */
    inline CCoeEnv* Env();

    /**
     * Creates the shortcuts merging the defaults with user defined ones.
     *
     * @since S60 v3.2
     */
    void CreateShortcutsL();

protected:


    /**
     * C++ constructor
     *
     * @since S60 v3.2
     * @param aPlugin Reference to the main plug-in class
     */
    CAiScutEngine(CAiScutPlugin& aPlugin);

    void ConstructL();

protected:

    /**
     * Merges the user defined shortcuts with the defaults.
     * Leaving version
     * @param aType  shortcut type
     * @param aRecreateAll forces the recreation of shortcuts
     * @since S60 v3.2
     */
    void MergeShortcutsL(TShortcutType aType, TBool aRecreateAll);

    /**
     * Checks shortcut accessibility. If the AppArc server or message server
     * respond that they are not ready, a timer is launched to check later.
     *
     * @since S60 v3.2
     * @param aCheckType Specifies which kind of shortcuts should check its access
     * @param aPublishAll All shortcuts are published
     */
    void CheckAccessAndPublish(TInt aCheckType, TBool aPublishAll);

    /**
     * Tells each shortcut to check whether or not its target is accessible.
     * Shortcuts will revert to the default setting if the user setting is
     * not accessible.
     *
     * @since S60 v3.2
     * @param aCheckType Specifies which kind of shortcuts should check its access
     * @param aPublishAll All shortcuts are published
     */
    void CheckAccessAndPublishL(TInt aCheckType, TBool aPublishAll);

    /**
     * Finds the shortcut object with the given id
     *
     * @since S60 v3.2
     * @param aId Shortcut id
     * @return Shortcut index or KErrNotFound
     */
    TInt FindShortcutIndex(TInt32 aId);

    /**
     * Handles the shortcut launch by index.
     *
     * @since S60 v3.2
     * @param aParam Index of the shortcut to launch
     */
    void HandleLaunchByIndexL(const TDesC& aParam);

    /**
     * Handles the special launching of a shortcut. The 
     * launching can be done based on the location of 
     * the shortcut (sk, toolbar item etc) or based on the
     * application it points to. Currently when this function is
     * called to a shortcut that points to appshell the fastswap
     * window is opened
     * 
     * @since s60 v5.0
     * @param aParam Index of the shortcut to perform the special launch
     */
    void HandleLaunchByIndexAlternateL(const TDesC& aParam);
    /**
     * Handles the shortcut launch by value
     *
     * @since S60 v3.2
     * @param aParam Value of the shortcut to launch
     */
    void HandleLaunchByValueL(const TDesC& aParam);

    /**
     * Shows the plug-in settings dialog.
     *
     * @since S60 v3.2
     */
    void ShowSettingsL(const TDesC& aParam);

    /**
     * Shows the plug-in setting.
     *
     * @since S60 v5.0
     */
    void ShowSettingL(const TDesC& aParam);
    
    /**
     * Opens the fast swap window
     * 
     * @since S60 v5.0
     */
    void OpenFastSwap();
    /**
     * Handles PS commands from WSPlugin.
     *
     * @since S60 v3.2
     */
    static TInt HandlePSCommand(TAny* aAny);

    /**
     * Handles call state changes.
     *
     * @since S60 v3.2
     */
    static TInt CallStateChangeCallback(TAny* aPtr);

    /**
     * Callback for delay timer
     */
    static TInt DelayTimerCallBack(TAny *aSelf );
        
    
    /**
     * Get soft key uid
     *
     * @since S60 v3.2
     * @param aSoftkeyId shortcut index
     */
    TUid SoftkeyUid(TUint32 aSoftkeyId);

    /**
     *Check softkey delay is required
     *
     * @since S60 v3.2
     * @param AppUid application uid     
     */
    TBool IsDelayRequired(TUid aAppUid);

    /**
     * Handles PS commands from WSPlugin (leaving version).
     *
     * @since S60 v3.2
     */
    void DoHandlePSCommandL();

    /**
     * Activates phone/video call application
     *
     * @since S60 v3.2
     */
    void ActivateTopMostApp();

    /**
     * Check MsvSession is Needed
     */
    TBool IsMsvSessionNeeded();

    /**
     * Check Bookmark Observer is Needed
     */
    TBool IsBookmarkObserverNeeded();

    /**
     * Load application titles list
     */
    void LoadAppTitleListL();

    /**
     * Get hidden applications
     */
    void GetHiddenAppsL();
    
    void CheckForThemeDefaultReinstalledL();

    TBool IsLockKey( TInt aScanCode, TScutLockKey aLockKey ) const;

    TInt AddOverrideIcon( TAiScutIcon &aIcon );

    /**
     * Starts a delay timer that calls HandleLaunchByIndexL() after
     * a short delay. Delay is read from cenrep with the key KAIKeyLockTimeout
     * 
     * @param aParam The parameter to pass to HandleLaunchByIndexL()
     * 
     */
    void DelayedLaunchByIndexL( const TDesC &aParam );
private: // From MFavouritesDbObserver

    /**
     * Handles database event.
     * @param aEvent Database event.
     */
    void HandleFavouritesDbEventL(RDbNotifier::TEvent aEvent);

protected:  // data

    /**
     * Shortcut objects.
     * Own.
     */
    RAiShortcutArray                iShortcuts;

    /**
     * Shortcut objects for storing theme default scuts.
     * Own.
     */
    RAiShortcutInfoArray            iThemeShortcuts;
    
    /**
     * Flags for shortcuts to indicate whether platform or theme default is used.
     */
    RArray            iDefaultUsed;

    /**
     * Central Repository session.
     * Own.
     */
    CRepository*                    iRepository;

    /**
     * Notifier for changes in the application list
     * (installations / uninstallations).
     * Own.
     */
    CApaAppListNotifier*            iAppNotifier;

    /**
     * Notifier for changes in the shortcut settings.
     * Own.
     */
    CAiScutRepositoryWatcher*       iSettingsNotifier;

    /**
     * Message server session.
     * Own.
     */
    CMsvSession*                    iMsvSession;

    /**
     * Timer that performs the availability check after a given delay.
     * Own
     */
    CPeriodic*                      iTimer;

    /**
     * Reference to the plug-in.
     * Not own.
     */
    CAiScutPlugin&                  iPlugin;

    /**
     * Application architecture server session.
     */
    RApaLsSession                   iApaSession;

    /**
     * Bookmark database session.
     * Own.
     */
    RFavouritesSession              iBookmarkSess;

    /**
     * Bookmark database.
     * Own.
     */
    RFavouritesDb                   iBookmarkDb;

    /**
     * Bookmark database change observer.
     * Own.
     */
    CActiveFavouritesDbNotifier*    iBookmarkDbObserver;

    /**
     * View server session wrapper.
     * Own
     */
    CVwsSessionWrapper*             iVwsSession;

    /**
     * Flag to indicate that all shortcus are to be published. Used when resuming.
     */
    TBool                           iPublishAll;

    /**
     *Call key event observer
     * Own
     */
    MAiPSPropertyObserver*          iKeyEventObserver;

    /**
     * Call state PS observer.
     * Own.
     */
    MAiPSPropertyObserver*          iCallStateObserver;

    /**
     * Call state
     */
    TBool                           iActiveCall;

    /**
     * First keylock key
     */
    TInt                            iFirstLockKey;

    /**
     * First keylock key pressed flag to ensure first lock has been
     * pressed when skipping key lock. Enabling the correct response to
     * skip command.
     */
    TBool                           iFirstLockKeyPressed;

    /**
     * Second keylock key
     */
    TInt                            iSecondLockKey;

    /**
     * Resource loader for common text resources.
     */
    RConeResourceLoader             iResourceLoaderTexts;

    /**
     * Resource loader for sendui text resources.
     */
    RConeResourceLoader             iResourceLoaderSendUi;

    /**
     * Coe environment.
     * Not own.
     */
    CCoeEnv*                        iEnv;

    /**
     * Array of UIDs which are hidden from the TARM
     */
    RArray                    iHiddenApps;

    /**
     * Central repository object for Hidden Apps
     * Own
     */
    CRepository*                    iHiddenAppsRepository;

    /**
     * Central repository change handler for Hidden Apps
     * Own
     */
    CAiScutRepositoryWatcher*       iHiddenAppsNotifier;

    /**
     * Application titles list
     */
    RArray    iAppTitleList;

    /**
     * Own
     */
    CAiScutTargetShutter*           iScutShutter;

    /**
     *
     */
    TBool                           iSoftkeyAppRunning;
    
#ifdef __WEB_WIDGETS
    /**
     * Widget registry client session to check if UID means widget.
     */
    RWidgetRegistryClientSession    iWidgetRegistry;
    TBool                           iWidgetRegistryConnected;
#endif
    /**
    * for parsing the icon overrides and softkeys
    */
    TAiScutParser                   iParser;

    /**
     * Override icons and softkeyicons are held here
     */
    RArray     iIcons;

    /**
     * For checking keylock buttons
     * Own
     */
    CKeyLockPolicyApi *iKeylockApi;
    /**
     * Timer user to delay the launching
     * of specific shortcuts.
     * Own
     */
    CPeriodic *iDelayTimer;
    
    /**
     * Command passed to HandleLaunchByIndexL()
     * when delayed launching is used
     * Own
     */
    HBufC    *iDelayedLaunchCmd;
    
    /**
     * Delayed launching delay. Read from cenrep
     */
    TInt iDelayTimerDelay;
};

#include "hs_app_caiscutengine.inl"

#endif // CAISCUTENGINE_H

// End of File.
hs_app_caiscutengine.inl
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Inline functions for the shortcut plug-in engine
*
*/


// ---------------------------------------------------------------------------
// Returns the application architecture server session owned by the engine.
// ---------------------------------------------------------------------------
//
inline RApaLsSession& CAiScutEngine::ApaSession()
{
    return iApaSession;
}

// ---------------------------------------------------------------------------
// Returns reference to the bookmark database owned by the engine.
// ---------------------------------------------------------------------------
//
inline RFavouritesDb& CAiScutEngine::FavouritesDb()
{
    return iBookmarkDb;
}

// ---------------------------------------------------------------------------
// Returns the message server session owned by the engine.
// ---------------------------------------------------------------------------
//
inline CMsvSession* CAiScutEngine::MsvSession()
{
    return iMsvSession;
}

// ---------------------------------------------------------------------------
// Returns a pointer to view server session wrapper.
// ---------------------------------------------------------------------------
//
inline CVwsSessionWrapper* CAiScutEngine::VwsSession()
{
    return iVwsSession;
}

// ---------------------------------------------------------------------------
// Returns a pointer to the coe environment
// ---------------------------------------------------------------------------
//
inline CCoeEnv* CAiScutEngine::Env()
{
    return iEnv;
}

// End of File.
hs_app_caiscutengineext.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in engine extension
*
*/


#ifndef CAISCUTENGINEEXT_H
#define CAISCUTENGINEEXT_H

#include 

#include "hs_app_caiscutengine.h"
#include "hs_app_maiscutextmessagehandler.h"
#include "hs_app_caiscutshortcutext.h"

class CAiScutPlugin;
class CAiScutExtServer;
class CAiScutExtDataModel;

/**
 *  The class extends CAiScutEngine by handling events from
 *  xSP extension server.
 *
 *  @since S60 v3.2
 */
class CAiScutEngineExt : public CAiScutEngine,
    public MAiScutExtMessageHandler
    {
    public:
        /**
         * Factory function
         * @see CAiScutEngine
         * @since S60 v3.2
         */
        static CAiScutEngineExt* NewL( CAiScutPlugin& aPlugin );

        /**
         * Destructor
         * @since S60 v3.2
         */
        ~CAiScutEngineExt();

    private:
        /**
         * Constructor
         * @see CAiScutEngine
         * @since S60 v3.2
         */
        CAiScutEngineExt( CAiScutPlugin& aPlugin );

        void ConstructL();

    public:  // New functions
        /**
         * Publishes specific shortcut
         * @since S60 v3.2
         */
        void CheckAccessAndPublish( CAiScutShortcut& aShortcut );

    private: // From CAiScutEngine
        void HandleAiEventL( TInt aEvent, const TDesC& aParam );
        void ResumeL( TBool aPublishAll, TAiTransitionReason aReason );

    private: // From MAiScutExtMessageHandler
        void HandleSetPopupLineArrayL( const TDesC& aDefinition, CDesCArray* aLineArray );
        void HandleResetPopupLineArrayL( const TDesC& aDefinition );
        void HandleSetIconL( const TDesC& aDefinition, CGulIcon* aIcon );
        void HandleResetIconL( const TDesC& aDefinition );
        TBool HandleIsInShortcutsL( const TDesC& aDefinition ) const;
        void HandleIssuePutInShortcutsL( const TDesC& aDefinition );

    private: // New functions
        /**
         * Finds a shortcut of which id matches with given.
         * @param aId Target id in hexadecimal string format
         * @return Pointer to shortcut or NULL if not found
         */
        CAiScutShortcutExt* FindShortcutById( const TDesC& aId ) const;

        /**
         * Iterates shortcuts and sets new extension data to matching
         * ones.
         * @param aDefinition Definition
         * @param aAiScutExtData Pointer to extension data or NULL
         * @return ETrue if matching shortcut(s) found
         */
        TBool PopulateExtData( const TDesC& aDefinition,
            const MAiScutExtData* aAiScutExtData );

    private: // data
        /**
         * xSP extension server instance
         * Own.
         */
        CAiScutExtServer* iAiScutExtServer;

        /**
         * Extension data model
         * Own.
         */
        CAiScutExtDataModel* iExtDataModel;
    };

#endif // CAISCUTENGINEEXT_H

// End of File.
hs_app_caiscutextdata.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: 
*
*/


#ifndef CAISCUTEXTDATA_H
#define CAISCUTEXTDATA_H

#include 
#include 

#include "hs_app_maiscutextdata.h"

class CGulIcon;

/**
 *  @since S60 v3.2
 */
class CAiScutExtData : public CBase, 
    public MAiScutExtData
    {
    public:
        /**
         * Factory function
         * @since S60 v3.2
         */
        static CAiScutExtData* NewL( const TDesC& aTargetDefinition );


        /**
         * Factory function
         * @since S60 v3.2
         */
        static CAiScutExtData* NewLC( const TDesC& aTargetDefinition );

        /**
         * Destructor
         * @since S60 v3.2
         */
        ~CAiScutExtData();
        
    private:
        /**
         * Constructor
         * @see CAiScutEngine
         * @since S60 v3.2
         */
        CAiScutExtData();

        void ConstructL( const TDesC& aTargetDefinition );

    public:  // New functions    
        /**
         * @since S60 v3.2
         */
        const TDesC& TargetDefinition() const;
     
         /**
         * Deletes old and stores new popup line array
         * @param aPopupLineArray Popup line array. Ownership is transferred.
         * @since S60 v3.2
         */
        void SwitchPopupLineArray( CDesCArray* aPopupLineArray );

        /**
         * @since S60 v3.2
         */
        void ResetPopupLineArray();

        /**
         * Deletes old and stores new icon
         * @param aIcon Icon. Ownership is transferred.
         * @since S60 v3.2
         */
        void SwitchIcon( CGulIcon* aIcon );

        /**
         * @since S60 v3.2
         */
        void ResetIcon();
       
    public:  //From MAiScutExtData
        const MDesCArray* PopupLineArray() const;        
        const CGulIcon* Icon() const;
        
    private: // data

        /**
         * Definition string of the target shortcut
         * Own.
         */
         HBufC* iTargetDefinition;

        /**
         * Popup line array
         * Own.
         */
         CDesCArray* iPopupLineArray;

        /**
         * Icon
         * Own.
         */
         CGulIcon* iIcon;
    };

#endif // CAISCUTEXTDATA_H

// End of File.
hs_app_caiscutextdatamodel.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in extension data model
*
*/


#ifndef CAISCUTEXTDATAMODEL_H
#define CAISCUTEXTDATAMODEL_H

#include 
#include 

class CGulIcon;
class CAiScutExtData;

/**
 *  This class owns an array of CAiScutExtData items and provides an API to
 *  update popup line array and icon data for different targets.
 *  @since S60 v3.2
 */
class CAiScutExtDataModel : public CBase
    {
    private:
        friend class T_CAiScutExtDataModel;

    public:
        /**
         * Factory function
         * @since S60 v3.2
         */
        static CAiScutExtDataModel* NewL();


        /**
         * Factory function
         * @since S60 v3.2
         */
        static CAiScutExtDataModel* NewLC();

        /**
         * Destructor
         * @since S60 v3.2
         */
        ~CAiScutExtDataModel();
        
    private:
        /**
         * Constructor
         * @see CAiScutEngine
         * @since S60 v3.2
         */
        CAiScutExtDataModel();

        void ConstructL();

    public:  // New functions    
        /**
         * Sets the new popup line array for target. The old one is deleted. If
         * matching target definition is not found new CAiScutExtData object is
         * created.
         * @param aDefinition Target definition string
         * @param aLineArray Pointer to line array. Ownership is transferred
         * @return Pointer to new or existing CAiScutExtData object
         * @since S60 v3.2
         */
        CAiScutExtData* SetPopupLineArrayL( const TDesC& aDefinition, CDesCArray* aLineArray );

        /**
         * Resets popup line array. If also the icon is not set the CAiScutExtData
         * item is deleted and removed from the array.
         * @param aDefinition Target definition string
         * @since S60 v3.2
         */
        CAiScutExtData* ResetPopupLineArray( const TDesC& aDefinition );

        /**
         * Sets the new icon for target. The old one is deleted. If
         * matching target definition is not found new CAiScutExtData object is
         * created.
         * @param aDefinition Target definition string
         * @param aIcon Pointer to icon. Ownership is transferred
         * @return Pointer to new or existing CAiScutExtData object
         * @since S60 v3.2
         */
        CAiScutExtData* SetIconL( const TDesC& aDefinition, CGulIcon* aIcon );

        /**
         * Resets icon. If also the popup line array is not set the CAiScutExtData
         * item is deleted and removed from the array.
         * @param aDefinition Target definition string
         * @since S60 v3.2
         */
        CAiScutExtData* ResetIcon( const TDesC& aDefinition );

        /**
         * @return Array of CAiScutExtData objects
         * @since S60 v3.2
         */
        TArray AiScutExtDataArray() const;

        /**
         * Deletes CAiScutExtData object and removes it from the array.
         * @param aDefinition Target definition string
         * @since S60 v3.2
         */
        void RemoveAiScutExtData( const TDesC& aDefinition );
        
    private: // New functions
        TInt FindAiScutExtData( const TDesC& aDefinition ) const;
        CAiScutExtData* CreateAiScutExtDataL( const TDesC& aDefinition );
        
    private: // data
        /**
         * Shortcut extension data items
         * Own.
         */
         RPointerArray iAiScutExtDataArray;
    };

#endif // CAISCUTEXTDATAMODEL_H

// End of File.
hs_app_caiscutextserver.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in xSP extension server class.
*
*/


#ifndef CAISCUTEXTSERVER_H
#define CAISCUTEXTSERVER_H

#include 
#include 

#include "hs_app_maiscutextmessagehandler.h"
#include "aicontentpublisher.h"

class CAiScutExtServer;
class CAknMessageQueryDialog;

/**
 *
 *  Helper class for passing parameters to the callback function.
 *
 *  @since S60 v3.2
 */
class CLinkParams : public CBase
    {
    public:

        CLinkParams(CAiScutExtServer& aServer, HBufC* aTargetDefinition);

        ~CLinkParams();

    public:

        /**
         * Reference to the server object.
         * Ref.
         */
        CAiScutExtServer& iServer;

        /**
         * Application identifier.
         * Own.
         */
        HBufC* iTargetDefinition;

        /**
         * The dialog that owns the link..
         * Ref.
         */
        CAknMessageQueryDialog* iNote;
    };

/**
 *  Server class for xSP extensions.
 *
 *  Handles sessions.
 *
 *  @since S60 v3.2
 */
class CAiScutExtServer : public CServer2
    {
    public:
        /**
         * Constructor
         * @param aObserver Reference to observer
         * @since S60 v3.2
         */
        CAiScutExtServer( MAiScutExtMessageHandler& aObserver, RWsSession& aWsSession );

        /**
         * 2nd-phase constructor
         * @since S60 v3.2
         */
        void ConstructL();

        /**
         * Destructor
         * @since S60 v3.2
         */
        ~CAiScutExtServer();

    private: // From CServer2

        CSession2* NewSessionL(
            const TVersion& aVersion, const RMessage2& aMessage ) const;

    private: // New methods

        void ReadAppListL();

        void WriteAppListL();

        static TInt LinkCallBack(TAny* aParam);

        static TInt IdleCallBack(TAny* aParam);

        void DoShowTipMessageL();

    public:

        TBool HasConnectedBefore( TUid& aUid, const RMessage2& aMessage );

        void ShowTipMessage( TUid aUid );

        void ResumeL( TAiTransitionReason aReason );

    private: // data

        /**
         * Reference to observer
         * Ref.
         */
        MAiScutExtMessageHandler& iObserver;

        /**
         * Reference to Window Server session
         * Ref.
         */
        RWsSession& iWsSession;

        /**
         * List of applications we are not going to
         * show the tip dialog.
         * Own.
         */
        RArray iUids;

        /**
         * List of applications to show the dialog.
         *
         * Own.
         */
        RArray iShowUids;

        /**
         * Resource offset for releasing the resoruce on destruction.
         *
         * Own.
         */
        TInt iResourceOffset;

        /**
         * CIdle for the tip dialog
         *
         * Own.
         */
        CIdle* iIdle;

        /**
         * Foreground/background indication
         *
         */
        TBool iIsForeground;

        /**
         * Tip message visible indication
         *
         */
        TBool iIsTipMessageVisible;
    };

#endif // CAISCUTEXTSERVER_H

// End of File.
hs_app_caiscutextsession.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in xSP extension session class.
*
*/


#ifndef CAISCUTEXTSESSION_H
#define CAISCUTEXTSESSION_H

#include 

class MAiScutExtMessageHandler;

/**
 *  Server session class for xSP extensions.
 *
 *  Handles IPC between server and client. Commands and data are passed to
 *  observer.
 *
 *  @since S60 v3.2
 */
class CAiScutExtSession : public CSession2
    {
    public:
        /**
         * Constructor
         * @param aObserver Reference to observer
         * @since S60 v3.2
         */
        CAiScutExtSession( MAiScutExtMessageHandler& aObserver );

        /**
         * Destructor
         * @since S60 v3.2
         */
        ~CAiScutExtSession();

    private: // From CSession2
        void ServiceL( const RMessage2& aMessage );
        void DispatchMessageL( const RMessage2& aMessage );

    private: // New functions
        void SetTargetDefinitionL( const RMessage2& aMessage );
        void SetPopupTextL( const RMessage2& aMessage );
        void ResetPopupTextL( const RMessage2& aMessage );
        void SetIconL( const RMessage2& aMessage );
        void ResetIconL( const RMessage2& aMessage );
        void IsInShortcutsL( const RMessage2& aMessage );
        void IssuePutInShortcutsL( const RMessage2& aMessage );

        void PanicClient( const RMessage2& aMessage, TInt aPanicCode ) const;

    private: // data

        /**
         * Reference to observer
         * Ref.
         */
        MAiScutExtMessageHandler& iObserver;
        
        /**
         * Target definition
         * Own.
         */
        HBufC* iTargetDefinition;
    };

#endif // CAISCUTEXTSESSION_H

// End of File.
hs_app_caiscutplugin.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#ifndef CAISCUTPLUGIN_H
#define CAISCUTPLUGIN_H

#include 
#include 
#include 
#include 

class CAiScutEngine;
class MAiContentObserver;
class MAiContentItemIterator;
class CAiScutShortcut;

/**
 *  Plug-in main class
 *
 *  @since S60 v3.2
 */
class CAiScutPlugin : public CAiContentPublisher
                    , public MAiPropertyExtension
                    , public MAiEventHandlerExtension
{

public: // factory methods and destructor.

    static CAiScutPlugin* NewL();

    virtual ~CAiScutPlugin();

public: // new methods

    /**
     * Publishes the given shortcut
     *
     * @since S60 v3.2
     * @return Reference to a shortcut to publish
     */
    void PublishShortcutsL(RAiShortcutArray& aShortcuts);

    /**
     *
     */
    TBool IsAlive() const;

    /**
     * @return Resume reason
     */
    TAiTransitionReason ResumeReason() const;

public: // methods from base classes

    // from base class CAiContentPublisher

    void Resume(TAiTransitionReason aReason);

    void Suspend(TAiTransitionReason aReason);

    void Stop(TAiTransitionReason aReason);

    /**
     * From CAiContentPublisher
     * Adds the content observer / subscriber to plug-in. The plug-in MUST
     * maintain a registry of subscribers and send notification to all them
     * whenever the plug-in changes state or new content available.
     *
     * @since S60 3.2
     * @param aObserver content observer to register.
     */
    void SubscribeL(MAiContentObserver& aObserver);

    /**
     * From CAiContentPublisher
     * Configures the plug-in.
     * Plug-ins take ownership of the settings array, so it must either
     * store it in a member or free it. Framework has put the array in cleanup
     * stack so the plug-in shouldn't do that.
     * If this leaves, the plug-in will be destroyed by AI FW.
     * Plug-in must support LaunchByValue-event even if normal shortcuts don't
     * work. The only allowed serious enough leave is KErrNotFound from CenRep.
     *
     * @since S60 3.2
     * @param aSettings setting items defined in the UI definition.
     */
    void ConfigureL(RAiSettingsItemArray& aSettings);

    /**
     * From CAiContentPublisher
     * Returns interface extension. In Series 60 3.1 only event & property
     * extensions are supported. See MAiEventExtension & MAiPropertyExtension
     * interfaces.
     *
     * @since S60 3.2
     * @param  aUid - UID of the extension interface to access.
     * @return the extension interface. Actual type depends on the passed aUid
     *         argument.
     */
    TAny* Extension(TUid aUid);

    // from base class MAiEventHandlerExtension

    /**
     * From MAiEventHandlerExtension
     * Invoked by the framework when plug-in must handle an event.
     *
     * @param aEvent - unique identifier of event from plug-in content model.
     * @param aParam - parameters associated with event. Each UI Definition
     *        declares events in the format: (),
     *        where  is mapped by the framework to unique
     *        identifier supplied in aEvent,  are provided to
     *        plug-in as-is in the descriptor.
     * @since S60 3.2
     */
    void HandleEvent(TInt aEvent, const TDesC& aParam);

    /**
	* Invoked by the framework for querying if plugin has menu item
	*
	* @return ETrue if plugin has specific menu item, EFalse otherwise
	*/   
	
// Online/Offline - web widgets	
    TBool HasMenuItem(const TDesC16& aMenuItem);
    
    // from base class MAiPropertyExtension

    /**
     * From MAiPropertyExtension.
     * Read property of publisher plug-in.
     *
     * @param aProperty - identification of property.
     * @return pointer to property value.
     * @since S60 3.2
     */
    TAny* GetPropertyL(TInt aProperty);

    /**
     * From MAiPropertyExtension.
     * Write property value.
     *
     * @param aProperty - identification of property.
     * @param aValue - contains pointer to property value.
     * @since S60 3.2
     */
    void SetPropertyL(TInt aProperty, TAny* aValue);

protected:

private:

    CAiScutPlugin();

    void ConstructL();

    void DoResumeL(TAiTransitionReason aReason);

    void FreeEngine();
    
    void DeleteDefaultShortcutsL();


private:  // data

    /**
     * Iterator for plug-in content.
     * Own.
     */
    MAiContentItemIterator*             iContent;

    /**
     * Iterator for plug-in resources.
     * Own.
     */
    MAiContentItemIterator*             iResources;

    /**
     * Iterator for plug-in events.
     * Own.
     */
    MAiContentItemIterator*             iEvents;

    /**
     * Plug-in engine
     * Own.
     */
    CAiScutEngine*                      iEngine;

    /**
     * Array of content observers
     * Not own.
     */
    RPointerArray   iObservers;

    /**
     * Information about the content publisher ( this plug-in ).
     */
    TAiPublisherInfo                    iInfo;

    /**
     * Plug-in state, suspended or alive.
     */
    TBool                               iAlive;

    /**
     * Resume reason
     */
    TAiTransitionReason                 iResumeReason;

    TBool                               iForcePublishAll;
};

#endif // CAISCUTPLUGIN_H

// End of File.
hs_app_caiscutsettings.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut settings plug-in main class.
*
*/


#ifndef CAISCUTSETTINGS_H
#define CAISCUTSETTINGS_H

#include 

class CAiScutSettingsContainer;
class CAiScutSettingsModel;

/**
 * Shortcut settings plug-in main class
 *
 * @lib hs_app_aiscutsettings.lib
 * @since S60 v3.2
 */
class CAiScutSettings : public CGSBaseView
{

public:

    static CAiScutSettings* NewL(TAny* aInitParams);

    virtual ~CAiScutSettings();

    // from base class CAknView

    /**
     * From CAknView
     * Returns view id.
     *
     * @since S60 3.2
     * @return TUid
     */
    TUid Id() const;

    /**
     * From CAknView
     * Handles commands.
     *
     * @since S60 3.2
     * @param aCommand Command to be handled.
     */
    void HandleCommandL(TInt aCommand);

    /**
     * See base class in AknView.h
     */
    void DoActivateL(const TVwsViewId& aPrevViewId, TUid aCustomMessageId, const TDesC8& aCustomMessage);

    /**
     * See base class.
     */
    void DoDeactivate();

    // from base class CGSPluginInterface

    /**
     * From CGSPluginInterface
     *
     * @since S60 3.2
     * @see CGSPluginInterface header file.
     */
    void GetCaptionL(TDes& aCaption) const;

    /**
     * From CGSPluginInterface
     *
     * @since S60 3.2
     * @see CGSPluginInterface header file.
     */
    TInt PluginProviderCategory() const;

    /**
     * From CGSPluginInterface
     *
     * @since S60 3.2
     * @see CGSPluginInterface header file.
     */
    TBool Visible() const;

    // from base class CGSBaseView

    /**
     * From CGSBaseView
     *
     * @since S60 3.2
     * Returns the container this view has.
     * @return pointer to container, does not transfer ownership.
     */
    CAiScutSettingsContainer* Container();
    
    /**
    * See base class
    */
    void HandleForegroundEventL(TBool aForeground);

    /**
    * Check if view is activate
    * @since S60 5.1
    * @return ETrue if activated, EFalse otherwise
    */    
    TBool Activated() const;

protected:

private: // From MEikMenuObserver

    /**
     * Changes MenuPane dynamically
     */
    void DynInitMenuPaneL(TInt aResourceId, CEikMenuPane* aMenuPane);

private:

    CAiScutSettings();

    void ConstructL();


    // from base class CGSBaseView

    /**
     * From CGSBaseView
     * Functionality for creating a container. Called by DoActivateL().
     */
    void NewContainerL();

    /**
     * From CGSBaseView
     * Handles listbox selection. Called by HandleListBoxEventL.
     * Implement by sub-class.
     */
    void HandleListBoxSelectionL();
    
    static TInt DoHandleListBoxSelectionL( TAny* aAny );


private:  // data

    /**
     * Settings plug-in model.
     * Own.
     */
    CAiScutSettingsModel*       iModel;

    /**
     * Resource loader for common text resources.
     */
    RConeResourceLoader         iResourceLoaderTexts;

    /***
     * Idle timer to delay event handling
     * Own.
     */
    CIdle* iListBoxTimer;

};

#endif // CAISCUTSETTINGS_H

// End of File.
hs_app_caiscutsettingsapplist.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Application list for settings listbox.
*
*/


#ifndef CAISCUTSETTINGSAPPLIST_H
#define CAISCUTSETTINGSAPPLIST_H

#include 
#include    // For MDesCArray
#include      // For RApaLsSession
#include      // For MMsvSessionObserver
#include    // For MApaAppListServObserver
#include "hs_app_aiscutsettings.hrh" // For TAiScutSettingType

class CAiScutSettingsItem;
class CCoeEnv;

/**
 * Shortcut definition parameter for theme change shortcut.
 */
_LIT( KScutParamChangeTheme,     "view=0x102750A7" );

/**
 * Shortcut definition parameter for messaging. New message
 */
_LIT( KScutParamNewMsg,          "new=msg" );

/**
 * Shortcut definition parameter for messaging. New email
 */
_LIT( KScutParamNewEmail,        "new=email" );

/**
 * Shortcut definition parameter for messaging. New syncml mail
 */
_LIT( KScutParamNewSyncMLMail,   "new=syncmlmail" );

/**
 * Shortcut definition parameter for messaging. New postcard
 */
_LIT( KScutParamNewPostcard,     "new=postcard" );

/**
 * Shortcut definition parameter for messaging. New audio message
 */
_LIT( KScutParamNewAudioMsg,     "new=audiomsg" );

/**
 * Shortcut definition parameter for messaging. Select message type
 */
_LIT( KScutParamSelectMsgType,   "new" );

/**
 * Shortcut definition parameter for messaging. Remote mailbox
 */
_LIT( KScutParamMailbox,         "mailbox=" );

/**
 * Shortcut definition parameter for general settings. Connectivity view
 */
_LIT( KScutParamConnectivityView,     "view=0x10207250" );

/**
 * Shortcut definition parameter for general settings. Installations view
 */
_LIT( KScutParamInstallationsView,     "view=0x10283321" );


/**
 * Observer interface for application list events
 *
 * @since S60 v3.2
 */
class MAiScutListObserver
{
public:

    /**
     * AppList event codes
     */
    enum TScutListEvent
    {
        EAppListReady,
        EAppListUpdated,
        EBkmListUpdated
    };

    /**
     * Callback for application list events
     *
     * @since S60 v3.2
     * @param aEvent AppList event code
     * @param aAdded ETrue if applications were added, EFalse if removed
     */
    virtual void HandleScutListEventL( TScutListEvent aEvent, TBool aAdded ) = 0;

    virtual TBool IsHidden(const TUid& aAppUid) const = 0;

};


/**
 * Application list for settings listbox
 *
 * @since S60 v3.2
 */
class CAiScutSettingsAppList : public CActive
                             , public MDesCArray
                             , public MMsvSessionObserver
                             , public MApaAppListServObserver
{

public:

    static CAiScutSettingsAppList* NewL( CCoeEnv* aEnv, MAiScutListObserver& aObserver );

    virtual ~CAiScutSettingsAppList();

    // from base class MDesCArray

    /**
     * From MDesCArray
     * Returns the number of descriptor elements in a descriptor array.
     *
     * @since S60 v3.2
     * @return The number of descriptor elements in a descriptor array.
     */
    TInt MdcaCount() const;

    /**
     * From MDesCArray
     * Indexes into a descriptor array.
     *
     * @since S60 v3.2
     * @param aIndex The position of the descriptor element within a descriptor array.
     * @return A 16 bit non-modifiable pointer descriptor representing the descriptor
     *         element located at position aIndex within a descriptor array.
     */
    TPtrC MdcaPoint( TInt aIndex ) const;

    // from base class MMsvSessionObserver

    /**
     * Handles an event from the message server.
     * Not used, but must be defined to be able to use the messaging server.
     *
     * @since S60 v3.2
     * @param aEvent Indicates the event type.
     * @param aArg1 Event type-specific argument value
     * @param aArg2 Event type-specific argument value
     * @param aArg3 Event type-specific argument value
     */
    void HandleSessionEventL( TMsvSessionEvent aEvent, TAny* aArg1, TAny* aArg2, TAny* aArg3 );

    // from base class MApaAppListServObserver

    /**
     * From MApaAppListServObserver
     * Handles a change in the application list
     *
     * @since S60 v3.2
     * @param aEvent Event id
     */
    void HandleAppListEvent( TInt aEvent );

    /**
     * Starts the asynchronous appliation list initialization
     *
     * @since S60 v3.2
     */
    void StartL();

    /**
     * Checks if the application list is ready to be shown
     *
     * @since S60 v3.2
     * @return ETrue if ready, EFalse if not
     */
    TBool IsReady() const;

    /**
     * Tells the application list to start or stop observing for changes
     *
     * @since S60 v3.2
     * @param aObserving ETrue if changes should be observed, EFalse if not
     */
    void SetObservingL( TBool aObserving );

    /**
     * Finds the index of the given settings item in the application list
     *
     * @since S60 v3.2
     * @param aItem Setting item to find
     * @return Index of the setting item in the application list
     */
    TInt FindIndex( CAiScutSettingsItem& aItem );

    /**
     * Returns target application data from the given index
     *
     * @since S60 v3.2
     * @param aIndex Index of the application in the list
     * @param aUid On return, the application uid
     * @param aParams On return, the application parameters
     * @param aCaption On return, the application caption
     * @param aType On return, the application type (app or url)
     * @return KErrNotFound if the application cannot be found, KErrNone otherwise
     */
    TInt GetDataByIndex( TInt aIndex, TUid& aUid, TPtrC& aParams, TPtrC& aCaption, TAiScutSettingType& aType ) const;

    /**
     * Adds extra list items to the application list.
     * For example "No Effect" item is added here.
     *
     * @since S60 v3.2
     */
    void AddExtraItemsL();

    /**
     * Removes extra list items from the application list.
     *
     * @since S60 v3.2
     */
    void RemoveExtraItemsL();

protected:

private:

    CAiScutSettingsAppList( CCoeEnv* aEnv, MAiScutListObserver& aObserver );

    void ConstructL();

    // from base class CActive

    /**
     * From CActive
     * Implements cancellation of an outstanding request.
     *
     * @since S60 v3.2
     */
    void DoCancel();

    /**
     * From CActive
     * Performs one step of the app list initialization
     *
     * @since S60 v3.2
     */
    void RunL();

    /**
     * From CActive
     * Handles an error situation
     *
     * @since S60 v3.2
     * @param aError Error code received from system
     * @return Error code after error handling
     */
    TInt RunError( TInt aError );

    /**
     * Completes own request status to make sure active scheduler
     * calls RunL again.
     *
     * @since S60 v3.2
     */
    void CompleteSelf();

    /**
     * Adds an application to the list
     *
     * @since S60 v3.2
     * @param aAppInfo Application information object
     */
    void AddApplicationL( TApaAppInfo& aAppInfo );

    /**
     * Adds the static list items to the application list.
     * For example "New Message" and "New Email" items are added here.
     *
     * @since S60 v3.2
     */
    void AddStaticItemsL();

    /**
     * Finds all mailboxes defined in the device
     */
    CMsvEntry* GetRootEntryL();

    /**
     * Adds remote mailboxes to the application list.
     *
     * @since S60 v3.2
     */
    void AddMailboxesL();

    /**
     * Adds a mailbox to the list
     *
     * @since S60 v3.2
     * @param aMailbox Name of the mailbox to add
     */
    void AddMailboxL( const TDesC& aMailbox, const TDesC& aMailboxId );

    /**
     * Removes a mailbox from the list
     *
     * @since S60 v3.2
     * @param aMailboxParam Parameter string of the mailbox to remove
     */
    void RemoveMailboxL( const TDesC& aMailboxParam );

    /**
     * Adds extra application to applist from central repository
     * 
     * @since S60 v3.2
     */
    void AddExtraItemsFromCRL();

    TBool IsBannedUid(TUid aUid);

    /**
     * Gets the next valid application from application architecture server.
     * Valid applications are non-hidden ones
     *
     * @since S60 v3.2
     * @param aAppInfo Application information of the next valid application
     * @return Error code from RApaLsSession or one of system wide errors
     */
    TInt GetNextValidApp( TApaAppInfo& aAppInfo );

    /**
     * Updates the application list
     *
     * @since S60 v3.2
     */
    void UpdateAppListL();

    /**
     * Figures out which application is missing from the list and adds it
     *
     * @since S60 v3.2
     * @param aCount Amount of applications to add
     */
    void AddInstalledAppToListL( TInt aCount );

    /**
     * Figures out which application should not be in the list and removes it
     *
     * @since S60 v3.2
     * @param aCount Amount of applications to remove
     */
    void RemoveUninstalledAppFromListL( TInt aCount );
    
    /**
     * Checks if application is midlet.
     * @param aUid Application uid
     * @since S60 v3.2
     */
    TBool IsNonNative(const TUid& aUid);
    
    /**
     * Checks if application is located in ROM.
     * @param aUid Application uid
     * @since S60 v5.0 
     */
    TBool IsInRom( const TUid& aUid );


private:

    /**
     * Nested class to store individual application list items
     *
     * @since S60 v3.2
     */
    class CAppListItem : public CBase
    {
    public:

        static CAppListItem* NewLC( TUid aUid, const TDesC& aCaption );

        ~CAppListItem();

        /**
         * Compare method used to add the items to the list in sorted order
         *
         * @since S60 v3.2
         * @param aFirst The first item to be compared
         * @param aSecond The second item to be compared
         * @return Negative if first comes before second, zero if equal and
         *         positive if first comes after second
         */
        static TInt CompareCaption( const CAppListItem& aFirst,
            const CAppListItem& aSecond );

        /**
         * Returns the item target application uid
         *
         * @since S60 v3.2
         * @return Target application uid
         */
        TUid Uid() const;

        /**
         * Returns the item target application caption
         *
         * @since S60 v3.2
         * @return Target application caption
         */
        TPtrC Caption() const;

        /**
         * Returns the possible parameters for item target
         *
         * @since S60 v3.2
         * @return Item target parameters
         */
        TPtrC Params() const;

        /**
         * Sets the parameters for the item target
         *
         * @since S60 v3.2
         * @param aParams Parameters for item target
         */
        void SetParamsL( const TDesC& aParams );

        /**
         * Sets the type for the item target
         * 
         * @since S60 v3.2
         * @param aType The item target type
         */
        void SetType( TAiScutSettingType aType );
        
        /**
         * Returns the type of this item target
         * 
         * @since S60 v3.2
         * @return Item type
         */
        TAiScutSettingType Type() const;
    private:

        CAppListItem( TUid aUid );

        void ConstructL( const TDesC& aCaption );

    private:  // data

        /**
         * Target application uid
         */
        TUid iUid;

        /**
         * Target application caption
         */
        HBufC* iCaption;

        /**
         * Target application parameters
         */
        HBufC* iParams;
        /**
         * Is this setting a application or URL. 
         * Needed for URLs added from cenrep
         */
        TAiScutSettingType iType;

    };

private:  // data

    /**
     * List of application items
     * Own.
     */
    RPointerArray iListItems;

    /**
     * Application architecture server session
     * Own.
     */
    RApaLsSession               iApaSession;

    /**
     * Message server session
     * Own.
     */
    CMsvSession*                iMsvSession;

    /**
     * Notifier for changes in the application list
     * ( installations / uninstallations )
     * Own.
     */
    CApaAppListNotifier*        iAppNotifier;

    /**
     * Amount of all applications in the device
     */
    TInt                        iTotalAppCount;

    /**
     * List of mailbox items. Points to iListItems.
     * DO NOT DELETE THROUGH THIS!
     * Own.
     */
    RPointerArray iMailboxes;

    /**
     * Flag indicating if the asynchronous application list generation is ready
     */
    TBool                       iReady;

    /**
     * Pointer to the control environment
     * Not own.
     */
    CCoeEnv*                    iEnv;

    /**
     * Registered observer for application list events
     */
    MAiScutListObserver&        iObserver;

    /**
     * A flag indicating if the app list should observe changes
     */
    TBool                       iObserving;

};

#endif // CAISCUTSETTINGSAPPLIST_H

// End of File.
hs_app_caiscutsettingsbkmlist.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Bookmark list for settings listbox.
*
*/


#ifndef CAISCUTSETTINGSBKMLIST_H
#define CAISCUTSETTINGSBKMLIST_H

#include 
#include                // For MDesCArray
#include    // For MFavouritesDbObserver

class CCoeEnv;
class CActiveFavouritesDbNotifier;
class CAiScutSettingsItem;
class CAiScutSettingsModel;

/**
 * Bookmark list for settings listbox
 *
 * @since S60 v3.2
 */
class CAiScutSettingsBkmList : public CBase
                             , public MDesCArray
                             , public MFavouritesDbObserver
{

public:

    static CAiScutSettingsBkmList* NewL(
        CCoeEnv* aEnv,
        CAiScutSettingsModel* aModel,
        MAiScutListObserver& aObserver);

    virtual ~CAiScutSettingsBkmList();

    // from base class MDesCArray

    /**
     * From MDesCArray
     * Returns the number of descriptor elements in a descriptor array.
     *
     * @since S60 v3.2
     * @return The number of descriptor elements in a descriptor array.
     */
    TInt MdcaCount() const;

    /**
     * From MDesCArray
     * Indexes into a descriptor array.
     *
     * @since S60 v3.2
     * @param aIndex The position of the descriptor element within a descriptor array.
     * @return A 16 bit non-modifiable pointer descriptor representing the descriptor
     *         element located at position aIndex within a descriptor array.
     */
    TPtrC MdcaPoint(TInt aIndex) const;

    /**
     * Gets the bookmark list.
     *
     * @since S60 v3.2
     */
    void GetBookmarkListL();

    /**
     * Tells the bookmark list to start or stop observing for changes
     *
     * @since S60 v3.2
     * @param aObserving ETrue if changes should be observed, EFalse if not
     */
    void SetObservingL(TBool aObserving);

    /**
     * Finds the index of the given settings item in the bookmark list
     *
     * @since S60 v3.2
     * @param aItem Setting item to find
     * @return Index of the setting item in the bookmark list
     */
    TInt FindIndex(CAiScutSettingsItem& aItem);

    /**
     * Returns target bookmark data from the given index
     *
     * @since S60 v3.2
     * @param aIndex Index of the bookmark in the list
     * @param aParams On return, the bookmark parameters
     * @param aCaption On return, the bookmark caption
     * @return KErrNotFound if the bookmark cannot be found, KErrNone otherwise
     */
    TInt GetDataByIndex(TInt aIndex, TPtrC& aParams, TPtrC& aCaption) const;

protected:

private:

    CAiScutSettingsBkmList(
        CCoeEnv* aEnv,
        CAiScutSettingsModel* aModel,
        MAiScutListObserver& aObserver);

    void ConstructL();

    /**
     * Adds an bookmark to the list
     *
     * @since S60 v3.2
     * @param aBkmInfo Bookmark information object
     */
    void AddBookmarkL(TUid aUid, const TDesC& aCaption);

    /**
     * Updates the bookmark list
     *
     * @since S60 v3.2
     */
    void UpdateBkmListL();

    // From MFavouritesDbObserver
    /**
     * Handles database event.
     * @param aEvent Database event.
     */
    void HandleFavouritesDbEventL(RDbNotifier::TEvent aEvent);

private:

    /**
     * Nested class to store individual bookmark list items
     *
     * @since S60 v3.2
     */
    class CBkmListItem : public CBase
    {
    public:

        static CBkmListItem* NewLC(TUid aUid, const TDesC& aCaption);

        ~CBkmListItem();

        /**
         * Compare method used to add the items to the list in sorted order
         *
         * @since S60 v3.2
         * @param aFirst The first item to be compared
         * @param aSecond The second item to be compared
         * @return Negative if first comes before second, zero if equal and
         *         positive if first comes after second
         */
        static TInt CompareCaption(const CBkmListItem& aFirst,
            const CBkmListItem& aSecond);

        /**
         * Returns the item target bookmark uid
         *
         * @since S60 v3.2
         * @return Target bookmark uid
         */
        TUid Uid() const;

        /**
         * Returns the item target bookmark caption
         *
         * @since S60 v3.2
         * @return Target bookmark caption
         */
        TPtrC Caption() const;

        /**
         * Returns the possible parameters for item target
         *
         * @since S60 v3.2
         * @return Item target parameters
         */
        TPtrC Params() const;

        /**
         * Sets the parameters for the item target
         *
         * @since S60 v3.2
         * @param aParams Parameters for item target
         */
        void SetParamsL(const TDesC& aParams);

    private:

        CBkmListItem(TUid aUid);

        void ConstructL(const TDesC& aCaption);

    private:  // data

        /**
         * Target bookmark uid
         */
        TUid iUid;

        /**
         * Target bookmark caption
         */
        HBufC* iCaption;

        /**
         * Target bookmark parameters
         */
        HBufC* iParams;

    };

private:  // data

    /**
     * List of bookmark items
     * Own.
     */
    RPointerArray iListItems;

    /**
     * Amount of all bookmarks in the device
     */
    TInt                        iTotalAppCount;

    /**
     * Pointer to the control environment
     * Not own.
     */
    CCoeEnv*                    iEnv;

    /**
     * Settings plug-in model.
     * Not own.
     */
    CAiScutSettingsModel*       iModel;

    /**
     * Registered observer for list events
     */
    MAiScutListObserver&        iObserver;

    /**
     * A flag indicating if the bookmark list should observe changes
     */
    TBool                       iObserving;

    /**
     * Bookmark database change observer.
     * Own.
     */
    CActiveFavouritesDbNotifier*    iBookmarkDbObserver;

};

#endif // CAISCUTSETTINGSBKMLIST_H

// End of File.
hs_app_caiscutsettingscontainer.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut settings plug-in container.
*
*/


#ifndef CAISCUTSETTINGSCONTAINER_H
#define CAISCUTSETTINGSCONTAINER_H

#include 

#include "hs_app_aiscutsettings.hrh"

class CAknRadioButtonSettingPage;
class CAknSettingPage;
class CAknWaitDialog;
class CAiScutSettingsModel;
class CAiScutSettingsBkmList;
class CAiScutSettingsItem;

/**
 * Shortcut settings plug-in container
 *
 * @lib hs_app_aiscutsettings.lib
 * @since S60 v3.2
 */
class CAiScutSettingsContainer : public CGSBaseContainer
{

public:

    CAiScutSettingsContainer();

    virtual ~CAiScutSettingsContainer();

    /**
     * Sets pointer to settings plug-in model.
     *
     * @since S60 v3.2
     * @param aModel Pointer to settings plug-in model
     */
    void SetModel(CAiScutSettingsModel* aModel);

    /**
     * Chandles a setting change command
     *
     * @since S60 v3.2
     */
    void HandleChangeCommandL();

    /**
     * Chandles a setting type change command
     *
     * @since S60 v3.2
     */
    void HandleChangeShortcutTypeCommandL(TAiScutSettingType aType);

    /**
  	 * Dialog showing changed
     *
     * @since S60 v3.2
      */
    TBool IsChangeDialogShowing();

    /**
     * Close change dialog
     *
     * @since S60 v3.2
     */
    void CloseChangeDialog();

    /**
     * Reset current list
     *
     * @since S60 v3.2
     */
    void ResetCurrentListL(TInt aIndex);

    /**
     * Hides the wait note dialog.
     *
     * @since S60 v3.2
     */
    void HideWaitNoteDialog();
    
    /**
    * Dismisses the wait note dialog and possible
    * other dialogs and stops the change process.
    *
    * @since S60 v3.2
    */
    void StopShortcutChangeProcess();

private:

    void ConstructL(const TRect& aRect);

    // from base class CGSBaseContainer

    /**
     * From CGSBaseContainer
     * Constructs the settings listbox
     *
     * @since S60 v3.2
     * @param aResLbxId Listbox resource id
     */
    void ConstructListBoxL(TInt aResLbxId);

    /**
     * Chandles a setting change command to select application from a list
     *
     * @since S60 v3.2
     * @param aItem Applist item to modify
     * @param aNew ETrue if selecting an application for first time, EFalse if not
     * @return ETrue if shortcut was changed. EFalse if not
     */
    TBool HandleAppListChangeCommandL(CAiScutSettingsItem& aItem, TBool aNew = EFalse);

    /**
     * Chandles a setting change command to select bookmark from a list
     *
     * @since S60 v3.2
     * @param aItem Applist item to modify
     * @param aNew ETrue if selecting an application for first time, EFalse if not
     * @return ETrue if shortcut was changed. EFalse if not
     */
    TBool HandleBookmarkChangeCommandL(CAiScutSettingsItem& aItem, TBool aNew = EFalse);

    /**
     * Chandles a setting change command to edit an URL
     *
     * @since S60 v3.2
     * @param aItem Applist item to modify
     * @param aNew ETrue if typing a new url, EFalse if editing an existing one
     * @return ETrue if shortcut was changed. EFalse if not
     */
    TBool HandleUrlChangeCommandL(CAiScutSettingsItem& aItem, TBool aNew = EFalse);

    /**
     * Handles text editing in an CAknTextSettingPage
     *
     * @since S60 v3.2
     * @param aResId Resource id for the text setting page
     * @param aDes The text to edit
     * @return ETrue if user pressed OK, ETrue if user pressed Cancel
     */
    TBool EditTextL(TInt aResId, TDes& aDes);

    /**
     * Shows the wait note dialog.
     *
     * @since S60 v3.2
     */
    void ShowWaitNoteDialogL();

    /**
     * Required for help.
     *
     */
    void GetHelpContext(TCoeHelpContext& aContext) const;

    /**
     * 
     */
    TKeyResponse OfferKeyEventL(const TKeyEvent& aKeyEvent, TEventCode aType);

    /**
     * Checks if there is a need to update the middle softkey label.
     */
    void CheckMiddleSoftkeyLabelL();

private:  // data

    /**
     * Settings plug-in model.
     * Not own.
     */
    CAiScutSettingsModel*       iModel;

    /**
     * Application selection list page.
     * Own.
     */
    CAknRadioButtonSettingPage* iAppListDialog;

    /**
     * Bookmark selection list page.
     * Own.
     */
    CAknRadioButtonSettingPage* iBkmListDialog;

    /**
     * Text setting page.
     * Own.
     */
    CAknSettingPage*            iEditDialog;

    /**
     * Wait dialog that is shown when the application list is not ready.
     * Own.
     */
    CAknWaitDialog*             iWaitDialog;

    /**
     *
     */
    TAiScutSettingType          iOldType;
    
    /**
    * Is the change process stopped by outside "forces"
    */
    TBool                       iChangeProcessStopped;
    
    /**
     * Is the change process in progress
     */
    TBool                       iChangeProcessInProgress;

};

#endif // CAISCUTSETTINGSCONTAINER_H

// End of File.
hs_app_caiscutsettingsitem.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for shortcut setting items.
*
*/


#ifndef CAISCUTSETTINGSITEM_H
#define CAISCUTSETTINGSITEM_H

#include 
#include "hs_app_aiscutsettings.hrh"

class CAiScutSettingsModel;
class CRepository;

/**
 * Line format for the settings list box
 */
_LIT(KSettingListboxLineFormat, " \t%S\t\t%S");

/**
 * Implements a shortcut setting item
 *
 * @since S60 v3.2
 */
class CAiScutSettingsItem : public CBase
{

public:

    /**
     * Constructs a new settings item leaving it on the cleanup stack
     *
     * @since S60 v3.2
     * @param aModel Reference to the plug-in model
     * @param aIndex Index of the setting in the setting list
     * @param aKey Setting item key
     * @param aValue Setting item value
     */
    static CAiScutSettingsItem* NewLC(
        CAiScutSettingsModel&   aModel,
        TInt                    aIndex,
        TUint32                 aKey);

    static CAiScutSettingsItem* NewLC(
        CAiScutSettingsModel&   aModel,
        TInt                    aIndex,
        TUint32                 aKey,
        const TDesC&            aValue);

    /**
     * Get item value from CRepository
     */
    void ReadL(CRepository* aRepository);

    /**
     * set item value into CRepository
     */
    TInt Save(CRepository* aRepository);

    /**
     *
     */
    virtual ~CAiScutSettingsItem();

    /**
     * Returns the setting item key
     *
     * @since S60 v3.2
     * @return Setting item key
     */
    inline TUint32 Key() const;

    /**
     * Returns the target shortcut uid
     *
     * @since S60 v3.2
     * @return Target shortcut uid
     */
    inline TUid Uid() const;

    /**
     * Returns the setting item type
     *
     * @since S60 v3.2
     * @return Setting item type
     */
    inline TAiScutSettingType Type() const;

    /**
     * Returns the setting item value
     *
     * @since S60 v3.2
     * @return Setting item value
     */
    TPtrC Value() const;

    /**
     * Returns the formatted listbox line descriptor
     *
     * @since S60 v3.2
     * @return Listbox line descriptor
     */
     TPtrC ListBoxLine() const;

    /**
     * Returns the setting item title
     *
     * @since S60 v3.2
     * @return setting item title
     */
    inline TPtrC Title() const;

    /**
     * Changes the setting item target application.
     * Can be used to change the setting item type to application setting
     *
     * @since S60 v3.2
     * @param aUid Target application uid
     * @param aParams Target application parameters, if any
     * @param aCaption Target application caption
     */
    void ChangeApplicationL(TUid aUid, const TDesC& aParams, const TDesC& aCaption);

    /**
     * Changes the setting item target bookmark.
     * Can be used to change the setting item type to bookmark setting
     *
     * @since S60 v3.2
     * @param aParams Target bookmark parameters
     * @param aCaption Target bookmark caption
     */
    void ChangeBookmarkL(const TDesC& aParams, const TDesC& aCaption);

    /**
     * Changes the setting item target url
     * Can be used to change the setting item type to an url setting
     *
     * @since S60 v3.2
     * @param aUrl Target url
     */
    void ChangeUrlL(const TDesC& aUrl);

private:

    /**
     *
     */
    CAiScutSettingsItem(
        CAiScutSettingsModel&   aModel,
        TInt                    aIndex,
        TUint32                 aKey);

    /**
     *
     */
    void ConstructL();

    /**
     *
     */
    void ConstructL(const TDesC& aValue);

    /**
     *
     */
    TInt ParseValueL(const TDesC& aValue);

    /**
     * Creates a formatted listbox line
     *
     * @since S60 v3.2
     * @param aCaption Caption to use in the listbox line
     */
    void CreateListBoxLineL(const TDesC& aCaption);

    /**
     * Creates a setting item title
     * Leaves the created descriptor on cleanup stack
     *
     * @since S60 v3.2
     * @return Key title
     */
    HBufC* CreateItemTitleLC();

    /**
     * Creates a key title for an optionally visible shortcut.
     * Leaves the created descriptor on cleanup stack
     *
     * @since S60 v3.2
     * @return Key title
     */
    HBufC* CreateOptionallyVisibleKeyTitleLC();

    /**
     * Creates a key title for a non-visible shortcut.
     * Leaves the created descriptor on cleanup stack
     *
     * @since S60 v3.2
     * @return Key title
     */
    //    HBufC* CreateNonVisibleKeyTitleLC();

protected:  // data

    /**
     * Reference to the plug-in model
     */
    CAiScutSettingsModel&   iModel;

    /**
     * Setting item index in the setting list
     */
    TInt                    iIndex;

    /**
     * Setting item key
     */
    TUint32                 iKey;

    /**
     * Setting item value
     * Own.
     */
    HBufC*                  iValue;

    /**
     * Target application uid
     */
    TUid                    iUid;

    /**
     * Setting item type
     */
    TAiScutSettingType      iType;

    /**
     * Formatted listbox line
     * Own.
     */
    HBufC*                  iListBoxLine;

    /**
     * Setting item title. Points to the iListBoxLine buffer
     */
    TPtrC                   iTitle;

};

#include "hs_app_caiscutsettingsitem.inl"

#endif // CAISCUTSETTINGSITEM_H

// End of File.
hs_app_caiscutsettingsitem.inl
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Inline functions for the shortcut settings item.
*
*/


// ---------------------------------------------------------------------------
// Returns the setting item key.
// ---------------------------------------------------------------------------
//
inline TUint32 CAiScutSettingsItem::Key() const
{
    return iKey;
}

// ---------------------------------------------------------------------------
// Returns the target shortcut uid.
// ---------------------------------------------------------------------------
//
inline TUid CAiScutSettingsItem::Uid() const
{
    return iUid;
}

// ---------------------------------------------------------------------------
// Returns the setting item type.
// ---------------------------------------------------------------------------
//
inline TAiScutSettingType CAiScutSettingsItem::Type() const
{
    return iType;
}



// ---------------------------------------------------------------------------
// Returns the setting item title.
// ---------------------------------------------------------------------------
//
inline TPtrC CAiScutSettingsItem::Title() const
{
    return iTitle;
}

// End of File.
hs_app_caiscutsettingsmodel.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shrortcut settings plug-in model.
*
*/


#ifndef CAISCUTSETTINGSMODEL_H
#define CAISCUTSETTINGSMODEL_H

#include 
#include                // For MDesCArray
#include                  // For RApaLsSession
#include            // For RFavouritesDb
#include      // For CFavouritesItemList

#include "hs_app_caiscutsettingsapplist.h"
#include "hs_app_caiscutsettingsbkmlist.h"

class CCoeEnv;
class CRepository;
class CAiScutSettingsItem;
class CAiScutSettingsContainer;
class CAiScutRepositoryWatcher;
class CAiScutSettings;

/**
 * Shrortcut settings plug-in model
 *
 * @lib hs_app_aiscutsettings.lib
 * @since S60 v3.2
 */
class CAiScutSettingsModel : public CBase
                           , public MDesCArray
                           , public MAiScutListObserver
{

public:

    /**
     *
     */
    static CAiScutSettingsModel* NewL(CAiScutSettings& aPlugin, CCoeEnv* aEnv);

    /**
     *
     */
    virtual ~CAiScutSettingsModel();

public: // from MDesCArray

    /**
     * Returns the number of descriptor elements in a descriptor array.
     *
     * @since S60 v3.2
     * @return The number of descriptor elements in a descriptor array.
     */
    TInt MdcaCount() const;

    /**
     * Indexes into a descriptor array.
     *
     * @since S60 v3.2
     * @param aIndex The position of the descriptor element within a descriptor array.
     * @return A 16 bit non-modifiable pointer descriptor representing the descriptor
     *         element located at position aIndex within a descriptor array.
     */
    TPtrC MdcaPoint(TInt aIndex) const;

    /**
     * Handle Shortcuts changed
     */
    static TInt HandleShortcutsChanged(TAny* aPtr);

    /**
     * Handle hidden Applications changed
     */
    static TInt HandleHiddenAppsChanged(TAny* aPtr);

public: // from MAiScutListObserver

    /**
     * From MAiScutListObserver
     * Callback for application list events
     *
     * @since S60 v3.2
     * @param aEvent AppList event code
     * @param aAdded ETrue if applications were added, EFalse if removed
     */
    void HandleScutListEventL(TScutListEvent aEvent, TBool aAdded);

    /**
     * Find application is hidden using Uid
     */
    TBool IsHidden(const TUid& aAppUid) const;

public:

    /**
     * Tells the application list and bookmark list to start or stop observing for changes
     */
    void ActivateObservers(TBool aActivate);

    /**
     * Returns a setting item for the given index
     *
     * @since S60 v3.2
     * @param aIndex Index of the setting item
     * @return Pointer to a setting item
     */
    CAiScutSettingsItem* Item(TInt aIndex) const;

    /**
     * Utility function to retrieve an appliation caption from an uid
     *
     * @since S60 v3.2
     * @param aUid Application uid
     * @return Pointer descriptor to the application caption
     */
    TInt GetAppCaption(const TUid aUid, TDes& aCaption);

    /**
     * Utility function to retrieve a bookmark caption from an uid
     *
     * @since S60 v3.2
     * @param aUid Bookmark uid
     * @return Pointer descriptor to the bookmark caption
     */
    TInt GetBkmCaptionL(const TUid aUid, TDes& aCaption);

    /**
     * Returns a pointer to the coe environment
     *
     * @since S60 v3.2
     * @return Pointer to coe environment
     */
    CCoeEnv* Env();

    /**
     * Handles saving a setting item to central repository
     *
     * @since S60 v3.2
     * @param aItem Item to save
     */
    void SaveItemL(CAiScutSettingsItem& aItem);

    /**
     * Sets pointer to settings plug-in container.
     *
     * @since S60 v3.2
     * @param aContainer Pointer to settings plug-in container.
     */
    void SetContainer(CAiScutSettingsContainer* aContainer);

    /**
     * Read bookmarks from favourites engine.
     *
     */
    void ReadBookmarksL();

    /**
     * Return bookmark count.
     */
    TInt BookmarkCount() const;

    /**
     * Get bookmark from index aIndex.
     */
    CFavouritesItem* GetBookmark(TInt aIndex);

    /**
     * Returns reference to the bookmark database owned by the engine
     *
     * @return Reference to RFavouritesDb
     */
    RFavouritesDb& FavouritesDb();

    /**
     *
     */
    CAiScutSettingsAppList* AppList();

    /**
     *
     */
    CAiScutSettingsBkmList* BkmList();
    
    /**
     *
     */
    void SetSettingsKeys(RArray& aKeys);
    
    /**
     *
     */
    void UpdateSettingsL();    

    /**
     *
     */
    void UpdateSettingsContainerL();

private:

    /**
     *
     */
    CAiScutSettingsModel(CAiScutSettings& aPlugin, CCoeEnv* aEnv);

    /**
     *
     */
    void ConstructL();


    /**
     *
     */
    void GetHiddenAppsL();

private:  // data

    /**
     * Array of setting items.
     * Own.
     */
    RPointerArray  iSettings;

    /**
     * Array of keys for settings items
     * Own.
     */    
    RArray                     iKeys;

    /**
     * Central repository handler.
     * Own.
     */
    CRepository*                        iRepository;

    /**
     * Application architecture server session.
     * Own.
     */
    RApaLsSession                       iApaSession;

    /**
     * Bookmark database session.
     * Own.
     */
    RFavouritesSession                  iBookmarkSess;

    /**
     * Bookmark database.
     * Own.
     */
    RFavouritesDb                       iBookmarkDb;

    /**
     * Bookmark list.
     * Own.
     */
    CFavouritesItemList*                iFavItemList;

    /**
     * Settings plugin
     * Not own.
     */    
    CAiScutSettings&                    iPlugin;     

    /**
     * Coe environment.
     * Not own.
     */
    CCoeEnv*                            iEnv;

    /**
     * Application list.
     * Own.
     */
    CAiScutSettingsAppList*             iAppList;

    /**
     * Bookmark list.
     * Own.
     */
    CAiScutSettingsBkmList*             iBkmList;

    /**
     * Notifier for changes in the shortcut settings.
     * Own.
     */
    CAiScutRepositoryWatcher*           iSettingsNotifier;

    /**
     * Settings plugin container.
     * Not own.
     */
    CAiScutSettingsContainer*           iContainer;

    // Array of UIDs which are hidden from the TARM
    RArray                        iHiddenApps;

    // Central repository object for Hidden Apps
    CRepository*                        iHiddenAppsRepository;

    // Central repository change handler for Hidden Apps
    CAiScutRepositoryWatcher*           iHiddenAppsNotifier;

};

#endif // CAISCUTSETTINGSMODEL_H

// End of File.
hs_app_caiscutshortcut.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Implementation for a shortcut.
*
*/


#ifndef CAISCUTSHORTCUT_H
#define CAISCUTSHORTCUT_H

#include 

#include "hs_app_taiscutparser.h"

class CAiScutEngine;
class CAiScutTarget;
class MAiContentObserver;
class MAiPropertyExtension;

/**
 *  Implementation for a shortcut
 *
 *  Handles parsing and launching an application shortcut
 *
 *  @since S60 v3.2
 */
class CAiScutShortcut : public CTimer
{

public:

    /**
     * First phase constructor.
     * Leaves the object on cleanup stack
     *
     * @since S60 v3.2
     * @param aId Shortcut id
     * @param aTarget The shortcut definition string.
     * @param aEngine Reference to shortcut plug-in engine
     */
    static CAiScutShortcut* NewLC(TInt aId, const TDesC& aTarget,
        CAiScutEngine& aEngine);

    /**
     * First phase constructor
     *
     * @since S60 v3.2
     * @param aId Shortcut id
     * @param aTarget The shortcut definition string
     * @param aEngine Reference to shortcut plug-in engine
     */
    static CAiScutShortcut* NewL(TInt aId, const TDesC& aTarget,
        CAiScutEngine& aEngine);

    virtual ~CAiScutShortcut();

    /**
     * Returns the shortcut id
     *
     * @since S60 v3.2
     * @return Shortcut id
     */
    TInt32 Id() const;

    /**
     * Publishes the shortcut content, non leaving version
     *
     * @since S60 v3.2
     * @param aPlugin Reference to plug-in
     * @param aObserver Content observer to publish to
     */
    void Publish(MAiPropertyExtension& aPlugin, MAiContentObserver& aObserver);

    /**
     * Checks if the application pointed to can be launched and reverts to the
     * default setting if not. If no valid target can be found, the shortcut
     * becomes empty. May only leave with KErrNotReady to signify that application
     * architecture server or message server is not ready and access check should
     * be retried later.
     *
     * @since S60 v3.2
     * @param aCheckType Specifies which kind of shortcuts should check its access
     * @return ETrue if the shortcut target is accessible
     */
    TBool CheckAccessL(TInt aCheckType);

    /**
     *
     */
    TBool IsTargetChanged() const;

    /**
     * Changes the shortcut target to the user defined setting
     *
     * @since S60 v3.2
     * @param aNewTarget The new user defined shortcut target
     */
    void SetUserTarget(const TDesC& aNewTarget);

    /**
     * Deletes the user target.
     *
     * @since S60 v3.2
     */
    void DeleteUserTarget();

    /**
     * Launches the shortcut
     *
     * @since S60 v3.2
     */
    void LaunchL();

    /**
     * Launches the shortcut
     *
     * @since S60 v5.1
     * @param aMessage A message to pass
     */
    void LaunchL(const TDesC8& aMessage);
    
    /**
     * Set call state
     *
     * @since S60 v3.2
     */
    void SetCallState(TBool aStatus);

    /**
     *
     * @since S60 v3.2
     */
    void SetToBePublished(TBool aFlag);

    /**
     *
     * @since S60 v3.2
     */
    TBool NeedsToBePublished();

    /**
     * Return shortcut type.
     *
     * @since S60 v3.2
     */
    TShortcutType Type() const;

    /**
     * Return application uid of this shortcut.
     *
     * @since S60 v3.2
     */
    TUid AppUid() const;

    /**
     * Return an additional id this target may use when 
     * launching.
     *
     * @since S60 v3.2
     */
    TUid AdditionalUid() const;
    
    /**
     * Return current valid definition.
     *
     * @since S60 v3.2
     */
    TPtrC ActiveDefinition();
    
    /**
     * Set the icon to publish to softkeys,
     * icon area or to touch toolbar. Uses
     * aIcon.iDestination to determine which icon
     * is in question
     *
     * @since S60 v5.0
     */
    void SetIcon(TAiScutIcon aIcon);


protected:


    CAiScutShortcut(TInt aId, CAiScutEngine& aEngine);

    void ConstructL(const TDesC& aTarget);

    /**
     * Creates a shortcut target object
     *
     * @since S60 v3.2
     * @param aDefinition Shortcut target definition
     * @return Pointer to shortcut target object
     */
    CAiScutTarget* CreateTargetL(
        const TDesC& aDefinition, TBool aCreateUserTarget);

    /**
     * Publishes the shortcut content, leaving version
     *
     * @since S60 v3.2
     * @param aPlugin Reference to plug-in
     * @param aObserver Content observer to publish to
     */
    virtual void PublishL(MAiPropertyExtension& aPlugin, MAiContentObserver& aObserver);

    /**
     * Publishes shortcut caption
     *
     * @since S60 v3.2
     * @param aPlugin Reference to plug-in
     * @param aObserver Content observer to publish to
     */
    virtual TInt PublishCaption(
        MAiPropertyExtension& aPlugin, MAiContentObserver& aObserver,
        TInt aCaptionContentId) const;

    /**
     * Publishes shortcut icon
     *
     * @since S60 v3.2
     * @param aPlugin Reference to plug-in
     * @param aObserver Content observer to publish to
     */
    virtual TInt PublishIcon(
        MAiPropertyExtension& aPlugin, MAiContentObserver& aObserver, TInt aIconContentId);

    /**
     * Set the icon to use instead of default icon
     *
     * @since S60 v3.2
     */
    void SetOverrideIcon(TAiScutIcon aIcon);

    /**
     * Set the icon to publish to softkeys
     *
     * @since S60 v3.2
     */
    void SetSoftkeyIcon(TAiScutIcon aIcon);

    /**
     * Set the icon to publish to touch toolbar
     *
     * @since S60 v5.0
     */
    void SetToolbarIcon(TAiScutIcon aIcon);
    
// from CActive/CTimer
		
	TInt RunError(TInt aError);
		
	void DoCancel();
		
	void RunL();

protected:  // data

    /**
     * Shortcut id.
     */
    TInt32          iId;

    /**
     * Default shortcut target.
     * Own.
     */
    CAiScutTarget*  iDefaultTarget;

    /**
     * User defined shortcut target.
     * Own.
     */
    CAiScutTarget*  iUserTarget;

    /**
     * Stores the old target data while the new one is being published.
     * During publishing the framework might still dereference pointers in the old
     * target so it must be kept alive until the new target is successfully published.
     * If publishing fails, this is taken back to use and the new target is deleted.
     * Own.
     */
    CAiScutTarget*  iRetiredTarget;

    /**
     * Pointer to the last published target.
     * DO NOT DELETE THROUGH THIS!
     * Not own.
     */
    CAiScutTarget*  iLastPublishedTarget;

    /**
     * Pointer to the active target.
     * Can point either to iDefaultTarget, iUserTarget or NULL
     * DO NOT DELETE THROUGH THIS!
     * Not own.
     */
    CAiScutTarget*  iActiveTarget;

    /**
     * Reference to the shortcut plug-in engine.
     */
    CAiScutEngine&  iEngine;

    /**
     * Boolean indicating if this shortcut needs to be published.
     */
    TBool           iNeedsToBePublished;

    /**
     * Call state
     */
    TBool           iActiveCall;
    
    /**
     * Force the publish of this shortcut. For example
     * after call state has changed the actual shortcut
     * isn't changed but it still needs to be published.
     */
    TBool           iForcePublish;

};

#endif // CAISCUTSHORTCUT_H

// End of File.
hs_app_caiscutshortcutext.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in shortcut extensions
*
*/


#ifndef CAISCUTSHORTCUTEXT_H
#define CAISCUTSHORTCUTEXT_H

#include 
#include 
#include 

#include "hs_app_caiscutshortcut.h"
#include "hs_app_mpopupeventhandleractions.h"

class CPopupEventHandler;
class MAiScutExtData;

/**
 *
 *  The class extends CAiScutShortcut by offering means to store
 *  changeable popup text lines. The class overrides content publishing
 *  functions from base class.
 *
 *  @since S60 v3.2
 */
class CAiScutShortcutExt : public CAiScutShortcut,
    public MPopupEventHandlerActions
    {
    public:
        /**
         * Factory function
         * @see CAiScutShortcut
         * @since S60 v3.2
         */
        static CAiScutShortcutExt* NewL( TInt aId, const TDesC& aTarget,
            CAiScutEngine& aEngine );

        /**
         * Factory function
         * @see CAiScutShortcut
         * @since S60 v3.2
         */
        static CAiScutShortcutExt* NewLC( TInt aId, const TDesC& aTarget,
            CAiScutEngine& aEngine );

        /**
         * Destructor
         * @since S60 v3.2
         */
        ~CAiScutShortcutExt();

    private:
        CAiScutShortcutExt( TInt aId, CAiScutEngine& aEngine );
        void ConstructL( const TDesC& aTarget );

    public:  // New functions
        /**
         * @return Definition string of active target
         * @since S60 v3.2
         */
        TPtrC ActiveTargetDefinition() const;

        /**
         * Handles events (e.g. gain/lost focus) from AI framework
         * @param aEvent Event
         * @since S60 v3.2
         */
        void HandleAIEventL( TInt aEvent );

        /**
         * Handles Resumed event
         * @param aResumeReason Resume reason
         * @since S60 v3.2
         */
        void HandleResumed( TAiTransitionReason aResumeReason );

        /**
         * Set extension data
         * @param aAiScutExtData Pointer to new extension data
         * @since S60 v3.2
         */
        void SetAiScutExtData( const MAiScutExtData* aAiScutExtData );


    private: // From CAiScutShortcut
        void PublishL( MAiPropertyExtension& aPlugin, 
            MAiContentObserver& aObserver );

        TInt PublishCaption( MAiPropertyExtension& aPlugin, 
            MAiContentObserver& aObserver, TInt aCaptionContentId) const;

        void PublishPopupText( MAiPropertyExtension& aPlugin, 
            MAiContentObserver& aObserver ) const;
        
        TInt PublishIcon( MAiPropertyExtension& aPlugin,
            MAiContentObserver& aObserver, TInt aIconContentId );

    private:    // From MPopupEventHandlerActions
        void IssuePublishShortcut();
        
    private: // data

        /**
         * Extension data
         * Ref.
         */
        const MAiScutExtData* iAiScutExtData;
        
        /**
         * Flag that tells whether to publish or clean the popup text box.
         * The flag is controlled by iPopupEventHandler
         * Own.
         */
        //TBool iPublishLineArray;

        /**
         * Handler of various events, includes state machine
         * Own.
         */
        CPopupEventHandler* iPopupEventHandler;
        
        /**
         * Pointer to previous popup line array. This is used detect changes
         * in data.
         * Ref.
         */
        const MDesCArray* iPreviousPopupLineArray;

        /**
         * Pointer to previous icon. This is used detect changes
         * in data.
         * Ref.
         */
        const CGulIcon* iPreviousIcon;
        
        /**
         * Has the icon changed
         */
        TBool iIconChanged;
        
        /**
         * Has the text changed
         */
        TBool iTextChanged;

    };

#endif // CAISCUTSHORTCUTEXT_H

// End of File.
hs_app_caiscutshortcutinfo.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Small container for shortcut info.
*
*/


#ifndef CAISCUTSHORTCUTINFO_H
#define CAISCUTSHORTCUTINFO_H

#include 

/**
 *  Implementation for a shortcut
 *
 *  Handles parsing and launching an application shortcut
 *
 *  @since S60 v3.2
 */
class CAiScutShortcutInfo : public CBase
{

public:

    /**
     * First phase constructor
     *
     * @since S60 v3.2
     * @param aId Shortcut id
     * @param aTarget The shortcut definition string
     */
    static CAiScutShortcutInfo* NewL(TInt aId, const TDesC& aTarget);

    virtual ~CAiScutShortcutInfo();

    /**
     * Returns the shortcut id
     *
     * @since S60 v3.2
     * @return Shortcut id
     */
    TInt32 Id() const;

    /**
     * Returns the shortcut target string.
     *
     * @since S60 v3.2
     * @return Shortcut target string
     */
    const TDesC& Target();
    
protected:

private:

    CAiScutShortcutInfo(TInt aId);

    void ConstructL(const TDesC& aTarget);

private:  // data

    /**
     * Shortcut id.
     */
    TInt32          iId;

    /**
     * Shortcut target string.
     * Own.
     */
    HBufC*  iTarget;

};

#endif // CAISCUTSHORTCUTINFO_H

// End of File.
hs_app_caiscuttarget.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Base class for all shortcut targets.
*
*/


#ifndef CAISCUTTARGET_H
#define CAISCUTTARGET_H

#include 

#include "hs_app_taiscutparser.h"
#include "aiscutdefs.h"
#include 

class CAiScutEngine;
class CGulIcon;

_LIT(KBitmapFile, "aiscutplugin.mif");

/**
 *  Base class for shortcut targets
 *
 *  @since S60 v3.2
 */
class CAiScutTarget : public CBase
{

public:

    virtual ~CAiScutTarget();

    /**
     * Returns the shortcut definition string.
     *
     * @since S60 v3.2
     * @return Shortcut definition string
     */
    virtual TPtrC Definition() const = 0;

    /**
     * Returns the shortcut target caption.
     * Caption can be either a descriptor or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the descriptor reference parameter is used.
     * Default implementation returns KErrNotSupported;
     *
     * Getting the target caption and icon utilizes the "lazy evaluation" idiom
     * which means they are created only when they are first needed. This is because
     * there are (atleast) two scenarios where they are never needed:
     * 1. The active theme does not support shortcut captions or icons.
     * 2. Shortcuts launched using LaunchByValue are never published.
     *
     * @since S60 v3.2
     * @param aDes On return, the descriptor if used
     * @return The resource id or zero to indicate that the descriptor is used.
     */
    virtual TInt GetCaption( TPtrC& aDes, TAiScutAppTitleType aTitleType ) const;

    /**
     * Returns the shortcut target icon.
     * Icon can be either an icon pointer or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the icon pointer is used.
     * Default implementation returns the icon that has possibly
     * been set with @c SetOverrideIcon() and returns
     * KErrNotSupported if no override icon has been set.
     *
     * Uses the "lazy evaluation" idiom to get the icon. See Caption()
     *
     * @since S60 v3.2
     * @param aIcon On return, the icon pointer if used
     * @return The resource id or zero to indicate that the icon pointer is used.
     */
    virtual TInt GetIcon( CGulIcon*& aIcon ) const;
    
     /**
     * Returns the shortcut icon that can be published to softkeys
     * Icon can be either an icon pointer or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the icon pointer is used.
     * Default implementation returns the icon that has possibly
     * been set with @c SetSoftkeyIcon() and returns
     * KErrNotSupported if no softkey icon has been set.
     *
     * Uses the "lazy evaluation" idiom to get the icon. See Caption()
     *
     * @since S60 v3.2
     * @param aIcon On return, the icon pointer if used
     * @return The resource id or zero to indicate that the icon pointer is used.
     */
    virtual TInt GetSoftkeyIcon( CGulIcon*& aIcon ) const;

     /**
     * Returns the shortcut icon that can be published to toolbar
     * Icon can be either an icon pointer or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the icon pointer is used.
     * Default implementation returns the icon that has possibly
     * been set with @c SetSoftkeyIcon() and returns
     * KErrNotSupported if no softkey icon has been set.
     *
     * Uses the "lazy evaluation" idiom to get the icon. See Caption()
     *
     * @since S60 v3.2
     * @param aIcon On return, the icon pointer if used
     * @return The resource id or zero to indicate that the icon pointer is used.
     */
    virtual TInt GetToolbarIcon( CGulIcon*& aIcon ) const;

    /**
     * Checks if the shortcut target is accessible.
     *
     * @since S60 v3.2
     * @param aCheckType Specifies which kind of shortcuts should check its access
     * @return ETrue if accessible, EFalse if not
     */
    virtual TBool IsAccessibleL( TInt aCheckType ) = 0;

    /**
     * Launches the shortcut.
     *
     * @since S60 v3.2
     */
    virtual void LaunchL() = 0;

    /**
     * Launches the shortcut.
     *
     * @since S60 v5.1
     * @param aMessage A message to pass
     */
    virtual void LaunchL(const TDesC8& aMessage) { (void)aMessage; };

    /**
     * Return application uid this target launches.
     *
     * @since S60 v3.2
     */
    virtual TUid AppUid() const = 0;

    /**
     * Return an additional id this target may use when 
     * launching. Default implementation return TUid(-1)
     *
     * @since S60 v3.2
     */
    virtual TUid AdditionalUid() const;

    /**
     * Return shortcut type.
     *
     * @since S60 v3.2
     */
    TShortcutType Type() const;
    
    /**
     * Starts a full screen effect.
     */
    void BeginEffectL();

    /**
     * Set the icon that overrides the shortcut default
     * icon. Instead of fetching the icon from for example an
     * application the icon defined here can be used. The shortcut
     * can use the @c GetIcon() to fetch the 
     * icon defined here. Currently we support
     * icon loading from skin or from MIF/MBM-file. 
     * The file must reside under z:\resource altough
     * it can be under some subdirectory. 
     *
     * @since S60 v3.2
     * @param aIcon The overriding icon
     */
    void SetOverrideIcon(TAiScutIcon aIcon);
    
    /**
     * Set the icon that is to be published to softkeys
     * The @c GetSoftkeyIcon() can be used to fetch the 
     * icon defined here. Currently we support
     * icon loading from skin or from MIF/MBM-file. 
     * The file must reside under z:\resource altough
     * it can be under some subdirectory. 
     *
     * @since S60 v3.2
     * @param aIcon The softkey icon
     */
    void SetSoftkeyIcon(TAiScutIcon aIcon);

    /**
     * Set the icon that is to be published to touch toolbar
     * The @c GetSoftkeyIcon() can be used to fetch the 
     * icon defined here. Currently we support
     * icon loading from skin or from mif-file. 
     * The mif-file must reside under z:\resource altough
     * it can be under some subdirectory. 
     *
     * @since S60 v5.0
     * @param aIcon The softkey icon
     */
    void SetToolbarIcon(TAiScutIcon aIcon);
    
protected:

    CAiScutTarget( CAiScutEngine& aEngine, TShortcutType aType );

private:
    
    /**
     * Returns the icon defined in aIconToLoads. Loads the icon
     * from MIF/MBM-file or from skin.
     *
     * @return KErrNone if no error
    */
    TInt GetIcon(const TAiScutIcon &aIconToLoad, CGulIcon *&aIcon ) const;
    
    /**
    * Loads an icon defined in aIconToLoad from skin
    *
    * @return KErrNone if no error
    */
    void LoadIconFromSkinL(const TAiScutIcon &aIconToLoad, CGulIcon*& aIcon) const;
    
    /**
    * Loads an icon defined in aIconToLoad from MIF/MBM-file
    * The file must reside under z:\resource. It can be under
    * some subdirectory.
    *
    * @return KErrNone if no error
    */
    void LoadIconFromFileL(const TAiScutIcon &aIconToLoad, CGulIcon*& aIcon) const;


protected:  // data

    /**
     * Reference to shortcut plug-in engine.
     */
    CAiScutEngine&  iEngine;

    /**
     * Shortcut type.
     */
    TShortcutType   iType;
    
    /**
    * Icon that is meant to override the default icon
    */
    TAiScutIcon iOverrideIcon;
   
    /**
    * Icon that is to be published to softkeys
    */
    TAiScutIcon     iSoftkeyIcon;
    
   /**
    * Icon that is to be published to toolbar
    */
    TAiScutIcon     iToolbarIcon;
   
};

#endif // CAISCUTTARGET_H

// End of File.
hs_app_caiscuttargetapp.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for application shortcut target.
*
*/


#ifndef CAISCUTTARGETAPP_H
#define CAISCUTTARGETAPP_H

#include "hs_app_caiscuttarget.h"

class CPeriodic; 
class MAknsSkinInstance; 
/**
 *  Implements an application shortcut target
 *
 *  Handles parsing and launching an application shortcut target
 *
 *  @since S60 v3.2
 */
class CAiScutTargetApp : public CAiScutTarget
{

public:

    /**
     * First phase constructor
     *
     * @since S60 v3.2
     * @param aEngine Reference to the plug-in engine
     * @param aParser Shortcut definition parser
     */
    static CAiScutTargetApp* NewL(
        CAiScutEngine& aEngine, TShortcutType aType, const TAiScutParser& aParser);

    virtual ~CAiScutTargetApp();

    /**
     * Returns the shortcut definition string
     *
     * @since S60 v3.2
     * @return Shortcut definition string
     */
    TPtrC Definition() const;

    /**
     * Returns the shortcut target caption.
     * Caption can be either a descriptor or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the descriptor reference parameter is used.
     * Default implementation returns KErrNotSupported;
     *
     * Getting the target caption and icon utilizes the "lazy evaluation" idiom
     * which means they are created only when they are first needed. This is because
     * there are (atleast) two scenarios where they are never needed:
     * 1. The active theme does not support shortcut captions or icons.
     * 2. Shortcuts launched using LaunchByValue are never published.
     *
     * @since S60 v3.2
     * @param aDes On return, the descriptor if used
     * @return The resource id or zero to indicate that the descriptor is used.
     */
    TInt GetCaption(TPtrC& aDes, TAiScutAppTitleType aTitleType) const;

    /**
     * Returns the shortcut target icon.
     * Icon can be either an icon pointer or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the icon pointer is used.
     * Default implementation returns KErrNotSupported;
     *
     * Uses the "lazy evaluation" idiom to get the icon. See Caption()
     *
     * @since S60 v3.2
     * @param aIcon On return, the icon pointer if used
     * @return The resource id or zero to indicate that the icon pointer is used.
     */
    TInt GetIcon(CGulIcon*& aIcon) const;

     /**
     * Returns the shortcut icon that can be published to toolbar
     * Icon can be either an icon pointer or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the icon pointer is used.
     * Default implementation returns the icon that has possibly
     * been set with @c SetSoftkeyIcon() and returns
     * KErrNotSupported if no softkey icon has been set.
     *
     * Uses the "lazy evaluation" idiom to get the icon. See Caption()
     *
     * @since S60 v3.2
     * @param aIcon On return, the icon pointer if used
     * @return The resource id or zero to indicate that the icon pointer is used.
     */
    TInt GetToolbarIcon(CGulIcon*& aIcon) const;

    /**
     * Checks if the shortcut target is accessible
     *
     * @since S60 v3.2
     * @param aCheckType Specifies which kind of shortcuts should check its access
     * @return ETrue if accessible, EFalse if not
     */
    TBool IsAccessibleL(TInt aCheckType);

    /**
     * Launches the shortcut
     *
     * @since S60 v3.2
     */
    void LaunchL();

    /**
     * Launches the shortcut
     *
     * @since S60 v5.1
     */
    void LaunchL( const TDesC8& aCustomMessage );

    /**
     * Return application uid this target launches.
     *
     * @since S60 v3.2
     */
    TUid AppUid() const;
    
    /**
     * Return an additional id this target may use when 
     * launching. Default implementation return TUid(-1)
     *
     * @since S60 v3.2
     */
    TUid AdditionalUid() const;

protected:

private:

    CAiScutTargetApp(CAiScutEngine& aEngine, TShortcutType aType, const TUid aUid);

    void ConstructL(const TAiScutParser& aParser);

    /**
     *
     */
    void GetCaptionL(TAiScutAppTitleType aTitleType) const;

    /**
     * Creates the application icon
     *
     * @since S60 v3.2
     */
    void CreateAppIconL(CGulIcon*& aIcon) const;

    /**
     * Creates the NonNative application icon
     *
     * @since S60 v3.2
     */
    CGulIcon* CreateNonNativeIconL() const;

    /**
     * Performs Central Repository shortcut set
     * for EasyVoIP application.
     */
    void SetEasyVoIPShortcutStartL() const;
    
    CGulIcon* CreateSubstituteIconL( MAknsSkinInstance* aSkin, TUid aAppUid, TUid iViewUid ) const;
private:  // data

    /**
     * Application uid.
     */
    TUid                iAppUid;

    /**
     * Possible view uid.
     */
    TUid                iViewUid;

    /**
     * Shortcut caption.
     * Own.
     */
    mutable HBufC*      iCaption;

    /**
     * Shortcut short caption.
     * Own.
     */
    mutable HBufC*      iShortCaption;

    /**
     * Holds the shortcut definition string.
     * Own.
     */
    HBufC*              iDefinition;

    /**
     * Run the application in the background.
     */
    TBool               iBackground;

    /**
     * Command line parameter.
     * Own.
     */
    HBufC8*              iMsg;

};

#endif // CAISCUTTARGETAPP_H

// End of File.
hs_app_caiscuttargetbkm.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for bookmark shortcut target.
*
*/


#ifndef CAISCUTTARGETBKM_H
#define CAISCUTTARGETBKM_H

#include "hs_app_caiscuttarget.h"

/**
 *  Implements an bookmark shortcut target
 *
 *  Handles parsing and launching an bookmark shortcut target
 *
 *  @since S60 v3.2
 */
class CAiScutTargetBkm : public CAiScutTarget
{

public:

    /**
     * First phase constructor
     *
     * @since S60 v3.2
     * @param aEngine Reference to the plug-in engine
     * @param aParser Shortcut definition parser
     */
    static CAiScutTargetBkm* NewL(
        CAiScutEngine& aEngine, TShortcutType aType, const TAiScutParser& aParser);

    virtual ~CAiScutTargetBkm();

    /**
     * Returns the shortcut definition string
     *
     * @since S60 v3.2
     * @return Shortcut definition string
     */
    TPtrC Definition() const;

    /**
     * Returns the shortcut target caption.
     * Caption can be either a descriptor or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the descriptor reference parameter is used.
     * Default implementation returns KErrNotSupported;
     *
     * Getting the target caption and icon utilizes the "lazy evaluation" idiom
     * which means they are created only when they are first needed. This is because
     * there are (atleast) two scenarios where they are never needed:
     * 1. The active theme does not support shortcut captions or icons.
     * 2. Shortcuts launched using LaunchByValue are never published.
     *
     * @since S60 v3.2
     * @param aDes On return, the descriptor if used
     * @return The resource id or zero to indicate that the descriptor is used.
     */
    TInt GetCaption(TPtrC& aDes, TAiScutAppTitleType aTitleType) const;

    /**
     * Returns the shortcut target icon.
     * Icon can be either an icon pointer or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the icon pointer is used.
     * Default implementation returns KErrNotSupported;
     *
     * Uses the "lazy evaluation" idiom to get the icon. See Caption()
     *
     * @since S60 v3.2
     * @param aIcon On return, the icon pointer if used
     * @return The resource id or zero to indicate that the icon pointer is used.
     */
    TInt GetIcon(CGulIcon*& aIcon) const;

    /**
     * Checks if the shortcut target is accessible
     *
     * @since S60 v3.2
     * @param aCheckType Specifies which kind of shortcuts should check its access
     * @return ETrue if accessible, EFalse if not
     */
    TBool IsAccessibleL(TInt aCheckType);

    /**
     * Launches the shortcut
     *
     * @since S60 v3.2
     */
    void LaunchL();

    /**
     * Return application uid this target launches.
     *
     * @since S60 v3.2
     */
    TUid AppUid() const;
    
    /**
     * Return an additional id this target may use when 
     * launching. Default implementation return TUid(-1)
     *
     * @since S60 v3.2
     */
    TUid AdditionalUid() const;

protected:

private:

    CAiScutTargetBkm(CAiScutEngine& aEngine, TShortcutType aType);

    void ConstructL(const TAiScutParser& aParser);

    /**
     *
     */
    void GetCaptionL() const;

private:  // data

    /**
     * Bookmark uid.
     */
    TUid                iBkmUid;

    /**
     * Shortcut caption.
     * Own.
     */
    mutable HBufC*      iCaption;

    /**
     * Holds the shortcut definition string.
     * Own.
     */
    HBufC*              iDefinition;

};

#endif // CAISCUTTARGETAPP_H

// End of File.
hs_app_caiscuttargetempty.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Empty target
*
*/


#ifndef CAISCUTEMPTY_H
#define CAISCUTEMPTY_H

#include "hs_app_caiscuttarget.h"

/**
 *  Empty target.
 *
 *  @since S60 v3.2
 */
class CAiScutTargetEmpty : public CAiScutTarget
{
public:     // Constructors and destructor

    /**
     * Two-phased constructor.
     * @param
     * @return new instance.
     */
    static CAiScutTargetEmpty* NewL(
        CAiScutEngine& aEngine, TShortcutType aType, const TDesC& aTarget );

    /**
     * Destructor.
     */
    virtual ~CAiScutTargetEmpty();

    /**
     * Returns the shortcut definition string
     *
     * @since S60 v3.2
     * @return Shortcut definition string
     */
    TPtrC Definition() const;

    /**
     * See base class
     */
    TInt GetCaption(TPtrC& aDes, TAiScutAppTitleType aTitleType) const;

    /**
     * See base class
     */
    TInt GetIcon(CGulIcon*& aIcon) const;

    /**
	 * See base class
     */
    TBool IsAccessibleL(TInt aCheckType);

    /**
     * Launches the shortcut
     *
     * @since S60 v3.2
     */
    void LaunchL();

    /**
     * Return application uid this target launches.
     *
     * @since S60 v3.2
     */
    TUid AppUid() const;

private: // New methods

    /**
     * C++ default constructor.
     */
    CAiScutTargetEmpty( CAiScutEngine& aEngine, TShortcutType aType );

    /**
     * By default Symbian OS constructor is private.
     */
    void ConstructL( const TDesC& aTarget );

private:  // Data

    /**
     * Holds the shortcut definition string
     * Owned.
     */
    HBufC*              iDefinition;

};

#endif

// End of File.
hs_app_caiscuttargethttp.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for http shortcut target.
*
*/


#ifndef CAISCUTTARGETHTTP_H
#define CAISCUTTARGETHTTP_H

#include "hs_app_caiscuttarget.h"

/**
 * Command line parameter for browser to open an url
 */
_LIT( KOpenUrlParam, "4 " );

/**
 *  Implements an http shortcut target
 *
 *  Handles parsing and launching an http shortcut target
 *
 *  @since S60 v3.2
 */
class CAiScutTargetHttp : public CAiScutTarget
{

public:

    /**
     * First phase constructor
     *
     * @since S60 v3.2
     * @param aEngine Reference to the plug-in engine
     * @param aTarget The shortcut definition string
     */
    static CAiScutTargetHttp* NewL(
        CAiScutEngine& aEngine, TShortcutType aType, const TAiScutParser& aParser );

    virtual ~CAiScutTargetHttp();

    /**
     * Returns the shortcut definition string
     *
     * @since S60 v3.2
     * @return Shortcut definition string
     */
    TPtrC Definition() const;

    /**
     * See base class
     */
    TInt GetCaption(TPtrC& aDes, TAiScutAppTitleType aTitleType) const;

    /**
     * See base class
     */
    TInt GetIcon(CGulIcon*& aIcon) const;

    /**
     * See base class
     */
    TBool IsAccessibleL(TInt aCheckType);

    /**
     * Launches the shortcut
     *
     * @since S60 v3.2
     */
    void LaunchL();

    /**
     * Return application uid this target launches.
     *
     * @since S60 v3.2
     */
    TUid AppUid() const;

    /**
     * Return additional UID this target refers to. In 
     * URL case this is a unique identifer created from the URL
     * 
     * @since S60 v3.2
     */
    TUid AdditionalUid() const;
protected:

private:

    CAiScutTargetHttp( CAiScutEngine& aEngine, TShortcutType aType );

    void ConstructL( const TAiScutParser& aParser );

private:  // data

    /**
     * Target caption, part of the http address or
     * custom title given with the URL string
     */
    mutable HBufC*       iCaption;

    /**
     * Holds the shortcut definition string
     * Owned.
     */
    HBufC*              iDefinition;
    
    /**
     * Checksum for the URL
     */
    TUid                iChecksum;

};

#endif // CAISCUTTARGETHTTP_H

// End of File.
hs_app_caiscuttargetkeylock.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Keylock
*
*/


#ifndef CAISCUTKEYLOCK_H
#define CAISCUTKEYLOCK_H

#include 
#include "hs_app_caiscuttarget.h"

/**
 *  Takes care of locking the keypad.
 *
 *  @since S60 v3.2
 */
class CAiScutTargetKeyLock : public CAiScutTarget
{
public:     // Constructors and destructor

    /**
     * Two-phased constructor.
     * @param
     * @return new instance.
     */
    static CAiScutTargetKeyLock* NewL(
        CAiScutEngine& aEngine, TShortcutType aType, const TDesC& aTarget);

    /**
     * Destructor.
     */
    virtual ~CAiScutTargetKeyLock();

    /**
     * Returns the shortcut definition string
     *
     * @since S60 v3.2
     * @return Shortcut definition string
     */
    TPtrC Definition() const;

    /**
     * Returns the shortcut target caption.
     * Caption can be either a descriptor or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the descriptor reference parameter is used.
     * Default implementation returns KErrNotSupported;
     *
     * Getting the target caption and icon utilizes the "lazy evaluation" idiom
     * which means they are created only when they are first needed. This is because
     * there are (atleast) two scenarios where they are never needed:
     * 1. The active theme does not support shortcut captions or icons.
     * 2. Shortcuts launched using LaunchByValue are never published.
     *
     * @since S60 v3.2
     * @param aDes On return, the descriptor if used
     * @return The resource id or zero to indicate that the descriptor is used.
     */
    TInt GetCaption(TPtrC& aDes, TAiScutAppTitleType aTitleType) const;

    /**
     * Returns the shortcut target icon.
     * Icon can be either an icon pointer or a resource id.
     * If the return value has a non-zero value, it is the resource id.
     * Zero indicates that the icon pointer is used.
     * Default implementation returns KErrNotSupported;
     *
     * Uses the "lazy evaluation" idiom to get the icon. See Caption()
     *
     * @since S60 v3.2
     * @param aIcon On return, the icon pointer if used
     * @return The resource id or zero to indicate that the icon pointer is used.
     */
    TInt GetIcon(CGulIcon*& aIcon) const;

    /**
     * Checks if the shortcut target is accessible
     *
     * @since S60 v3.2
     * @param aCheckType Specifies which kind of shortcuts should check its access
     * @return ETrue if accessible, EFalse if not
     */
    TBool IsAccessibleL(TInt aCheckType);

    /**
     * Launches the shortcut
     *
     * @since S60 v3.2
     */
    void LaunchL();

    /**
     * Return application uid this target launches.
     *
     * @since S60 v3.2
     */
    TUid AppUid() const;

private: // New methods

    /**
     * Enables keylock.
     */
    void EnableKeyLock();

    /**
     * Checks if keylock is enabled.
     */
    TBool IsKeyLockEnabled();

    /**
     * C++ default constructor.
     */
    CAiScutTargetKeyLock(CAiScutEngine& aEngine, TShortcutType aType);

    /**
     * By default Symbian OS constructor is private.
     */
    void ConstructL(const TDesC& aTarget);

private:  // Data

    /**
     * Keylock
     */
    RAknKeylock2         iKeyLock;

    /**
     * Holds the shortcut definition string
     * Owned.
     */
    HBufC*              iDefinition;

};

#endif // CAIKEYLOCK_H

// End of File.
hs_app_caiscuttargetmessagingview.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for messaging view shortcut target.
*
*/


#ifndef CAISCUTTARGETMESSAGINGVIEW_H
#define CAISCUTTARGETMESSAGINGVIEW_H

#include 

#include "hs_app_caiscuttarget.h"

class CGulIcon;

/**
 *  Implements a mailbox shortcut target
 *
 *  Handles parsing and launching a mailbox shortcut target
 *
 *  @since S60 v3.2
 */
class CAiScutTargetMessagingView : public CAiScutTarget
{

public:

    /**
     * First phase constructor
     *
     * @since S60 v3.2
     * @param aEngine Reference to the plug-in engine
     * @param aParser Shortcut definition parser
     */
    static CAiScutTargetMessagingView* NewL(
        CAiScutEngine& aEngine, TShortcutType aType, const TAiScutParser& aParser);

    virtual ~CAiScutTargetMessagingView();

    /**
     * Returns the shortcut definition string
     *
     * @since S60 v3.2
     * @return Shortcut definition string
     */
    TPtrC Definition() const;

    /**
     * See base class
     */
    TInt GetCaption(TPtrC& aDes, TAiScutAppTitleType aTitleType) const;

    /**
	 * See base class
     */
    TInt GetIcon(CGulIcon*& aIcon) const;

    /**
     * See base class
     */
    TBool IsAccessibleL(TInt aCheckType);

    /**
     * Launches the shortcut
     *
     * @since S60 v3.2
     */
    void LaunchL();

    /**
     * Return application uid this target launches.
     *
     * @since S60 v3.2
     */
    TUid AppUid() const;

protected:

private:

    CAiScutTargetMessagingView(CAiScutEngine& aEngine, TShortcutType aType);

    void ConstructL(const TAiScutParser& aParser);

    /**
     * Tries to find a view id
     *
     * @since S60 v3.2
     * @return Mailbox id
     */
    TMsvId FindViewIdL();

    /**
     * Leaving version of GetIcon.
     */
    void GetIconL(CGulIcon*& aIcon) const;

private:  // data

    /**
     * View name. Contains the remote mailbox name or the messaging view name
     * Own.
     */
    HBufC* iViewName;

    /**
     * Holds the shortcut definition string
     * Owned.
     */
    HBufC* iDefinition;

};

#endif // CAISCUTTARGETMESSAGINGVIEW_H

// End of File.
hs_app_caiscuttargetnewmsg.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for new message shortcut target.
*
*/


#ifndef CAISCUTTARGETNEWMSG_H
#define CAISCUTTARGETNEWMSG_H

#include 

#include "hs_app_caiscuttarget.h"

class CGulIcon;

/**
 *  Implements a new message or new email shortcut target
 *
 *  Handles parsing and launching a new message shortcut target
 *
 *  @since S60 v3.2
 */
class CAiScutTargetNewMsg : public CAiScutTarget
{

public:

    /**
     * First phase constructor
     *
     * @since S60 v3.2
     * @param aEngine Reference to the plug-in engine
     * @param aParser Shortcut definition parser
     */
    static CAiScutTargetNewMsg* NewL(
        CAiScutEngine& aEngine, TShortcutType aType, const TAiScutParser& aParser);

    virtual ~CAiScutTargetNewMsg();

    /**
     * Returns the shortcut definition string
     *
     * @since S60 v3.2
     * @return Shortcut definition string
     */
    TPtrC Definition() const;

    /**
     * See base class
     */
    TInt GetCaption(TPtrC& aDes, TAiScutAppTitleType aTitleType) const;

    /**
     * See base class
     */
    TInt GetIcon(CGulIcon*& aIcon) const;

    /**
     * See base class
     */
    TBool IsAccessibleL(TInt aCheckType);

    /**
     * Launches the shortcut
     *
     * @since S60 v3.2
     */
    void LaunchL();

    /**
     * Return application uid this target launches.
     *
     * @since S60 v3.2
     */
    TUid AppUid() const;


 
    
    
protected:

private:

    CAiScutTargetNewMsg(CAiScutEngine& aEngine, TShortcutType aType);

    void ConstructL(const TAiScutParser& aParser);

    /**
     *
     */
    void GetCaptionL(TAiScutAppTitleType aTitleType) const;

    /**
     * Leaving version of GetIcon.
     */
    void GetIconL(CGulIcon*& aIcon) const;
    
    void ShowErrorNote();

private:  // data

    /**
     * Application uid.
     */
    TUid                iAppUid;

    /**
     * Possible view uid.
     */
    TUid                iViewUid;

    /**
     * Shortcut caption.
     * Own.
     */
    mutable HBufC*      iCaption;

    /**
     * Shortcut short caption.
     * Own.
     */
    mutable HBufC*      iShortCaption;

    /**
     * Holds the shortcut definition string
     * Owned.
     */
    HBufC*              iDefinition;

    /**
     * Message type
     */
    TUid                iMtm;
};

#endif // CAISCUTTARGETNEWMSG_H

// End of File.
hs_app_cpopupeventhandler.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in Popup event handler class
*
*/


#ifndef CPOPUPEVENTHANDLER_H
#define CPOPUPEVENTHANDLER_H

#include 
#include 

#include "hs_app_PopupFSM.h"
#include "hs_app_MPopupFSMActions.h"

class MPopupEventHandlerActions;

/**
 *
 *  The class handles Popup events (set, reset, gain/lost focus, etc.) by
 *  delegating them to automatically generated state machine class which in 
 *  turn decides what actions the events cause in different states.
 *
 *  This class has bi-directional friend relationship to CAiScutShortcutExt
 *  in order to establish concrete actions while decoupling state machine
 *  related functions out of CAiScutShortcutExt.
 *
 *  @since S60 v3.2
 */
class CPopupEventHandler : public CActive, 
    public MPopupFSMActions
    {
    public:
        /**
         * Factory function
         * @param aPopupEventHandlerActions actions interface
         * @since S60 v3.2
         */
        static CPopupEventHandler* NewL( 
            MPopupEventHandlerActions& aPopupEventHandlerActions );

        /**
         * Factory function
         * @param aPopupEventHandlerActions actions interface
         * @since S60 v3.2
         */
        static CPopupEventHandler* NewLC( 
            MPopupEventHandlerActions& aPopupEventHandlerActions );

        /**
         * Destructor
         * @since S60 v3.2
         */
        ~CPopupEventHandler();

    private:

        /**
         * Constructor
         * @param aPopupEventHandlerActions actions interface
         * @since S60 v3.2
         */
        CPopupEventHandler( 
            MPopupEventHandlerActions& aPopupEventHandlerActions );

        void ConstructL();

    public:  // New functions
        /**
         * Accessor for state machine
         * @return Reference to state machine instance
         * @since S60 v3.2
         */
        TPopupFSM& PopupFSM();

        TBool PublishPopup() const;
        TBool PopupVisible() const;
        
        /**
         * @return Is publishing needed
         */
        TBool PublishCaption() const;

        /**
         * @return Is caption visible
         */
        TBool CaptionVisible() const;
        
    private:    // From CActive
        void DoCancel();
        void RunL();

    private: // From MPopupFSMActions
        void CompleteSelf();
        void CancelRequest();
        void StartShortTimer();
        void StartLongTimer();
        void IssuePublishPopup();
        void IssueCleanPopup();
        void IssuePublishCaption();
        void IssueCleanCaption();

    private: // data
        /**
         * Actions interface
         * Ref.
         */
        MPopupEventHandlerActions& iPopupEventHandlerActions;

        /**
         * State machine instance
         * Own.
         */
        TPopupFSM iPopupFSM;

        /**
         * Timeout timer
         * Own.
         */
        RTimer iTimer;

        TBool iPublishPopup;
        TBool iPopupVisible;

        TBool iPublishCaption;
        TBool iCaptionVisible;
    };

#endif // CPOPUPEVENTHANDLER_H

// End of File.
hs_app_maiscutextdata.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in xSP extension data
*
*/


#ifndef MAISCUTEXTDATA_H
#define MAISCUTEXTDATA_H

#include 

class CGulIcon;

/**
 *  @since S60 v3.2
 */
class MAiScutExtData
    {
    public:
        /**
         * @return Pointer to popup line array or NULL if not set
         * @since S60 v3.2
         */
        virtual const MDesCArray* PopupLineArray() const = 0;
        
        /**
         * return Pointer to icon or NULL if not set
         * @since S60 v3.2
         */
        virtual const CGulIcon* Icon() const = 0;
    };

#endif // MAISCUTEXTDATA_H

// End of File.
hs_app_maiscutextmessagehandler.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in xSP extension server message handler.
*
*/


#ifndef MAISCUTEXTMESSAGEHANDLER_H
#define MAISCUTEXTMESSAGEHANDLER_H

#include 

class CGulIcon;

/**
 *
 *  Shortcut plug-in xSP extension server message handler.
 *
 *  @since S60 v3.2
 */
class MAiScutExtMessageHandler
    {
    public:
        /**
         * Notifies that the popup text has been changed.
         * @param aDefinition Target shortcut definition
         * @param aLineArray Pointer to array of popup line texts. Ownership
         * is transferred.
         * @since S60 v3.2
         */
        virtual void HandleSetPopupLineArrayL( const TDesC& aDefinition,
            CDesCArray* aLineArray ) = 0;
        /**
         * Notifies that the popup text has been reseted.
         * @param aDefinition Target shortcut definition
         * @since S60 v3.2
         */
        virtual void HandleResetPopupLineArrayL( const TDesC& aDefinition ) = 0;

        /**
         * Notifies that the ion has been changed.
         * @param aDefinition Target shortcut definition
         * @param aIcon Pointer to new icon. Ownership
         * is transferred.
         * @since S60 v3.2
         */
        virtual void HandleSetIconL( const TDesC& aDefinition,
            CGulIcon* aIcon ) = 0;

        /**
         * Notifies that the icon has been reseted.
         * @param aDefinition Target shortcut definition
         * @since S60 v3.2
         */
        virtual void HandleResetIconL( const TDesC& aDefinition ) = 0;
        
        /**
         * Checks whether the target is in shortcuts
         * @param aDefinition Target shortcut definition
         * @return ETrue if the target is in shortcuts
         * @since S60 v3.2
         */
        virtual TBool HandleIsInShortcutsL( const TDesC& aDefinition ) const = 0;
        
        /**
         * Launches General Settings so that the target definition is passed in.
         * @param aDefinition Target shortcut definition
         * @since S60 v3.2
         */
        virtual void HandleIssuePutInShortcutsL( const TDesC& aDefinition ) = 0;
    };

#endif // MAISCUTEXTMESSAGEHANDLER_H

// End of File.
hs_app_mpopupeventhandleractions.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/
#ifndef MPOPUPEVENTHANDLERACTIONS_H
#define MPOPUPEVENTHANDLERACTIONS_H

//  EXTERNAL INCLUDES
#include 

//  CLASS DEFINITION
/**
 * MPopupEventHandlerActions.
 */
class MPopupEventHandlerActions
    {
    public:     // Abstract methods
        /**
         * Publishes the shortcut
         */
        virtual void IssuePublishShortcut() = 0;
    };

#endif      //  MPOPUPEVENTHANDLERACTIONS_H

// End of file
hs_app_taiscutparser.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut definition parser.
*
*/


#ifndef TAISCUTPARSER_H
#define TAISCUTPARSER_H
#include                   // For TUriParser16
#include  

// =============================================================================
// ========================= Supported URI schemes =============================
/** URI scheme for local application shortcuts */
_LIT( KScutURISchemeLocalApp, "localapp" );

/** URI sheme for normal web addresses */
_LIT( KScutURISchemeHttp,     "http" );
/**  URI sheme for secure web addresses */
_LIT( KScutURISchemeHttps,    "https" );
// =============================================================================

// =============================================================================
// ============= Application shortcut formatting literals ======================

/** Literal to format an application shortcut without parameters */
_LIT( KScutFormatApplication,                "localapp:0x%x" );

/** Literal to format an application shortcut with parameter name and value */
_LIT( KScutFormatApplicationWithParams,      "localapp:0x%x?%S=%S" );

/** Literal to format an application shortcut with a single parameter string */
_LIT( KScutFormatApplicationWithParamString, "localapp:0x%x?%S" );

// =============================================================================

// =============================================================================
// ============ Shortcut parameter name and value literals =====================

/** Parameter name for view ids */
_LIT( KScutParamNameView,           "view" );

/** Parameter name for remote mailboxes. Specific to messaging shortcuts */
_LIT( KScutParamNameMailbox,        "mailbox" );

/** Parameter name for new message and new email. Specific to messaging shortcuts */
_LIT( KScutParamNameNew,            "new" );

/** Parameter value for new message shortcuts. */
_LIT( KScutParamValueMsg,           "msg" );

/** Parameter value for new email shortcuts */
_LIT( KScutParamValueEmail,         "email" );

/** Parameter value for new syncml mail shortcuts */
_LIT( KScutParamValueSyncMLMail,    "syncmlmail" );

/** Parameter value for new postcard shortcuts */
_LIT( KScutParamValuePostcard,      "postcard" );

/** Parameter value for new audio message shortcuts */
_LIT( KScutParamValueAudioMsg,      "audiomsg" );

/** Parameter value for the connectivity status view shortcut */
const TUid KScutParamValueConnectivityView = { 0x10207250 };

/** Parameter name for enable keylock */
_LIT( KScutParamNameOn,             "on" );

/** Parameter name for missed calls view */
_LIT( KScutParamValueMissedCalls,   "missed" );

/** Parameter name for dialled calls view */
_LIT( KScutParamValueDialledCalls,  "dialled" );

/** Parameter name for received calls view */
_LIT( KScutParamValueReceivedCalls, "received" );

/** Parameter name for logs main view */
_LIT( KScutParamValueMainView,      "counters" );

/** Parameter name for bookmark ids */
_LIT( KScutParamNameBookmark,       "bkm" );

/** Parameter name for icon id in skin
  Format localapp:0xUID?iconid=majorid;minorid;optionalColourGroup */   
_LIT( KScutParamNameIconSkinId,       "iconid" );

/** Parameter name for icon path. Left here for backward
    compatibility.
    Format localapp:0xUID?iconmifpath=mif_file.mif;index */
_LIT( KScutParamNameIconMifPath,       "iconmifpath" );

/** Parameter name for icon path. MBM and MIF supported
    Format localapp:0xUID?iconmifpath=mif_file.mif;index */
_LIT( KScutParamNameIconPath,       "iconpath" );
/** Parameter name for custom URL title.
    Format http://www.url.com?customtitle=Here is my great title */
_LIT( KScutParamNameCustomTitle,       "customtitle" );
/** Parameter name for CBA icon
    Format localapp:0xUID?iconid=majorid;minorid;optionalColourGroup&cba=1 */   
_LIT( KScutParamNameCBAIcon,       "cba" );

/** Parameter name for toolbar icon */
_LIT( KScutParamNameToolbarIcon,       "toolbar" );

/** Shortcut definition parameter for "no effect" */
_LIT( KScutParamNoEffect,           "noeffect" );

// =============================================================================
// =============================================================================
// ============ Shortcut parameter name and value literals =====================

/** Alias for messaging shortcuts */
_LIT( KScutTargetAliasMessaging, "msg" );

/** Alias for keylock shortcuts */
_LIT( KScutTargetAliasKeylock,   "keylock" );

/** Alias for logs shortcuts */
_LIT( KScutTargetAliasLogs,      "logs" );

/** Alias for voice dialer shortcuts */
_LIT( KScutTargetAliasVoiceDial, "voicedial" );

// =============================================================================
/** Maximum length of shortcut definition. Used when composing a definition */
const TInt KMaxDefinitionLength = 100;

/** Shortcut parameter value separator character */
const TText KParamValueSeparator = '=';

/** Shortcut parameter next param separator */
const TText KParamNextSeparator = '&';

_LIT( KScutMIFExtension, ".mif" );  
_LIT( KScutMBMExtension, ".mbm" );  
_LIT( KScutSkinItemSeparator, ";" );

/**
 * Shortcut definition components
 */
enum TScutDefComponent
{
	EScutDefScheme,    
	EScutDefTarget,        
	EScutDefParamName,        
	EScutDefParamValue,    
	EScutDefParamNameAndValue,    
	EScutDefComplete
};

/**
 * Shortcut types
 */
enum TShortcutType
{
	EScutUnknown,
	EScutAnyType = 0,
	EScutNoEffect,
	EScutApplication,
	EScutApplicationView,
	EScutApplicationWithParams,
	EScutNewMessage,
	EScutNewEmail,
	EScutNewSyncMLMail,
	EScutNewPostcard,
	EScutNewAudioMsg,
	EScutNewMsgType,
	EScutMailbox,
	EScutChangeTheme,
	EScutWebAddress,
	EScutBookmark,
	EScutKeylock,
	EScutLogsMissedCallsView,
	EScutLogsDialledCallsView,
	EScutLogsReceivedCallsView,
	EScutLogsMainView,
	EScutConnectivityStatusView,
	EScutApplicationManagerView
};

/**
 * Icon type
 */
enum TShortcutIconType
{
	EScutIconNone,
	EScutIconSkin,
    EScutIconMif,
    EScutIconMbm
};

enum TShortcutIconDestination
{
	EScutDestinationNormal,
	EScutDestinationSoftkey,
	EScutDestinationToolbar
};

class TAiScutIcon
{
	public:
        /**
        * Index of the icon in icon file
        */
        TInt iIconId;

        /**
        * Path to the icon file
        */
		TFileName iPath;
		 
		/**
		 * Skin item id of the icon
		 */
		TAknsItemID iSkinId;
		
		/**
		 * Colour groups id in skin
		 */
		TInt iColourGroup;
		
		/**
		 * Type of the icon. From skin or from mif
		 */
		TShortcutIconType iType;
		
		/**
		 * AppUid that this icon belongs to
		 */
		TUid iAppUid;
		
		/**
		 * Possible view id
		 */
		TUid iViewId;
		
		/**
		 * Type of the shortcut
		 */
		TShortcutType iShortcutType;
		
		/**
		 * Is this CBA specific icon
		 */
		TShortcutIconDestination iDestination;
		
};

/**
 *  Shortcuf definition parser
 *
 *  @since S60 v3.2
 */
class TAiScutParser
{

public:
	TAiScutParser();
	
	/**
	 * Static utility function to parse an uid from the given descriptor
	 *
	 * @since S60 v3.2
	 * @param aString The String to parse
	 * @return Parsed application uid
	 */
	 static TUid ParseUid( const TDesC& aDesC );
	
	/**
	 * Parses a shortcut definition
	 *
	 * @since S60 v3.2
	 * @param aDefinition Shortcut definition
	 * @return System wide error code. KErrCorrupt if not recognized
	 */
	 TInt Parse( const TDesC& aDefinition );
	
	/**
	 * Checks if the shortcut definition was valid
	 *
	 * @since S60 v3.2
	 * @return ETrue if valid, EFalse if not
	 */
	 TBool IsValid() const;
	
	/**
	 * Returns the shortcut target type
	 *
	 * @since S60 v3.2
	 * @return Shortcut target type
	 */
	 TShortcutType Type() const;
	 
	/**
	 * Returns the possible shortcut overriding icon 
	 * that has been defined in the URL either with the format 
	 *  localapp:0xUID?iconid=majorid;minorid;colourgroup
	 * or
	 *  localapp:0xUID?iconmifpath=mif_file.mif;index
	 *
	 * @since S60 v3.2
	 * @return Shortcut icon override
	 */
	 TAiScutIcon Icon() const;
	
	/**
	 * Returns the shortcut target uid. Used for application shortcuts
	 *
	 * @since S60 v3.2
	 * @return Shortcut target uid
	 */
	 TUid Uid() const;
	 
	/**
	 * Returns a shortcut definition component value
	 *
	 * @since S60 v3.2
	 * @param aComponent Shortcut definition component
	 * @return Pointer descriptor to component value
	 */
	 TPtrC Get( TScutDefComponent aComponent ) const;
	 
	/**
	 * Composes a shortcut definition string from given parameters
	 *
	 * @since S60 v3.2
	 * @param aDes On return, the shortcut definition. Transfers ownership
	 * @param aUid Application uid
	 * @param aParamName Parameter name
	 * @param aParamValue Parameter value
	 */
	 void ComposeL( HBufC*& aDes, const TUid aUid,
	 	const TDesC& aParamName, const TDesC& aParamValue );
	
	/**
	 * Composes a shortcut definition string from given parameters
	 *
	 * @since S60 v3.2
	 * @param aDes On return, the shortcut definition. Transfers ownership
	 * @param aUid Application uid
	 * @param aParamString Parameter string
	 */
	 void ComposeL( HBufC*& aDes, const TUid aUid,
	 	const TDesC& aParamString );
	 	
    /**
     * Creates a checksum for the given aDefinition. This is used
     * in URL matching so that no string need to be stored. Checksum is 
     * done checksum = positionInString * charValue
     *
     * @since S60 v3.2 
     * @param aDefinition The definition to calculate the checksum from
     * @return TInt The checksum
     */
    TInt ChecksumForString( const TDesC& aDefinition) const; 

    /**
     * Removes icon definitions from the given string. Icon definitions are
     * KScutParamNameIconSkinId, KScutParamNameIconSkinPath, KScutParamNameCBAIcon
     * KScutParamNameCustomTitle
     * 
     * @since S60 v3.2
     */
    void RemoveExtraDefinitionsL( TDes &aString ) const;
    /**
     * Parses the custom title from the current definition.
     * Returns ETrue on success and places the extracted 
     * custom title to the aTarget
     * 
     * @param aTarget Where to place the custom title. It is callers responsibility
     *  to provide a descriptor with enough room for the custom title.
     * 
     * @return KErrNone if everything is fine, KErrNotFound
     *  if there is no custom title in the definition, KErrNoMemory in
     *  case there is not enough room to place the result (low memory situations
     *  or too small descriptor provided)
     */
    TInt CustomTitle( TDes& aTarget ) const;

protected:
private:

	/**
	 * Checks if an alias was used in shortcut definition and parses an uid from it
	 *
	 * @since S60 v3.2
	 * @return ETrue if alias was found and parsed, EFalse if not
	 */
	 TBool ParseAlias();
	 
	/**
	 * Parses the possible application shortcut parameters
	 *
	 * @since S60 v3.2
	 */
	 void ParseParams();
	 
private:  // data
	/**
	 * URI Parser
	 */
	 TUriParser iUriParser;
	 
	/**
	 * Pointer to the full shortcut definition
	 */
	 TPtrC iDefinition;
	 
	/**
	 * Shortcut target type
	 */
	 TShortcutType iType;
	 
	/**
	 * Shortcut application uid
	 */
	 TUid iUid;
	 
	 /**
	  * Pointer to shortcut parameter name
	  */
	  TPtrC iParamName;
	  
	 /**
	  * Pointer to shortcut parameter value
	  */
	  TPtrC iParamValue;
	 /**
	  * Shortcut icon that has been given with the
	  * URL-string
	  */
	  TAiScutIcon iIcon;
	  };
	  
#endif // TAISCUTPARSER_H

// End of File.
hs_app_ai3scutplugin.loc
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Localization strings for project aiscutplugin
*
*/


// d: Header text for Information query pop-up window.
// l: heading_pane_t1
// w:
// r: TB9.2
//
#define qtn_ai_sc_query_modify_header "Tip:"

// d: message part in Information query pop-up window,
// d: which informs the user where to set installed application as a shortcut in idle.
// d: %U in the message is the application name
// d: Path in the query text is a link.
// l: popup_info_list_pane_t1
// w:
// r: TB9.2
//
#define qtn_ai_sc_query_modify_gs "%U can show additional information in Shortcut area. If you want to modify shortcuts select Options - Change shortcut settings"

// End of File.
hs_app_ai3scutsettings.loc
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Localization strings for project aiscutsettings
*
*/


//d:Localized name of the plugin
//d:
//l:list_set_graphic_pane_t1
//w:
//r:3.2
//
#define qtn_ai_set_cont_apps "Shortcuts"

// d: Text in title pane
// l: title_pane_t2/opt9
// w:
// r: 3.2
//
#define qtn_set_title_pers_shortcuts "Shortcuts"

// d: Text of a list item in personalisation view's folder list
// d: Item opens Shortcuts folder
// l: list_setting_pane_t1
// w:
// r: 3.2
//
#define qtn_set_pers_shortcuts "Shortcuts"

// d: Application cannot be opened during Backup
// l: popup_note_window
// w:
// r: 3.2
//
#define qtn_ai_scut_operation_disabled "Application cannot be opened during backup"

// d: Shortcuts Item caption
// d: Active Idle Shortcut Settings View
// d: %N order number of the shortcut item
// l: list_setting_pane_t1
// w:
// r: 3.2
//
#define qtn_ai_set_myt_linkn "%N. Shortcut item"

// d: Prompt text for type new URL data query
// d: Active Idle Shortcut Settings View
// l: popup_query_data_window
// w:
// r: 3.2
//
#define qtn_ai_shorts_type_url "Type URL"

// d: Prompt text for edit URL data query
// d: Active Idle Shortcut Settings View
// l: popup_query_data_window
// w:
// r: 3.2
//
#define qtn_ai_shorts_edit_url "Edit URL"

// d: Prompt text for change shortcut type query
// d: Active Idle Shortcut Settings View
// l: heading_pane_t1
// w:
// r: 3.2
//
#define qtn_sc_set_change_prompt "Change to:"

// d: Application shortcut type choice item in change shortcut type query
// d: Active Idle Shortcut Settings View
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_sc_set_change_apps "Application"

// d: Bookmark shortcut type choice item in change shortcut type query
// d: Active Idle Shortcut Settings View
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_sc_set_change_bookmark "Bookmark"

// d: URL shortcut type choice item in change shortcut type query
// d: Active Idle Shortcut Settings View
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_sc_set_change_url "Web address"

// d: Text of a list item in shortcut setting view's application list.
// d: User selects this item when she wants Scroll keys or Selection key
// d: have no effect is Idle state.
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_set_idle_skeys_no_effect "No effect"


// d: Title of a list item shortcut setting view's setting list
// d: Item opens Left idle softkey setting page
// l: list_setting_pane_t1
// w:
// r: 3.2
//
#define qtn_set_left_idle_softkey "Left idle softkey"

// d: Title of a list item shortcut setting view's setting list
// d: Item opens Right idle softkey setting page
// l: list_setting_pane_t1
// w:
// r: 3.2
//
#define qtn_set_right_idle_softkey "Right idle softkey"

// d: Title of a list item shortcut setting view's setting list
// d: Item opens Right Scroll key setting page
// l: list_setting_pane_t1
// w:
// r: 3.2
//
#define qtn_set_idle_right_scroll "Right Scroll key"

// d: Title of a list item shortcut setting view's setting list
// d: Item opens Left Scroll key setting page
// l: list_setting_pane_t1
// w:
// r: 3.2
//
#define qtn_set_idle_left_scroll "Left Scroll key"

// d: Title of a list item shortcut setting view's setting list
// d: Item opens Down Scroll key setting page
// l: list_setting_pane_t1
// w:
// r: 3.2
//
#define qtn_set_idle_down_scroll "Down Scroll key"

// d: Title of a list item shortcut setting view's setting list
// d: Item opens Up Scroll key setting page
// l: list_setting_pane_t1
// w:
// r: 3.2
//
#define qtn_set_idle_up_scroll "Up Scroll key"

// d: Title of a list item shortcut setting view's setting list
// d: Item opens Selection key setting page
// l: list_setting_pane_t1
// w:
// r: 3.2
//
#define qtn_set_idle_selec_key "Selection key"


// d: Text for fixed item information note
// d: Shown when user tries to change fixed shortcut in settings
// l: popup_note_window
// w:
// r: 3.2
//
#define qtn_ai_set_app_note_fixed "Fixed item. Can't be changed"

// d: Text for empty listbox item
// d: Shown when there are no modifiable shortcuts in settings
// l: main_list_empty_pane
// w:
// r: 3.2
//
#define qtn_ai_sc_set_all_fixed "(No editable shortcuts available in this Idle theme.)"

// =====================================================================
// App titles
// =====================================================================

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_about_grid               "About"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_about_list               "About product"

// d: Focused application name on idle shortcut plugin tooltip.
// l: popup_ai_links_title_window_t1
// w:
// r: 5.0
//
#define qtn_app_caption_string           "Application Manager"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_am_gs                    "App. manage"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_am_skey                  "AppMngr"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_am                   "AppMngr"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.1
//
#define qtn_apps_menu_gs                  "Menu"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.1
//
#define qtn_apps_menu_skey                "Menu"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_menu                 "Menu"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_blid_grid                "Navigator"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_blid_list                "Navigator"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.0
//
#define qtn_apps_blid_gs                  "Navigator"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.0
//
#define qtn_apps_blid_skey                "Navigator"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_blid                 "Navigator"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_bluetooth_grid           "Bluetooth"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_bluetooth_list           "Bluetooth"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_bluetooth_gs             "Bluetooth"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_bluetooth_skey           "Bluetooth"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_bluetooth            "Bluetooth"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_browserng_grid           "Web"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_browserng_list           "Web"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.1
//
#define qtn_apps_services_gs_new          "WAP services"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.1
//
#define qtn_apps_services_skey_new        "Services"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_services_new         "Services"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_oper_url             "%U"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_calculator_grid          "Calculator"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_calculator_list          "Calculator"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_calculator_gs            "Calculator"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_calculator_skey          "Calculat."

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_calculator           "Calculat."

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_calendar_grid            "Calendar"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_calendar_list            "Calendar"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_calendar_gs              "Calendar"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_calendar_skey            "Calendar"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_calendar             "Calendar"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_ccor_grid                "Camcorder"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_ccor_list                "Camcorder"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_ccor_gs                  "Camcorder"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_ccor_skey                "Camcorder"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_ccor                 "Camcorder"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_dict_grid                "Dictionary"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_dict_list                "Dictionary"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_dict_gs                  "Dictionary"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_dict_skey                "Dictionary"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_dict                 "Dictionary"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_clock_grid               "Clock"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_clock_list               "Clock"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_clock_gs                 "Clock"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_clock_skey               "Clock"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_clock                "Clock"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_cmon_grid                "Conn. Manager"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_cmon_list                "Conn. Manager"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_cmon_gs                  "Conn. manager"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_cmon_skey                "Conn. m."

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_cmon                 "Conn. m."

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_cnv_app_caption_short         "Converter"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_cnv_app_caption               "Converter"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_converter_gs             "Converter"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_converter_skey           "Convert."

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_converter            "Convert."

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_dm_grid                  "Device Manager"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_dm_list                  "Device Manager"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.6
//
#define qtn_apps_dm_gs                    "Device manager"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.6
//
#define qtn_apps_dm_skey                  "Dev. mgr."

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_dm                   "Dev. mgr."

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_drm_grid                 "Rights Mgr"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_drm_list                 "Rights Manager"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_drm_gs                   "Rights manager"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_drm_skey                 "DRM Mgr"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_drm                  "DRM Mgr"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_fax_modem_grid           "Modem"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_fax_modem_list           "Modem"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_fax_modem_gs             "Modem"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_fax_modem_skey           "Modem"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_fax_modem            "Modem"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_fmgr_grid                "File manager"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_fmgr_list                "File manager"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_fmgr_gs                  "File manager"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_fmgr_skey                "File manager"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_fmgr                 "File Manager"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_radio_grid               "Radio"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_radio_list               "Radio"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_radio_gs                 "Radio"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.7
//
#define qtn_apps_radio_skey               "Radio"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_radio                "Radio"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.7
//
#define qtn_fmtx_idle_sk                   "FM Tx sk"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_fmtx_idle_msk                  "FM Tx msk"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_settings_grid            "Settings"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_settings_list            "Settings"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_settings_gs              "Settings"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_settings_skey            "Settings"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_gs                   "Settings"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 5.0
//
#define qtn_apps_controlpanel_grid        "Control Panel"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 5.0
//
#define qtn_apps_controlpanel_list        "Control Panel"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 5.0
//
#define qtn_apps_controlpanel_gs          "Control Panel"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 5.0
//
#define qtn_apps_controlpanel_skey        "Control Panel"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 5.0
//
#define qtn_msk_idle_controlpanel         "Control Panel"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_help_grid                "Help"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_help_list                "Help"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_help_gs                  "Help"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_help_skey                "Help"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_help                 "Help"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_infrared_grid            "Infrared"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_infrared_list            "Infrared"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_infrared_gs              "Infrared"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_infrared_skey            "Infrared"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_infrared             "Infrared"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_instant_grid             "Chat"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_instant_list             "Chat"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_instant_gs               "Chat"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_instant_skey             "Chat"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_instant              "Chat"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_udict_grid               "User dict."

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_udict_list               "User dictionary"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.0
//
#define qtn_apps_udict_gs                 "User dictionary"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.0
//
#define qtn_apps_udict_skey               "User dict."

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_udict                "User dict."

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_lm_grid                  "Landmarks"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_lm_list                  "Landmarks"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.0
//
#define qtn_apps_lm_gs                    "Landmarks"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.0
//
#define qtn_apps_lm_skey                  "Landmarks"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_lm                   "Landmarks"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_logs_grid                "Log"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_logs_list                "Log"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_logs_gs                  "Log"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_logs_skey                "Log"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_logs                 "Log"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_mg_grid                  "Gallery"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_mg_list                  "Gallery"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_mg_gs                    "Gallery"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_mg_skey                  "Gallery"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_mg                   "Gallery"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_mp_grid                  "Media Player"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_mp_list                  "Media Player"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_mp_gs                    "Media Player"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_mp_skey                  "Media Player"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_mp                   "Media Player"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_memc_appl_grid           "Memory"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_memc_appl_list           "Memory card"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_mmc_gs                   "Memory Card"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_mmc_skey                 "Memory c..."

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_mmc                  "Memory c..."

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_messaging_grid           "Messages"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_messaging_list           "Messages"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_messaging_gs             "Messages"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_messaging_skey           "Messag."

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_messaging            "Messag."

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_set_idle_skey_new_message     "New message"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// d: User is prompted to write SMS, MMS or Email if the softkey is pressed.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_idle_skey_new_message         "New msg."

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_new_message          "New msg."

// d: Text of a list item in shortcut setting view's application list.
// d: Caption for the special New Message shortcut
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_set_idle_skey_new_msg         "New message"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// d: User is prompted to new message if the softkey is pressed.
// l: control_pane_t1/opt7
// w:
// r: 3.1
//
#define qtn_idle_skey_new_msg             "New message"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_new_msg              "New message"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_set_idle_skeys_sms_editor     "New SMS"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_sms_skey                 "New SMS"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_sms                  "New SMS"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_set_idle_skeys_mms_editor     "New MMS"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_mms_skey                 "New MMS"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_mms                  "New MMS"

// d: Text of a list item in shortcut setting view's application list.
// d: Caption for the special Select message type shortcut
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_set_idle_skey_select_msg_type "Select msg type"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// d: User is prompted to Select message if the softkey is pressed.
// l: control_pane_t1/opt7
// w:
// r: 3.1
//
#define qtn_idle_skey_select_msg          "Select msg"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_select_msg           "Select msg"

// d: Text of a list item in shortcut setting view's application list.
// d: Caption for the special New Email shortcut
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_set_idle_skeys_email_editor   "New Email"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_email_skey               "New Email"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_email                "New Email"

// d: Text of a list item in shortcut setting view's application list.
// d: Caption for the special New MMS Postcard shortcut
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_mmspostcard_gs           "New MMS postcard"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.0
//
#define qtn_apps_mmspostcard_skey         "New MMS postcard"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_mmspostcard          "New MMS postcard"

// d: Text of a list item in shortcut setting view's application list.
// d: Caption for the special New SyncML mail shortcut
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_syncml_mail_gs           "New SyncML mail"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.0
//
#define qtn_apps_syncml_mail_skey         "New SyncML mail"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_syncml_mail          "New SyncML mail"

// d: Text of a list item in shortcut setting view's application list.
// d: Caption for the special New Audio message shortcut
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_audio_msg_gs             "New audio message"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.1u
//
#define qtn_apps_audio_msg_skey           "New audio msg"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_audio_msg            "New audio msg"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_mplayer_grid             "Music player"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_mplayer_list             "Music player"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.0
//
#define qtn_apps_mplayer_gs               "Music player"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.0
//
#define qtn_apps_mplayer_skey             "Music"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_mplayer              "Music"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_notepad_grid             "Notepad"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_notepad_list             "Notepad"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_notepad_gs               "Notepad"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_notepad_skey             "Notepad"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_notepad              "Notepad"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_notepad_newnote_gs       "New note"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.2
//
#define qtn_apps_notepad_newnote_skey     "New note"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_notepad_newnote      "New note"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_skins_grid               "Skins"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_skins_list               "Skins"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_skins_gs                 "Skins"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_skins_skey               "Skins"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_skins                "Skins"

// d: Text of a list item in shortcut setting view's application list.
// d: Caption for the special Change Theme shortcut
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_idle_skin_gs             "Idle theme"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.2
//
#define qtn_apps_idle_skin_skey           "Idle theme"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_skin                 "Idle theme"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_phone_grid               "Telephone"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_phone_list               "Telephone"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_phonebook_grid           "Contacts"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_phonebook_list           "Contacts"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_phonebook_gs             "Contacts"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_phonebook_skey           "Contacts"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_phonebook            "Contacts"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_mode_grid                "Profiles"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_mode_list                "Profiles"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_mode_gs                  "Profiles"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_mode_skey                "Profiles"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_mode                 "Profiles"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_ptt_grid                 "PTT"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_ptt_list                 "Pust to talk"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_ptt_gs                   "Push to talk"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.2
//
#define qtn_apps_ptt_skey                 "PTT"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_ptt                  "PTT"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_search_grid              "Search"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_search_list              "Search"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_search_gs                "Search"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.2
//
#define qtn_apps_search_skey              "Search"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_search               "Search"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_simapps_grid             "SIM services"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_simapps_list             "SIM services"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_sd_grid                  "Speed dial"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_sd_list                  "Speed dial"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_sd_gs                    "Speed dial"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_sd_skey                  "Sp. dials"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_sd                   "Sp. dials"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_usb_grid                 "USB"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_usb_list                 "USB"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.0
//
#define qtn_apps_usb_gs                   "USB"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.0
//
#define qtn_apps_usb_skey                 "USB"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_usb                  "USB"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_vc_grid                  "Voice Commands"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_vc_list                  "Voice Commands"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_vc_gs                    "Voice Commands"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_vc_skey                  "Voice Commands"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_vc                   "Voice Commands"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_smsvo_grid               "Voice mail"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_smsvo_list               "Voice mailbox"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_smsvo_gs                 "Voice mailbox"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_smsvo_skey               "Voice m."

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_smsvo                "Voice m."

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_voip_grid                "Voice over IP"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_voip_list                "Voice over IP"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 3.0
//
#define qtn_apps_voip_gs                  "Voice over IP"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.0
//
#define qtn_apps_voip_skey                "Voice over IP"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_voip                 "Voice over IP"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_vorec_app_menu_grid           "Recorder"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 3.2
//
#define qtn_vorec_app_menu_list           "Recorder"

// d: Text of a list item in shortcut setting view's application list.
// l: list_set_graphic_pane_t1
// w:
// r: 2.8
//
#define qtn_apps_recorder_gs              "Recorder"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 2.8
//
#define qtn_apps_recorder_skey            "Recorder"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 3.2
//
#define qtn_msk_idle_recorder             "Recorder"

// d: Application name in the App Shell grid.
// l: cell_app_pane_t1
// w:
// r: 3.2
//
#define qtn_apps_sml_grid                 "Sync"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1_cp2
// w:
// r: 3.2
//
#define qtn_apps_sml_list                 "Sync"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.1
//
#define qtn_apps_video_grid               "Vid.Services"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.1
//
#define qtn_apps_operatormenu_skey        "Oper. menu"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.1
//
#define qtn_apps_fplayer_skey             "Flash Player"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 3.1
//
#define qtn_apps_exchangemail_skey        "Exh. mail"

// d: Application name in the App Shell list.
// l: list_single_large_graphic_pane_t1
// w:
// r: 5.0
//
#define qtn_apps_connectivity_list             "Connectivity"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as Left or Right idle softkey.
// l: control_pane_t1/opt7
// w:
// r: 5.0
//
#define qtn_apps_connectivity_skey             "Connectivity"

// d: User can personalize idle softkeys to be other application from general settings.
// d: The text is shown as middle softkey.
// l: control_pane_t3/opt7
// w:
// r: 5.0
//
#define qtn_msk_idle_connectivity              "Connectivity"


// End of File.
hs_app_aiscutplugin.iby
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Image description file for project aiscutplugin
*
*/


#ifndef AISCUTPLUGIN_IBY
#define AISCUTPLUGIN_IBY

#include 

// Shortcut plugin
data=DATAZ_\BITMAP_DIR\aiscutplugin.mif BITMAP_DIR\aiscutplugin.mif
ECOM_PLUGIN( hs_app_aiscutplugin.dll, hs_app_aiscutplugin.rsc )

// Shortcut settings plugin
ECOM_PLUGIN( hs_app_aiscutsettings.dll, hs_app_aiscutsettings.rsc )

file=ABI_DIR\BUILD_DIR\hs_app_aiscutextserv.dll       SHARED_LIB_DIR\hs_app_aiscutextserv.dll

// Central repository file, temporarily here
//data=\S60\ActiveIdle2\plugins\shortcutplugin\src\10275104.txt "private\10202BE9\10275104.txt"

data=ZPRIVATE\102750F9\backup_registration.xml  private\102750F9\backup_registration.xml

#endif // AISCUTPLUGIN_IBY

// End of File.
hs_app_aiscutplugin_resources.iby
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Image description file for project aiscutplugin localizable resources
*
*/


#ifndef AISCUTPLUGIN_RESOURCES_IBY
#define AISCUTPLUGIN_RESOURCES_IBY

#include 

// Shortcut settings plugin localizable resources
data=DATAZ_\RESOURCE_FILES_DIR\hs_app_aiscutsettingsres.rsc  RESOURCE_FILES_DIR\hs_app_aiscutsettingsres.rsc
data=DATAZ_\RESOURCE_FILES_DIR\hs_app_aiscuttexts.rsc        RESOURCE_FILES_DIR\hs_app_aiscuttexts.rsc
data=DATAZ_\RESOURCE_FILES_DIR\hs_app_aiscutpluginres.rsc    RESOURCE_FILES_DIR\hs_app_aiscutpluginres.rsc

#endif // AISCUTPLUGIN_RESOURCES_IBY

// End of File.
GenPopupFSM.py
#
# Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
# All rights reserved.
# This component and the accompanying materials are made available
# under the terms of "Eclipse Public License v1.0"
# which accompanies this distribution, and is available
# at the URL "http://www.eclipse.org/legal/epl-v10.html".
#
# Initial Contributors:
# Nokia Corporation - initial contribution.
#
# Contributors:
#
# Description:
#

'''
Finite State Machine generator for Symbian OS projects.

Just define fsmName, actionsIfaceName and stt and the script generates the
needed files for you.

The files are:
- State Machine header file (including state classes, overwrites the existing file)
- State Machine source file (including state classes, overwrites the existing file)
- Actions interface header (abstract M-class, overwrites the existing file)
- Header file for tracing (will be generated only if missing)


Version 1: 22-Jun-2006, Jaakko Vuori, Initial version
Version 2: 26-Jun-2006, Jaakko Vuori, Added argument passing
Version 3: 27-Jun-2006, Jaakko Vuori, Changed state classes nested in FSM class

'''
from sets import Set
import os, re, string

#------------------------------------------------------------------------
#State machine name
fsmName = "Popup"

#Actions interface name
actionsIfaceName = "PopupFSMActions"

#State transition table
stt=[   #source state       #event                            #dest state         #actions
        ("NotSetOffFocus",  [
                            ("HandleUpdate()",                "SetOffFocus",      ["IssueCleanCaption()"]),
                            ("HandleGotFocus()",              "NotSetOnFocus",    []),
                            ("HandleForeground()",            "NotSetOffFocus",   ["IssuePublishCaption()"]),
                            ]),    

        ("SetOffFocus",     [
                            ("HandleGotFocus()",              "GettingFocus",     ["StartShortTimer()"]),
                            ("HandleReset()",                 "NotSetOffFocus",   ["IssuePublishCaption()"]),
                            ]),    

        ("GettingFocus",    [
                            ("HandleRequestCompleted()",      "Visible",          ["IssuePublishPopup()", "StartLongTimer()"]),
                            ("HandleReset()",                 "NotSetOnFocus",    ["IssuePublishCaption()", "CancelRequest()"]),
                            ("HandleLostFocus()",             "SetOffFocus",      ["CancelRequest()"]),
                            ]),    
                            
        ("LosingFocus",     [
                            ("HandleRequestCompleted()",      "SetOffFocus",      ["IssueCleanPopup()"]),
                            ("HandleReset()",                 "NotSetOffFocus",   ["IssuePublishCaption()", "CancelRequest()"]),
                            ("HandleGotFocus()",              "Visible",          ["CancelRequest()", "StartLongTimer()"]),
                            ]),
                            
        ("NotSetOnFocus",   [
                            ("HandleUpdate()",                "Visible",          ["IssueCleanCaption()", "IssuePublishPopup()", "StartLongTimer()"]),
                            ("HandleLostFocus()",             "NotSetOffFocus",   []),
                            ("HandleBackground()",            "BackgroundNotSetOnFocus", []),
                            ("HandleForeground()",            "NotSetOnFocus",    ["IssuePublishCaption()"]),
                            ]),    
                                                        
        ("Visible",         [
                            ("HandleUpdate()",                "Visible",              ["IssueCleanCaption()", "IssuePublishPopup()", "StartLongTimer()"]),
                            ("HandleReset()",                 "NotSetOnFocus",        ["IssuePublishCaption()", "IssueCleanPopup()", "CancelRequest()"]),
                            ("HandleLostFocus()",             "LosingFocus",          ["CancelRequest()", "CompleteSelf()"]),
                            ("HandleRequestCompleted()",      "NotVisible",           ["IssueCleanPopup()"]),
                            ("HandleBackground()",            "BackgroundSetOnFocus", ["CancelRequest()", "IssueCleanPopup()"]),
                            ]),
                            
        ("NotVisible",      [
                            ("HandleUpdate()",                "Visible",          ["IssueCleanCaption()", "IssuePublishPopup()", "StartLongTimer()"]),
                            ("HandleReset()",                 "NotSetOnFocus",    ["IssuePublishCaption()"]),
                            ("HandleLostFocus()",             "SetOffFocus",      []),
                            ]),

        ("BackgroundNotSetOnFocus",      [
                            ("HandleForeground()",            "NotSetOnFocus",        ["IssuePublishCaption()"]),
                            ("HandleUpdate()",                "BackgroundSetOnFocus", ["IssueCleanCaption()"]),
                            ]),

        ("BackgroundSetOnFocus",      [
                            ("HandleReset()",                 "BackgroundNotSetOnFocus",        ["IssuePublishCaption()"]),
                            ("HandleForeground()",            "Visible",                        ["IssuePublishPopup()", "StartLongTimer()"]),
                            ]),

    ]
#------------------------------------------------------------------------    

def write( s ):
    f.write( s + '\n' )

def writeHeader():
    global f
    fname = '%sFSM.h' % (fsmName)
    print "Generating %s..." % (fname)
    f = open( fname, 'w' )

    write( "#ifndef %sFSM_H" % ( fsmName.upper() ) )
    write( "#define %sFSM_H" % ( fsmName.upper() ) )
    write( "" )
    write( "//  EXTERNAL INCLUDES" )
    write( "#include " )
    write( "" )
    write( "//  FORWARD DECLARATIONS" )
    write( "class T%sFSM;" % (fsmName) )
    write( "class M%s;" % (actionsIfaceName) )
    write( "" )
    write( "//  CLASS DEFINITIONS" )

    write( "/**" )
    write( " * %s state machine" % (fsmName) )
    write( " */" )
    write( "class T%sFSM" % (fsmName) )
    write( "    {" )

    write( "    /**" )
    write( "     * Base class for states" )
    write( "     */" )
    write( "    class T%sStateBase" % (fsmName) )
    write( "        {" )
    write( "        public:     // New methods" )
    
    events=[]
    for s in stt:
        for e in s[1]:
            events.append( e[0] )    
    for event in Set(events):
        fname, args = re.match('(.*?)[(](.*?)[)]',event).groups()
        if len(args)>0:
            write( "            virtual void %s( T%sFSM* a%sFSM, M%s& a%s,%s);" % (fname,fsmName,fsmName,actionsIfaceName,actionsIfaceName,args) )
        else:
            write( "            virtual void %s( T%sFSM* a%sFSM, M%s& a%s );" % (fname,fsmName,fsmName,actionsIfaceName,actionsIfaceName) )
        
        
    write( "        };" )
    write( "" )
    
    for s in stt:
        write( "    /**" )
        write( "     * State class T%s" % (s[0]) )
        write( "     */" )    
        write( "    class T%s : public T%sStateBase" % (s[0],fsmName) )
        write( "        {" )
        write( "        protected:  // Methods derived from T%sState" % (fsmName))
        for event in s[1]:        
            fname, args = re.match('(.*?)[(](.*?)[)]',event[0]).groups()
            if len(args)>0:
                write( "            void %s( T%sFSM* a%sFSM, M%s& a%s,%s);" % (fname,fsmName,fsmName,actionsIfaceName,actionsIfaceName,args) )
            else:
                write( "            void %s( T%sFSM* a%sFSM, M%s& a%s );" % (fname,fsmName,fsmName,actionsIfaceName,actionsIfaceName) )
            
        write( "        };" )
        write( "" )

    write( "" )
    write( "    public:    // Constructors" )
    write( "        T%sFSM( M%s& a%s );" % (fsmName,actionsIfaceName,actionsIfaceName))
    write( "" )
    write( "    public:     // New methods" )
    for event in Set(events):            
        write( "        void %s;" % (event))
    write( "" )
    write( "    private:     // New methods" )
    write( "        void SetState( T%sStateBase* aNewState );" % (fsmName) )
    write( "" )
    write( "    private:    // Data" )
    write( "        //Ref:" )
    write( "        T%sStateBase* iCurrentState;" % (fsmName))
    write( "        M%s& i%s;" % (actionsIfaceName,actionsIfaceName))
    write( "" )
    write( "        //Own:" )
    for s in stt:
        write( "        T%s i%s;" % (s[0],s[0]))

    write( "    private:    // Friend class definitions" )
    for s in stt:
        write( "        friend class T%s;" % (s[0]))
        
    write( "    };" )
    write( "" )
    write( "#endif      //  %sFSM_H" % (fsmName.upper()) )
    write( "" )
    write( "// End of file" )
    f.close()


def writeSource():
    global f
    fname = '%sFSM.cpp' % (fsmName)
    print "Generating %s..." % (fname)    
    f = open( fname, 'w' )

    write( '#include "%sFSM.h"' % (fsmName) )
    write( '#include "M%s.h"' % (actionsIfaceName) )
    write( '#include "%sTrace.h"' % (fsmName) )
    write( '' )
    write( '#pragma warning( disable:4100 )' )    
    write( '#pragma warning( disable:4068 )' )        
    write( '#pragma warn_unusedarg off' )    
    
    write( '' )
    write( 'T%sFSM::T%sFSM( M%s& a%s ) : ' % (fsmName,fsmName,actionsIfaceName,actionsIfaceName) )
    write( '    iCurrentState( &i%s ),' % (stt[0][0]) )
    write( '    i%s( a%s )' % (actionsIfaceName,actionsIfaceName) )
    write( '    {' )
    write( '    }' )
    write( '' )
    
    events=[]
    for s in stt:
        for e in s[1]:
            events.append( e[0] )    
            
    for event in Set(events):                
        fname, args = re.match('(.*?)[(](.*?)[)]',event).groups()
        if len(args)>0:
            write( 'void T%sFSM::T%sStateBase::%s( T%sFSM* /*a%sFSM*/, M%s& /*a%s*/,%s )' % (fsmName,fsmName,fname,fsmName,fsmName,actionsIfaceName,actionsIfaceName,args))
        else:
            write( 'void T%sFSM::T%sStateBase::%s( T%sFSM* /*a%sFSM*/, M%s& /*a%s*/ )' % (fsmName,fsmName,fname,fsmName,fsmName,actionsIfaceName,actionsIfaceName))
        write( '    {' )        
        write( '    TRACE( _L("T%sStateBase::%s") );' % (fsmName,event))
        write( '    }' )
        write( '' )

    for event in Set(events):                
        fname, args = re.match('(.*?)[(](.*?)[)]',event).groups()
        write( 'void T%sFSM::%s(%s)' % (fsmName,fname,args) )
        write( '    {' )
        arglist=args.split(',')
        argnames = string.join([arg.split()[-1:][0] for arg in arglist if arg!=""], ', ')
        if len(argnames)>0:
            write( '    iCurrentState->%s( this, i%s, %s );' % (fname,actionsIfaceName,argnames) )
        else:
            write( '    iCurrentState->%s( this, i%s );' % (fname,actionsIfaceName) )
        write( '    }' )
        write( '' )

    write( 'void T%sFSM::SetState( T%sStateBase* aNewState )' % (fsmName,fsmName) )
    write( '    {' )
    write( '    iCurrentState = aNewState;' )
    write( '    }' )
    write( '' )

    for s in stt:
        stateName, events = s
        for event in events:
            eventName = event[0]
            destState = event[1]
            actions = event[2]
            fname, args = re.match('(.*?)[(](.*?)[)]',eventName).groups()
            if len(actions)>0:                
                if len(args)>0:
                    write( 'void T%sFSM::T%s::%s( T%sFSM* a%sFSM, M%s& a%s,%s )' % (fsmName,stateName,fname,fsmName,fsmName,actionsIfaceName,actionsIfaceName,args) )
                else:
                    write( 'void T%sFSM::T%s::%s( T%sFSM* a%sFSM, M%s& a%s )' % (fsmName,stateName,fname,fsmName,fsmName,actionsIfaceName,actionsIfaceName) )
            else:
                if len(args)>0:
                    write( 'void T%sFSM::T%s::%s( T%sFSM* a%sFSM, M%s& /*a%s*/,%s )' % (fsmName,stateName,fname,fsmName,fsmName,actionsIfaceName,actionsIfaceName,args) )
                else:
                    write( 'void T%sFSM::T%s::%s( T%sFSM* a%sFSM, M%s& /*a%s*/ )' % (fsmName,stateName,fname,fsmName,fsmName,actionsIfaceName,actionsIfaceName) )
            
            write( '    {' )
            write( '    TRACE( _L("T%s::%s") );' % (stateName, eventName) )
            write( '    a%sFSM->SetState( &a%sFSM->i%s );' % (fsmName,fsmName,destState) )
            for action in actions:
                fname, args = re.match('(.*?)[(](.*?)[)]',action).groups()
                if len(args)>0:
                    arglist=args.split(',')                
                    argnames = string.join([arg.split()[-1:][0] for arg in arglist if arg!=""], ', ')
                    write( '    a%s.%s( %s );' % (actionsIfaceName,fname,argnames) )
                else:
                    write( '    a%s.%s();' % (actionsIfaceName,fname) )
            write( '    }' )
            write( '' )
        
    write( '// End of file' )


def writeTraceHeader():
    if not os.path.isfile( '%sTrace.h' % (fsmName) ):
        global f
        fname = '%sTrace.h' % (fsmName)
        print "Generating %s..." % (fname)            
        f = open( fname, 'w' )
        write( '#ifndef %sTRACE_H' % (fsmName.upper()) )
        write( '#define %sTRACE_H' % (fsmName.upper()) )
        write( '' )
        write( '//  MACROS' )
        write( '#define TRACE' )
        write( '' )
        write( '#endif      //  %sTRACE_H' % (fsmName.upper()) )
        write( '' )
        write( '// End of file' )
        f.close()


def writeActionsIface():
    global f
    fname = 'M%s.h' % (actionsIfaceName)
    print "Generating %s..." % (fname)            
    f = open( fname, 'w' )

    write( '#ifndef M%s_H' % (actionsIfaceName.upper()) )
    write( '#define M%s_H' % (actionsIfaceName.upper()) )
    write( '' )
    write( '//  EXTERNAL INCLUDES' )
    write( '#include ' )
    write( '' )
    write( '//  CLASS DEFINITION' )
    write( '/**' )
    write( ' * M%s actions.' % (actionsIfaceName) )
    write( ' * Note: This file has been generated automatically. Do not edit!' )
    write( ' */' )
    write( 'class M%s' % (actionsIfaceName) )
    write( '    {' )
    write( '    public:     // Abstract methods' )

    actions=[]
    for s in stt:
        for e in s[1]:
            actions.extend( e[2] )    
    for action in Set(actions):
        write( '        virtual void %s = 0;' % (action))
    write( '    };' )
    write( '' )
    write( '#endif      //  M%s_H' % (actionsIfaceName.upper()) )
    write( '' )
    write( '// End of file' )
    f.close()
    
if __name__ == "__main__":
    writeHeader()
    writeSource()
    writeTraceHeader()
    writeActionsIface()
hs_app_aidefaultshortcut.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Platform default shortcuts.
*
*/


#include "hs_app_aidefaultshortcut.h"
#include "hs_app_taiscutparser.h"
#include 
#include 
#include 
#include   // For wchar_t

namespace {

       struct TDefaultShortcut
           {
           /**
            * Identifier
            */
           TInt id;

           /**
            * Key to identify this shortcut
            */
           TInt key;

           /**
            * Definition for this shortcut
            */
           const wchar_t* definition;
           };
       
       enum TDefaultShortcutCenrepId
           {
           EDefaultShortcutFirst = 0,
           EDefaultShortcutSecond,
           EDefaultShortcutThird,
           EDefaultShortcutFourth,
           EDefaultShortcutFifth,
           EDefaultShortcutSixth,
           EDefaultShortcutSeventh,
           EDefaultShortcutEighth,
           EDefaultShortcutNaviLeft,
           EDefaultShortcutNaviRight,
           EDefaultShortcutNaviUp,
           EDefaultShortcutNaviDown,
           EDefaultShortcutNaviKey,
           EDefaultShortcutLSK,
           EDefaultShortcutRSK
           };
       
 // Platform default shortcuts.
       const TDefaultShortcut KDefaultShortcuts[] =
       {
       { EDefaultShortcutFirst,     0x00000001, L"localapp:0x101F4CCE" },               // Phonebook,
       { EDefaultShortcutSecond,    0x00000002, L"localapp:0x100058C5" },               // Messaging,
       { EDefaultShortcutThird,     0x00000003, L"localapp:0x10008D39" },               // Browser,
       { EDefaultShortcutFourth,    0x00000004, L"localapp:0x200009EE" },               // Photos,
       { EDefaultShortcutFifth,     0x00000005, L"localapp:0x10005901" },               // Calendar,
       { EDefaultShortcutSixth,     0x00000006, L"localapp:msg?new=msg" },              // New message,
       { EDefaultShortcutSeventh,   0x00000007, L"localapp:0x102072C3" },               // Music Player,
       { EDefaultShortcutEighth,    0x00000008, L"localapp:0x10207A89" },               // Radio,
       { EDefaultShortcutNaviLeft,  0x01000000, L"localapp:0x100058C5?new=msg" },       // New message,
       { EDefaultShortcutNaviRight, 0x01000001, L"localapp:0x10005901" },                // Calendar,
       { EDefaultShortcutNaviUp,    0x01000002, L"localapp:0x101F4CCE" },               // Contacts,
       { EDefaultShortcutNaviDown,  0x01000003, L"localapp:0x101F4CCE" },                // Contacts,
       { EDefaultShortcutNaviKey,   0x01000004, L"localapp:0x100058C5" },               // Messagind,
       { EDefaultShortcutLSK,       0x01000100, L"localapp:0x101F4CD2" },                // Menu,
       { EDefaultShortcutRSK,       0x01000101, L"localapp:0x101F4CCE" }                // Contacts,
       };
       
       const TInt KDefaultShortcutCount = (sizeof(KDefaultShortcuts)/sizeof(KDefaultShortcuts[0])); 
}

inline TPtrC16 DefaultDefinition( const TDefaultShortcut& aShortcut )
    {
    return TPtrC16( (const TText16*) aShortcut.definition );
    }
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void GetPlatformDefaultShortcut(TInt aIndex, TUid& aUid, TDes& aDefinition)
    {
    TInt err = KErrNone;
    TAiScutParser parser;
    if (aIndex < 0)
        {
        aIndex = 0;
        }

    aIndex = aIndex % ::KDefaultShortcutCount;
    aDefinition.Copy( ::DefaultDefinition(::KDefaultShortcuts[aIndex]) );

    err = parser.Parse( aDefinition );
    if ( err == KErrNone )
        {
        aUid = TAiScutParser::ParseUid( parser.Get( EScutDefTarget) );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TInt ResolveCenrepIdFromKey( TInt aKey, TInt &aCenrepId )
    {
    TInt ret = KErrNotFound;
    for ( TInt i = 0; i < KDefaultShortcutCount; ++i )
        {
        if ( KDefaultShortcuts[i].key == aKey )
            {            
            aCenrepId = KDefaultShortcuts[i].id;
            ret = KErrNone;
            break;
            }
        }
    return ret;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void TAiDefaultShortcut::GetDefaultShortcut(TInt aKey, TUid& aUid, TDes& aDefinition)
{
    CRepository *cr = NULL;
    TInt err = KErrNone;
    TInt index = KErrNotFound;
    err = ::ResolveCenrepIdFromKey( aKey, index );
    TInt32 crIndex = KAIBackupShortcutDefinitionStart;
    if ( err == KErrNone )
        {
        TRAP( err, cr = CRepository::NewL( TUid::Uid( KCRUidActiveIdleLV ) ) );

        aUid.iUid = KErrNotFound;
        if ( err == KErrNone )
            {
            crIndex += index;
            err = cr->Get( crIndex, aDefinition );
            // In case of a null definition use the platform default
            if ( aDefinition.Length() <= 0 )
                {
                err = KErrNotFound;
                }            
            else if ( err == KErrNone )
                {
                TAiScutParser parser;
                err = parser.Parse( aDefinition );
                if ( err == KErrNone )
                    {
                    aUid = TAiScutParser::ParseUid( parser.Get( EScutDefTarget) );
                    }
                }               
            }           
        }
        
    // Ensure that some definition is returned
    // in case of any error occurrs
    if ( err != KErrNone )
        {
        ::GetPlatformDefaultShortcut( index, aUid, aDefinition );
        }    
    delete cr;
}

// End of File.
hs_app_aiscutappuidparser.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut definition parser
*
*/


#include "hs_app_aiscutappuidparser.h"

// ========================= MEMBER FUNCTIONS ================================

// ---------------------------------------------------------------------------
// TAiScutAppUidParser::TAiScutAppUidParser
// ---------------------------------------------------------------------------
//
TAiScutAppUidParser::TAiScutAppUidParser(const TDesC& aData, RArray& aUidArray)
    :
    iUidArray(aUidArray),
    iLex(aData),
    iLexIsValid(EFalse)
{
}

// ---------------------------------------------------------------------------
// TAiScutAppUidParser::SkipChar
// ---------------------------------------------------------------------------
//
void TAiScutAppUidParser::SkipChar(TChar aChar, TBool aConditionalSkip)
{
    iLex.SkipSpaceAndMark();
    if (iLex.Peek() == aChar)
    {
        iLex.Inc();
    }
    else
    {
        // If not conditional skip, then the input data is invalid
        if (!aConditionalSkip)
        {
            iLexIsValid = EFalse;
        }
    }
    iLex.SkipSpaceAndMark();
}

// ---------------------------------------------------------------------------
// TAiScutAppUidParser::ReadAppUid
// ---------------------------------------------------------------------------
//
TUid TAiScutAppUidParser::ReadAppUid()
{
    TUint32 appUid;

    iLex.Mark();
    while (iLex.Peek().IsHexDigit())
    {
        iLex.Inc();
    }
    TPtrC uidToken = iLex.MarkedToken();
    TLex uidLex(uidToken);
    if (uidLex.Val(appUid, EHex) != KErrNone)
    {
        iLexIsValid = EFalse;
    }

    return TUid::Uid(appUid);
}

// ---------------------------------------------------------------------------
// TAiScutAppUidParser::ParseL
// ---------------------------------------------------------------------------
//
void TAiScutAppUidParser::ParseL()
{
    iLexIsValid = ETrue;

    while (!iLex.Eos() && iLexIsValid)
    {
        SkipChar(',', ETrue);
        TUid applicationUid = ReadAppUid();

        if (iLexIsValid)
        {
            iUidArray.AppendL(TUid(applicationUid));
        }
    }
}

// End of File
hs_app_aiscutextserv.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  AI Shortcut xSP Extension API
*
*/


#include 
#include 
#include 
#include 

#include 
#include 

// ======== LOCAL DEFINITIONS ========

namespace
    {
    //  LOCAL CONSTANTS
    /**
     * Default message slots
     */
    const TUint KDefaultMessageSlots = 4;

    /**
     * Marshalling buffer expand size
     */
    const TInt KBufExpandSize = 32;

    /**
     * Target string format that matches with aiscutplugin
     */
    _LIT( KTargetStringFormat, "localapp:0x%x" );

    //  LOCAL TYPES
    typedef TBuf<19> TTargetString;

    //  LOCAL FUNCTIONS
    /**
     * Panics server
     * @aReason Panic reason code
     */
    void Panic( TInt aReason )
        {
        User::Panic( KAiScutExtServerName, aReason );
        }

    /**
     * Generates target string from Uid3 of current process
     */
    TTargetString DefaultTargetString()
        {
        TUid uid3 = RProcess().Type()[ 2 ];
        TTargetString targetString;
        targetString.Format( KTargetStringFormat, uid3 );
        return targetString;
        }
    }

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
EXPORT_C TInt RAiScutExtServ::Connect()
    {
    return Connect( DefaultTargetString() );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
EXPORT_C TInt RAiScutExtServ::Connect( const TDesC& aTargetDefinition )
    {
    TInt err = CreateSession( KAiScutExtServerName, Version(),
        KDefaultMessageSlots );
    if( err == KErrNone )
        {
        TIpcArgs args( &aTargetDefinition );
        err = SendReceive( EAiScutExtServSetTargetDefinition, args );
        if( err != KErrNone )
            {
            Close();
            }
        }
    return err;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
EXPORT_C TVersion RAiScutExtServ::Version() const
    {
    return( TVersion(
        KAiScutExtServMajorVersionNumber,
        KAiScutExtServMinorVersionNumber,
        KAiScutExtServBuildVersionNumber ) );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
EXPORT_C TInt RAiScutExtServ::UpdatePopupTextL(
    const MDesCArray& aPopupTextLines )
    {
    TInt lineCount = aPopupTextLines.MdcaCount();
    __ASSERT_ALWAYS( lineCount <= KMaxPopupTextLines, Panic( KErrArgument ) );
    CBufBase* lineArrayBuf = CBufFlat::NewL( KBufExpandSize );
    CleanupStack::PushL( lineArrayBuf );

    RBufWriteStream stream( *lineArrayBuf );

    stream.WriteUint8L( lineCount );
    for( TInt i = 0; i < lineCount; i++ )
        {
        stream << aPopupTextLines.MdcaPoint( i );
        }

    TPtr8 lineArray = lineArrayBuf->Ptr( 0 );

    TIpcArgs args( &lineArray );
    TInt err = SendReceive( EAiScutExtServSetPopupText, args );

    CleanupStack::PopAndDestroy( lineArrayBuf );
    return err;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
EXPORT_C TInt RAiScutExtServ::ResetPopupText()
    {
    return SendReceive( EAiScutExtServResetPopupText );
    }


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
EXPORT_C TInt RAiScutExtServ::UpdateIconL( const CGulIcon& aIcon )
    {
    CBufBase* marshallBuf = CBufFlat::NewL( KBufExpandSize );
    CleanupStack::PushL( marshallBuf );

    RBufWriteStream stream( *marshallBuf );

    aIcon.Bitmap()->ExternalizeL( stream );
    aIcon.Mask()->ExternalizeL( stream );

    TPtr8 marshalledData = marshallBuf->Ptr( 0 );

    TIpcArgs args( &marshalledData );
    TInt err = SendReceive( EAiScutExtServSetIcon, args );

    CleanupStack::PopAndDestroy( marshallBuf );
    return err;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
EXPORT_C TInt RAiScutExtServ::ResetIcon()
    {
    return SendReceive( EAiScutExtServResetIcon );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
EXPORT_C TInt RAiScutExtServ::IsInShortcuts( TBool& aIsInShortcuts ) const
    {
    TPtr8 isInShortcutsDes(
        reinterpret_cast< TUint8* >( &aIsInShortcuts ),
        sizeof( aIsInShortcuts ),
        sizeof( aIsInShortcuts ) );

    TIpcArgs args( &isInShortcutsDes );

    return SendReceive( EAiScutExtServIsInShortcuts, args );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
EXPORT_C TInt RAiScutExtServ::IssuePutInShortcuts()
    {
    return SendReceive( EAiScutExtServIssuePutInShortcuts );
    }

// End of File.
hs_app_aiscutfactory.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in factory class.
*
*/


#include "hs_app_aiscutfactory.h"
#include "hs_app_caiscutengine.h"
#include "hs_app_caiscutshortcut.h"

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutEngine* AiScutFactory::CreateAiScutEngineL( CAiScutPlugin& aPlugin )
    {
    return CAiScutEngine::NewL( aPlugin );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcut* AiScutFactory::CreateAiScutShortcutL( TInt aId,
    const TDesC& aTarget, CAiScutEngine& aEngine )
    {
    return CAiScutShortcut::NewL( aId, aTarget, aEngine );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcut* AiScutFactory::CreateAiScutShortcutLC( TInt aId,
    const TDesC& aTarget, CAiScutEngine& aEngine )
    {
    return CAiScutShortcut::NewLC( aId, aTarget, aEngine );
    }

// End of File.
hs_app_aiscutfactoryext.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in factory class.
*
*/


#include "hs_app_aiscutfactory.h"
#include "hs_app_caiscutengineext.h"
#include "hs_app_caiscutshortcutext.h"

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutEngine* AiScutFactory::CreateAiScutEngineL( CAiScutPlugin& aPlugin )
    {
    return CAiScutEngineExt::NewL( aPlugin );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcut* AiScutFactory::CreateAiScutShortcutL( TInt aId,
    const TDesC& aTarget, CAiScutEngine& aEngine )
    {
    return CAiScutShortcutExt::NewL( aId, aTarget, aEngine );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcut* AiScutFactory::CreateAiScutShortcutLC( TInt aId,
    const TDesC& aTarget, CAiScutEngine& aEngine )
    {
    return CAiScutShortcutExt::NewLC( aId, aTarget, aEngine );
    }

// End of File.
hs_app_aiscutplugin.rss
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  ECOM plug-in resource file.
*
*/


#include 

#include 

// ---------------------------------------------------------------------------
// registry_info
//
// ---------------------------------------------------------------------------
//
RESOURCE REGISTRY_INFO registry_info
{
    resource_format_version = RESOURCE_FORMAT_VERSION_2;

    dll_uid = AI_UID_ECOM_DLL_CONTENTPUBLISHER_SCUTPLUGIN;

    // Interface info array.
    interfaces =
    {
        INTERFACE_INFO
        {
            // UID of the implemented interface.
            interface_uid = AI_UID_ECOM_INTERFACE_CONTENTPUBLISHER;

            implementations =
            {
                IMPLEMENTATION_INFO
                {
                    implementation_uid  =  AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_SCUTPLUGIN;
                    version_no          =  1;
                    display_name        =  "Shortcut Plug-in";
                    default_data        =  "";
                    opaque_data         =  "";
                }
            };
        }
    };
}

// End of File.
hs_app_aiscutpluginres.rss
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Resource definitions for Shortcut plug-in settings
*
*/


#include 
#include 
#include 

#include 

NAME SCPL

RESOURCE RSS_SIGNATURE { }

RESOURCE TBUF { buf="SCPL"; }

//----------------------------------------------------
// EIK_APP_INFO
// Contains application information.
//----------------------------------------------------
//
RESOURCE EIK_APP_INFO
{
}

// ----------------------------------------------------------------------------
//
// %U application can show additional information in Shortcut area..."
//
// ----------------------------------------------------------------------------
//
RESOURCE TBUF r_ai_sc_query_modify_gs
    {
    buf = qtn_ai_sc_query_modify_gs;
    }

//----------------------------------------------------------
// r_scut_xsptip_note
//
//----------------------------------------------------------
//
RESOURCE DIALOG r_scut_xsptip_note
{
    flags = EGeneralQueryFlags | EEikDialogFlagNoBorder | EEikDialogFlagNoShadow;
    buttons = R_AVKON_SOFTKEYS_OK_EMPTY;
    items =
    {
        DLG_LINE
        {
            type = EAknCtPopupHeadingPane;
            id = EAknMessageQueryHeaderId;
            control = AVKON_HEADING
            {
                label = qtn_ai_sc_query_modify_header;
                headinglayout = R_AVKON_WML_SIGN_QUERY_HEADING_PANE;
                // headinglayout = R_AVKON_LIST_HEADING_PANE_POPUPS;
            };
        },
        DLG_LINE
        {
            type = EAknCtMessageQuery;
            id = EAknMessageQueryContentId;
            control = AVKON_MESSAGE_QUERY
            {
            };
        }
    };
}  

// End of File.
hs_app_aiscutrepositorywatcher.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut definition parser
*
*/


#include "hs_app_aiscutrepositorywatcher.h"
#include       // For CRepository



CAiScutRepositoryWatcher* CAiScutRepositoryWatcher::NewL(
    const TUid aUid,
    const TUint32 aKey,
    CCenRepNotifyHandler::TCenRepKeyType aKeyType,
    TCallBack aCallBack,
    CRepository* aRepository)
{
    CAiScutRepositoryWatcher* self =
        new (ELeave) CAiScutRepositoryWatcher(aUid, aKey, aCallBack, aRepository);

    CleanupStack::PushL(self);
    self->ConstructL(aKeyType);
    CleanupStack::Pop(self);

    return self;
}

CAiScutRepositoryWatcher* CAiScutRepositoryWatcher::NewL(
    const TUid aUid,
    TCallBack aCallBack,
    CRepository* aRepository)
{
    CAiScutRepositoryWatcher* self =
        new (ELeave) CAiScutRepositoryWatcher(
            aUid,
            NCentralRepositoryConstants::KInvalidNotificationId,
            aCallBack,
            aRepository);

    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);

    return self;
}

CAiScutRepositoryWatcher::~CAiScutRepositoryWatcher()
{
    if (iNotifyHandler)
    {
        iNotifyHandler->StopListening();
        delete iNotifyHandler;
    }
}

CAiScutRepositoryWatcher::CAiScutRepositoryWatcher(
    const TUid aUid,
    const TUint32 aKey,
    TCallBack aCallBack,
    CRepository* aRepository)
:
iUid(aUid), iKey(aKey), iCallBack(aCallBack), iRepository(aRepository)
{
}

void CAiScutRepositoryWatcher::ConstructL(
    CCenRepNotifyHandler::TCenRepKeyType aKeyType)
{
    iNotifyHandler = CCenRepNotifyHandler::NewL(
        *this, *iRepository, aKeyType, iKey);
}

void CAiScutRepositoryWatcher::ConstructL()
{
    iNotifyHandler = CCenRepNotifyHandler::NewL(*this, *iRepository);
}

void CAiScutRepositoryWatcher::StartListeningL()
{
    if (iNotifyHandler)
    {
        iNotifyHandler->StartListeningL();
    }
}

void CAiScutRepositoryWatcher::StopListening()
{
    if (iNotifyHandler)
    {
        iNotifyHandler->StopListening();
    }
}

TUint32 CAiScutRepositoryWatcher::ChangedKey()
{
    return iChangedKey;
}

void CAiScutRepositoryWatcher::HandleNotifyInt(TUint32 aKey, TInt /*aNewValue*/)
{
    iChangedKey = aKey;
    iCallBack.CallBack();
    iChangedKey = NCentralRepositoryConstants::KInvalidNotificationId;
}

void CAiScutRepositoryWatcher::HandleNotifyString(
    TUint32 aKey, const TDesC16& /*aNewValue*/)
{
    iChangedKey = aKey;
    iCallBack.CallBack();
    iChangedKey = NCentralRepositoryConstants::KInvalidNotificationId;
}

void CAiScutRepositoryWatcher::HandleNotifyGeneric(TUint32 aKey)
{
    iChangedKey = aKey;
    iCallBack.CallBack();
    iChangedKey = NCentralRepositoryConstants::KInvalidNotificationId;
}

void CAiScutRepositoryWatcher::HandleNotifyError(
    TUint32 /*aKey*/, TInt /*aError*/, CCenRepNotifyHandler* /*aHandler*/)
{
}

// End of File
hs_app_aiscutsettings.rss
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  ECOM plug-in resource file
*
*/


#include 

#include 

// ---------------------------------------------------------------------------
// registry_info
//
// ---------------------------------------------------------------------------
//
RESOURCE REGISTRY_INFO registry_info
{
    resource_format_version = RESOURCE_FORMAT_VERSION_2;

    dll_uid = AI_UID_ECOM_DLL_SETTINGS_SCUTPLUGIN;

    // Interface info array.
    interfaces =
    {
        INTERFACE_INFO
        {
            // UID of the implemented interface.
            interface_uid = 0x10207236; 

            implementations =
            {
                IMPLEMENTATION_INFO
                {
                    implementation_uid  =  AI_UID_ECOM_IMPLEMENTATION_SETTINGS_SCUTPLUGIN;
                    version_no          =  1;
                    display_name        =  "Shortcuts";
                    default_data        =  "0x1020723B"; // Parent UID (PrslnPlugin)
                    opaque_data         =  "-1"; // Order number
                }
            };
        }
    };
}

// End of File.
hs_app_aiscutsettingsres.rss
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Resource definitions for Shortcut plug-in settings
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

#include 

#include "hs_app_aiscutsettings.hrh"


NAME SCSE

RESOURCE RSS_SIGNATURE { }

RESOURCE TBUF { buf="SCSE"; }

//----------------------------------------------------
// EIK_APP_INFO
// Contains application information.
//----------------------------------------------------
//
RESOURCE EIK_APP_INFO
{
}

//----------------------------------------------------
// r_scutsettings_menubar
//
//----------------------------------------------------
//
RESOURCE MENU_BAR r_scutsettings_menubar
{
    titles =
    {
        MENU_TITLE { menu_pane = r_scutsettings_menupane; }
    };
}

//----------------------------------------------------
// r_scutsettings_menupane
// Options menu.
//----------------------------------------------------
//
RESOURCE MENU_PANE r_scutsettings_menupane
{
    items =
    {
        MENU_ITEM
        {
            command = EAiScutSettingsCmdChange;
            txt     = qtn_options_change;
        }

#ifdef __SERIES60_HELP
        ,
        MENU_ITEM
        {
            command = EAknCmdHelp;
            txt     = qtn_options_help;
        }
#endif  // __SERIES60_HELP
        ,
        MENU_ITEM
        {
            command = EAknCmdExit;
            txt     = qtn_options_exit;
        }
    };
}

//----------------------------------------------------
// r_scut_settings_view
// Settings views.
//----------------------------------------------------
//
RESOURCE AVKON_VIEW r_scut_settings_view
{
    menubar = r_scutsettings_menubar;
    //cba = R_AVKON_SOFTKEYS_OPTIONS_BACK;
    cba = r_scut_softkeys_options_back_change;
}

//----------------------------------------------------
// r_setting_listbox
// Common listbox editor resource for setting pages.
//----------------------------------------------------
//
RESOURCE LISTBOX r_setting_listbox
{
    flags = EEikListBoxMultipleSelection;
}

//----------------------------------------------------
// r_scut_settings_applist_page
// Selection key idle softkey setting page.
//----------------------------------------------------
//
RESOURCE AVKON_SETTING_PAGE r_scut_settings_applist_page
{
    number = EAknSettingPageNoOrdinalDisplayed;
    //    label = qtn_set_idle_selec_key;
    // note: default cba resource is ok_cancel_select
    //softkey_resource = R_AVKON_SOFTKEYS_OK_CANCEL;
    type = EAknSetListBox;
    editor_resource_id = r_setting_listbox;
}

//----------------------------------------------------------
// r_scut_type_url_page
// Setting page editing an url.
//----------------------------------------------------------
//
RESOURCE AVKON_SETTING_PAGE r_scut_type_url_page
{
    softkey_resource = R_AVKON_SOFTKEYS_OK_CANCEL__OK;
    number= EAknSettingPageNoOrdinalDisplayed;
    label= qtn_ai_shorts_type_url;
    type = EEikCtEdwin;
    editor_resource_id = r_scut_url_editor;
}

//----------------------------------------------------------
// r_scut_edit_url_page
// Setting page editing an url.
//----------------------------------------------------------
//
RESOURCE AVKON_SETTING_PAGE r_scut_edit_url_page
{
    softkey_resource = R_AVKON_SOFTKEYS_OK_CANCEL__OK;
    number= EAknSettingPageNoOrdinalDisplayed;
    label= qtn_ai_shorts_edit_url;
    type = EEikCtEdwin;
    editor_resource_id = r_scut_url_editor;
}

//----------------------------------------------------------
// r_scut_url_editor
// URL editor.
//----------------------------------------------------------
//
RESOURCE EDWIN r_scut_url_editor
{
    width = 10;
    lines = 2;
    maxlength = 1000;
    numeric_keymap = EAknEditorCalculatorNumberModeKeymap;
    allowed_input_modes = EAknEditorTextInputMode | EAknEditorNumericInputMode;
    default_input_mode = EAknEditorTextInputMode;
    special_character_table = R_AVKON_URL_SPECIAL_CHARACTER_TABLE_DIALOG;
    default_case = EAknEditorLowerCase;
    flags = EEikEdwinAutoSelection | EAknEditorLowerCase | EEikEdwinNoLineOrParaBreaks;
    avkon_flags = EAknEditorFlagNoT9 | EAknEditorFlagLatinInputModesOnly;
}

//----------------------------------------------------
// r_scut_change_to_page
// "Change To" setting page.
//----------------------------------------------------
//
RESOURCE ARRAY r_scut_change_to_page_lbx
{
    items =
    {
        LBUF { txt = qtn_sc_set_change_apps;     },
        LBUF { txt = qtn_sc_set_change_bookmark; }
        
        // Only this menu option disabled.
        // The implementation of url functionality still exists in code, 
        // even though this option has been decided to remove due to better
        // usability. Affects lots of code if removed entirely.
        /*,
        LBUF { txt = qtn_sc_set_change_url;    }*/
    };
}

//----------------------------------------------------
// r_scut_listquery_change_to_page
// "Change To" setting page.
//----------------------------------------------------
//
RESOURCE AVKON_LIST_QUERY r_scut_listquery_change_to_page
{
    softkeys=R_AVKON_SOFTKEYS_SELECT_CANCEL;
    items =
    {
        AVKON_LIST_QUERY_DLG_LINE
        {
            control = AVKON_LIST_QUERY_CONTROL
            {
                listtype = EAknCtSinglePopupMenuListBox;
                heading = qtn_sc_set_change_prompt;
                listbox = AVKON_LIST_QUERY_LIST
                {
                    // array of items will be defined dynamically
                };
            };
        }
    };
}

//----------------------------------------------------------
// r_scut_wait_note
//
//----------------------------------------------------------
//
RESOURCE DIALOG r_scut_wait_note
{
    flags = EAknWaitNoteFlags | EEikDialogFlagWait;
    buttons = R_AVKON_SOFTKEYS_EMPTY;
    items=
    {
        DLG_LINE
        {
            type = EAknCtNote;
            id = EGeneralNote;
            control= AVKON_NOTE
            {
                layout = EWaitLayout;
                singular_label = qtn_gen_note_opening;
                animation = R_QGN_GRAF_WAIT_BAR_ANIM;
            };
        }
    };
}

//----------------------------------------------------
// r_scut_settings_view_caption
// View caption for plug-in. max 256
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_view_caption
{
    buf = qtn_set_pers_shortcuts;
}

//----------------------------------------------------
// r_scut_settings_view_title
// View title.
//----------------------------------------------------
//
RESOURCE TITLE_PANE r_scut_settings_view_title
{
    txt = qtn_set_title_pers_shortcuts;
}

//----------------------------------------------------
//  r_ai_settings_txt_fixed_item
//  Text used in information note when attempting
//  to change a read-only shortcut
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_txt_fixed_item
{
    buf = qtn_ai_set_app_note_fixed;
}

//----------------------------------------------------
//  r_scut_settings_txt_all_fixed
//  Text for empty listbox item
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_txt_all_fixed
{
    buf = qtn_ai_sc_set_all_fixed;
}

//----------------------------------------------------
//  r_scut_settings_txt_linkn
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_txt_linkn
{
    buf = qtn_ai_set_myt_linkn;
}

//----------------------------------------------------
//  r_scut_settings_softkey_left
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_softkey_left
{
    buf = qtn_set_left_idle_softkey;
}

//----------------------------------------------------
//  r_scut_settings_softkey_right
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_softkey_right
{
    buf = qtn_set_right_idle_softkey;
}

//----------------------------------------------------
//  r_scut_settings_scroll_left
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_scroll_left
{
    buf = qtn_set_idle_left_scroll;
}

//----------------------------------------------------
//  r_scut_settings_scroll_right
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_scroll_right
{
    buf = qtn_set_idle_right_scroll;
}

//----------------------------------------------------
//  r_scut_settings_scroll_up
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_scroll_up
{
    buf = qtn_set_idle_up_scroll;
}

//----------------------------------------------------
//  r_scut_settings_scroll_down
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_scroll_down
{
    buf = qtn_set_idle_down_scroll;
}

//----------------------------------------------------
//  r_scut_settings_selection_key
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_selection_key
{
    buf = qtn_set_idle_selec_key;
}

// -----------------------------------------------------------------------------
//  r_scut_settings_no_effect
//
// -----------------------------------------------------------------------------
//
RESOURCE TBUF r_scut_settings_no_effect
{
    buf = qtn_set_idle_skeys_no_effect;
}

// -----------------------------------------------------------------------------
//  r_scut_msk_edit
//
// -----------------------------------------------------------------------------
//
RESOURCE TBUF r_scut_msk_edit
{
    buf = qtn_msk_edit;
}

// -----------------------------------------------------------------------------
//  r_scut_msk_change
//
// -----------------------------------------------------------------------------
//
RESOURCE TBUF r_scut_msk_change
{
    buf = qtn_msk_change;
}

/*
//----------------------------------------------------
//  r_scut_settings_key_press
//
//----------------------------------------------------
//
//RESOURCE TBUF r_scut_settings_key_press
//    {
//    buf = qtn_ai_shorts_key_press;
//    }

*/

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
//
RESOURCE CBA r_scut_softkeys_options_back_change
{
    buttons =
    {
        CBA_BUTTON {id = EAknSoftkeyOptions;       txt = text_softkey_option; },
        CBA_BUTTON {id = EAknSoftkeyBack;          txt = text_softkey_back;   },
        CBA_BUTTON {id = EAiScutSettingsCmdChange; txt = qtn_msk_change;      }
    };
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
//
RESOURCE CBA r_scut_softkeys_options_exit_change
{
    buttons =
    {
        CBA_BUTTON {id = EAknSoftkeyOptions;       txt = text_softkey_option; },
        CBA_BUTTON {id = EAknSoftkeyExit;          txt = text_softkey_exit;   },
        CBA_BUTTON {id = EAiScutSettingsCmdChange; txt = qtn_msk_change;      }
    };
}

// End of File.
hs_app_aiscuttargetshutter.cpp
/*
* Copyright (c) 2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: 
*
*/


#include         //TApaTask
#include          //RApaLsSession

#include "hs_app_aiscuttargetshutter.h"
#include "aiscutdefs.h"
#include "debug.h"

#include 

const TUid KMenuUID3 = { 0x101F4CD2 }; 

const TInt KTaskExistsDelay = 1500000; //1.5 second
const TInt KTaskNotExistsDelay = 500000; //0.5 second
const TInt KMaxNumberOfTries = 3;


// ======== MEMBER FUNCTIONS ========

CAiScutTargetShutter::CAiScutTargetShutter(CCoeEnv* aEnv, TUid aAppUid)
    : CActive(CActive::EPriorityLow)
    , iEnv(aEnv)
    , iAppUid(aAppUid)
{
    CActiveScheduler::Add(this);
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetShutter::~CAiScutTargetShutter()
{
    if (iPeriodic)
    {
        iPeriodic->Cancel();
        delete iPeriodic;
    }

    iWsSession.Close();
    Cancel();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutTargetShutter::ConstructL(TBool aIsRunning, TBool aIsDialog)
{
    iIsRunning = aIsRunning;
    iIsDialog = aIsDialog;
    iTaskExists = EFalse;
    iTaskKilled = EFalse;
    iCounter = 0;
    iPeriodic = CPeriodic::NewL(CActive::EPriorityLow);
    User::LeaveIfError(iWsSession.Connect());
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetShutter* CAiScutTargetShutter::NewL(CCoeEnv* aEnv, TUid aAppUid, TBool aIsRunning, TBool aIsDialog)
{
    CAiScutTargetShutter* self = new (ELeave) CAiScutTargetShutter(aEnv, aAppUid);
    CleanupStack::PushL(self);
    self->ConstructL(aIsRunning, aIsDialog);
    CleanupStack::Pop(self);
    return self;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutTargetShutter::StartL()
{
	__PRINT( __DBG_FORMAT( "XAI: CAiScutTargetShutter::Start() app uid=0x%x"), iAppUid.iUid);
	

    TApaTaskList taskList(iWsSession);
    TApaTask idleTask(taskList.FindApp(KScutActiveIdleUid));

    if ( idleTask.Exists() && iIsRunning)
    {
        if ( iIsDialog )
            {
            TKeyEvent keyEvent;
            keyEvent.iCode = EKeyEscape;
            keyEvent.iModifiers = 0;
            keyEvent.iRepeats = 0;
            iEnv->SimulateKeyEventL(keyEvent, EEventKey);            
            }
        //idleTask.BringToForeground();
        CAknSgcClient::MoveApp(idleTask.WgId(), ESgcMoveAppToForeground);
        iTaskExists = ETrue;               
		__PRINTS( "XAI:   exists and running");

    }
    else
    {
        TKeyEvent keyEvent;
        keyEvent.iCode = EKeyEscape;
        keyEvent.iModifiers = 0;
        keyEvent.iRepeats = 0;
        iEnv->SimulateKeyEventL(keyEvent, EEventKey);

        // bring active idle to foreground
        TApaTask idleTask(taskList.FindApp(KScutActiveIdleUid));
        if (idleTask.Exists())
        {
			__PRINTS("XAI:   idle to foreground");
            //idleTask.BringToForeground();
            CAknSgcClient::MoveApp(idleTask.WgId(), ESgcMoveAppToForeground);
        }
        TApaTask task(taskList.FindApp(iAppUid));
		if (task.Exists())
        {
			//task.SendToBackground();
			CAknSgcClient::MoveApp(task.WgId(), ESgcMoveAppToBackground);
        }
    }
	if( !iPeriodic->IsActive() )
	{
	    if (iTaskExists)
    	{
            iPeriodic->Start(KTaskExistsDelay, KTaskExistsDelay,
                TCallBack(TaskExistsCallback, this));
    	}
    	else
	    {
            iPeriodic->Start(KTaskNotExistsDelay, KTaskNotExistsDelay,
                TCallBack(TaskNotExistsCallback, this));
    	}
		
	}
}

// ---------------------------------------------------------------------------
// From CActive
// ---------------------------------------------------------------------------
//
void CAiScutTargetShutter::DoCancel()
{
    if (iPeriodic)
    {
        iPeriodic->Cancel();
    }
}

// ---------------------------------------------------------------------------
// From CActive.
// ---------------------------------------------------------------------------
//
void CAiScutTargetShutter::RunL()
{
	__PRINT( __DBG_FORMAT( "XAI: CAiScutTargetShutter::RunL() app uid=0x%x"), iAppUid.iUid);	

	TUid menuUid = KMenuUID3;
	
    TApaTaskList taskList(iWsSession);
    TApaTask task(taskList.FindApp(iAppUid));

    if (iTaskExists)
    {
        RWindowGroup windowGroup = iEnv->RootWin();

        if (windowGroup.OrdinalPosition() != 0)
        {
            TApaTask idleTask(taskList.FindApp(KScutActiveIdleUid));
            if (idleTask.Exists())
            {
			__PRINTS( "XAI:   idle to foreground");
	
                //idleTask.BringToForeground();
                CAknSgcClient::MoveApp(idleTask.WgId(), ESgcMoveAppToForeground);
            }
        }
        iPeriodic->Cancel();
    }
    else
    {
        if (iCounter >= KMaxNumberOfTries || iTaskKilled)
        {
            iPeriodic->Cancel();
        }
        else if (task.Exists() && iAppUid != menuUid)        
        {
			__PRINTS("XAI:   shutdown task");
			//task.SendToBackground();
			CAknSgcClient::MoveApp(task.WgId(), ESgcMoveAppToBackground);
            task.SendSystemEvent(EApaSystemEventShutdown);
            iTaskKilled = ETrue;
        }
        else
        {
            iCounter++;
        }
    }
}

// ---------------------------------------------------------------------------
// From CActive
// Handles an error situation.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetShutter::RunError(TInt aError)
{
    return aError;
}

// ---------------------------------------------------------------------------
//
//
// ---------------------------------------------------------------------------
//
void CAiScutTargetShutter::Run()
{
    SetActive();
    TRequestStatus *status = &iStatus;
    User::RequestComplete(status, KErrNone);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetShutter::TaskExistsCallback(TAny* aPtr)
{
    CAiScutTargetShutter* self = static_cast(aPtr);

    if (self)
    {
        self->Run();
    }

    return KErrNone;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetShutter::TaskNotExistsCallback(TAny* aPtr)
{
    CAiScutTargetShutter* self = static_cast(aPtr);

    if (self)
    {
        self->Run();
    }

    return KErrNone;
}

// End of File.
hs_app_aiscuttexts.rss
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in common texts
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
//#include 
//#include 
//#include 
//#include 
//#include 

#include 

#include "hs_app_aiscutapptitle.rh"
#include "aiscutappuids.hrh"

NAME SCTX

RESOURCE RSS_SIGNATURE { }

RESOURCE TBUF { buf=""; }

//----------------------------------------------------
//  r_scut_plugin_name
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_plugin_name
{
    buf = qtn_ai_set_cont_apps;
}

//----------------------------------------------------
//  r_scut_settings_change_theme
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_change_theme
{
    buf = qtn_apps_idle_skin_gs;
}

//----------------------------------------------------
//  r_scut_settings_new_msg
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_new_msg
{
    buf = qtn_set_idle_skey_new_msg;
}

//----------------------------------------------------
//  r_scut_settings_new_email
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_new_email
{
    buf = qtn_set_idle_skeys_email_editor;
}

//----------------------------------------------------
//  r_scut_settings_new_syncml_mail
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_new_syncml_mail
{
    buf = qtn_apps_syncml_mail_gs;
}

//----------------------------------------------------
//  r_scut_settings_new_postcard
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_new_postcard
{
    buf = qtn_apps_mmspostcard_gs;
}

//----------------------------------------------------
//  r_scut_settings_new_audio_msg
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_new_audio_msg
{
    buf = qtn_apps_audio_msg_gs;
}

//----------------------------------------------------
//  r_scut_settings_select_msg_type
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_select_msg_type
{
    buf = qtn_set_idle_skey_select_msg_type;
}

//----------------------------------------------------
//  r_scut_settings_connectivity_status
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_connectivity_status
{
    buf = qtn_apps_connectivity_list;
}

//----------------------------------------------------
//  r_scut_settings_connectivity_status
//
//----------------------------------------------------
//
RESOURCE TBUF r_scut_settings_appmngr
{
    buf =  qtn_apps_am_gs;           
}

//----------------------------------------------------
//  r_ai_scut_operation_disabled
//
//----------------------------------------------------
//
RESOURCE TBUF r_qtn_ai_scut_operation_disabled
    {
    buf = qtn_ai_scut_operation_disabled; 
    }


// -----------------------------------------------------------------------------
//  r_scut_app_title_list
//
// -----------------------------------------------------------------------------
//
RESOURCE AI_APP_TITLE_LIST r_scut_app_title_list
{
    items =
    {
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutAboutUidValue;
            //longtitle   = qtn_apps_about_list;
            //shorttitle  = qtn_apps_about_grid;
            skeytitle   = qtn_apps_about_grid;
            msktitle    = qtn_apps_about_grid;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutGeneralSettingsUidValue;
            viewid      = KScutInstallationViewIdValue;
            longtitle   = qtn_app_caption_string;
            shorttitle  = qtn_apps_am_gs;
            skeytitle   = qtn_apps_am_skey;
            msktitle    = qtn_msk_idle_am;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutApplicationManagerUidValue;
            //viewid      = KScutInstallationViewIdValue;
            //longtitle   = qtn_app_caption_string;
            //shorttitle  = qtn_app_caption_string;
            skeytitle   = qtn_apps_am_skey;
            msktitle    = qtn_msk_idle_am;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutApplicationShellUidValue;
            viewid      = 1;
            //longtitle   = "";
            //shorttitle  = "";
            skeytitle   = qtn_apps_menu_skey;
            msktitle    = qtn_msk_idle_menu;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutNavigatorUidValue;
            //longtitle   = qtn_apps_blid_list;
            //shorttitle  = qtn_apps_blid_grid;
            skeytitle   = qtn_apps_blid_skey;
            msktitle    = qtn_msk_idle_blid;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutBluetoothUidValue;
            //longtitle   = qtn_apps_bluetooth_list;
            //shorttitle  = qtn_apps_bluetooth_grid;
            skeytitle   = qtn_apps_bluetooth_skey;
            msktitle    = qtn_msk_idle_bluetooth;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutBrowserUidValue;
            //longtitle   = qtn_apps_browserng_grid;
            //shorttitle  = qtn_apps_browserng_list;
            skeytitle   = qtn_apps_services_skey_new;
            msktitle    = qtn_msk_idle_services_new;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutCalculatorUidValue;
            //longtitle   = qtn_apps_calculator_list;
            //shorttitle  = qtn_apps_calculator_grid;
            skeytitle   = qtn_apps_calculator_skey;
            msktitle    = qtn_msk_idle_calculator;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutCalendarUidValue;
            //longtitle   = qtn_apps_calendar_list;
            //shorttitle  = qtn_apps_calendar_grid;
            skeytitle   = qtn_apps_calendar_skey;
            msktitle    = qtn_msk_idle_calendar;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutCamcorderUidValue;
            //longtitle   = qtn_apps_ccor_list;
            //shorttitle  = qtn_apps_ccor_grid;
            skeytitle   = qtn_apps_ccor_skey;
            msktitle    = qtn_msk_idle_ccor;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutChineseDictionaryUidValue;
            //longtitle   = qtn_apps_dict_list;
            //shorttitle  = qtn_apps_dict_grid;
            skeytitle   = qtn_apps_dict_skey;
            msktitle    = qtn_msk_idle_dict;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutClockUidValue;
            //longtitle   = qtn_apps_clock_list;
            //shorttitle  = qtn_apps_clock_grid;
            skeytitle   = qtn_apps_clock_skey;
            msktitle    = qtn_msk_idle_clock;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutConnectionManagerUidValue;
            //longtitle   = qtn_apps_cmon_list;
            //shorttitle  = qtn_apps_cmon_grid;
            skeytitle   = qtn_apps_cmon_skey;
            msktitle    = qtn_msk_idle_cmon;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutConverterUidValue;
            //longtitle   = qtn_cnv_app_caption;
            //shorttitle  = qtn_cnv_app_caption_short;
            skeytitle   = qtn_apps_converter_skey;
            msktitle    = qtn_msk_idle_converter;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutDeviceManagerUidValue;
            //longtitle   = qtn_apps_dm_list;
            //shorttitle  = qtn_apps_dm_grid;
            skeytitle   = qtn_apps_dm_skey;
            msktitle    = qtn_msk_idle_dm;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutDRMRightsManagerUidValue;
            //longtitle   = qtn_apps_drm_list;
            //shorttitle  = qtn_apps_drm_grid;
            skeytitle   = qtn_apps_drm_skey;
            msktitle    = qtn_msk_idle_drm;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutFaxModemUidValue;
            //longtitle   = qtn_apps_fax_modem_list;
            //shorttitle  = qtn_apps_fax_modem_grid;
            skeytitle   = qtn_apps_fax_modem_skey;
            msktitle    = qtn_msk_idle_fax_modem;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutFileManagerUidValue;
            //longtitle   = qtn_apps_fmgr_list;
            //shorttitle  = qtn_apps_fmgr_grid;
            skeytitle   = qtn_apps_fmgr_skey;
            msktitle    = qtn_msk_idle_fmgr;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutFMRadioUidValue;
            //longtitle   = qtn_apps_radio_list;
            //shorttitle  = qtn_apps_radio_grid;
            skeytitle   = qtn_apps_radio_skey;
            msktitle    = qtn_msk_idle_radio;
        },
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutFMTXRadioUidValue;
            //longtitle   = qtn_apps_radio_list;
            //shorttitle  = qtn_apps_radio_grid;
            skeytitle   = qtn_fmtx_idle_sk;
            msktitle    = qtn_fmtx_idle_msk;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutGeneralSettingsUidValue;
            //longtitle   = qtn_apps_settings_list;
            //shorttitle  = qtn_apps_settings_grid;
            skeytitle   = qtn_apps_settings_skey;
            msktitle    = qtn_msk_idle_gs;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutControlPanelUidValue;
            //longtitle   = qtn_apps_controlpanel_list;
            //shorttitle  = qtn_apps_controlpanel_grid;
            skeytitle   = qtn_apps_controlpanel_skey;
            msktitle    = qtn_msk_idle_controlpanel;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutHelpUidValue;
            //longtitle   = qtn_apps_help_list;
            //shorttitle  = qtn_apps_help_grid;
            skeytitle   = qtn_apps_help_skey;
            msktitle    = qtn_msk_idle_help;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutIRUidValue;
            //longtitle   = qtn_apps_infrared_list;
            //shorttitle  = qtn_apps_infrared_grid;
            skeytitle   = qtn_apps_infrared_skey;
            msktitle    = qtn_msk_idle_infrared;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutInstantMessagingUidValue;
            //longtitle   = qtn_apps_instant_list;
            //shorttitle  = qtn_apps_instant_grid;
            skeytitle   = qtn_apps_instant_skey;
            msktitle    = qtn_msk_idle_instant;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutUserDictionaryUidValue;
            //longtitle   = qtn_apps_udict_list;
            //shorttitle  = qtn_apps_udict_grid;
            skeytitle   = qtn_apps_udict_skey;
            msktitle    = qtn_msk_idle_udict;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutLandmarksUidValue;
            //longtitle   = qtn_apps_lm_list;
            //shorttitle  = qtn_apps_lm_grid;
            skeytitle   = qtn_apps_lm_skey;
            msktitle    = qtn_msk_idle_lm;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutLogsUidValue;
            //longtitle   = qtn_apps_logs_list;
            //shorttitle  = qtn_apps_logs_grid;
            skeytitle   = qtn_apps_logs_skey;
            msktitle    = qtn_msk_idle_logs;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutMediaGallery2UidValue;
            //longtitle   = qtn_apps_mg_list;
            //shorttitle  = qtn_apps_mg_grid;
            skeytitle   = qtn_apps_mg_skey;
            msktitle    = qtn_msk_idle_mg;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutMediaPlayerUidValue;
            //longtitle   = qtn_apps_mp_list;
            //shorttitle  = qtn_apps_mp_grid;
            skeytitle   = qtn_apps_mp_skey;
            msktitle    = qtn_msk_idle_mp;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutMemoryCardUidValue;
            //longtitle   = qtn_apps_memc_appl_list;
            //shorttitle  = qtn_apps_memc_appl_grid;
            skeytitle   = qtn_apps_mmc_skey;
            msktitle    = qtn_msk_idle_mmc;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutMessagingCenterUidValue;
            //longtitle   = qtn_apps_messaging_list;
            //shorttitle  = qtn_apps_messaging_grid;
            skeytitle   = qtn_apps_messaging_skey;
            msktitle    = qtn_msk_idle_messaging;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutMusicPlayerUidValue;
            //longtitle   = qtn_apps_mplayer_list;
            //shorttitle  = qtn_apps_mplayer_grid;
            skeytitle   = qtn_apps_mplayer_skey;
            msktitle    = qtn_msk_idle_mplayer;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutNotepadUidValue;
            //longtitle   = qtn_apps_notepad_list;
            //shorttitle  = qtn_apps_notepad_grid;
            skeytitle   = qtn_apps_notepad_skey;
            msktitle    = qtn_msk_idle_notepad;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutPersonalisationUidValue;
            //longtitle   = qtn_apps_skins_list;
            //shorttitle  = qtn_apps_skins_grid;
            skeytitle   = qtn_apps_skins_skey;
            msktitle    = qtn_msk_idle_skins;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutPhoneUidValue;
            //longtitle   = qtn_apps_phone_list;
            //shorttitle  = qtn_apps_phone_grid;
            skeytitle   = qtn_apps_phone_grid;
            msktitle    = qtn_apps_phone_grid;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutPhonebookUidValue;
            //longtitle   = qtn_apps_phonebook_list;
            //shorttitle  = qtn_apps_phonebook_grid;
            skeytitle   = qtn_apps_phonebook_skey;
            msktitle    = qtn_msk_idle_phonebook;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutProfilesUidValue;
            //longtitle   = qtn_apps_mode_list;
            //shorttitle  = qtn_apps_mode_grid;
            skeytitle   = qtn_apps_mode_skey;
            msktitle    = qtn_msk_idle_mode;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutPocUidValue;
            //longtitle   = qtn_apps_ptt_list;
            //shorttitle  = qtn_apps_ptt_grid;
            skeytitle   = qtn_apps_ptt_skey;
            msktitle    = qtn_msk_idle_ptt;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutSearchUidValue;
            //longtitle   = qtn_apps_search_list;
            //shorttitle  = qtn_apps_search_grid;
            skeytitle   = qtn_apps_search_skey;
            msktitle    = qtn_msk_idle_search;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutSatUiUidValue;
            //longtitle   = qtn_apps_simapps_list;
            //shorttitle  = qtn_apps_simapps_grid;
            skeytitle   = qtn_apps_simapps_grid;
            msktitle    = qtn_apps_simapps_grid;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutSpeedDialUidValue;
            //longtitle   = qtn_apps_sd_list;
            //shorttitle  = qtn_apps_sd_grid;
            skeytitle   = qtn_apps_sd_skey;
            msktitle    = qtn_msk_idle_sd;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutUSBUidValue;
            //longtitle   = qtn_apps_usb_list;
            //shorttitle  = qtn_apps_usb_grid;
            skeytitle   = qtn_apps_usb_skey;
            msktitle    = qtn_msk_idle_usb;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutVoiceCommandsUidValue;
            //longtitle   = qtn_apps_vc_list;
            //shorttitle  = qtn_apps_vc_grid;
            skeytitle   = qtn_apps_vc_skey;
            msktitle    = qtn_msk_idle_vc;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutVoiceMailboxUidValue;
            //longtitle   = qtn_apps_smsvo_list;
            //shorttitle  = qtn_apps_smsvo_grid;
            skeytitle   = qtn_apps_smsvo_skey;
            msktitle    = qtn_msk_idle_smsvo;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutVoIPUidValue;
            //longtitle   = qtn_apps_voip_list;
            //shorttitle  = qtn_apps_voip_grid;
            skeytitle   = qtn_apps_voip_skey;
            msktitle    = qtn_msk_idle_voip;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutVoiceRecorderUidValue;
            //longtitle   = qtn_vorec_app_menu_list;
            //shorttitle  = qtn_vorec_app_menu_grid;
            skeytitle   = qtn_apps_recorder_skey;
            msktitle    = qtn_msk_idle_recorder;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutSmlSyncUidValue;
            //longtitle   = qtn_apps_sml_list;
            //shorttitle  = qtn_apps_sml_grid;
            skeytitle   = qtn_apps_sml_grid;
            msktitle    = qtn_apps_sml_grid;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutPersonalisationUidValue;
            viewid      = KScutChangeThemeViewIdValue;
            longtitle   = qtn_apps_idle_skin_gs;
            shorttitle  = qtn_apps_idle_skin_skey;
            skeytitle   = qtn_apps_idle_skin_skey;
            msktitle    = qtn_msk_idle_skin;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutAmsEditorUidValue;
            longtitle   = qtn_apps_audio_msg_gs;
            shorttitle  = qtn_apps_audio_msg_skey;
            skeytitle   = qtn_apps_audio_msg_skey;
            msktitle    = qtn_msk_idle_audio_msg;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutEmailEditorUidValue;
            longtitle   = qtn_set_idle_skeys_email_editor;
            shorttitle  = qtn_apps_email_skey;
            skeytitle   = qtn_apps_email_skey;
            msktitle    = qtn_msk_idle_email;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutPostcardEditorUidValue;
            longtitle   = qtn_apps_mmspostcard_gs;
            shorttitle  = qtn_apps_mmspostcard_skey;
            skeytitle   = qtn_apps_mmspostcard_skey;
            msktitle    = qtn_msk_idle_mmspostcard;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutUnifiedEditorUidValue;
            longtitle   = qtn_set_idle_skey_new_msg;
            shorttitle  = qtn_idle_skey_new_msg;
            skeytitle   = qtn_idle_skey_new_msg;
            msktitle    = qtn_msk_idle_new_msg;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutEmailEditorUidValue;
            viewid      = KScutSyncMlEmailUidValue;
            longtitle   = qtn_apps_syncml_mail_gs;
            shorttitle  = qtn_apps_syncml_mail_skey;
            skeytitle   = qtn_apps_syncml_mail_skey;
            msktitle    = qtn_msk_idle_syncml_mail;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutMessagingCenterUidValue;
            viewid      = KScutMessagingCenterUidValue;
            longtitle   = qtn_set_idle_skey_select_msg_type;
            shorttitle  = qtn_idle_skey_select_msg;
            skeytitle   = qtn_idle_skey_select_msg;
            msktitle    = qtn_msk_idle_select_msg;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutGeneralSettingsUidValue;
            viewid      = KScutConnectivityStatusViewIdValue;
            longtitle   = qtn_apps_connectivity_list;
            shorttitle  = qtn_apps_connectivity_skey;
            skeytitle   = qtn_apps_connectivity_skey;
            msktitle    = qtn_msk_idle_connectivity;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutVideoServicesUidValue;
            skeytitle   = qtn_apps_video_grid;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutMusicPlayerUidValue;
            skeytitle   = qtn_apps_mplayer_skey;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutFlashPlayerUidValue;
            skeytitle   = qtn_apps_fplayer_skey;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = KScutExchangeMailUidValue;
            skeytitle   = qtn_apps_exchangemail_skey;
        }
        ,
        AI_APP_TITLE_ITEM
        {
            appuid      = -1;
            //longtitle   = "not found";
            //shorttitle  = "not found";
            skeytitle   = "not found";
            msktitle    = "not found";
        }
    };
}

// End of File.
hs_app_caiscutengine.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in engine class
*
*/


#include                 // For CCoeEnv
#include       // For CRepository
#include                  // For RWsSession
#include                 // For TApaTaskList
#include                 // For CVwsSessionWrapper
#include                  // For TVwsViewId
#include             // For RProperty
#include                     // For CnvUtfConverter
#include 
#include 
#include  // For CActiveFavouritesDbNotifier
#include 
#include 
#include                     // for fast swap
#ifdef SYMBIAN_ENABLE_SPLIT_HEADERS
#include 
#endif


#include 
#include 
#include 
#include 
#include 
#include 
#include 

#include 
#include "hs_app_caiscutengine.h"
#include "hs_app_aiscutpluginprivatecrkeys.h"
#include "aiscutcontentmodel.h"
#include "hs_app_caiscutplugin.h"
#include "hs_app_caiscutshortcut.h"
#include "hs_app_caiscutshortcutinfo.h"
#include "hs_app_aidefaultshortcut.h"
#include "hs_app_aiscutappuidparser.h"
#include "hs_app_aiscutrepositorywatcher.h"
#include "hs_app_aiscuttargetshutter.h"
#include "aiscutdefs.h"
#include "hs_app_aiscutfactory.h"

#include 
#include "debug.h"
/**
 * Timer delay for access check retry. Two seconds.
 */
const TInt KScutAccessCheckRetryDelay = 2000000;
const TUid KVoiceCallUidViewId = { 0x10282D81 };
const TUid KVideoCallUid = { 0x101F8681 };

_LIT(KScutTextsResourceFileName,    "hs_app_aiscuttexts.rsc");
_LIT8(KScutDirectOpen,    "?open");

// ======== LOCAL FUNCTIONS ========

LOCAL_C TInt CompareKey(const TUint32& aLeft, const TUint32& aRight)
{
    TUint32 left  = aLeft  & (KScutBitMaskThemeDefault & KScutBitMaskLocked);
    TUint32 right = aRight & (KScutBitMaskThemeDefault & KScutBitMaskLocked);

    if (left < right)
    {
        return -1;
    }
    else if (left > right)
    {
        return 1;
    }

    return 0;
}

static TInt IntFromDesc( const TDesC &aParam )
    {
    TInt err = KErrArgument;
    if (aParam.Length() > 0)
       {
           _LIT(KHexPrefix, "0x");
           const TInt prefixLen = 2;

           TRadix radix(EDecimal);
           TPtrC ptr(aParam);

           if (aParam.Left(prefixLen).CompareC(KHexPrefix) == 0)
           {
               // Strip the '0x' prefix.
               ptr.Set(aParam.Right(aParam.Length() - prefixLen));

               radix = EHex;
           }

           TLex lexer(ptr);
           TUint32 id;
           
           err = lexer.Val(id, radix);
           if ( err == KErrNone )
               {
               return id;
               }
           else
               {
               return err;
               }
       }
    return err;
    }
// ---------------------------------------------------------------------------
// Timer callback.
// ---------------------------------------------------------------------------
//
TInt DelayedCheckCallBack(TAny* aEngine)
{
    if (aEngine)
    {
    	static_cast(aEngine)->RetryAccessCheck();	
    }
    
    return KErrNone;
}

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutEngine::CAiScutEngine(CAiScutPlugin& aPlugin)
    :
    iPlugin(aPlugin),
    iResourceLoaderTexts(*CCoeEnv::Static()),
    iResourceLoaderSendUi(*CCoeEnv::Static())
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngine::ConstructL()
{
    FeatureManager::InitializeLibL();

    User::LeaveIfError(iApaSession.Connect());
    User::LeaveIfError(iBookmarkSess.Connect());
    User::LeaveIfError(iBookmarkDb.Open(iBookmarkSess, KBrowserBookmarks));

    iVwsSession = CVwsSessionWrapper::NewL();
    iRepository = CRepository::NewL(KCRUidShortcutItems);
   
    iHiddenAppsRepository = CRepository::NewL(KCRUidMenu);

    // Create message server session because it may be needed during shortcut
    // creation for checking mailbox access.
    iMsvSession = CMsvSession::OpenAsObserverL(*this);

    iEnv = CCoeEnv::Static();

    TParsePtrC driveParse(PathInfo::RomRootPath());
    TFileName resourceName(driveParse.Drive());
    TParse parse;
    parse.Set(KScutTextsResourceFileName, &KDC_RESOURCE_FILES_DIR, NULL);
    resourceName.Append(parse.FullName());
    iResourceLoaderTexts.OpenL(resourceName);

    TFileName resourceName2(driveParse.Drive());
    TParse parse2;
    parse2.Set(KSendNormResource, &KDC_RESOURCE_FILES_DIR, NULL);
    resourceName2.Append(parse2.FullName());
    iResourceLoaderSendUi.OpenL(resourceName2);

    LoadAppTitleListL();

    // Engine should still remain alive even though shortcut construction failed
    // because LaunchByValue must still be possible.
    TRAP_IGNORE(CreateShortcutsL());

    // Close message server session for now. It's opened again in Resume if needed.
    delete iMsvSession;
    iMsvSession = NULL;

    iKeyEventObserver = AiUtility::CreatePSPropertyObserverL(
        TCallBack(HandlePSCommand, this),
        KUidSystemCategory, KPSUidShortcutCmd);

    iCallStateObserver = AiUtility::CreatePSPropertyObserverL(
        TCallBack(CallStateChangeCallback, this),
        KPSUidCtsyCallInformation, KCTsyCallState);

    iKeylockApi = CKeyLockPolicyApi::NewL( EPolicyActivateKeyguard );
    if ( !iKeylockApi->HasConfiguration() )
        {
        delete iKeylockApi;
        iKeylockApi = NULL;
        }
    CRepository* repository = CRepository::NewLC(TUid::Uid(KCRUidActiveIdleLV));
    
    repository->Get(KAIFirstKeyLockKey,  iFirstLockKey);
    repository->Get(KAISecondKeyLockKey, iSecondLockKey);
    repository->Get(KAIKeyLockTimeout,  iDelayTimerDelay);    
    CleanupStack::PopAndDestroy(repository);
    // convert micro to milliseconds
    const TInt KUsInMs = 1000;
    iDelayTimerDelay = KUsInMs * iDelayTimerDelay;       
    iDelayTimer = CPeriodic::NewL (CActive::EPriorityStandard );
}

TInt CAiScutEngine::DelayTimerCallBack (TAny *aSelf )
    {
    CAiScutEngine* self = static_cast(aSelf );
    TInt err = KErrNone;
    if (self )
        {
        self->iDelayTimer->Cancel();
        TRAP(err,
                self->HandleLaunchByIndexL( *(self->iDelayedLaunchCmd) );
                );
        
        }
    return err;
    }

void CAiScutEngine::DelayedLaunchByIndexL( const TDesC &aParam )
    {
    delete iDelayedLaunchCmd;        
    iDelayedLaunchCmd = NULL;
    iDelayedLaunchCmd = aParam.AllocL();
    iDelayTimer->Cancel();
    iDelayTimer->Start( iDelayTimerDelay,
            iDelayTimerDelay,
            TCallBack( DelayTimerCallBack, this ));
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutEngine* CAiScutEngine::NewL(CAiScutPlugin& aPlugin)
{
    CAiScutEngine* self = new (ELeave) CAiScutEngine(aPlugin);
    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);
    return self;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutEngine::~CAiScutEngine()
{
#ifdef __WEB_WIDGETS
    if( iWidgetRegistryConnected )
        {
        iWidgetRegistry.Disconnect();
        }
#endif
    delete iKeylockApi;
    delete iSettingsNotifier;
    delete iRepository;

    delete iHiddenAppsNotifier;
    delete iHiddenAppsRepository;

    iHiddenApps.Close();

    delete iAppNotifier;
    delete iTimer;
    delete iMsvSession;
    delete iVwsSession;
    delete iScutShutter;

    Release(iKeyEventObserver);
    Release(iCallStateObserver);

    iShortcuts.ResetAndDestroy();
    iThemeShortcuts.ResetAndDestroy();
    iDefaultUsed.Close();

    delete iBookmarkDbObserver;
    iBookmarkDb.Close();
    iBookmarkSess.Close();

    iApaSession.Close();

    while(iAppTitleList.Count())
    {
        delete iAppTitleList[0].iLongTitle;
        delete iAppTitleList[0].iShortTitle;
        delete iAppTitleList[0].iSkeyTitle;
        delete iAppTitleList[0].iMskTitle;
        iAppTitleList.Remove(0);
    }
    iAppTitleList.Close();

    iResourceLoaderTexts.Close();
    iResourceLoaderSendUi.Close();

    delete iDelayTimer;
    delete iDelayedLaunchCmd;
    iIcons.Close();
    FeatureManager::UnInitializeLib();
}

// ---------------------------------------------------------------------------
// From class MMsvSessionObserver.
// Handles an event from the message server.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::HandleSessionEventL(
    TMsvSessionEvent aEvent, TAny* /*aArg1*/, TAny* /*aArg2*/, TAny* /*aArg3*/)
{
    switch (aEvent)
    {
    case EMsvEntriesCreated:
    case EMsvEntriesDeleted:
    case EMsvEntriesChanged:
        if (iShortcuts.Count() > 0)
        {
            MergeShortcuts(EScutMailbox, ETrue);
            CheckAccessAndPublish(EScutCheckMailbox, EFalse);
        }
        break;

    default:
        break;
    }
}

// ---------------------------------------------------------------------------
// From class MApaAppListServObserver.
// Handles a change in the application list.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::HandleAppListEvent(TInt /*aEvent*/)
{
    TRAP_IGNORE( CheckForThemeDefaultReinstalledL() );
    MergeShortcuts(EScutAnyType, ETrue);
    CheckAccessAndPublish(EScutCheckApp, ETrue);
}

// ---------------------------------------------------------------------------
// Resumes the engine.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::ResumeL(TBool aPublishAll, TAiTransitionReason /*aReason*/)
{
    // Merge shortcuts and start notifiers only if we have publishable shortcuts.
    if (iShortcuts.Count() > 0)
    {
        if (!iSettingsNotifier)
        {
            iSettingsNotifier = CAiScutRepositoryWatcher::NewL(
                KCRUidShortcutItems,
                TCallBack(HandleShortcutsChanged, this),
                iRepository);
        }

        if (!iHiddenAppsNotifier)
        {
            iHiddenAppsNotifier = CAiScutRepositoryWatcher::NewL(
                KCRUidMenu,
                KMenuHideApplication,
                CCenRepNotifyHandler::EStringKey,
                TCallBack(HandleHiddenAppsChanged, this),
                iHiddenAppsRepository);
        }
    }
#ifdef __WEB_WIDGETS
    if( !iWidgetRegistryConnected )
        {
        TInt cError = iWidgetRegistry.Connect();
        if( cError == KErrNone )
            {
            iWidgetRegistryConnected = ETrue;
            }
        }
#endif

    GetHiddenAppsL();

    MergeShortcutsL(EScutAnyType, EFalse);

    // Call state check must be done always because RSK "Back"
    // must be published when theme is changed during phone call, too.
    HandleCallStateChange();

    CheckAccessAndPublish(EScutCheckAll, aPublishAll);

    if (iShortcuts.Count() > 0)
    {
        iSettingsNotifier->StartListeningL();

        iHiddenAppsNotifier->StartListeningL();

        if (!iAppNotifier)
        {
            iAppNotifier = CApaAppListNotifier::NewL(this, CActive::EPriorityStandard);
        }
    }
}

// ---------------------------------------------------------------------------
// Suspends the engine.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::Suspend()
{
    delete iMsvSession; // This is to stop receiving message server events.
    iMsvSession = NULL;

    delete iSettingsNotifier;
    iSettingsNotifier = NULL;

    delete iHiddenAppsNotifier;
    iHiddenAppsNotifier = NULL;

    delete iAppNotifier;
    iAppNotifier = NULL;

    delete iTimer;
    iTimer = NULL;

    delete iScutShutter;
    iScutShutter = NULL;

    if (iBookmarkDbObserver)
    {
        iBookmarkDbObserver->Cancel();
    }
    delete iBookmarkDbObserver;
    iBookmarkDbObserver = NULL;
#ifdef __WEB_WIDGETS
    if( iWidgetRegistryConnected )
        {
        TInt cError = iWidgetRegistry.Disconnect();
        if( cError == KErrNone )
            {
            iWidgetRegistryConnected = EFalse;
            }
        }
#endif
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TInt CAiScutEngine::HandleShortcutsChanged(TAny* aPtr)
{
    __PRINTS("XAI: CAiScutEngine::HandleShortcutsChanged");
    CAiScutEngine* self = static_cast(aPtr);
	
	if (self)
	{
    	self->MergeShortcuts(EScutAnyType, ETrue);
    	self->CheckAccessAndPublish(EScutCheckAll, EFalse);		
	}

    return KErrNone;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TInt CAiScutEngine::HandleHiddenAppsChanged(TAny* aPtr)
{
    CAiScutEngine* self = static_cast(aPtr);

	if (self)
	{
    	TRAP_IGNORE(self->GetHiddenAppsL());
    	self->MergeShortcuts(EScutAnyType, ETrue);
    	self->CheckAccessAndPublish(EScutCheckAll, EFalse);		
	}

    return KErrNone;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutEngine::IsLockKey( TInt aScanCode, TScutLockKey aLockKey ) const
    {
    TBool returnValue = EFalse;
    if ( iKeylockApi )
        {      
        TInt index = 0;
        TUint32 priKey = 0;
        TUint32 secKey = 0;
        TInt err = KErrNone;  
        // Loop through all the combinations in order
        // to find wether this key is part of the locking
        // process or not (1st or 2nd key)      
        while( !returnValue )
            {
            err = iKeylockApi->GetKeyCombination(index, priKey, secKey);
            if ( err == KErrNone )
                {
                switch( aLockKey )
                    {
                    case EScutFirstLockKey:
                        returnValue = (priKey == aScanCode);
                        break;
                    case EScutSecondLockKey:
                        returnValue = (secKey == aScanCode);
                        break;
                    default:
                        returnValue = EFalse;
                        break;                        
                    }
                }               
            else // no more combinations
                {
                break;
                }
            ++index;
            }
        return returnValue;
        }
    switch( aLockKey )
        {
        case EScutFirstLockKey:
            returnValue = iFirstLockKey == aScanCode;
            break;
        case EScutSecondLockKey:
            returnValue = iSecondLockKey == aScanCode;
            break;
        default:
            returnValue = EFalse;
            break;
        }
    return returnValue;
    }



// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutEngine::IsHidden(const TUid& aAppUid) const
{
    if (iHiddenApps.Find(aAppUid) == KErrNotFound)
    {
        return EFalse;
    }

	__PRINT( __DBG_FORMAT( "XAI: CAiScutEngine::IsHidden (0x%x) ETrue"), aAppUid);
    return ETrue;
}

// ---------------------------------------------------------------------------
// Handles an event sent by the AI framework.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::HandleAiEventL(TInt aEvent, const TDesC& aParam)
{
	__PRINT( __DBG_FORMAT( "XAI: CAiScutEngine::HandleAiEventL( %d, '%S' ) alive = %d"), aEvent, &aParam, iPlugin.IsAlive());

    TUid appUid = KNullUid;
    iFirstLockKeyPressed = EFalse;
    iSoftkeyAppRunning = EFalse;

    if (aParam.Compare(KLeftSoftkey) == 0)
    {
        if ( IsLockKey( EStdKeyDevice0, EScutFirstLockKey) || IsLockKey( EStdKeyDevice0 , EScutSecondLockKey))
        {
            // Raise the first lock key pressed flag
            // only when this is raised, keylock skip causes scut launch
            iFirstLockKeyPressed = ETrue;
            appUid = SoftkeyUid(KLeftSoftkeyId);
        }
    }

    if (aParam.Compare(KRightSoftkey) == 0)
    {
        if ( IsLockKey( EStdKeyDevice1 , EScutFirstLockKey) || IsLockKey( EStdKeyDevice1 , EScutSecondLockKey))
        {
            // Raise the first lock key pressed flag
            // only when this is raised, keylock skip causes scut launch
            iFirstLockKeyPressed = ETrue;
            appUid = SoftkeyUid(KRightSoftkeyId);
        }
    }

    if (iFirstLockKeyPressed && appUid != KNullUid)
    {
        TApaTaskList taskList(iEnv->WsSession());
        TApaTask task(taskList.FindApp(appUid));

        if (task.Exists())
        {
        	if (IsHiddenFromFSW(appUid))
            	iSoftkeyAppRunning = EFalse;
        	else
        		iSoftkeyAppRunning = ETrue;	
        }
    }

    if (IsDelayRequired(appUid))
    {
        DelayedLaunchByIndexL( aParam );
        return;
    }

    if( iActiveCall && aParam.Compare( KRightSoftkey ) == 0 )
        {   
        ActivateTopMostApp();
        return;
        }

    switch( aEvent )
        {
        case EAiScutEventLaunchByIndex:
            HandleLaunchByIndexL(aParam);
            break;
    
        case EAiScutEventLaunchByValue:
            HandleLaunchByValueL(aParam);
            break;
    
        case EAiScutEventShowSettings:
            ShowSettingsL(aParam);
            break;
            
        case EAiScutEventShowSetting:
            ShowSettingL(aParam);
            break;
            
        case EAiScutEventLaunchFastswap:
            OpenFastSwap();
            break;
    
        case EAiScutEventLaunchByIndexAlternate:
            HandleLaunchByIndexAlternateL(aParam);
            break;
            
        default:
            break;
        }

}

// ---------------------------------------------------------------------------
// Called by the timer. Retries the access check for shortcuts.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::RetryAccessCheck()
{
    CheckAccessAndPublish(EScutCheckAll, iPublishAll);

    // One retry is enough.
    iTimer->Cancel();
    delete iTimer;
    iTimer = NULL;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutEngine::IsNonNative(const TUid& aUid) 
{
    TBool ret = EFalse;

    const TUid KMidletAppType = { 0x10210E26 };
    TUid typeuid = KNullUid;

    if (KErrNone == iApaSession.GetAppType(typeuid, aUid))
    {
        if (typeuid == KMidletAppType)
        {
            ret = ETrue;
        }
    }

#ifdef __WEB_WIDGETS
    if (IsWidget(aUid))
    {
        ret = ETrue;
    }
#endif

    return ret;
}

#ifdef __WEB_WIDGETS
TBool CAiScutEngine::IsWidget(const TUid& aUid)
{
    if( iWidgetRegistryConnected )
        {
        return iWidgetRegistry.IsWidget(aUid);
        }
    else
        {
        return EFalse;
        }
}
#endif

// ---------------------------------------------------------------------------
// Creates the default shortcuts.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::CreateShortcutsL()
{
    TInt scIndex = 0;

    iShortcuts.ResetAndDestroy();

    RArray keys;
    CleanupClosePushL(keys);
    // Find the keys that define theme-default shortcut settings.
    iRepository->FindL(KScutCenRepKeyThemeDefault, KScutCenRepKeyMask, keys);
    
    
    TLinearOrder order(CompareKey);
    keys.Sort(order);

    HBufC* buffer = HBufC::NewLC(NCentralRepositoryConstants::KMaxUnicodeStringLength);
    TPtr bufferPtr = buffer->Des();

    if (iSettingsNotifier)
    {
        iSettingsNotifier->StopListening();
    }
    if (iHiddenAppsNotifier)
    {
        iHiddenAppsNotifier->StopListening();
    }

    for (TInt i = 0; i < keys.Count(); ++i)
    {
        TUint32 key = keys[i];
        if (iRepository->Get(key, bufferPtr) == KErrNone)
        {
            // Strip off the default-setting-bit, it's not part of the shortcut id.
            key &= KScutBitMaskThemeDefault;

            // Parse the icon from the URL and fetch the icon to our icon array
            // The actual icon => shortcut matching and overriding is done in 
            // CheckAccessAndPublishL() just before publishing                
            iParser.Parse(bufferPtr);
            TAiScutIcon icon = iParser.Icon();
            if ( icon.iType != EScutIconNone  )
                {
                AddOverrideIcon( icon );                
                }
            // Keys over 0x20000000 means that they are just icon overrides                      
            if ( !(key & KScutFlagBitIconOverride ) )
                {
                key &= KScutMaskAdditionalSetting;
                // Ignore possible errors during shortcut construction
                // and simply try to move on to the next shortcut.
                CAiScutShortcut* shortcut = NULL;
                TRAPD(err, shortcut = AiScutFactory::CreateAiScutShortcutL(key, bufferPtr, *this));
                if (err == KErrNone)
                {
                    // If shortcut is not accessible, replace it with platform default.
                    TBool access = EFalse;
                    if (shortcut)
                    {
                        // Append theme default to our array, incase of uninstall/reinstall/mem card removal
                        // restoration is required.
                        CAiScutShortcutInfo* shortcutInfo = NULL;
                        TRAP_IGNORE(shortcutInfo = CAiScutShortcutInfo::NewL(key | KScutFlagBitThemeDefault,
                                                                             bufferPtr));
                        if ( shortcutInfo )
                        {
                            iThemeShortcuts.Append(shortcutInfo);
                        }
                    
                        TScutDefault usedDefault = EScutDefaultToPlatform;
                        
                    	TRAP_IGNORE(access = shortcut->CheckAccessL(EScutCheckAll));
                    	if (!access)
                    	{
                            HBufC* target = HBufC::NewLC(NCentralRepositoryConstants::KMaxUnicodeStringLength);
                            TPtr targetPtr = target->Des();
                        	TUid   dummy;
    	
        	                // Get the default shortcut definition for index 'scIndex'.
            	            // uid is ignored.
                	        TAiDefaultShortcut::GetDefaultShortcut(key, dummy, targetPtr);
    	
        	                delete shortcut;
            	            shortcut = NULL;
                            TRAP(err, shortcut = AiScutFactory::CreateAiScutShortcutL(key, targetPtr, *this));

                	        if (err == KErrNone)
                        	{
                            	// Add the bit that indicates this is a default shortcut setting.
    	                        key |= KScutFlagBitThemeDefault;
        	                    iRepository->Set(key, targetPtr);
        	                    
        	                    // Try to locate a icon override from the default
        	                    // definition
        	                    iParser.Parse( targetPtr );
        	                    TAiScutIcon tIcon = iParser.Icon();
        	                    if ( tIcon.iType != EScutIconNone  )
        	                        {
        	                        AddOverrideIcon( tIcon );                
        	                        }
            	            }
                    	    CleanupStack::PopAndDestroy( target );
                	    }
                	    else
                	    {
                    	    usedDefault = EScutDefaultToTheme;
                	    }

                    	scIndex++;
    	
    	                if (shortcut) // This test ensures that the creation right above went well.
    	                {
    	                    iDefaultUsed.Append(usedDefault);
            	            err = iShortcuts.Append(shortcut);
            	            
                	        if (err != KErrNone)
                    	    {
                        	    delete shortcut;
                            	shortcut = NULL;
                        	}	
    	                }
                    }
                }
            }
        }
    }

    if (iSettingsNotifier)
    {
        iSettingsNotifier->StartListeningL();
    }
    if (iHiddenAppsNotifier)
    {
        iHiddenAppsNotifier->StartListeningL();
    }

    CleanupStack::PopAndDestroy(buffer);
    CleanupStack::PopAndDestroy(&keys);
}

// ---------------------------------------------------------------------------
// Check whether theme default sc was reinstalled.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::CheckForThemeDefaultReinstalledL()
{
    HBufC* buffer = HBufC::NewLC(NCentralRepositoryConstants::KMaxUnicodeStringLength);
    TPtr bufferPtr = buffer->Des();

    if (iSettingsNotifier)
    {
        iSettingsNotifier->StopListening();
    }
    if (iHiddenAppsNotifier)
    {
        iHiddenAppsNotifier->StopListening();
    }

    TInt count = iThemeShortcuts.Count();
    for (TInt i = 0; (i < count) &&
                     (i < iDefaultUsed.Count()) &&
                     (i < iShortcuts.Count());
         ++i)
    {
        if (iDefaultUsed[i] == EScutDefaultToPlatform ||
            iDefaultUsed[i] == EScutUserDefined)
        {
            bufferPtr.Zero();
            CAiScutShortcut*& shortcut = iShortcuts[i];
            // Strip off the default-setting-bit, it's not part of the shortcut id.
            TUint32 scutKey = iThemeShortcuts[i]->Id() & KScutBitMaskThemeDefault;
            bufferPtr.Append(iThemeShortcuts[i]->Target());
            CAiScutShortcut* newScut = NULL;
            TRAPD(err, newScut = AiScutFactory::CreateAiScutShortcutL(scutKey, bufferPtr, *this));
    	    if (err == KErrNone)
          	{
                delete shortcut;
                shortcut = NULL;
                shortcut = newScut;
                // Add the bit that indicates this is a default shortcut setting.
                scutKey |= KScutFlagBitThemeDefault;
                iRepository->Set(scutKey, bufferPtr);
            }
            iDefaultUsed[i] = EScutDefaultToTheme;
            // Recheck access
            shortcut->CheckAccessL(EScutCheckAll);
        }
    }
    if (iSettingsNotifier)
    {
        iSettingsNotifier->StartListeningL();
    }
    if (iHiddenAppsNotifier)
    {
        iHiddenAppsNotifier->StartListeningL();
    }

    CleanupStack::PopAndDestroy(buffer);
}

// ---------------------------------------------------------------------------
// Merges the user defined shortcuts with the defaults and checks shortcut access.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::MergeShortcuts(TShortcutType aType, TBool aRecreateAll)
{
    TRAP_IGNORE(MergeShortcutsL(aType, aRecreateAll));
}

// ---------------------------------------------------------------------------
// Merges the user defined shortcuts with the defaults.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::MergeShortcutsL(TShortcutType aType, TBool aRecreateAll)
{
    RArray keys;
    CleanupClosePushL(keys);

    // Find the keys that define user defined shortcut settings.
    iRepository->FindL(KScutCenRepKeyUserDefined, KScutCenRepKeyMask, keys);

    HBufC* buffer = HBufC::NewLC(
        NCentralRepositoryConstants::KMaxUnicodeStringLength);
    TPtr bufferPtr = buffer->Des();

    for (TInt i = 0; i < iShortcuts.Count(); ++i)
    {
        CAiScutShortcut* shortcut = iShortcuts[i];
        if (aType == EScutAnyType || shortcut->Type() == aType)
        {

            TInt keyIndex = keys.Find(shortcut->Id());
            if (keyIndex != KErrNotFound)
            {
                // Set the new user target.
                if (keys.Count() > keyIndex && keyIndex >= 0 &&
                    iRepository->Get(keys[keyIndex], bufferPtr) == KErrNone)
                {
                    iParser.Parse(bufferPtr);
                    TAiScutIcon icon = iParser.Icon();
                    if ( icon.iType != EScutIconNone  )
                        {
                        AddOverrideIcon( icon );
                        }
                    if ( aRecreateAll ||
                            buffer->CompareC( shortcut->ActiveDefinition() ) != 0 )
                        {
                        shortcut->DeleteUserTarget();                    
                        shortcut->SetUserTarget(bufferPtr);                       
                        }
                    if (i < iDefaultUsed.Count())
                    {
                        iDefaultUsed[i] = EScutUserDefined;
                    }
                }
            }
        }
    }

    CleanupStack::PopAndDestroy(buffer);
    CleanupStack::PopAndDestroy(&keys);
}

// ---------------------------------------------------------------------------
// Checks shortcut accessibility.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::CheckAccessAndPublish(TInt aCheckType, TBool aPublishAll)
{
    TRAPD(err, CheckAccessAndPublishL(aCheckType, aPublishAll));

    if (err == KErrNotReady)
    {
        // Access check failed, create a timer to try again later.
        iTimer = CPeriodic::New(CActive::EPriorityStandard);
        iTimer->Start(KScutAccessCheckRetryDelay, KScutAccessCheckRetryDelay,
            TCallBack(DelayedCheckCallBack));
    }
}

// ---------------------------------------------------------------------------
// Tells each shortcut to check whether or not its target is accessible.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::CheckAccessAndPublishL(TInt aCheckType, TBool aPublishAll)
{
	__PRINTS("XAI: CheckAccessAndPublishL");
    if (!iMsvSession && IsMsvSessionNeeded())
    {
        iMsvSession = CMsvSession::OpenAsObserverL(*this);
    }

    if (!iBookmarkDbObserver && IsBookmarkObserverNeeded())
    {
        iBookmarkDbObserver =
            new (ELeave) CActiveFavouritesDbNotifier(iBookmarkDb, *this);
        if (! iBookmarkDbObserver->IsActive())
        {
        	iBookmarkDbObserver->Start();	
        }        
    }

    iPublishAll = aPublishAll;

    TInt count = iShortcuts.Count();
    for (TInt i = 0; i < count; ++i)
    {
        CAiScutShortcut*& shortcut = iShortcuts[i];

        // Check shortcut access and publish it if its target has changed.
        // When the plug-in is being resumed, all shortcuts are published.
        // Non-visible and locked shortcuts are never published.
        if ( !shortcut->CheckAccessL(aCheckType) )
        {
            HBufC* target = HBufC::NewLC(NCentralRepositoryConstants::KMaxUnicodeStringLength);
            TPtr targetPtr = target->Des();
        	TUid dummy;
            // Get the default shortcut definition from cenrep using key 'key'.
            // uid is ignored.
        	TUint32 key = shortcut->Id();
	        TAiDefaultShortcut::GetDefaultShortcut(key, dummy, targetPtr);
            delete shortcut;
            shortcut = NULL;
            TRAPD(err, shortcut = AiScutFactory::CreateAiScutShortcutL(key, targetPtr, *this));
    	    if (err == KErrNone)
        	{
            	// Add the bit that indicates this is a default shortcut setting.
                key |= KScutFlagBitThemeDefault;
                iRepository->Set(key, targetPtr);
                
                // Try to locate a icon override from the default
                // definition
                iParser.Parse( targetPtr );
                TAiScutIcon tIcon = iParser.Icon();
                if ( tIcon.iType != EScutIconNone  )
                    {
                    AddOverrideIcon( tIcon );                
                    }
        	}
    	    CleanupStack::PopAndDestroy( target );
            if (i < iDefaultUsed.Count())
                {
                iDefaultUsed[i] = EScutDefaultToPlatform;
                }
            // Recheck access
            shortcut->CheckAccessL(aCheckType);
        }

        TBool targetChanged = shortcut->IsTargetChanged();
        TInt32 id = shortcut->Id();
        TBool nonVisible = (0 != (id & KScutFlagBitNonVisible));
        
        if (aCheckType == EScutCheckBkm && shortcut->Type() == EScutBookmark)
        {
            targetChanged = ETrue;
        }

        shortcut->SetToBePublished(
            (targetChanged || iPublishAll) &&
            !nonVisible 
            );

         // Assign overridden icons to shortcuts if needed
         for ( TInt j = 0; j < iIcons.Count(); j++)
             {         
             // Check that the appuid and type matches
             if ( shortcut->AppUid() == iIcons[j].iAppUid &&
                  shortcut->Type() == iIcons[j].iShortcutType )
                {   
                // We need to check also the view id / bkm id if present or otherwise all bookmarks
                // app views would be overridden           
                if ( iIcons[j].iViewId.iUid <= 0 || 
                     iIcons[j].iViewId == shortcut->AdditionalUid() )
                    {
                    shortcut->SetIcon(iIcons[j]);
                    }          
                }
            }

		__PRINT( __DBG_FORMAT( "XAI:   id = 0x%x, type = %d, publish = %d"), 
			shortcut->Id(), shortcut->Type(), shortcut->NeedsToBePublished());
    }

    iPlugin.PublishShortcutsL(iShortcuts);
}

// ---------------------------------------------------------------------------
// Finds the shortcut object with the given id.
// ---------------------------------------------------------------------------
//
TInt CAiScutEngine::FindShortcutIndex(TInt32 aId)
{
    for (TInt i = 0; i < iShortcuts.Count(); ++i)
    {
        if (iShortcuts[i]->Id() == aId)
        {
            return i;
        }
    }

    return KErrNotFound;
}

// ---------------------------------------------------------------------------
// Handles the shortcut launch by index.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::HandleLaunchByIndexL(const TDesC& aParam)
{
	__PRINT( __DBG_FORMAT( "XAI: CAiScutEngine::HandleLaunchByIndexL ('%S')"), &aParam);
    if (aParam.Length() > 0)
    {
        _LIT(KHexPrefix, "0x");
        const TInt prefixLen = 2;

        TRadix radix(EDecimal);
        TPtrC ptr(aParam);

        if (aParam.Left(prefixLen).CompareC(KHexPrefix) == 0)
        {
            // Strip the '0x' prefix.
            ptr.Set(aParam.Right(aParam.Length() - prefixLen));

            radix = EHex;
        }

        TLex lexer(ptr);
        TUint32 id;
        if (lexer.Val(id, radix) == KErrNone)
        {
            TInt idx = FindShortcutIndex(id);
            if (idx != KErrNotFound && idx >= 0 && iShortcuts.Count() > idx)
            {
                iShortcuts[idx]->LaunchL();
            }
        }
    }
}
// ---------------------------------------------------------------------------
// Handles the shortcut launch by index.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::HandleLaunchByIndexAlternateL(const TDesC& aParam)
/**
 * These are the cases at the moment that are handled here.
 * 1) Appshell targeted => Fastswap opened
 */
{
    __PRINT( __DBG_FORMAT( "XAI: CAiScutEngine::HandleLaunchByIndexAlternateL ('%S')"), &aParam);
    TInt index = IntFromDesc( aParam );
    TInt idx = FindShortcutIndex( index );   
    if (idx != KErrNotFound && idx >= 0 && iShortcuts.Count() > idx)
        {
        CAiScutShortcut *scut = iShortcuts[idx];
        // Open fastswap in case appshell was targeted with alternate launch
        if ( scut->AppUid() == KScutAppShellUid )
            {
            OpenFastSwap();
            return;
            }
        // add other special cases here
        /*if ( index == EAiScutSoftKeyLeft )
            {
            // do something
            }*/
    }
}

// ---------------------------------------------------------------------------
// Handles the shortcut launch by value.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::HandleLaunchByValueL(const TDesC& aParam)
{
	__PRINT( __DBG_FORMAT( "XAI: CAiScutEngine::HandleLaunchByIndexL ('%S')"), &aParam);

    if (aParam.Length() > 0)
    {
        CAiScutShortcut* shortcut = AiScutFactory::CreateAiScutShortcutLC(0x0, aParam, *this);
        shortcut->CheckAccessL(EScutCheckAll);
        shortcut->LaunchL();
        CleanupStack::PopAndDestroy(shortcut);
    }
}

// ---------------------------------------------------------------------------
// Shows the plug-in settings dialog.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::ShowSettingsL(const TDesC& aParam)
{
    __PRINT( __DBG_FORMAT( "XAI: CAiScutEngine::ShowSettingsL ('%S')"), &aParam);
    
    _LIT(KGeneralSettings, "localapp:0x100058EC?view=0x102750FC");
    	        
    CAiScutShortcut* shortcut = CAiScutShortcut::NewLC(0x0, KGeneralSettings, *this);
    shortcut->CheckAccessL(EScutCheckAll);

    if (aParam.Length() > 0)
        {
        HBufC8* param = CnvUtfConverter::ConvertFromUnicodeToUtf8L(aParam);
        CleanupStack::PushL(param);
        
        const TDesC8& msg(*param);
        
        shortcut->LaunchL(msg);
        
        CleanupStack::PopAndDestroy(param);
        }
    else
        {
        shortcut->LaunchL(KNullDesC8);
        }        
        
                    
    CleanupStack::PopAndDestroy(shortcut);        
}

// ---------------------------------------------------------------------------
// Shows the plug-in setting.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::ShowSettingL(const TDesC& aParam)
{
    __PRINT( __DBG_FORMAT( "XAI: CAiScutEngine::ShowSettingL ('%S')"), &aParam);
    
    _LIT(KGeneralSettings, "localapp:0x100058EC?view=0x102750FC");
                
    CAiScutShortcut* shortcut = CAiScutShortcut::NewLC(0x0, KGeneralSettings, *this);
    shortcut->CheckAccessL(EScutCheckAll);

    if (aParam.Length() > 0)
        {
        HBufC8* param = CnvUtfConverter::ConvertFromUnicodeToUtf8L(aParam);
        CleanupStack::PushL(param);
        
        HBufC8* param2 = HBufC8::NewLC(param->Des().Length()+KScutDirectOpen.iTypeLength);
        param2->Des().Copy(param->Des());
        param2->Des().Append(KScutDirectOpen);
        const TDesC8& msg(*param2);
        
        shortcut->LaunchL(msg);
        
        CleanupStack::PopAndDestroy(param2);
        CleanupStack::PopAndDestroy(param);
        }
    else
        {
        shortcut->LaunchL(KNullDesC8);
        }        
        
                    
    CleanupStack::PopAndDestroy(shortcut);       
}

// ---------------------------------------------------------------------------
// Opens the fastswap window
// ---------------------------------------------------------------------------
//
void CAiScutEngine::OpenFastSwap()
{
    RAknUiServer* uiServer = CAknSgcClient::AknSrv();
    if ( uiServer )
        {
        uiServer->MakeTaskListVisible( ETrue );
        }    
}



// ---------------------------------------------------------------------------
// Handles PS commands from WSPlugin.
// ---------------------------------------------------------------------------
//
TInt CAiScutEngine::HandlePSCommand(TAny* aAny)
{
    CAiScutEngine* self = reinterpret_cast< CAiScutEngine* >(aAny);
    TInt err = KErrNone;
    if (self)
    {
    	TRAP(err, self->DoHandlePSCommandL());	
    }
    
    return err;
}

// ---------------------------------------------------------------------------
// Handles call state changes.
// ---------------------------------------------------------------------------
//
TInt CAiScutEngine::CallStateChangeCallback(TAny* /*aAny*/)
{
    return KErrNone;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TUid CAiScutEngine::SoftkeyUid(TUint32 aSoftkeyId)
{
    TUid uid = KNullUid;

    TInt idx = FindShortcutIndex(aSoftkeyId);
    if (idx != KErrNotFound && idx >= 0 && iShortcuts.Count() > idx)
    {
        uid = iShortcuts[idx]->AppUid();

	__PRINT( __DBG_FORMAT( "XAI: SoftkeyUid %d app uid = 0x%x"), idx, uid.iUid);
    }

    return uid;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutEngine::IsDelayRequired(TUid aAppUid)
{
    // softkey delay is reuired for these applications because of problems
    // in killing them immediatly after keylock activation.
    if (aAppUid.iUid == KScutBrowserUidValue      ||
        aAppUid.iUid == KScutOperatorMenuUidValue ||
        aAppUid.iUid == KScutVideoServicesUidValue ||
        IsNonNative( aAppUid )
        )
    {
        return ETrue;
    }

    return EFalse;
}

// ---------------------------------------------------------------------------
// Handles PS commands from WSPlugin.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::DoHandlePSCommandL()
{
    TBuf command;
    TUint32 lockKeyId = 0;
    iKeyEventObserver->Get(command);

	__PRINT( __DBG_FORMAT( "XAI: CAiScutEngine::DoHandlePSCommandL command = '%S'"), &command);

    TUid appUid = KNullUid;

    if (iFirstLockKey == EStdKeyDevice0)
    {
        appUid = SoftkeyUid(KLeftSoftkeyId);
        lockKeyId = KLeftSoftkeyId;
    }

    if (iFirstLockKey == EStdKeyDevice1)
    {
        appUid = SoftkeyUid(KRightSoftkeyId);
        lockKeyId = KRightSoftkeyId;
    }

    if (iFirstLockKeyPressed && command.Compare(KAiPSEnableKeyLock) == 0)
    {
        if (appUid != KNullUid)
        {
            TBool isDialog = EFalse;
            TInt idx = 0;
            delete iScutShutter;
            iScutShutter = NULL;
            
            // In case new message shortcut in lockkey
            // we need to dismiss the dialog 
            if ( lockKeyId > 0 )
                {
                idx = FindShortcutIndex( lockKeyId );
                if (idx != KErrNotFound)
                    {
                    switch (iShortcuts[idx]->Type())
                        {
                        case EScutNewMsgType:
                            isDialog = ETrue;
                            break;
                        default:
                            isDialog = EFalse;
                            break;                          
                        }                                                
                    }

                }                    
            iDelayTimer->Cancel();
            iScutShutter = CAiScutTargetShutter::NewL(iEnv, appUid, iSoftkeyAppRunning, isDialog);
            iScutShutter->StartL();
        }
    }

    if (command.Compare(KAiPSSkipKeyLock) == 0)
    {
        iDelayTimer->Cancel();
        return ;
    }
    else if (command.Compare(KAiPSKeyLockTimeout) == 0)
    {
        if (iFirstLockKeyPressed)
        {
            iFirstLockKeyPressed = EFalse;

            if (iFirstLockKey == EStdKeyDevice0)
            {
                if (IsDelayRequired(appUid))
                {
                    HandleLaunchByIndexL(KLeftSoftkey);
                }
                return ;
            }

            if (iFirstLockKey == EStdKeyDevice1)
            {
                if (IsDelayRequired(appUid))
                {
                    HandleLaunchByIndexL(KRightSoftkey);
                }
                return ;
            }
        }
        return ;
    }

    if (FeatureManager::FeatureSupported(KFeatureIdKeypadNoVoiceKey) &&
        command.Compare(KAiPSSkipNameDialer) == 0)
    {
        HandleLaunchByIndexL(KRightSoftkey);
        return ;
    }

    HandleLaunchByValueL(command);
}

// ---------------------------------------------------------------------------
// Handles call state changes.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::HandleCallStateChange()
{
    TInt value = 0;
    TInt err = iCallStateObserver->Get(value);
    iActiveCall = (value > EPSCTsyCallStateNone) && err == KErrNone;

	__PRINT( __DBG_FORMAT( "XAI: CAiScutEngine::HandleCallStateChange = %d"), value);
	__PRINT( __DBG_FORMAT( "XAI:   iActiveCall = %d"), iActiveCall);

    for (TInt i = 0; i < iShortcuts.Count(); ++i)
    {
        iShortcuts[i]->SetCallState(iActiveCall);
    }
}

// ---------------------------------------------------------------------------
// Activates TopMost Application
// ---------------------------------------------------------------------------
//
void CAiScutEngine::ActivateTopMostApp()
{
    // Phone Topmost app as default
    TInt idleAppUid   = 0;
    TInt topMostAppId = 0;

    RProperty::Get(KPSUidAiInformation, KActiveIdleUid, idleAppUid);

    RProperty property;
    TInt err = property.Attach(KPSUidUikon, KUikVideoCallTopApp);

    if (err == KErrNone)
    {
        property.Get(topMostAppId);
    }

    property.Close();

	__PRINT( __DBG_FORMAT( "XAI: ActivateTopMostApp idle uid = 0x%x topmost = 0x%x"), idleAppUid, topMostAppId);

    TUid appId(TUid::Uid(topMostAppId));
    
    if(appId == KVideoCallUid)
    {
	    const TVwsViewId viewId(appId, appId);
	    err = iVwsSession->CreateActivateViewEvent(viewId, KNullUid, KNullDesC8());

		__PRINT( __DBG_FORMAT( "XAI:   CreateActivateViewEvent = %d"), err);	
    }
    else
    {
    	const TVwsViewId viewId(appId, KVoiceCallUidViewId);
	    err = iVwsSession->CreateActivateViewEvent(viewId, KVoiceCallUidViewId, KNullDesC8());

		__PRINT( __DBG_FORMAT( "XAI:   CreateActivateViewEvent = %d"), err);	
    }

}

// ---------------------------------------------------------------------------
// From class MFavouritesDbObserver.
// Handles database event.
// ---------------------------------------------------------------------------
//
void CAiScutEngine::HandleFavouritesDbEventL(RDbNotifier::TEvent aEvent)
{
	__PRINT( __DBG_FORMAT( "XAI: CAiScutEngine::HandleFavouritesDbEventL aEvent = %d"), aEvent);

    if (aEvent == RDbNotifier::ECommit)
    {
        MergeShortcuts(EScutBookmark, ETrue);
        CheckAccessAndPublish(EScutCheckBkm, EFalse);
    }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutEngine::IsMsvSessionNeeded()
{
    TInt count = iShortcuts.Count();

    for (TInt i = 0; i < count; ++i)
    {
        CAiScutShortcut* shortcut = iShortcuts[i];
        TShortcutType type = shortcut->Type();

        if (type == EScutNewMessage    ||
            type == EScutNewEmail      ||
            type == EScutNewSyncMLMail ||
            type == EScutNewPostcard   ||
            type == EScutNewAudioMsg   ||
            type == EScutNewMsgType    ||
            type == EScutMailbox)
        {
            return ETrue;
        }
    }

    return EFalse;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutEngine::IsBookmarkObserverNeeded()
{
    TInt count = iShortcuts.Count();

    for (TInt i = 0; i < count; ++i)
    {
        CAiScutShortcut* shortcut = iShortcuts[i];
        if (shortcut->Type() == EScutBookmark)
        {
            return ETrue;
        }
    }

    return EFalse;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutEngine::GetAppTitle(
    const TUid& aAppUid, const TUid& aViewId, TDes& aTitle, TAiScutAppTitleType aType)
{
    TBool ret = EFalse;
    TInt count = iAppTitleList.Count();

    for (TInt i = 0; i < count; i++)
    {
        TAiScutAppTitleEntry entry = iAppTitleList[i];

        if (entry.iAppUid == aAppUid && entry.iViewId == aViewId)
        {
            switch (aType)
            {
            case EAiScutLongTitle:
                if (entry.iLongTitle)
                {
                    aTitle = *entry.iLongTitle;
                    ret = ETrue;
                }
                break;

            case EAiScutShortTitle:
                if (entry.iShortTitle)
                {
                    aTitle = *entry.iShortTitle;
                    ret = ETrue;
                }
                break;

            case EAiScutSkeyTitle:
                if (entry.iSkeyTitle)
                {
                    aTitle = *entry.iSkeyTitle;
                    ret = ETrue;
                }
                break;

            case EAiScutMskTitle:
                if (entry.iMskTitle)
                {
                    aTitle = *entry.iMskTitle;
                    ret = ETrue;
                }
                break;
            default :
            	break;
            }

            break; // break the for loop
        }
    }

	if (! ret) __PRINT( __DBG_FORMAT( "XAI: GetAppTitle NOT found for uid = 0x%x"), aAppUid);

    return ret;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngine::LoadAppTitleListL()
{
    TResourceReader reader;
    iEnv->CreateResourceReaderLC(reader, R_SCUT_APP_TITLE_LIST);

    TInt items = reader.ReadInt16();

	__PRINT( __DBG_FORMAT( "XAI: LoadAppTitleListL items = %d"), items);

    TUid appuid;
    TUid viewid;

    for (TInt i = 0; i < items; i++)
    {
        appuid.iUid = reader.ReadInt32();
        viewid.iUid = reader.ReadInt32();

        HBufC16* longTitle = reader.ReadHBufC16L();
        CleanupStack::PushL(longTitle);

        HBufC16* shortTitle = reader.ReadHBufC16L();
        CleanupStack::PushL(shortTitle);

        HBufC16* skeyTitle = reader.ReadHBufC16L();
        CleanupStack::PushL(skeyTitle);

        HBufC16* mskTitle = reader.ReadHBufC16L();
        CleanupStack::PushL(mskTitle);

        TAiScutAppTitleEntry entry;

        entry.iAppUid     = appuid;
        entry.iViewId     = viewid;
        entry.iLongTitle  = longTitle;
        entry.iShortTitle = shortTitle;
        entry.iSkeyTitle  = skeyTitle;
        entry.iMskTitle   = mskTitle;

        User::LeaveIfError(iAppTitleList.Append(entry));

        // Title names are deleted in destructor.
        CleanupStack::Pop(4, longTitle);
    }

    CleanupStack::PopAndDestroy(); // reader
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngine::GetHiddenAppsL()
{
    HBufC* buffer = HBufC::NewLC(
        NCentralRepositoryConstants::KMaxUnicodeStringLength);
    TPtr bufferPtr = buffer->Des();

    iHiddenAppsRepository->Get(KMenuHideApplication, bufferPtr);

	__PRINT( __DBG_FORMAT( "XAI: CAiScutSettingsModel::GetHiddenAppsL '%S' "), buffer);

    iHiddenApps.Reset();
    TAiScutAppUidParser uidParser(bufferPtr, iHiddenApps);
    uidParser.ParseL();

    CleanupStack::PopAndDestroy(buffer);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutEngine::IsHiddenFromFSW( const TUid& aAppUid )
{
	const TUid KPSUidUikon = { 0x101F8773 };
 	const TUint32 KUikAppHiddenList  = 0x00000010;
 	const TInt KMaxHiddenApps = 25;

	TBuf16 <2*KMaxHiddenApps> retrievedList;
    TInt err = RProperty::Get( KPSUidUikon, KUikAppHiddenList,
retrievedList );
    TInt i = 0;

	TUint32 listValue;
	while( i < KMaxHiddenApps && KErrNone == err )
    {
    	// 32-bit uid values are retrieved in two 16-bit parts
    	listValue = retrievedList[2*i] << 16;
  		listValue += retrievedList[2*i+1];
   
    	if ( listValue )
    	{
        	TUid t ( KNullUid );
        	t.iUid = listValue;
        	if( t == aAppUid )
        	{
        		return ETrue;	
        	}
   		}
    	else
        {
        	err = KErrEof;
        	return EFalse;                
        }
    	i++;
    }
    return EFalse;
} 
// ---------------------------------------------------------------------------
// Adds an override icon to iIcons array in case the same icon 
// isn't there already
// ---------------------------------------------------------------------------
//
TInt CAiScutEngine::AddOverrideIcon( TAiScutIcon &aIcon )
    {
    TBool foundExisting = EFalse;
    
    for ( TInt i = 0; i < iIcons.Count(); i++)
        {
        if ( aIcon.iAppUid == iIcons[i].iAppUid &&
             aIcon.iShortcutType == iIcons[i].iShortcutType && 
             aIcon.iViewId == iIcons[i].iViewId &&
             aIcon.iDestination == iIcons[i].iDestination )             
            {
            foundExisting = ETrue;
            break;
            }
        }
    if ( !foundExisting )
        {
        return iIcons.Append( aIcon );
        }
    return KErrNone;
    }
// End of File.
hs_app_caiscutengineext.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in engine extension
*
*/

#include 
#include 
#include 
#include 

#include 

#include "hs_app_caiscutengineext.h"
#include "hs_app_caiscutextserver.h"
#include "hs_app_taiscutparser.h"
#include "hs_app_caiscutshortcut.h"
#include "hs_app_caiscutplugin.h"
#include "aiscutcontentmodel.h"
#include "hs_app_caiscutextdata.h"
#include "hs_app_caiscutextdatamodel.h"

// ======== LOCAL DEFINITIONS ========

namespace
    {
    //  LOCAL CONSTANTS
    /**
     * Target id hex format
     */
    _LIT( KTargetIdFormat, "0x%08x" );

    /**
     * Maximum length of target id
     */
    const TInt KTargetIdMaxLength = 11;
    }

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutEngineExt* CAiScutEngineExt::NewL( CAiScutPlugin& aPlugin )
    {
    CAiScutEngineExt* self = new( ELeave ) CAiScutEngineExt( aPlugin );
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutEngineExt::~CAiScutEngineExt()
    {
    delete iAiScutExtServer;
    delete iExtDataModel;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutEngineExt::CAiScutEngineExt( CAiScutPlugin& aPlugin )
    : CAiScutEngine( aPlugin )
    {
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngineExt::ConstructL()
    {
    CAiScutEngine::ConstructL();

    iExtDataModel = CAiScutExtDataModel::NewL();
    iAiScutExtServer = new( ELeave ) CAiScutExtServer( *this, Env()->WsSession() );
    iAiScutExtServer->ConstructL();
    TRAPD( err, iAiScutExtServer->StartL( KAiScutExtServerName ) );

    if( err != KErrNone && err != KErrAlreadyExists )
        {
        User::Leave( err );
        }
    
    //Send EAiScutEventGainFocus to the leftmost shortcut in order to put
    //its state machine in correct state
    if( iShortcuts.Count() > 0 )
    {
        static_cast< CAiScutShortcutExt* >( iShortcuts[ 0 ] )->HandleAIEventL(
            EAiScutEventGainFocus );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngineExt::CheckAccessAndPublish( CAiScutShortcut& aShortcut )
    {
    TRAPD( err,
        RAiShortcutArray shortcutArray;
        CleanupClosePushL( shortcutArray );
        shortcutArray.AppendL( &aShortcut );
        aShortcut.SetToBePublished( ETrue );
        iPlugin.PublishShortcutsL( shortcutArray );
        CleanupStack::PopAndDestroy( &shortcutArray );
        );

    if( err != KErrNone )
        {
        //Delegate publishing to the original engine
        CAiScutEngine::CheckAccessAndPublish( EScutCheckAll, ETrue );
        }
    }

// ---------------------------------------------------------------------------
// Handles an event sent by the AI framework.
// ---------------------------------------------------------------------------
//
void CAiScutEngineExt::HandleAiEventL( TInt aEvent, const TDesC& aParam )
    {
    CAiScutShortcutExt* shortcut = FindShortcutById( aParam );
    if( shortcut )
        {
        shortcut->HandleAIEventL( aEvent );
        }
    CAiScutEngine::HandleAiEventL( aEvent, aParam );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngineExt::ResumeL( TBool aPublishAll, TAiTransitionReason aReason )
    {
    TArray extDataArray = iExtDataModel->AiScutExtDataArray();
    const TInt count = extDataArray.Count();
    //Iterate extension data items and populate to matching shortcuts.
    //Remove the items that are not used in any shortcut.
    for( TInt i = 0; i < count; i++ )
        {
        CAiScutExtData* extData = extDataArray[ i ];
        const TDesC& targetDefinition = extData->TargetDefinition();
        if( !PopulateExtData( targetDefinition, extData ) )
            {
            iExtDataModel->RemoveAiScutExtData( targetDefinition );
            }
        }

    TAiTransitionReason resumeReason = iPlugin.ResumeReason();
    const TInt shortcutCount = iShortcuts.Count();
    for( TInt i = 0; i < shortcutCount; i++ )
        {
        CAiScutShortcutExt* shortcut = static_cast< CAiScutShortcutExt* >
            ( iShortcuts[ i ] );
        shortcut->HandleResumed( resumeReason );
        }

    iAiScutExtServer->ResumeL( aReason );

    CAiScutEngine::ResumeL( aPublishAll, aReason );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngineExt::HandleSetPopupLineArrayL( const TDesC& aDefinition,
    CDesCArray* aLineArray )
    {
    CAiScutExtData* extData = iExtDataModel->SetPopupLineArrayL(
        aDefinition, aLineArray );
    TBool shortcutsFound = PopulateExtData(
        aDefinition, extData );
    if( !shortcutsFound )
        {
        iExtDataModel->RemoveAiScutExtData( aDefinition );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngineExt::HandleResetPopupLineArrayL( const TDesC& aDefinition )
    {
    CAiScutExtData* extData = iExtDataModel->ResetPopupLineArray( aDefinition );
    TBool shortcutsFound = PopulateExtData(
        aDefinition, extData );
    if( !shortcutsFound )
        {
        iExtDataModel->RemoveAiScutExtData( aDefinition );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngineExt::HandleSetIconL( const TDesC& aDefinition, CGulIcon* aIcon )
    {
    CAiScutExtData* extData = iExtDataModel->SetIconL( aDefinition, aIcon );
    TBool shortcutsFound = PopulateExtData(
        aDefinition, extData );
    if( !shortcutsFound )
        {
        iExtDataModel->RemoveAiScutExtData( aDefinition );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngineExt::HandleResetIconL( const TDesC& aDefinition )
    {
    CAiScutExtData* extData = iExtDataModel->ResetIcon( aDefinition );
    TBool shortcutsFound = PopulateExtData(
        aDefinition, extData );
    if( !shortcutsFound )
        {
        iExtDataModel->RemoveAiScutExtData( aDefinition );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutEngineExt::HandleIsInShortcutsL( const TDesC& aDefinition ) const
    {
    const TInt shortcutCount = iShortcuts.Count();
    for( TInt i = 0; i < shortcutCount; i++ )
        {
        CAiScutShortcutExt* shortcut = static_cast< CAiScutShortcutExt* >
            ( iShortcuts[ i ] );
        TPtrC activeTargetDefinition = shortcut->ActiveTargetDefinition();
        if( activeTargetDefinition.CompareF( aDefinition ) == 0 )
            {
            return ETrue;
            }
        }

    return EFalse;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutEngineExt::HandleIssuePutInShortcutsL( const TDesC& /*aDefinition*/ )
    {
    CGSLauncher* l = CGSLauncher::NewLC();
    l->LaunchGSViewL ( TUid::Uid( AI_UID_ECOM_IMPLEMENTATION_SETTINGS_SCUTPLUGIN ),
                       KScutActiveIdleUid,
                       KNullDesC8 );    
    CleanupStack::PopAndDestroy( l );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutEngineExt::PopulateExtData( const TDesC& aDefinition,
    const MAiScutExtData* aAiScutExtData )
    {
    //Iterate shortcuts and update matching ones with new extData
    TBool shortcutsFound = EFalse;
    const TInt shortcutCount = iShortcuts.Count();
    for( TInt i = 0; i < shortcutCount; i++ )
        {
        CAiScutShortcutExt* shortcut = static_cast< CAiScutShortcutExt* >
            ( iShortcuts[ i ] );
        TPtrC activeTargetDefinition = shortcut->ActiveTargetDefinition();
        if( activeTargetDefinition.CompareF( aDefinition ) == 0 )
            {
            shortcut->SetAiScutExtData( aAiScutExtData );
            shortcutsFound = ETrue;
            }
        }

    return shortcutsFound;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcutExt* CAiScutEngineExt::FindShortcutById(
    const TDesC& aId ) const
    {
    const TInt shortcutCount = iShortcuts.Count();
    for( TInt i = 0; i < shortcutCount; i++ )
        {
        CAiScutShortcutExt* shortcut = static_cast< CAiScutShortcutExt* >
            ( iShortcuts[ i ] );

        TBuf< KTargetIdMaxLength > id;
        id.Format( KTargetIdFormat, shortcut->Id() );

        if( id.CompareF( aId ) == 0 )
            {
            return shortcut;
            }
        }
    return NULL;
    }

// End of File.
hs_app_caiscutextdata.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in engine extension
*
*/


#include "hs_app_caiscutextdata.h"
#include 
#include 

// ======== LOCAL DEFINITIONS ========

namespace
    {
    }

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtData* CAiScutExtData::NewL( const TDesC& aTargetDefinition )
    {
    CAiScutExtData* self = CAiScutExtData::NewLC( aTargetDefinition );
    CleanupStack::Pop( self );
    return self;
    }

CAiScutExtData* CAiScutExtData::NewLC( const TDesC& aTargetDefinition )
    {
    CAiScutExtData* self = new( ELeave ) CAiScutExtData;
    CleanupStack::PushL( self );
    self->ConstructL( aTargetDefinition );
    return self;
    }
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtData::~CAiScutExtData()
    {
    delete iIcon;
    delete iPopupLineArray;
    delete iTargetDefinition;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtData::CAiScutExtData()
    {
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtData::ConstructL( const TDesC& aTargetDefinition )
    {
    iTargetDefinition = aTargetDefinition.AllocL();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
const TDesC& CAiScutExtData::TargetDefinition() const
    {
    return *iTargetDefinition;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtData::SwitchPopupLineArray( CDesCArray* aPopupLineArray )
    {
    delete iPopupLineArray;
    iPopupLineArray = aPopupLineArray;
    }
    
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtData::ResetPopupLineArray()
    {
    delete iPopupLineArray;
    iPopupLineArray = NULL;
    }
    
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtData::SwitchIcon( CGulIcon* aIcon )
    {
    delete iIcon;
    iIcon = aIcon;
    }
    
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtData::ResetIcon()
    {
    delete iIcon;
    iIcon = NULL;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
const MDesCArray* CAiScutExtData::PopupLineArray() const
    {
    return iPopupLineArray;
    }
    
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
const CGulIcon* CAiScutExtData::Icon() const
    {
    return iIcon;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
/*
CGulIcon* CAiScutExtData::DuplicateIconL() const
    {
    if( !iIcon )
        {
        return NULL;
        }

    CGulIcon* newIcon = CGulIcon::NewLC();
    
    CFbsBitmap* iconBitmap = iIcon->Bitmap();
    if( iconBitmap && iconBitmap->Handle() != 0 )
        {
        CFbsBitmap* newBitmap = new( ELeave ) CFbsBitmap();
        CleanupStack::PushL( newBitmap );
        User::LeaveIfError( newBitmap->Duplicate( iconBitmap->Handle() ) );
        CleanupStack::Pop( newBitmap );
        newIcon->SetBitmap( newBitmap );
        }

    CFbsBitmap* iconMask = iIcon->Mask();
    if( iconMask && iconMask->Handle() != 0 )
        {
        CFbsBitmap* newMask = new( ELeave ) CFbsBitmap();
        CleanupStack::PushL( newMask );
        User::LeaveIfError( newMask->Duplicate( iconMask->Handle() ) );
        CleanupStack::Pop( newMask );
        newIcon->SetMask( newMask );
        }

    CleanupStack::Pop( newIcon );
    return newIcon;
    }
*/
    
// End of File.
hs_app_caiscutextdatamodel.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in extension data model
*
*/


#include "hs_app_caiscutextdatamodel.h"
#include "hs_app_caiscutextdata.h"

// ======== LOCAL DEFINITIONS ========

namespace
    {
    }

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtDataModel* CAiScutExtDataModel::NewL()
    {
    CAiScutExtDataModel* self = CAiScutExtDataModel::NewLC();
    CleanupStack::Pop( self );
    return self;
    }

CAiScutExtDataModel* CAiScutExtDataModel::NewLC()
    {
    CAiScutExtDataModel* self = new( ELeave ) CAiScutExtDataModel;
    CleanupStack::PushL( self );
    self->ConstructL();
    return self;
    }
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtDataModel::~CAiScutExtDataModel()
    {
    iAiScutExtDataArray.ResetAndDestroy();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtDataModel::CAiScutExtDataModel()
    {
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtDataModel::ConstructL()
    {
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtData* CAiScutExtDataModel::SetPopupLineArrayL( 
    const TDesC& aDefinition, CDesCArray* aLineArray )
    {
    CAiScutExtData* extData = NULL;
    TInt index = FindAiScutExtData( aDefinition );
    if( index != KErrNotFound )
        {
        extData = iAiScutExtDataArray[ index ];
        }
    else
        {
        extData = CreateAiScutExtDataL( aDefinition );
        }

    extData->SwitchPopupLineArray( aLineArray );    //Takes ownership
    return extData;
    }

CAiScutExtData* CAiScutExtDataModel::ResetPopupLineArray( const TDesC& aDefinition )
    {
    CAiScutExtData* extData = NULL;
    TInt index = FindAiScutExtData( aDefinition );
    if( index != KErrNotFound )
        {
        extData = iAiScutExtDataArray[ index ];
        if( extData->Icon() )
            {
            extData->ResetPopupLineArray();
            }
        else
            {            
            iAiScutExtDataArray.Remove( index );
            delete extData;
            extData = NULL;
            }        
        }
    return extData;
    }

CAiScutExtData* CAiScutExtDataModel::SetIconL( const TDesC& aDefinition, CGulIcon* aIcon )
    {
    CAiScutExtData* extData = NULL;
    TInt index = FindAiScutExtData( aDefinition );
    if( index != KErrNotFound )
        {
        extData = iAiScutExtDataArray[ index ];
        }
    else
        {
        extData = CreateAiScutExtDataL( aDefinition );
        }

    extData->SwitchIcon( aIcon );    //Takes ownership
    return extData;
    }

CAiScutExtData* CAiScutExtDataModel::ResetIcon( const TDesC& aDefinition )
    {
    CAiScutExtData* extData = NULL;
    TInt index = FindAiScutExtData( aDefinition );
    if( index != KErrNotFound )
        {
        extData = iAiScutExtDataArray[ index ];
        if( extData->PopupLineArray() )
            {
            extData->ResetIcon();
            }
        else
            {            
            iAiScutExtDataArray.Remove( index );
            delete extData;
            extData = NULL;
            }        
        }
    return extData;
    }

TArray CAiScutExtDataModel::AiScutExtDataArray() const
    {
    return iAiScutExtDataArray.Array();
    }

void CAiScutExtDataModel::RemoveAiScutExtData( const TDesC& aDefinition )
    {
    TInt index = FindAiScutExtData( aDefinition );    
    if( index != KErrNotFound )
        {
        CAiScutExtData* extData = iAiScutExtDataArray[ index ];
        iAiScutExtDataArray.Remove( index );
        delete extData;
        }
    }

TInt CAiScutExtDataModel::FindAiScutExtData( const TDesC& aDefinition ) const
    {
    const TInt count = iAiScutExtDataArray.Count();
    for( TInt i = 0; i < count; i++ )
        {
        if( iAiScutExtDataArray[ i ]->TargetDefinition().CompareF( aDefinition ) == 0 )
            {
            return i;
            }
        }
    return KErrNotFound;
    }
    
CAiScutExtData* CAiScutExtDataModel::CreateAiScutExtDataL( const TDesC& aDefinition )
    {    
    CAiScutExtData* extData = CAiScutExtData::NewLC( aDefinition );
    iAiScutExtDataArray.AppendL( extData ); //Takes ownership
    CleanupStack::Pop( extData );
    return extData;
    }
// End of File.
hs_app_caiscutextserver.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in xSP extension server class.
*
*/


#include 
#include 
#include 
#include 
#include 
#include 

#include 
#include 

#include 
#include 
#include 

#include "hs_app_caiscutextserver.h"
#include "hs_app_caiscutextsession.h"
#include "hs_app_taiscutparser.h"
#include "hs_app_caiscutextserver.h"
#include "activeidle2domainpskeys.h"


// Amount of bytes the data buffer increases at a time.
const TInt KAppsListDataGranularity = 100;

// The length of '0x' in front of a hex literal.
const TInt KTokenPrefix = 2;

// Index to UID 3
const TInt KUidIndex = 2;

// Count of characters one UID occupies in CenRep (prefix + 8 digits + spacer)
const TInt KUidStorageLength = KTokenPrefix + 8 + 1;

_LIT(KUidFormat, "0x%08X ");

_LIT(KResource, "z:\\resource\\hs_app_aiscutpluginres.rsc");

_LIT(KRomDrive, "z");


CLinkParams::CLinkParams(CAiScutExtServer& aServer, HBufC* aTargetDefinition)
    : iServer(aServer)
    {
    iTargetDefinition = aTargetDefinition;
    }

CLinkParams::~CLinkParams()
    {
    delete iTargetDefinition;
    }

// ======== MEMBER FUNCTIONS ========


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtServer::CAiScutExtServer( MAiScutExtMessageHandler& aObserver, RWsSession& aWsSession )
    : CServer2( CActive::EPriorityStandard ), iObserver( aObserver ), iWsSession(aWsSession)
    {
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtServer::ConstructL()
{
    iIdle = CIdle::NewL( EPriorityStandard );

    TFileName fileName( KResource );
    CEikonEnv* env = CEikonEnv::Static();
    BaflUtils::NearestLanguageFile( env->FsSession(), fileName );
    iResourceOffset = env->AddResourceFileL( fileName );    

    ReadAppListL();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtServer::~CAiScutExtServer()
    {
    if( iIdle )
        {
        iIdle->Cancel();
        delete iIdle;
        }

    CEikonEnv::Static()->DeleteResourceFile( iResourceOffset );

    iShowUids.Close();
    iUids.Close();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CSession2* CAiScutExtServer::NewSessionL(
    const TVersion& aVersion, const RMessage2& /*aMessage*/ ) const
    {
    TVersion version(
        KAiScutExtServMajorVersionNumber,
        KAiScutExtServMinorVersionNumber,
        KAiScutExtServBuildVersionNumber );

    if ( !User::QueryVersionSupported( version, aVersion ) )
        {
        User::Leave( KErrNotSupported );
        }
    CAiScutExtSession* session = new( ELeave ) CAiScutExtSession( iObserver );
    return session;
}

// ---------------------------------------------------------------------------
// Read a list of application UIDs which we must not show the tip.
// ---------------------------------------------------------------------------
//
void CAiScutExtServer::ReadAppListL()
    {
    CRepository* repository = CRepository::NewL( KCRUidShortcutItems );
    CleanupStack::PushL( repository );

    RBuf buffer;
    buffer.CreateL( KAppsListDataGranularity );
    buffer.CleanupClosePushL();

    TInt err = repository->Get( KAIxSPNoTipAppsList, buffer );
    while( err == KErrOverflow )
        {
        buffer.ReAllocL( buffer.MaxLength() + KAppsListDataGranularity );
        err = repository->Get( KAIxSPNoTipAppsList, buffer );
        }

    // Handle error silently if reading from Central Repository fails.
    if( err == KErrNone )
        {
        // Parse application UIDs and put them to list.
        TLex lex(buffer);

        while( !lex.Eos() )
            {
            TPtrC token( lex.NextToken() );
            if( token.Length() < KTokenPrefix )
                {
                break;
                }
            TLex lexUid( token.Right( token.Length() - KTokenPrefix ) );

            TUint32 uid;
            if( lexUid.Val( uid, EHex ) == KErrNone )
                {
                iUids.AppendL( TUid::Uid( uid ) );
                }
            }
        }

    CleanupStack::PopAndDestroy();      // buffer
    CleanupStack::PopAndDestroy( repository );
    }

// ---------------------------------------------------------------------------
// Saves the list of applications UIDs.
// ---------------------------------------------------------------------------
//
void CAiScutExtServer::WriteAppListL()
    {
    CRepository* repository = CRepository::NewL( KCRUidShortcutItems );
    CleanupStack::PushL( repository );

    RBuf buffer;
    buffer.CreateL( iUids.Count() * KUidStorageLength );
    buffer.Zero();
    buffer.CleanupClosePushL();

    TBuf uidString;

    for(TInt c = 0; c < iUids.Count(); c++)
        {
        uidString.Format( KUidFormat, iUids[c] );
        buffer.Append( uidString );   // Ignore error
        }

    User::LeaveIfError( repository->Set( KAIxSPNoTipAppsList, buffer ) );

    CleanupStack::PopAndDestroy();    // buffer
    CleanupStack::PopAndDestroy( repository );
    }

// ---------------------------------------------------------------------------
// Tests if the client has connected us before, i.e. determines if
// the tip message should be shown.
// ---------------------------------------------------------------------------
//
TBool CAiScutExtServer::HasConnectedBefore( TUid& aUid, const RMessage2& aMessage )
    {
    // First test if the current theme supports the xSP feature
    TInt isXspSupported = EPSAiXspNotSupported;
    TInt err = RProperty::Get( KPSUidAiInformation, KActiveIdleThemeSupportsXsp,
        isXspSupported );

    if( err != KErrNone || isXspSupported == EPSAiXspNotSupported)
    {
        // xSP is not supported so don't show the dialog. Also if we could not
        // read the P&S key we won't show the dialog.
        return ETrue;
    }

    RThread threadClient;

    if( aMessage.Client( threadClient ) != KErrNone )
        {
        // In case of error we report that the client has connected us
        // before in order not to show the dialog.
        return ETrue;
        }

    RProcess processClient;

    if( threadClient.Process(processClient) != KErrNone )
        {
        // Prevent dialog from showing in case of error.
        return ETrue;
        }

    // See if client application is in ROM
    TFileName fileName = processClient.FileName();
    TPtr processDrive( fileName.LeftTPtr( KRomDrive().Length() ) );
    processDrive.LowerCase();

    if( processDrive == KRomDrive() )
        {
        // Don't show tip message for ROM clients.
        return ETrue;
        }

    TUidType uidType = processClient.Type();

    // UID3 of the client process
    TUid uid3( uidType[ KUidIndex ] );
    aUid = uid3;

    // See if the uid is already in the list
    if( iUids.Find( uid3 ) != KErrNotFound )
        {
        return ETrue;
        }

    return EFalse;
    }

void CAiScutExtServer::ShowTipMessage( TUid aUid )
    {
    if( iShowUids.Find( aUid ) == KErrNotFound )
        {
        iShowUids.Append( aUid );
        iIdle->Cancel();
        iIdle->Start( TCallBack( CAiScutExtServer::IdleCallBack, this ) );
        }
    }

TInt CAiScutExtServer::IdleCallBack(TAny* aParam)
    {
    CAiScutExtServer* p = (CAiScutExtServer*) aParam;

    p->iIdle->Cancel();

    if( p->iIsForeground )
        {
        TRAP_IGNORE( p->DoShowTipMessageL() );
        }

    return KErrNone;
    }

// ---------------------------------------------------------------------------
// Shows a dialog
// ---------------------------------------------------------------------------
//
void CAiScutExtServer::DoShowTipMessageL()
    {
    // Find out the name of the application
    RApaLsSession als;
    User::LeaveIfError( als.Connect() );
    CleanupClosePushL( als );

    while( iShowUids.Count() > 0 && !iIsTipMessageVisible)
        {
        TUid uid = iShowUids[ 0 ];
        TApaAppInfo appInfo;
        User::LeaveIfError( als.GetAppInfo( appInfo, uid ) );

        // Prepare the parameters for the link function
        HBufC* definitionBuf = HBufC::NewLC( KMaxDefinitionLength );
        TPtr definition( definitionBuf->Des() );
        definition.Format( KScutFormatApplication, uid );

        TBool isInShortcuts = iObserver.HandleIsInShortcutsL( definition );

        CLinkParams* params = new( ELeave) CLinkParams( *this, definitionBuf );
        CleanupStack::Pop( definitionBuf );
        CleanupStack::PushL( params );

        TCallBack cb(CAiScutExtServer::LinkCallBack, params);

        // Read and format tip message from the resource file
        HBufC* messageBuf = StringLoader::LoadLC( R_AI_SC_QUERY_MODIFY_GS, appInfo.iCaption );
        TPtr message( messageBuf->Des() );

        // Don't show the tip if the application is already in shortcuts
        if( !isInShortcuts )
            {
            iIsTipMessageVisible = ETrue;
            CAknMessageQueryDialog* note = CAknMessageQueryDialog::NewL( message );
            params->iNote = note;

            note->SetLink( cb );
            note->ExecuteLD( R_SCUT_XSPTIP_NOTE );
            iIsTipMessageVisible = EFalse;
            }

        // Update the list so we don't show the tip message
        // again for this application.
        iUids.Append( uid );   // Ignore error
        iShowUids.Remove( 0 );

        // Save the list of uids to persistant memory.
        WriteAppListL();

        CleanupStack::PopAndDestroy( messageBuf );
        CleanupStack::PopAndDestroy( params );
        }

    CleanupStack::PopAndDestroy();  // als
    }

// ---------------------------------------------------------------------------
// Opens the shurtcuts settings view
// ---------------------------------------------------------------------------
//
TInt CAiScutExtServer::LinkCallBack(TAny* aParam)
    {
    CLinkParams* params = (CLinkParams*) aParam;

    TRAP_IGNORE(
        params->iServer.iObserver.HandleIssuePutInShortcutsL(
            params->iTargetDefinition->Des() );
    );

    return KErrNone;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtServer::ResumeL( TAiTransitionReason aReason )
    {
    switch( aReason )
        {
        case EAiIdleForeground:
            iIsForeground = ETrue;
            DoShowTipMessageL();
            break;

        case EAiIdleBackground:
            iIsForeground = EFalse;
            break;

        default:
            break;
        }
    }

// End of File.
hs_app_caiscutextsession.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in xSP extension session class.
*
*/


#include 
#include 
#include 
#include 

#include 

#include "hs_app_caiscutextsession.h"
#include "hs_app_maiscutextmessagehandler.h"

#include  "hs_app_caiscutextserver.h"


// ======== MEMBER FUNCTIONS ========


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtSession::CAiScutExtSession( MAiScutExtMessageHandler& aObserver )
    : iObserver( aObserver )
    {
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutExtSession::~CAiScutExtSession()
    {
    CAiScutExtServer* server = const_cast(
        dynamic_cast( Server() ) );

    if( iTargetDefinition && server )
        {
        TRAP_IGNORE(
            iObserver.HandleResetPopupLineArrayL( *iTargetDefinition );
            iObserver.HandleResetIconL( *iTargetDefinition );
            );
        }

    delete iTargetDefinition;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtSession::ServiceL( const RMessage2& aMessage )
    {
    CAiScutExtServer* server = const_cast(
        dynamic_cast( Server() ) );

    __ASSERT_ALWAYS( server, User::Leave( KErrCorrupt ) );

    TUid uid;
    if( !server->HasConnectedBefore(uid, aMessage) )
        {
        server->ShowTipMessage( uid );
        }

    TRAPD( err, DispatchMessageL( aMessage ) );

    if( !aMessage.IsNull() )
        {
        aMessage.Complete( err );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtSession::DispatchMessageL( const RMessage2& aMessage )
    {
    switch ( aMessage.Function() )
        {
        case EAiScutExtServSetTargetDefinition:
            {
            SetTargetDefinitionL( aMessage );
            break;
            }
        case EAiScutExtServSetPopupText:
            {
            SetPopupTextL( aMessage );
            break;
            }
        case EAiScutExtServResetPopupText:
            {
            ResetPopupTextL( aMessage );
            break;
            }
        case EAiScutExtServSetIcon:
            {
            SetIconL( aMessage );
            break;
            }
        case EAiScutExtServResetIcon:
            {
            ResetIconL( aMessage );
            break;
            }
        case EAiScutExtServIsInShortcuts:
            {
            IsInShortcutsL( aMessage );
            break;
            }
        case EAiScutExtServIssuePutInShortcuts:
            {
            IssuePutInShortcutsL( aMessage );
            break;
            }
        default:
            {
            User::Leave( KErrNotSupported );
            }
        }
    }


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtSession::SetTargetDefinitionL( const RMessage2& aMessage )
    {
    HBufC* targetStringBuf = HBufC::NewLC( aMessage.GetDesLengthL( 0 ) );
    TPtr targetString( targetStringBuf->Des() );
    aMessage.ReadL( 0, targetString, 0 );
    delete iTargetDefinition;
    iTargetDefinition = targetStringBuf;
    CleanupStack::Pop( targetStringBuf );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtSession::SetPopupTextL( const RMessage2& aMessage )
    {
    if( !iTargetDefinition )
        {
        return;
        }
    HBufC8* marshalledLineArrayBuf = HBufC8::NewLC(
        aMessage.GetDesLengthL( 0 ) );
    TPtr8 marshalledLineArray( marshalledLineArrayBuf->Des() );
    aMessage.ReadL( 0, marshalledLineArray, 0 );

    RDesReadStream stream( marshalledLineArray );
    CleanupClosePushL( stream );

    const TInt lineCount = stream.ReadUint8L();
    __ASSERT_ALWAYS( lineCount >= 0 && lineCount <= KMaxPopupTextLines,
        User::Leave( KErrArgument ) );

    CDesCArray* array = new( ELeave ) CDesCArrayFlat(
        lineCount > 0 ? lineCount : 1 );
    CleanupStack::PushL( array );

    for( TInt i = 0; i < lineCount; i++ )
        {
        HBufC* lineBuf = HBufC::NewLC( stream, KMaxTInt );
        array->AppendL( *lineBuf );
        CleanupStack::PopAndDestroy( lineBuf );
        }

    iObserver.HandleSetPopupLineArrayL( *iTargetDefinition, array );  //Takes ownership of array

    CleanupStack::Pop( array );
    CleanupStack::PopAndDestroy( &stream );
    CleanupStack::PopAndDestroy( marshalledLineArrayBuf );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtSession::ResetPopupTextL( const RMessage2& /*aMessage*/ )
    {
    if( iTargetDefinition )
        {
        iObserver.HandleResetPopupLineArrayL( *iTargetDefinition );
        }
    }


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtSession::SetIconL( const RMessage2& aMessage )
    {
    if( !iTargetDefinition )
        {
        return;
        }
    HBufC8* marshallBuf = HBufC8::NewLC( aMessage.GetDesLengthL( 0 ) );
    TPtr8 marshalledData( marshallBuf->Des() );
    aMessage.ReadL( 0, marshalledData, 0 );

    RDesReadStream stream( marshalledData );
    CleanupClosePushL( stream );

    CFbsBitmap* bitmap = new( ELeave ) CFbsBitmap;
    CleanupStack::PushL( bitmap );
    bitmap->InternalizeL( stream );

    CFbsBitmap* mask = new( ELeave ) CFbsBitmap;
    CleanupStack::PushL( mask );
    mask->InternalizeL( stream );

    CGulIcon* icon = CGulIcon::NewL( bitmap, mask );
    CleanupStack::Pop( 2, bitmap );
    CleanupStack::PushL( icon );

    iObserver.HandleSetIconL( *iTargetDefinition, icon );

    CleanupStack::Pop( icon );

    CleanupStack::PopAndDestroy( &stream );
    CleanupStack::PopAndDestroy( marshallBuf );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtSession::ResetIconL( const RMessage2& /*aMessage*/ )
    {
    if( iTargetDefinition )
        {
        iObserver.HandleResetIconL( *iTargetDefinition );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtSession::IsInShortcutsL( const RMessage2& aMessage )
    {
    if( iTargetDefinition )
        {
        TBool isInShortcuts = iObserver.HandleIsInShortcutsL( *iTargetDefinition );

        TPtr8 isInShortcutsDes(
            reinterpret_cast< TUint8* >( &isInShortcuts ),
            sizeof( isInShortcuts ),
            sizeof( isInShortcuts ) );
        aMessage.WriteL( 0, isInShortcutsDes, 0 );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtSession::IssuePutInShortcutsL( const RMessage2& /*aMessage*/ )
    {
    if( iTargetDefinition )
        {
        iObserver.HandleIssuePutInShortcutsL( *iTargetDefinition );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutExtSession::PanicClient(
    const RMessage2& aMessage, TInt aPanicCode ) const
    {
    aMessage.Panic( KAiScutExtServerName, aPanicCode );
    }

// End of File.
hs_app_caiscutplugin.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#include 
#include 

#include 
#include 

#include 
#include "hs_app_aiscutpluginprivatecrkeys.h"
#include "aiscutdefs.h"
#include "aiscutcontentmodel.h"
#include "hs_app_caiscutplugin.h"
#include "hs_app_caiscutengine.h"
#include "hs_app_aiscutfactory.h"
#include "hs_app_caiscutshortcut.h"

#include "debug.h"

const TImplementationProxy KImplementationTable[] =
{
    IMPLEMENTATION_PROXY_ENTRY(KImplUidScutPlugin, CAiScutPlugin::NewL)
};

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutPlugin::CAiScutPlugin()
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::ConstructL()
{
    // Initialize the info which the fw uses to identify the plug-in.
    // Fill in only the uid at this point, the fw will send this back with the
    // name filled in later through SetPropertyL().
    iInfo.iUid.iUid = AI_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_SCUTPLUGIN;

    iContent = AiUtility::CreateContentItemArrayIteratorL(KAiScutContent);
    iResources = AiUtility::CreateContentItemArrayIteratorL(KAiScutResources);
    iEvents = AiUtility::CreateContentItemArrayIteratorL(KAiScutEvents);

    CRepository* repository = NULL;
    TRAP_IGNORE(repository = CRepository::NewL(KCRUidShortcutItems));
    // No leaving code here since 'repository' is not in cleanup stack.
    if (repository)
    {
        // A theme might not contain any publishable shortcuts at all, only
        // locked ones. To take this into account we must always delete old
        // theme-default settings to make sure the engine won't create any
        // unwanted shortcut objects. Any errors that might happen during
        // deletion are ignored to make sure the plug-in is kept alive.
        TUint32 errorKey;

        repository->Delete(KScutCenRepKeyThemeDefault, KScutCenRepKeyMask, errorKey);
    }
    delete repository;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutPlugin* CAiScutPlugin::NewL()
{
    CAiScutPlugin* self = new (ELeave) CAiScutPlugin;
    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);
    return self;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutPlugin::~CAiScutPlugin()
{
    TRAP_IGNORE( DeleteDefaultShortcutsL() );
    Release(iContent);
    Release(iResources);
    Release(iEvents);
    delete iEngine;
    iObservers.Close();
}

// ---------------------------------------------------------------------------
// Publishes the given shortcut.
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::PublishShortcutsL(RAiShortcutArray& aShortcuts)
{
    TInt err = KErrNone;
    TInt observers = iObservers.Count();
    TInt shortcuts = aShortcuts.Count();
    
    for (TInt i = 0; i < observers; ++i)
    {
        MAiContentObserver* observer = iObservers[i];
        TBool transactionStarted = EFalse;
        TInt transactionId = reinterpret_cast(this);
        err = observer->StartTransaction(transactionId);

        if (err != KErrNotSupported)
        {
            // The observer does not support transactions, check for real errors.
            User::LeaveIfError(err);
            transactionStarted = ETrue;
        }
        err = KErrAlreadyExists;
        for (TInt j = 0; j < shortcuts; j++)
        {
            CAiScutShortcut* shortcut = aShortcuts[j];

            if (shortcut->NeedsToBePublished())
            {
                shortcut->Publish(*this, *observer);
                err = KErrNone;
            }
        }

        if ( transactionStarted && err == KErrNone )
            {
            User::LeaveIfError(observer->Commit(transactionId));
            }
        else if ( transactionStarted )
            {
            User::LeaveIfError(observer->CancelTransaction(transactionId));
            }
    }
}

// ---------------------------------------------------------------------------
// Is plug-in suspended or not.
// ---------------------------------------------------------------------------
//
TBool CAiScutPlugin::IsAlive() const
{
    return iAlive;
}

// ---------------------------------------------------------------------------
// Resume reason
// ---------------------------------------------------------------------------
//
TAiTransitionReason CAiScutPlugin::ResumeReason() const
    {
    return iResumeReason;
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher.
// Resumes the plug-in.
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::Resume(TAiTransitionReason aReason)
{
    TRAP_IGNORE(DoResumeL(aReason));    
}

// ---------------------------------------------------------------------------
// Resumes the plug-in.
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::DoResumeL(TAiTransitionReason aReason)
{
	__PRINT( __DBG_FORMAT( "XAI: CAiScutPlugin::Resume reason %d alive = %d"), aReason, iAlive);
    iResumeReason = aReason;
	// Reload the engine in case general theme changed or
	// the engine has been suspended. 
    if (aReason == EAiGeneralThemeChanged || !iAlive)
    {
        // if general theme changed, free engine so that is will be
        // loaded again because shortcut icons must be re-created.
        FreeEngine();
    }

    if (!iEngine)
    {
		iEngine = AiScutFactory::CreateAiScutEngineL(*this);
    }

    iEngine->ResumeL( (iAlive == EFalse) ||
        (
        aReason != EAiBacklightOn    &&
        aReason != EAiBacklightOff   &&
        aReason != EAiIdleBackground &&
        aReason != EAiIdleForeground
        ),
        aReason
    );
    
    iAlive = ETrue;
}

// ---------------------------------------------------------------------------
// From class CAiContentPublisher.
// Suspends the plug-in.
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::Suspend(TAiTransitionReason aReason)
{
	__PRINT( __DBG_FORMAT( "XAI: CAiScutPlugin::Suspend reason %d"), aReason);

    if (iEngine)
    {
        iEngine->Suspend();
    }

    iAlive = EFalse;
}

// ---------------------------------------------------------------------------
// From class CAiContentPublisher.
// Frees the plug-in engine.
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::Stop(TAiTransitionReason aReason)
{
	__PRINT( __DBG_FORMAT( "XAI: CAiScutPlugin::Stop reason %d"), aReason);

	if ( aReason == EAiBackupRestoreStarted )
	    {
	    Suspend( aReason );
	    }
	else
	    {
	    FreeEngine();
	    }
}
// ---------------------------------------------------------------------------
// From class CAiContentPublisher.
// Adds the content observer / subscriber to plug-in.
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::SubscribeL(MAiContentObserver& aObserver)
{
    iObservers.AppendL(&aObserver);
}

void CAiScutPlugin::DeleteDefaultShortcutsL()
    {
    // Ignore any errors that might occur when deleting
    // the default keys
    TUint32 errorKey;
    CRepository* cr = CRepository::NewL(KCRUidShortcutItems);
    cr->Delete(KScutCenRepKeyThemeDefault, KScutCenRepKeyMask, errorKey);
    delete cr;
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher.
// Configures the plug-in.
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::ConfigureL(RAiSettingsItemArray& aSettings)
{
    CRepository* repository = NULL;

    TRAPD(err, repository = CRepository::NewL(KCRUidShortcutItems));

    if (err == KErrNotFound)
    {
        // CenRep file is missing from the image, this is a serious error.
        User::Leave(err);
    }

    // Write settings if repository was successfully opened. All other errors
    // are ignored to ensure that the plug-in is up and running, even if
    // crippled.

    // No leaving code here since 'repository' is not in cleanup stack.
    if (repository)
    {
        repository->StartTransaction(CRepository::EConcurrentReadWriteTransaction);

        // A theme might not contain any publishable shortcuts at all, only
        // locked ones. To take this into account we must always delete old
        // theme-default settings to make sure the engine won't create any
        // unwanted shortcut objects. Any errors that might happen during
        // deletion are ignored to make sure the plug-in is kept alive.
        TUint32 errorKey;

        repository->Delete(KScutCenRepKeyThemeDefault, KScutCenRepKeyMask, errorKey);
        
		__PRINTS( "XAI: CAiScutPlugin::ConfigureL");

        TInt count = aSettings.Count();
        if (count > 0)
        {
            // Write new shortcut definitions.
            for (TInt i = 0; i < count; ++i)
            {
                MAiPluginSettings* settings = aSettings[ i ];
                
                if( settings->AiPluginItemType() == EAiPluginSettingsItem )
                    {
                    MAiPluginSettingsItem& item = settings->AiPluginSettingsItem();
                    TUint32 key = item.Key(); // implicit cast from TInt32 to TUint32.
    
    				__PRINT( __DBG_FORMAT( "XAI:   %d. key = 0x%x"), i+1, key);
    
                    // Add the bit that indicates this is a default shortcut setting.
                    key |= KScutFlagBitThemeDefault;
    
                    // Ignore possible error and keep going.
                    repository->Create(key, item.Value());
                    }
            }
        }

        TUint32 info = 0;
        repository->CommitTransaction(info);

        delete repository;
        repository = NULL;
        
        if (iEngine)
        {
            iEngine->CreateShortcutsL();
            iEngine->ResumeL( ETrue, EAiGeneralThemeChanged );
        }
    }

    // We don't need to store the settings so clear the array.
    aSettings.ResetAndDestroy();
}

// ---------------------------------------------------------------------------
// From class CAiContentPublisher.
// Returns the extension interface.
// ---------------------------------------------------------------------------
//
TAny* CAiScutPlugin::Extension(TUid aUid)
{
    if (aUid == KExtensionUidProperty)
    {
        return static_cast(this);
    }
    else if (aUid == KExtensionUidEventHandler)
    {
        return static_cast(this);
    }
    else
    {
        return NULL;
    }
}

// ---------------------------------------------------------------------------
// From class MAiEventHandlerExtension.
// Handles an event sent by the AI framework.
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::HandleEvent(TInt aEvent, const TDesC& aParam)
{
    if (iEngine)
    {
        // We have no way of reporting errors to framework so just ignore them.
        TRAP_IGNORE(iEngine->HandleAiEventL(aEvent, aParam));
    }
}

// ---------------------------------------------------------------------------
// CAiScutPlugin::HasMenuItem
//
// ---------------------------------------------------------------------------
//
TBool CAiScutPlugin::HasMenuItem(const TDesC16& /*aMenuItem*/)
    {
    return EFalse;
    }

// ---------------------------------------------------------------------------
// From class MAiPropertyExtension
// Returns a plug-in property.
// ---------------------------------------------------------------------------
//
TAny* CAiScutPlugin::GetPropertyL(TInt aProperty)
{
    switch (aProperty)
    {
    case EAiPublisherInfo:
        return static_cast(&iInfo);

    case EAiPublisherContent:
        return static_cast(iContent);

    case EAiPublisherResources:
        return static_cast(iResources);

    case EAiPublisherEvents:
        return static_cast(iEvents);

    default:
        break;
    }

    return NULL;
}

// ---------------------------------------------------------------------------
// From class MAiPropertyExtension
// Sets a plug-in property to optimize the content model.
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::SetPropertyL(TInt aProperty, TAny* aValue)
    {
    if( aProperty == EAiPublisherInfo )
        {
        ASSERT( aValue );
        
        const TAiPublisherInfo* info( 
                static_cast( aValue ) );
        
        iInfo = *info;               
        }    
    }

// ---------------------------------------------------------------------------
//
//
// ---------------------------------------------------------------------------
//
void CAiScutPlugin::FreeEngine()
{
    delete iEngine;
    iEngine = NULL;
    iAlive = EFalse;    
}

// ======== GLOBAL FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
EXPORT_C const TImplementationProxy* ImplementationGroupProxy(TInt& aTableCount)
{
    aTableCount = sizeof(KImplementationTable) / sizeof(TImplementationProxy);
    return KImplementationTable;
}

// End of File.
hs_app_caiscutsettings.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut settings plug-in main class.
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include                 // For RProperty
#include     // For KPSUidActiveIdle2

#include 
#include 
#include 

#include "hs_app_aiscutsettings.hrh"
#include "hs_app_caiscutsettings.h"
#include "hs_app_caiscutsettingsitem.h"
#include "hs_app_caiscutsettingscontainer.h"
#include "hs_app_caiscutsettingsmodel.h"
#include 
#include "aiscutdefs.h"
#include 

const TUid KUidScutSettingsPlugin =
{
    AI_UID_ECOM_IMPLEMENTATION_SETTINGS_SCUTPLUGIN
};

_LIT(KScutSettingsResourceFileName, "hs_app_aiscutsettingsres.rsc");
_LIT(KScutTextsResourceFileName,    "hs_app_aiscuttexts.rsc");
_LIT8(KScutDirectOpenTag,    "?open");


// ======== LOCAL FUNCTIONS ========


static void ParseKeysL( const TDesC8& aCustomMessage, RArray& aKeys, TBool& aOpen )
    {
    HBufC8* message = aCustomMessage.AllocLC();
    
    TPtr8 ptr( message->Des() );
            
    TInt pos;
    TInt openPos;
    TBool openTag=EFalse;
    
    do
        {                
        pos = ptr.Locate( ',' );
        
        if( pos != KErrNotFound )
            {
            const TDesC8& str1 = ptr.Left( pos );
            const TDesC8& str2 = str1.Right( str1.Length() - 2 );
            
            TUint32 value;
            TLex8 lex( str2 );
                        
            if( lex.Val( value, EHex ) == KErrNone )
                {
                aKeys.AppendL( value );
                }
                                    
            ptr = ptr.MidTPtr( pos + 1 );
            }
        else
            {
            const TDesC8& str1 = ptr;
            const TDesC8& str2 = str1.Right( str1.Length() - 2 );
            openPos = ptr.Find( KScutDirectOpenTag );
            TLex8 lex;
            if( openPos != KErrNotFound )
                {
                openTag=ETrue;
                const TDesC8& str3 = str2.Left( openPos -2 );
                lex.Assign( str3 );
                }
            else
                {
                lex.Assign( str2 );
                }
            TUint32 value;
            
            
            if( lex.Val( value, EHex ) == KErrNone )
                {
                aKeys.AppendL( value );
                }                        
            }                                           
        }
    while( pos != KErrNotFound );        
            
    if( openTag && aKeys.Count() == 1 )
        {
        aOpen = ETrue;
        }
    CleanupStack::PopAndDestroy();
    }
// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettings::CAiScutSettings() : iResourceLoaderTexts(*iCoeEnv)
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettings::ConstructL()
{
    FeatureManager::InitializeLibL();

    TParsePtrC driveParse(PathInfo::RomRootPath());
    TFileName resourceName(driveParse.Drive());

    // Find the resource file.
    TParse parse;
    parse.Set(KScutSettingsResourceFileName, &KDC_RESOURCE_FILES_DIR, NULL);
    resourceName.Append(parse.FullName());

    // Open resource file.
    iResourceLoader.OpenL(resourceName);

    resourceName.Copy(driveParse.Drive());
    parse.Set(KScutTextsResourceFileName, &KDC_RESOURCE_FILES_DIR, NULL);
    resourceName.Append(parse.FullName());

    // Open resource file.
    iResourceLoaderTexts.OpenL(resourceName);

    iModel = CAiScutSettingsModel::NewL(*this, iCoeEnv);
    
    iListBoxTimer = CIdle::NewL(CActive::EPriorityHigh);


    BaseConstructL(R_SCUT_SETTINGS_VIEW);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettings* CAiScutSettings::NewL(TAny* /*aInitParams*/)
{
    CAiScutSettings* self = new (ELeave) CAiScutSettings;
    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);
    return self;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettings::~CAiScutSettings()
{
    FeatureManager::UnInitializeLib();
    
    if( iListBoxTimer )
        {
        iListBoxTimer->Cancel();
        delete iListBoxTimer;
        }    

    iResourceLoader.Close();
    iResourceLoaderTexts.Close();

    delete iModel;
}

// ---------------------------------------------------------------------------
// From CAknView
// Returns view id.
// ---------------------------------------------------------------------------
//
TUid CAiScutSettings::Id() const
{
    return KUidScutSettingsPlugin;
}

// ---------------------------------------------------------------------------
// From CAknView
// Handles commands.
// ---------------------------------------------------------------------------
//
void CAiScutSettings::HandleCommandL(TInt aCommand)
{
    switch (aCommand)
    {
    case EAiScutSettingsCmdChange:
        Container()->HandleChangeCommandL();
        break;

    case EAknCmdHelp:
	/*
        TUid fwUid = TUid::Uid( AI_UID3_AIFW_COMMON );
        TCoeContextName helpString;
        helpString.Copy( KSET_HLP_HOME_SCREEN_SHORTCUTS );
        
        CArrayFixFlat* array = 
            new (ELeave) CArrayFixFlat(1);
        CleanupStack::PushL( array );
        array->AppendL( TCoeHelpContext( fwUid, helpString ) );
        HlpLauncher::LaunchHelpApplicationL( CCoeEnv::Static()->WsSession(), array );
        CleanupStack::Pop( array );
	*/
        break;

    case EAknSoftkeyBack:
        if (iAppUi->View(KGSMainViewUid))
        {
            // if we are in GS activate parent plugin view (standby view)...
            iAppUi->ActivateLocalViewL(KGSPrslnPluginUid);
        }
        else
        {
            iAppUi->ActivateLocalViewL(iPrevViewId.iViewUid);
        }
        break;

    case EAknSoftkeyExit:
        iAppUi->HandleCommandL(EAknCmdExit);
        break;

    default:
        iAppUi->HandleCommandL(aCommand);
        break;
    }
}

// ----------------------------------------------------------------------------
// From CAknView
// First method called by the Avkon framwork
// ----------------------------------------------------------------------------
//
void CAiScutSettings::DoActivateL(const TVwsViewId& aPrevViewId, TUid aCustomMessageId, const TDesC8& aCustomMessage)
{
#ifdef MY_DEBUG
    RDebug::Print(_L("XAI: CAiScutSettings::DoActivateL"));
    RDebug::Print(_L("XAI:   aCustomMessageId = 0x%08x"), aCustomMessageId.iUid);
    RDebug::Print(_L("XAI:   aPrevViewId      = 0x%08x"), aPrevViewId.iAppUid.iUid);
#endif

    CEikButtonGroupContainer* cba = Cba();

    if (cba)
    {
        if (aCustomMessageId == KScutActiveIdleUid)
        {
            cba->SetCommandSetL(R_SCUT_SOFTKEYS_OPTIONS_EXIT_CHANGE);
        }
        else
        {
            cba->SetCommandSetL(R_SCUT_SOFTKEYS_OPTIONS_BACK_CHANGE);
        }
        cba->DrawDeferred();
    }

    CGSBaseView::DoActivateL(aPrevViewId, aCustomMessageId, aCustomMessage);

    TBool open=EFalse;
    if( aCustomMessage != KNullDesC8 )
        {
        RArray keys;
        CleanupClosePushL( keys );

        ParseKeysL( aCustomMessage, keys, open );
        
        iModel->SetSettingsKeys( keys );
        
        CleanupStack::PopAndDestroy();
        }
    
    iModel->UpdateSettingsContainerL();

    if( open )
        {
        /* Let idle timer do this job. */
        iListBoxTimer->Cancel();
        iListBoxTimer->Start(TCallBack(DoHandleListBoxSelectionL, this));
        }
}

// ----------------------------------------------------------------------------
// From CAknView
// Called by the Avkon view framework when closing.
// ----------------------------------------------------------------------------
//
void CAiScutSettings::DoDeactivate()
{
    iModel->ActivateObservers(EFalse);

    // deletes iContainer.
    CGSBaseView::DoDeactivate();

    iModel->SetContainer(Container());
}

void CAiScutSettings::HandleForegroundEventL(TBool /*aForeground*/)
    {
    // No implementation required
    }

// ----------------------------------------------------------------------------
// From MEikMenuObserver
// ----------------------------------------------------------------------------
//
void CAiScutSettings::DynInitMenuPaneL(
    TInt aResourceId, CEikMenuPane* aMenuPane)
{
    if (aMenuPane && aResourceId == R_SCUTSETTINGS_MENUPANE)
    {
        if (!FeatureManager::FeatureSupported(KFeatureIdHelp))
        {
            // Disable help if not supported
            aMenuPane->SetItemDimmed(EAknCmdHelp, ETrue);
        }
        if (iModel->MdcaCount() == 0)
        {
            aMenuPane->SetItemDimmed(EAiScutSettingsCmdChange, ETrue);
        }
    }
}

// ---------------------------------------------------------------------------
// From CGSPluginInterface. 256
// ---------------------------------------------------------------------------
//
void CAiScutSettings::GetCaptionL(TDes& aCaption) const
{
    iCoeEnv->ReadResourceL(aCaption, R_SCUT_SETTINGS_VIEW_CAPTION);
}

// ---------------------------------------------------------------------------
// From CGSPluginInterface
// ---------------------------------------------------------------------------
//
TInt CAiScutSettings::PluginProviderCategory() const
{
    return KGSPluginProviderInternal;
}

// ---------------------------------------------------------------------------
// From CGSPluginInterface
// ---------------------------------------------------------------------------
//
TBool CAiScutSettings::Visible() const
{
    return EFalse;
}

// ---------------------------------------------------------------------------
// From CGSBaseView
// Returns view id.
// ---------------------------------------------------------------------------
//
CAiScutSettingsContainer* CAiScutSettings::Container()
{
    return static_cast(iContainer);
}

// ---------------------------------------------------------------------------
// From CGSBaseView
// ---------------------------------------------------------------------------
//
void CAiScutSettings::NewContainerL()
{
    delete iContainer;
    iContainer = NULL;
    
    iContainer = new (ELeave) CAiScutSettingsContainer();
    Container()->SetModel(iModel);
    iModel->SetContainer(Container());
}

// ---------------------------------------------------------------------------
// From CGSBaseView
// ---------------------------------------------------------------------------
//
void CAiScutSettings::HandleListBoxSelectionL()
{
    Container()->HandleChangeCommandL();
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
//
TBool CAiScutSettings::Activated() const
    {
    return iContainer ? ETrue : EFalse;
    }

// -----------------------------------------------------------------------------
// CActiveIdleState::DoUpdateSaSetting
// -----------------------------------------------------------------------------
//
TInt CAiScutSettings::DoHandleListBoxSelectionL(TAny* aAny)
    {
    CAiScutSettings* self = static_cast(aAny);
    if(self)
        {
        self->iListBoxTimer->Cancel();
        self->HandleListBoxSelectionL();
        }
    return KErrNone;
    }


// End of File.
hs_app_caiscutsettingsapplist.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Application list for settings listbox
*
*/


#include         // For KMsvRootIndexEntryIdValue
#include 
#include 

#include 
#include 

#include 
#include 
#include 
#include 
#include 
#include 

#include "hs_app_caiscutsettingsapplist.h"
#include "hs_app_taiscutparser.h"
#include "hs_app_caiscutsettingsitem.h"
#include "aiscutdefs.h"
#include 

#include "debug.h"

using namespace Java;


const TInt KDriveAndColon = 2; //drive char and colon string length, e.g. "c:"

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsAppList::CAiScutSettingsAppList(CCoeEnv* aEnv, MAiScutListObserver& aObserver)
    : CActive(CActive::EPriorityLow)    // Background task priority.
                                        // Higher priority would block the wait dialog.
    , iEnv(aEnv)
    , iObserver(aObserver)
    {
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::ConstructL()
    {
    User::LeaveIfError(iApaSession.Connect());
    iMsvSession = CMsvSession::OpenAsObserverL(*this);

    CActiveScheduler::Add(this);
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsAppList* CAiScutSettingsAppList::NewL(CCoeEnv* aEnv,
    MAiScutListObserver& aObserver)
    {
    CAiScutSettingsAppList* self = new (ELeave) CAiScutSettingsAppList(aEnv, aObserver);
    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);
    return self;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsAppList::~CAiScutSettingsAppList()
    {
    if (IsActive())
        {
        Cancel();
        }

    delete iAppNotifier;
    delete iMsvSession;
    iApaSession.Close();
    iListItems.ResetAndDestroy();
    iMailboxes.Close(); // Do not call ResetAndDestroy() to this.
    }

// ---------------------------------------------------------------------------
// From MDesCArray
// Returns the number of descriptor elements in a descriptor array.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsAppList::MdcaCount() const
    {
    return iListItems.Count();
    }

// ---------------------------------------------------------------------------
// From MDesCArray
// Indexes into a descriptor array.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutSettingsAppList::MdcaPoint(TInt aIndex) const
    {
    if (aIndex < 0 || aIndex >= iListItems.Count())
        {
        TPtrC ret(KNullDesC);
        return ret;
        }
    return iListItems[aIndex]->Caption();
    }

// ---------------------------------------------------------------------------
// From class MMsvSessionObserver.
// Handles an event from the message server.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::HandleSessionEventL(
    TMsvSessionEvent aEvent, TAny* /*aArg1*/, TAny* /*aArg2*/, TAny* /*aArg3*/)
    {
    TBool updated = ETrue;
    TBool added   = EFalse;

    switch (aEvent)
        {
    case EMsvEntriesCreated:
    case EMsvEntriesDeleted:
    case EMsvEntriesChanged:
        if (iObserving)
            {
            CMsvEntry* rootEntry = GetRootEntryL();
            
            CleanupStack::PushL(rootEntry);
            TBuf<255> mailboxId;
            
            // Reset iMailboxes
            for (TInt j = iMailboxes.Count() - 1; j >= 0; --j)
            {            
              RemoveMailboxL(iMailboxes[j]->Params());
            }

      // Add all mailboxes
      for (TInt i = rootEntry->Count() - 1; i >= 0; --i)
                {
                    const TMsvEntry& tentry = (*rootEntry)[i];

              if (tentry.iMtm == KSenduiMtmImap4Uid || tentry.iMtm == KSenduiMtmPop3Uid)
                {   
                  mailboxId.Num(tentry.Id());       
                        AddMailboxL(tentry.iDetails, mailboxId);
                    }                      
              }      
              
            CleanupStack::PopAndDestroy(rootEntry);
            }

        if (updated)
            {
            iObserver.HandleScutListEventL(MAiScutListObserver::EAppListUpdated, added);
            }
        break;

    default:
        break;
        }
    }

// ---------------------------------------------------------------------------
// From class MApaAppListServObserver.
// Handles a change in the application list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::HandleAppListEvent(TInt /*aEvent*/)
    {
    TRAP_IGNORE(UpdateAppListL());
    }

// ---------------------------------------------------------------------------
// Starts the asynchronous application list initialization.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::StartL()
    {
    iListItems.ResetAndDestroy();

    AddStaticItemsL();
    AddMailboxesL();
    AddExtraItemsFromCRL();

    if (iApaSession.GetAllApps() == KErrNone &&
        iApaSession.AppCount(iTotalAppCount) == KErrNone)
        {
        CompleteSelf();
        }
    }

// ---------------------------------------------------------------------------
// Checks if the application list is ready to be shown.
// ---------------------------------------------------------------------------
//
TBool CAiScutSettingsAppList::IsReady() const
    {
    return iReady;
    }

// ---------------------------------------------------------------------------
// Tells the application list to start or stop observing for changes.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::SetObservingL(TBool aObserving)
    {
    delete iAppNotifier;
    iAppNotifier = NULL;

    if (aObserving)
        {
        UpdateAppListL();

        iAppNotifier = CApaAppListNotifier::NewL(this, CActive::EPriorityStandard);
        }

    iObserving = aObserving;
    }

// ---------------------------------------------------------------------------
// Finds the index of the given settings item in the application list.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsAppList::FindIndex(CAiScutSettingsItem& aItem)
    {
    TInt index = KErrNotFound;

    TAiScutParser parser;
    parser.Parse(aItem.Value());
    TPtrC params(parser.Get(EScutDefParamNameAndValue));

    TUid uid = aItem.Uid();
    for (TInt i = iListItems.Count() - 1; i >= 0; --i)
        {
        CAppListItem* item = iListItems[i];
        if ( (item->Uid() == uid) && params.Compare(item->Params()) == 0)
        {
            index = i;
            break;
        }
        // Url => compare the whole url not just the parameters
        else if( item->Type() == EAiScutSettingTypeUrl )
            {
            if ( parser.Get(EScutDefComplete).Compare(item->Params()) == 0 )
                {
                index = i;
                break;
                }
            }
        }

    return index;
    }

// ---------------------------------------------------------------------------
// Returns target application data from the given index.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsAppList::GetDataByIndex(TInt aIndex, TUid& aUid,
    TPtrC& aParams, TPtrC& aCaption, TAiScutSettingType& aType ) const
    {
    if (aIndex >= 0 && aIndex < iListItems.Count())
        {
        CAppListItem* item = iListItems[aIndex];
        aUid = item->Uid();
        aType = item->Type();
        aParams.Set(item->Params());
        aCaption.Set(item->Caption());
        return KErrNone;
        }

    return KErrNotFound;
    }

// ---------------------------------------------------------------------------
// From CActive
// Implements cancellation of an outstanding request.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::DoCancel()
    {
    }

// ---------------------------------------------------------------------------
// From CActive
// Performs one step of the app list initialization.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::RunL()
    {
    TApaAppInfo appInfo;
    TInt err = GetNextValidApp(appInfo);

    switch (err)
        {
    case KErrNone:
        AddApplicationL(appInfo);
        CompleteSelf();
        break;

    case RApaLsSession::ENoMoreAppsInList:
        iReady = ETrue;
        iObserver.HandleScutListEventL(MAiScutListObserver::EAppListReady, EFalse);
        break;

    //Indicates that an RApaLsSession member function was called before the session's 
    //  application list is fully populated. 
    case RApaLsSession::EAppListInvalid:
        StartL(); // Just try again.
        break;

    default:
        User::LeaveIfError(err);
        break;
        }
    }

// ---------------------------------------------------------------------------
// From CActive
// Handles an error situation.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsAppList::RunError(TInt aError)
    {
    return aError;
    }

// ---------------------------------------------------------------------------
// Completes own request status to make sure active scheduler calls RunL again.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::CompleteSelf()
    {
    if (!IsActive())
        {
        TRequestStatus* status = &iStatus;
        User::RequestComplete(status, KErrNone);
        SetActive();
        }
    }

// ---------------------------------------------------------------------------
// Adds an application to the list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::AddApplicationL(TApaAppInfo& aAppInfo)
    {
    TBool allowed = ETrue;

    // EasyVoIP is only added when VoIP is supported
    if (aAppInfo.iUid == KScutEasyVoIPApplicationUid)
        {
        // Check VoIP variation status
        TInt voipStatus = 0;
        // For checking VoIP variation status
        CRepository* repository = CRepository::NewL(KCRUidTelephonySettings);
        repository->Get(KDynamicVoIP, voipStatus);
        delete repository;
        allowed = (voipStatus && FeatureManager::FeatureSupported(KFeatureIdCommonVoip));

        __PRINTS( "XAI: CAiScutSettingsAppList::AddApplicationL");
        __PRINT( __DBG_FORMAT( "XAI:   voipStatus = %d, allowed = %d"), voipStatus, allowed);
        }

    // VoIP launcher is always invisible in shortcuts.
    if (aAppInfo.iUid == KScutVoIPLauncherUid)
        {
        allowed = EFalse;
        }

    if (iObserver.IsHidden(aAppInfo.iUid))
        {
        allowed = EFalse;
        }

    if (allowed)
        {
        CAppListItem* listItem = CAppListItem::NewLC(aAppInfo.iUid, aAppInfo.iCaption);
        listItem->SetType( EAiScutSettingTypeApplication );
        TLinearOrder sortMethod(CAppListItem::CompareCaption);
        User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
        CleanupStack::Pop(listItem);
        }
    }

// ---------------------------------------------------------------------------
// Adds the static list items to the application list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::AddStaticItemsL()
    {
    HBufC* caption = NULL;
    CAppListItem* listItem = NULL;
    TLinearOrder sortMethod(CAppListItem::CompareCaption);

    // Connectivity Status item
    caption = StringLoader::LoadLC(R_SCUT_SETTINGS_CONNECTIVITY_STATUS, iEnv);
    listItem = CAppListItem::NewLC(KScutGeneralSettingsUid, *caption);
    listItem->SetParamsL(KScutParamConnectivityView);
    listItem->SetType( EAiScutSettingTypeApplication );
    User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
    CleanupStack::Pop(listItem);
    CleanupStack::PopAndDestroy(caption);
    caption = NULL;
    listItem = NULL;

    // New Message item.
    caption = StringLoader::LoadLC(R_SCUT_SETTINGS_NEW_MSG, iEnv);
    listItem = CAppListItem::NewLC(KScutMessagingUid, *caption);
    listItem->SetParamsL(KScutParamNewMsg);
    listItem->SetType( EAiScutSettingTypeApplication );
    User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
    CleanupStack::Pop(listItem);
    CleanupStack::PopAndDestroy(caption);
    caption = NULL;
    listItem = NULL;

    // New Email item.
    caption = StringLoader::LoadLC(R_SCUT_SETTINGS_NEW_EMAIL, iEnv);
    listItem = CAppListItem::NewLC(KScutMessagingUid, *caption);
    listItem->SetParamsL(KScutParamNewEmail);
    listItem->SetType( EAiScutSettingTypeApplication );
    User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
    CleanupStack::Pop(listItem);
    CleanupStack::PopAndDestroy(caption);
    caption = NULL;
    listItem = NULL;

#ifdef __SYNCML_DS_EMAIL
    // New SyncML mail item.
    caption = StringLoader::LoadLC(R_SCUT_SETTINGS_NEW_SYNCML_MAIL, iEnv);
    listItem = CAppListItem::NewLC(KScutMessagingUid, *caption);
    listItem->SetParamsL(KScutParamNewSyncMLMail);
    listItem->SetType( EAiScutSettingTypeApplication );
    User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
    CleanupStack::Pop(listItem);
    CleanupStack::PopAndDestroy(caption);
    caption = NULL;
    listItem = NULL;
#endif

    if (FeatureManager::FeatureSupported(KFeatureIdMmsPostcard)
        && IsInRom( KScutPostcardEditorUid ) )
        {
        // New Postcard item.
        caption = StringLoader::LoadLC(R_SCUT_SETTINGS_NEW_POSTCARD, iEnv);
        listItem = CAppListItem::NewLC(KScutMessagingUid, *caption);
        listItem->SetParamsL(KScutParamNewPostcard);
        listItem->SetType( EAiScutSettingTypeApplication );
        User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
        CleanupStack::Pop(listItem);
        CleanupStack::PopAndDestroy(caption);
        caption = NULL;
        listItem = NULL;
        }

    if (FeatureManager::FeatureSupported(KFeatureIdAudioMessaging))
        {
        // New Audio Message item.
        caption = StringLoader::LoadLC(R_SCUT_SETTINGS_NEW_AUDIO_MSG, iEnv);
        listItem = CAppListItem::NewLC(KScutMessagingUid, *caption);
        listItem->SetParamsL(KScutParamNewAudioMsg);
        listItem->SetType( EAiScutSettingTypeApplication );
        User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
        CleanupStack::Pop(listItem);
        CleanupStack::PopAndDestroy(caption);
        caption = NULL;
        listItem = NULL;
        }

    // Select Message type item.
    caption = StringLoader::LoadLC(R_SCUT_SETTINGS_SELECT_MSG_TYPE, iEnv);
    listItem = CAppListItem::NewLC(KScutMessagingUid, *caption);
    listItem->SetParamsL(KScutParamSelectMsgType);
    listItem->SetType( EAiScutSettingTypeApplication );
    User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
    CleanupStack::Pop(listItem);
    CleanupStack::PopAndDestroy(caption);
    caption = NULL;
    listItem = NULL;
    // Installation view.
    caption = StringLoader::LoadLC(R_SCUT_SETTINGS_APPMNGR, iEnv); 
    listItem = CAppListItem::NewLC(KScutGeneralSettingsUid, *caption);
    listItem->SetParamsL(KScutParamInstallationsView);
    listItem->SetType( EAiScutSettingTypeApplication );
    User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
    CleanupStack::Pop(listItem);
    CleanupStack::PopAndDestroy(caption);
    caption = NULL;
    listItem = NULL;
    }

// ---------------------------------------------------------------------------
// Adds extra list items to the application list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::AddExtraItemsL()
    {
    // No Effect item.
    HBufC* caption = StringLoader::LoadLC(R_SCUT_SETTINGS_NO_EFFECT, iEnv);
    CAppListItem* listItem = CAppListItem::NewLC(KScutSettingsDllUid, *caption);
    listItem->SetParamsL(KScutParamNoEffect);
    listItem->SetType( EAiScutSettingTypeApplication );
    User::LeaveIfError(iListItems.Insert(listItem, 0)); // insert as first item.
    CleanupStack::Pop(listItem);
    CleanupStack::PopAndDestroy(caption);
    }

void CAiScutSettingsAppList::AddExtraItemsFromCRL()
    {
    CRepository *cr = CRepository::NewL( TUid::Uid( KCRUidActiveIdleLV ) );        
    User::LeaveIfNull( cr );
    
    CleanupStack::PushL( cr );
    
    TUint32 crKey = KAIExtraShortcutsKeyRangeStart;
    TBool moreSettings = ETrue;
    TInt err = KErrNone;
    TAiScutParser parser;
    
    HBufC* settingValue = HBufC::NewLC(NCentralRepositoryConstants::KMaxUnicodeStringLength);
    TPtr settingValuePtr = settingValue->Des();
    
    while( moreSettings )
        {
        err = cr->Get( crKey++, settingValuePtr ); 
        if ( err == KErrNone && settingValue->Length() > 0 )
            {
            CAppListItem* listItem = NULL;
            parser.Parse( *settingValue );
            
            // First try to find the custom title
            HBufC* caption = HBufC::NewLC( settingValue->Length() );
            TPtr captionPtr = caption->Des();
            TInt err = parser.CustomTitle( captionPtr );    
            TUid appUid = parser.Uid();
                
            if ( err != KErrNone || caption->Length() <= 0 )
                {
                CleanupStack::PopAndDestroy( caption );
                caption = NULL;
                }
            
            if ( !caption )
                {
                // Web address...
                 if ( parser.Type() == EScutWebAddress || parser.Type() == EScutUnknown )
                     {
                     TUriParser parser;
                     TInt err = parser.Parse(*settingValue);

                     if (err == KErrNone)
                         {
                         // Remove scheme from the url.
                         caption = parser.Extract(EUriHost).AllocLC();
                         }
                     else
                         {
                         caption = settingValue->AllocLC();
                         }
                     }
                 //  ...application. Nothing else supported at the moment
                 else
                     {
                     TApaAppInfo appInfo;
                     err = iApaSession.GetAppInfo(appInfo, appUid);
                     if (err == KErrNone)
                         {
                         caption = appInfo.iCaption.AllocLC();
                         }
                     }
                }
            if ( caption )
                {
                listItem = CAppListItem::NewLC( KNullUid , *caption  );
                listItem->SetParamsL( *settingValue );
                listItem->SetType( EAiScutSettingTypeUrl );
                TLinearOrder sortMethod(CAppListItem::CompareCaption);
                User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
                CleanupStack::Pop( listItem );
                CleanupStack::PopAndDestroy( caption );
                }
            }
        else
            {
            moreSettings = EFalse;
            }
        }
    

    
    CleanupStack::PopAndDestroy( settingValue );
    CleanupStack::PopAndDestroy( cr );
    }
// ---------------------------------------------------------------------------
// Removes extra list items from the application list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::RemoveExtraItemsL()
    {
    // No Effect item.
    CAppListItem* listItem = iListItems[0];
    iListItems.Remove(0);
    if (listItem)
        {
        delete listItem;
        listItem = NULL;      
        }
    }

// ---------------------------------------------------------------------------
// Returns the root entry containing mailboxes.
// ---------------------------------------------------------------------------
//
CMsvEntry* CAiScutSettingsAppList::GetRootEntryL()
    {
    return iMsvSession->GetEntryL(KMsvRootIndexEntryIdValue);
    }

// ---------------------------------------------------------------------------
// Adds remote mailboxes to the application list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::AddMailboxesL()
    {
    CMsvEntry* rootEntry = GetRootEntryL();

    CleanupStack::PushL(rootEntry);
    TBuf<255> mailboxId;

    for (TInt i = rootEntry->Count() - 1; i >= 0; --i)
        {
        const TMsvEntry& tentry = (*rootEntry)[i];

        if (tentry.iMtm == KSenduiMtmImap4Uid || tentry.iMtm == KSenduiMtmPop3Uid)
            {
            mailboxId.Num(tentry.Id());
            AddMailboxL(tentry.iDetails, mailboxId);
            }
        }

    CleanupStack::PopAndDestroy(rootEntry);
    }

// ---------------------------------------------------------------------------
// Adds a mailbox to the list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::AddMailboxL(const TDesC& aMailbox, const TDesC& aMailboxId)
{
    CAppListItem* listItem = CAppListItem::NewLC(KScutMessagingUid, aMailbox);

  // Insert params containing mailbox id
    HBufC* params = HBufC::NewLC(KScutParamMailbox().Length() + aMailboxId.Length());
    params->Des().Copy(KScutParamMailbox);
    params->Des().Append(aMailboxId);
    listItem->SetParamsL(*params);
    listItem->SetType( EAiScutSettingTypeApplication );
    CleanupStack::PopAndDestroy(params);

    TLinearOrder sortMethod(CAppListItem::CompareCaption);
    User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
    CleanupStack::Pop(listItem);
    User::LeaveIfError(iMailboxes.Append(listItem));
    listItem = NULL;
}

// ---------------------------------------------------------------------------
// Removes a mailbox from the list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::RemoveMailboxL(const TDesC& aMailboxParam)
    {
    for (TInt i = iListItems.Count() - 1; i >= 0; --i)
        {
        CAppListItem* listItem = iListItems[i];
        if (aMailboxParam.Compare(listItem->Params()) == 0)
            {
            // Also remove the mailbox from the mailbox array
            for (TInt j = iMailboxes.Count() - 1; j >= 0; --j)
                {
                if (aMailboxParam.Compare(iMailboxes[j]->Params()) == 0)
                    {
                    iMailboxes.Remove(j);
                    }
                }

            iListItems.Remove(i);
            delete listItem;
            listItem = NULL;

            break;
            }
        }
    }

// ---------------------------------------------------------------------------
// Gets the next valid application from application architecture server.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsAppList::GetNextValidApp(TApaAppInfo& aAppInfo)
    {
    TInt err = KErrNone;
    TBool validAppFound = EFalse;

    while (!validAppFound)
        {
        TApaAppInfo appInfo;
        err = iApaSession.GetNextApp(appInfo);
        if (err == KErrNone)
            {
            TApaAppCapabilityBuf capBuf;
            TApaAppCapability cap;

            if ((iApaSession.GetAppCapability(capBuf, appInfo.iUid) == KErrNone))
                {
                cap = capBuf();

                TInt screenNumber(0);
                err = iApaSession.GetDefaultScreenNumber( screenNumber, appInfo.iUid );

                if ((err == KErrNone) && (cap.iAppIsHidden == EFalse) && (screenNumber == 0)) 
                    {
                    aAppInfo = appInfo;
                    validAppFound = ETrue;
                    }
                }
            }
        else
            {
            return err;
            }
        }

    return err;
    }

// ---------------------------------------------------------------------------
// Updates the application list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::UpdateAppListL()
    {
    TBool updated = EFalse;
    TBool added   = EFalse;

    TInt totalAppCount = 0;

    if (iApaSession.AppCount(totalAppCount) == KErrNone)
        {
        if (totalAppCount < iTotalAppCount)
            {
            RemoveUninstalledAppFromListL(iTotalAppCount - totalAppCount);
            updated = ETrue;
            added = EFalse;
            }
        else if (totalAppCount > iTotalAppCount)
            {
            AddInstalledAppToListL(totalAppCount - iTotalAppCount);
            updated = ETrue;
            added = ETrue;
            }

        iTotalAppCount = totalAppCount;
        }

    if (updated)
        {
        iObserver.HandleScutListEventL(MAiScutListObserver::EAppListUpdated, added);
        }
    }

// ---------------------------------------------------------------------------
// Figures out which application is missing from the list and adds it.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::AddInstalledAppToListL(TInt aCount)
    {
    TInt added = 0;
    TApaAppInfo appInfo;
    TInt err = GetNextValidApp(appInfo);

    while (err == KErrNone)
        {
        TBool found = EFalse;

        for (TInt i = iListItems.Count() - 1; i >= 0; --i)
            {
            if (iListItems[i]->Uid() == appInfo.iUid)
                {
                found = ETrue;
                break;
                }
            }

        if (!found)
            {
            AddApplicationL(appInfo);
            if (++added == aCount)
                {
                // Found all of them, no need to go further
                return ;
                }
            }

        err = GetNextValidApp(appInfo);
        }

    // create registry 
    CJavaRegistry* registry = CJavaRegistry::NewLC();

    // get all uids stored in registry
    RArray uids;
    registry->GetRegistryEntryUidsL( uids );

    CleanupClosePushL(uids);

    for (TInt javaIndex = 0; javaIndex < uids.Count(); ++javaIndex)
        {
        TInt found = EFalse;
        for (TInt listIndex = 0; listIndex < iListItems.Count(); ++listIndex )
            {
            if (iListItems[listIndex]->Uid() == uids[javaIndex])
                {
                found = ETrue;
                }
            }
        if (!found)
            {
            // get registry entry by uid (i.e. the first entry)
            CJavaRegistryEntry* entry =
                registry->RegistryEntryL( uids[javaIndex] );
            if( entry )
                {
                CleanupStack::PushL(entry);

                // get entry properties (i.e. name)
                const TDesC& name = entry->Name();
                TUid uid = entry->Uid();

                    CAppListItem* listItem = CAppListItem::NewLC(uid, name);
                  listItem->SetType( EAiScutSettingTypeApplication );
                TLinearOrder sortMethod(CAppListItem::CompareCaption);
                if (entry->Type() >= EGeneralApplication)
                    {
                    User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
                    ++added;
                    }
                else
                    {
                    delete listItem;
                    }
                CleanupStack::Pop(listItem);

                CleanupStack::PopAndDestroy(entry);
                }
            if (added == aCount)
                {
                break;
                }
            }
        }
    CleanupStack::PopAndDestroy(); // uids
    CleanupStack::PopAndDestroy(registry);
    }

// ---------------------------------------------------------------------------
// Figures out which application should not be in the list and removes it.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::RemoveUninstalledAppFromListL(TInt aCount)
    {
    TInt removed = 0;

    for (TInt i = iListItems.Count() - 1; i >= 0; --i)
        {
        CAppListItem* listItem = iListItems[i];
        TApaAppInfo ignored;
        if (iApaSession.GetAppInfo(ignored, listItem->Uid()) == KErrNotFound)
            {
            iListItems.Remove(i);
            delete listItem;
            listItem = NULL;

            if (++removed == aCount)
                {
                return ;
                }
            }
        }
    // create registry 
    CJavaRegistry* registry = CJavaRegistry::NewLC();
    // get all uids stored in registry
    RArray uids;
    registry->GetRegistryEntryUidsL( uids );

    CleanupClosePushL(uids);

    for (TInt listIndex = iListItems.Count(); listIndex >= 0 ; --listIndex )
        {
        TInt found = EFalse;
        for (TInt javaIndex = 0; javaIndex < uids.Count(); ++javaIndex)
            {
            if (iListItems[listIndex]->Uid() == uids[javaIndex])
                {
                found = ETrue;
                }
            }
        if (!found)
            {
            // Item removed, remove from item list
            CAppListItem* listItem = iListItems[listIndex];
            iListItems.Remove(listIndex);
            delete listItem;
            if (++removed == aCount)
                {
                break;
                }
            }
        }
    CleanupStack::PopAndDestroy(); // uids
    CleanupStack::PopAndDestroy(registry);
    }

TBool CAiScutSettingsAppList::IsNonNative(const TUid& aUid)
    {
    TBool ret = EFalse;

    const TUid KMidletAppType = { 0x10210E26 };
    TUid typeuid = KNullUid;

    if (KErrNone == iApaSession.GetAppType(typeuid, aUid))
        {
        if (typeuid == KMidletAppType)
            {
            ret = ETrue;
            }
        }

    return ret;
    }


TBool CAiScutSettingsAppList::IsInRom( const TUid& aUid )
    {
    TBool inROM = EFalse;

    TApaAppInfo appInfo;    
    if( iApaSession.GetAppInfo( appInfo, aUid ) == KErrNone )
        {
        // Does the full path start with z: 
        if( appInfo.iFullName.FindC( 
                PathInfo::RomRootPath().Left( KDriveAndColon ) ) >= 0 )            
            {          
            inROM = ETrue;                     
            }
        }
    return inROM;
    }


// ---------------------------------------------------------------------------
// Nested class to store individual application list items
// ---------------------------------------------------------------------------
//
CAiScutSettingsAppList::CAppListItem::CAppListItem(TUid aUid) : iUid(aUid)
    {
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::CAppListItem::ConstructL(const TDesC& aCaption)
    {
    iCaption = aCaption.AllocL();
    // Defaults to application
    iType = EAiScutSettingTypeApplication;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsAppList::CAppListItem* CAiScutSettingsAppList::CAppListItem::NewLC(
    TUid aUid, const TDesC& aCaption)
    {
    CAppListItem* self = new (ELeave) CAppListItem(aUid);
    CleanupStack::PushL(self);
    self->ConstructL(aCaption);
    return self;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsAppList::CAppListItem::~CAppListItem()
    {
    delete iCaption;
    delete iParams;
    }

// ---------------------------------------------------------------------------
// Compare method used to add the items to the list in sorted order.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsAppList::CAppListItem::CompareCaption(const CAppListItem& aFirst,
    const CAppListItem& aSecond)
    {
    return aFirst.iCaption->Des().CompareC(*aSecond.iCaption);
    }

// ---------------------------------------------------------------------------
// Returns the item target application uid.
// ---------------------------------------------------------------------------
//
TUid CAiScutSettingsAppList::CAppListItem::Uid() const
    {
    return iUid;
    }

// ---------------------------------------------------------------------------
// Returns the item target application caption.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutSettingsAppList::CAppListItem::Caption() const
    {
    return TPtrC(*iCaption);
    }

// ---------------------------------------------------------------------------
// Returns the possible parameters for item target.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutSettingsAppList::CAppListItem::Params() const
    {
    TPtrC params;
    if (iParams)
        {
        params.Set(*iParams);
        }
    return params;
    }

// ---------------------------------------------------------------------------
// Sets the parameters for the item target.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsAppList::CAppListItem::SetParamsL(const TDesC& aParams)
    {
    HBufC* newParams = aParams.AllocL();
    delete iParams;
    iParams = newParams;
    }

TAiScutSettingType CAiScutSettingsAppList::CAppListItem::Type() const
{
    return iType;
}

void CAiScutSettingsAppList::CAppListItem::SetType( TAiScutSettingType aType )
{
    iType = aType;
}
// End of File.
hs_app_caiscutsettingsbkmlist.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Bookmark list for settings listbox
*
*/


#include 
#include  // For CActiveFavouritesDbNotifier

#include 
#include 

#include "hs_app_caiscutsettingsmodel.h"
#include "hs_app_caiscutsettingsapplist.h"
#include "hs_app_caiscutsettingsbkmlist.h"
#include "hs_app_taiscutparser.h"
#include "hs_app_caiscutsettingsitem.h"
#include "aiscutdefs.h"

#include "debug.h"


_LIT( KText, "bkm=0x%x" );
const TInt KTBUF16 = 16;

// ======== MEMBER FUNCTIONS ========

CAiScutSettingsBkmList::CAiScutSettingsBkmList(
    CCoeEnv*                aEnv,
    CAiScutSettingsModel*   aModel,
    MAiScutListObserver&    aObserver
    )
    : iEnv(aEnv)
    , iModel(aModel)
    , iObserver(aObserver)
{
}

void CAiScutSettingsBkmList::ConstructL()
{
}

CAiScutSettingsBkmList* CAiScutSettingsBkmList::NewL(
    CCoeEnv* aEnv,
    CAiScutSettingsModel* aModel,
    MAiScutListObserver& aObserver)
{
    CAiScutSettingsBkmList* self = new (ELeave) CAiScutSettingsBkmList(
        aEnv, aModel, aObserver);
    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);
    return self;
}

CAiScutSettingsBkmList::~CAiScutSettingsBkmList()
{
    iListItems.ResetAndDestroy();
    delete iBookmarkDbObserver;
}

// ---------------------------------------------------------------------------
// From MDesCArray
// Returns the number of descriptor elements in a descriptor array.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsBkmList::MdcaCount() const
{
    return iListItems.Count();
}

// ---------------------------------------------------------------------------
// From MDesCArray
// Indexes into a descriptor array.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutSettingsBkmList::MdcaPoint(TInt aIndex) const
{
    if (aIndex < 0 || aIndex >= iListItems.Count())
    {
        TPtrC ret(KNullDesC);
        return ret;
    }
    return iListItems[aIndex]->Caption();
}

// ---------------------------------------------------------------------------
// Gets bookmark list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsBkmList::GetBookmarkListL()
{
    iListItems.ResetAndDestroy();

    iModel->ReadBookmarksL();

    TInt count = iModel->BookmarkCount();

    for (TInt i = count - 1; i >= 0; i--) // newest on top
    {
        CFavouritesItem* item = iModel->GetBookmark(i);

        TUid  uid  = TUid::Uid(item->Uid());
        TPtrC name = item->Name();

        AddBookmarkL(uid, name);
    }
}

// ---------------------------------------------------------------------------
// Tells the bookmark list to start or stop observing for changes.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsBkmList::SetObservingL(TBool aObserving)
{
    delete iBookmarkDbObserver;
    iBookmarkDbObserver = NULL;

    if (aObserving)
    {

        iBookmarkDbObserver = new (ELeave) CActiveFavouritesDbNotifier(
            iModel->FavouritesDb(), *this);
        iBookmarkDbObserver->Start();
    }

    iObserving = aObserving;
}

// ---------------------------------------------------------------------------
// Finds the index of the given settings item in the bookmark list.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsBkmList::FindIndex(CAiScutSettingsItem& aItem)
{
    TInt index = KErrNotFound;

    TAiScutParser parser;
    parser.Parse(aItem.Value());
    TUid uid = parser.ParseUid(parser.Get(EScutDefParamValue));

    for (TInt i = iListItems.Count() - 1; i >= 0; --i)
    {
        if (iListItems[i]->Uid() == uid)
        {
            index = i;
            break;
        }
    }

    return index;
}

// ---------------------------------------------------------------------------
// Returns target bookmark data from the given index.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsBkmList::GetDataByIndex(
    TInt aIndex, TPtrC& aParams, TPtrC& aCaption) const
{
    if (aIndex >= 0 && aIndex < iListItems.Count())
    {
        CBkmListItem* item = iListItems[aIndex];
        aParams.Set(item->Params());
        aCaption.Set(item->Caption());
        return KErrNone;
    }

    return KErrNotFound;
}

// ---------------------------------------------------------------------------
// Adds an bookmark to the list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsBkmList::AddBookmarkL(TUid aUid, const TDesC& aCaption)
{
    CBkmListItem* listItem = CBkmListItem::NewLC(aUid, aCaption);

    TBuf buf;
    buf.Format( KText, aUid.iUid );

    listItem->SetParamsL(buf);
    TLinearOrder sortMethod(CBkmListItem::CompareCaption);
    User::LeaveIfError(iListItems.InsertInOrderAllowRepeats(listItem, sortMethod));
    CleanupStack::Pop(listItem);
}

// ---------------------------------------------------------------------------
// Updates the bookmark list.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsBkmList::UpdateBkmListL()
{
    GetBookmarkListL();
    iObserver.HandleScutListEventL(MAiScutListObserver::EBkmListUpdated, EFalse);
}

// -----------------------------------------------------------------------------
// From class MFavouritesDbObserver.
// Handles database event.
// -----------------------------------------------------------------------------
//
void CAiScutSettingsBkmList::HandleFavouritesDbEventL(RDbNotifier::TEvent aEvent)
{
	__PRINT( __DBG_FORMAT( "XAI: CAiScutSettingsBkmList::HandleFavouritesDbEventL aEvent = %d"), aEvent);
	
    if (aEvent == RDbNotifier::ECommit)
    {
        UpdateBkmListL();
    }
}

// ---------------------------------------------------------------------------
//Nested class to store individual bookmark list items
// ---------------------------------------------------------------------------
//
CAiScutSettingsBkmList::CBkmListItem::CBkmListItem(TUid aUid) : iUid(aUid)
{
}

void CAiScutSettingsBkmList::CBkmListItem::ConstructL(const TDesC& aCaption)
{
    iCaption = aCaption.AllocL();
}

CAiScutSettingsBkmList::CBkmListItem* CAiScutSettingsBkmList::CBkmListItem::NewLC(
    TUid aUid, const TDesC& aCaption)
{
    CBkmListItem* self = new (ELeave) CBkmListItem(aUid);
    CleanupStack::PushL(self);
    self->ConstructL(aCaption);
    return self;
}

CAiScutSettingsBkmList::CBkmListItem::~CBkmListItem()
{
    delete iCaption;
    delete iParams;
}

// ---------------------------------------------------------------------------
// Compare method used to add the items to the list in sorted order.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsBkmList::CBkmListItem::CompareCaption(const CBkmListItem& aFirst,
    const CBkmListItem& aSecond)
{
    return aFirst.iCaption->Des().CompareC(*aSecond.iCaption);
}

// ---------------------------------------------------------------------------
// Returns the item target bookmark uid.
// ---------------------------------------------------------------------------
//
TUid CAiScutSettingsBkmList::CBkmListItem::Uid() const
{
    return iUid;
}

// ---------------------------------------------------------------------------
// Returns the item target bookmark caption.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutSettingsBkmList::CBkmListItem::Caption() const
{
    return TPtrC(*iCaption);
}

// ---------------------------------------------------------------------------
// Returns the possible parameters for item target.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutSettingsBkmList::CBkmListItem::Params() const
{
    TPtrC params;
    if (iParams)
    {
        params.Set(*iParams);
    }
    return params;
}

// ---------------------------------------------------------------------------
// Sets the parameters for the item target.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsBkmList::CBkmListItem::SetParamsL(const TDesC& aParams)
{
    HBufC* newParams = aParams.AllocL();
    delete iParams;
    iParams = newParams;
}

// End of File.
hs_app_caiscutsettingscontainer.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut settings plug-in container.
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
//#include 
#include 
#include 
#include 
#include 

#include 
#include 

#include "hs_app_caiscutsettingscontainer.h"
#include "hs_app_caiscutsettingsmodel.h"
#include "hs_app_caiscutsettingsbkmlist.h"
#include "hs_app_caiscutsettingsitem.h"
#include "hs_app_aiscutpluginprivatecrkeys.h"
#include "aiscutdefs.h"

const TUid KUidAI = { 0x101F8701 }; // Active Standby Shortcuts help uid

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsContainer::CAiScutSettingsContainer()
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsContainer::ConstructL(const TRect& aRect)
{
    iListBox = new (ELeave) CAknSettingStyleListBox;
    BaseConstructL(aRect, R_SCUT_SETTINGS_VIEW_TITLE, NULL);

    iOldType = EAiScutSettingTypeUndefined;

    CheckMiddleSoftkeyLabelL();

    iModel->ActivateObservers(ETrue);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsContainer::~CAiScutSettingsContainer()
{
    HideWaitNoteDialog();
}

// ---------------------------------------------------------------------------
// Sets pointer to settings plug-in model.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsContainer::SetModel(CAiScutSettingsModel* aModel)
{
    iModel = aModel;
}

// ---------------------------------------------------------------------------
// Chandles a setting change command.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsContainer::HandleChangeCommandL()
{       
    if ( iChangeProcessInProgress )
        {
        return;
        }
    TBool changed = EFalse;
    TInt current = iListBox->CurrentItemIndex();
    CAiScutSettingsItem* item = iModel->Item(current);
    if (!item)
    {
        return ;
    }

    TUint32 key = item->Key();
    TBool locked = (0 != (key & KScutFlagBitLocked));

    if (locked)
    {
        HBufC* text = iCoeEnv->AllocReadResourceLC(R_SCUT_SETTINGS_TXT_FIXED_ITEM);
        CAknInformationNote* note = new (ELeave) CAknInformationNote(ETrue);
        note->ExecuteLD(*text);
        CleanupStack::PopAndDestroy(text);
    }
    else
    {
        TAiScutSettingType oldType = item->Type();
        TInt newType = oldType;

        CDesCArrayFlat* array = iCoeEnv->ReadDesC16ArrayResourceL(
            R_SCUT_CHANGE_TO_PAGE_LBX);
        CleanupStack::PushL(array);

        CAknListQueryDialog* dialog = new(ELeave)CAknListQueryDialog(&newType);
        CleanupStack::PushL(dialog);
    	dialog->PrepareLC(R_SCUT_LISTQUERY_CHANGE_TO_PAGE);
    	CleanupStack::Pop(dialog);
        dialog->SetItemTextArray(array);
	    dialog->SetOwnershipType(ELbmDoesNotOwnItemArray);
	    iChangeProcessInProgress = ETrue;
        if (dialog->RunLD())
        {
            item = iModel->Item(current);
            if (newType == EAiScutSettingTypeUrl)
            {
                changed = HandleUrlChangeCommandL(*item, (newType != oldType));
            }
            else if (newType == EAiScutSettingTypeBookmark)
            {
                changed = HandleBookmarkChangeCommandL(*item, (newType != oldType));
            }
            else
            {
                changed = HandleAppListChangeCommandL(*item, (newType != oldType));
            }
            if ( changed )
                {
                ResetCurrentListL(current);    
                }

        }
        iChangeProcessInProgress = EFalse;
        CleanupStack::PopAndDestroy(array);
    }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutSettingsContainer::IsChangeDialogShowing()
{
    return (iAppListDialog || iBkmListDialog || iEditDialog);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsContainer::CloseChangeDialog()
{
    TKeyEvent keyEvent;

    keyEvent.iCode      = EKeyEscape;
    keyEvent.iScanCode  = EStdKeyEscape;
    keyEvent.iModifiers = 0;
    keyEvent.iRepeats   = 0;

    CCoeControl* dialog = NULL;

    if (iAppListDialog)
    {
        dialog = static_cast(iAppListDialog);
    }
    else if (iBkmListDialog)
    {
        dialog = static_cast(iBkmListDialog);
    }
    else if (iEditDialog)
    {
        dialog = static_cast(iEditDialog);
    }

    if (dialog)
    {
        TRAP_IGNORE(dialog->OfferKeyEventL(keyEvent, EEventKey));
    }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsContainer::ResetCurrentListL(TInt aIndex)
{
    if (iModel->MdcaCount() == 0)
    {
        iListBox->HandleItemRemovalL();
    }
    else
    {
        iListBox->HandleItemAdditionL();
    }

    iListBox->SetCurrentItemIndex(aIndex);

    CheckMiddleSoftkeyLabelL();
}

// ---------------------------------------------------------------------------
// From CGSBaseContainer
// Constructs the settings listbox.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsContainer::ConstructListBoxL(TInt /*aResLbxId*/)
{
    iListBox->ConstructL(this, EAknListBoxSelectionList);

    // Set empty listbox's text.
    HBufC* text = iCoeEnv->AllocReadResourceLC(R_SCUT_SETTINGS_TXT_ALL_FIXED);
    iListBox->View()->SetListEmptyTextL(*text);
    CleanupStack::PopAndDestroy(text);

    iListBox->Model()->SetItemTextArray(iModel);
    iListBox->Model()->SetOwnershipType(ELbmDoesNotOwnItemArray);
}

// ---------------------------------------------------------------------------
// Chandles a setting change command to select application from a list.
// ---------------------------------------------------------------------------
//
TBool CAiScutSettingsContainer::HandleAppListChangeCommandL(CAiScutSettingsItem& aItem,
    TBool /*aNew*/)
{
    
    TBool changed = EFalse;
    
    iChangeProcessStopped = EFalse;
    
    if (!iModel->AppList()->IsReady())
    {
        ShowWaitNoteDialogL(); // Blocks until applist reports that it is ready.
    }
    // If wait note was "killed" then don't continue the change process
    // If the process is not stopped here it could lead to situation where
    // self is deleted before the ShowWaitNoteDialogL() returns
    if ( iChangeProcessStopped )
        {
        return EFalse;
        }

    TUint32 key = aItem.Key();
    TBool optional  = (0 != (key & KScutFlagBitOptionallyVisible));
    TBool scrollkey = (0 != ((key & 0xFFFF) < EAiScutSoftKeyLeft));

    if (optional && scrollkey)
    {
        iModel->AppList()->AddExtraItemsL();
    }

    TInt index = iModel->AppList()->FindIndex(aItem);
    TInt oldIndex = index;

    iAppListDialog = new (ELeave) CAknRadioButtonSettingPage(
        R_SCUT_SETTINGS_APPLIST_PAGE, index, iModel->AppList());

    iAppListDialog->SetSettingTextL(aItem.Title());
    iAppListDialog->ConstructL();

    if (iAppListDialog->ExecuteLD(CAknSettingPage::EUpdateWhenChanged) &&
        index != oldIndex)
    {
        TUid uid;
        TPtrC params;
        TPtrC caption;
        TAiScutSettingType type;
        if (iModel->AppList()->GetDataByIndex(index, uid, params, caption, type) == KErrNone)
        {
            if ( type == EAiScutSettingTypeUrl )
                {
                aItem.ChangeUrlL( params );
                }
            else
                {                
                aItem.ChangeApplicationL(uid, params, caption);
                }
            iModel->SaveItemL(aItem);
            changed = ETrue;
        }
    }

    if (optional && scrollkey)
    {
        iModel->AppList()->RemoveExtraItemsL();
    }

    iAppListDialog = NULL;
    return changed;
}

// ---------------------------------------------------------------------------
// Chandles a setting change command to select bookmark from a list.
// ---------------------------------------------------------------------------
//
TBool CAiScutSettingsContainer::HandleBookmarkChangeCommandL(CAiScutSettingsItem& aItem,
    TBool /*aNew*/)
{

    TBool changed = EFalse;
    iModel->BkmList()->GetBookmarkListL();
    TInt index = iModel->BkmList()->FindIndex(aItem);
    TInt oldIndex = index;

    iBkmListDialog = new (ELeave) CAknRadioButtonSettingPage(
        R_SCUT_SETTINGS_APPLIST_PAGE, index, iModel->BkmList());

    iBkmListDialog->SetSettingTextL(aItem.Title());
    iBkmListDialog->ConstructL();

    if (iBkmListDialog->ExecuteLD(CAknSettingPage::EUpdateWhenChanged) &&
        index != oldIndex)
    {
        TPtrC params;
        TPtrC caption;
        if (iModel->BkmList()->GetDataByIndex(index, params, caption) == KErrNone)
        {
            aItem.ChangeBookmarkL(params, caption);
            iModel->SaveItemL(aItem);
            changed = ETrue;
        }
    }

    iBkmListDialog = NULL;
    return changed;
}

// ---------------------------------------------------------------------------
// Chandles a setting change command to edit an URL.
// ---------------------------------------------------------------------------
//
TBool CAiScutSettingsContainer::HandleUrlChangeCommandL(CAiScutSettingsItem& aItem,
    TBool aNew)
{
    TBool changed = EFalse;
    HBufC* newUrl = HBufC::NewLC(NCentralRepositoryConstants::KMaxUnicodeStringLength);
    TPtr urlPtr = newUrl->Des();

    if (!aNew)
    {
        urlPtr.Copy(aItem.Value());
    }

    if (EditTextL(R_SCUT_TYPE_URL_PAGE , urlPtr))
    {
        aItem.ChangeUrlL(urlPtr);
        iModel->SaveItemL(aItem);
        changed = ETrue;
    }

    CleanupStack::PopAndDestroy(newUrl);
    return changed;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutSettingsContainer::EditTextL(TInt aResId, TDes& aDes)
{
    TBool ret = EFalse;

    iEditDialog = new (ELeave) CAknTextSettingPage(aResId, aDes);

    if (iEditDialog->ExecuteLD(CAknSettingPage::EUpdateWhenChanged))
    {
        if (aDes.Length())
        {
            ret = ETrue;
        }
    }

    iEditDialog = NULL;

    return ret;
}

// ---------------------------------------------------------------------------
// Shows the wait note dialog.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsContainer::ShowWaitNoteDialogL()
{
    if (!iWaitDialog)
    {
        iWaitDialog = new (ELeave) CAknWaitDialog(
            (reinterpret_cast (&iWaitDialog)),
            ETrue                                               // aVisibilityDelayOff
        );
        iWaitDialog->ExecuteLD(R_SCUT_WAIT_NOTE);
    }
}

// ---------------------------------------------------------------------------
// Hides the wait note dialog.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsContainer::HideWaitNoteDialog()
{
    if (iWaitDialog)
    {
        TRAP_IGNORE(iWaitDialog->ProcessFinishedL()); // deletes the dialog.
        iWaitDialog = NULL;
    }
}

void CAiScutSettingsContainer::StopShortcutChangeProcess()
{
    iChangeProcessStopped = ETrue;
    HideWaitNoteDialog();
    if ( IsChangeDialogShowing() )
        {
        CloseChangeDialog();    
        }    
}

// ---------------------------------------------------------------------------
// Gets Help
// ---------------------------------------------------------------------------
//
void CAiScutSettingsContainer::GetHelpContext(TCoeHelpContext& aContext) const
{
    aContext.iMajor   = KUidAI;
    //aContext.iContext = KSET_HLP_PERSONAL_SHORTCUTS; // This is specified in HRH file
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TKeyResponse CAiScutSettingsContainer::OfferKeyEventL(
    const TKeyEvent& aKeyEvent, TEventCode aType)
{
    switch (aKeyEvent.iCode)
    {
    case EKeyUpArrow:
    case EKeyDownArrow:
        {
            TKeyResponse resp = iListBox->OfferKeyEventL(aKeyEvent, aType);
            return resp;
        }

    case EKeyLeftArrow:
    case EKeyRightArrow:
        // Listbox takes all event even if it doesn't use them:
        return EKeyWasNotConsumed;
		
    default:
        break;
    }

    // Now it's iListBox's job to process the key event
    return iListBox->OfferKeyEventL(aKeyEvent, aType);
}

// ---------------------------------------------------------------------------
// Checks if there is a need to update the middle softkey label.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsContainer::CheckMiddleSoftkeyLabelL()
{
    CEikButtonGroupContainer* cba = CEikButtonGroupContainer::Current();
    if (cba)
    {
        cba->MakeCommandVisible(EAiScutSettingsCmdChange, (iModel->MdcaCount() != 0));
    }
}

// End of File.
hs_app_caiscutsettingsimplementationtable.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Implementation table for shortcut settings plug-in
*
*/


#include 
#include 

#include "hs_app_caiscutsettings.h"
#include 

/** Implementation table for shortcut settings plug-in */
const TImplementationProxy KAiScutSettingsImplementationTable[] =
{
    IMPLEMENTATION_PROXY_ENTRY(
        AI_UID_ECOM_IMPLEMENTATION_SETTINGS_SCUTPLUGIN, CAiScutSettings::NewL)
};


// ---------------------------------------------------------------------------
// Gate/factory function.
// ---------------------------------------------------------------------------
//
EXPORT_C const TImplementationProxy* ImplementationGroupProxy(TInt& aTableCount)
{
    aTableCount =
        sizeof(KAiScutSettingsImplementationTable) /
        sizeof(TImplementationProxy);
    return KAiScutSettingsImplementationTable;
}

// End of File.
hs_app_caiscutsettingsitem.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for shortcut setting items
*
*/



#include 
#include 
#include         // For KMsvRootIndexEntryIdValue
#include 
#include                   // For TUriParser16
#include 
#include 
#include "hs_app_caiscutsettingsitem.h"
#include "hs_app_caiscutsettingsmodel.h"
#include "hs_app_aiscutpluginprivatecrkeys.h"
#include "hs_app_taiscutparser.h"
#include "aiscutdefs.h"
#include "hs_app_aiscutsettings.hrh"
#include "hs_app_aidefaultshortcut.h"
#include "debug.h"

const TInt KMaxBufSize = 250;
// ======== MEMBER FUNCTIONS ========
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//

CAiScutSettingsItem::CAiScutSettingsItem(
    CAiScutSettingsModel&   aModel,
    TInt                    aIndex,
    TUint32                 aKey)
    : iModel(aModel)
        , iIndex(aIndex)
        , iKey(aKey)
{
}
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsItem::ReadL(CRepository* aRepository)
{
    if( !aRepository )
       {
          return;
       }

    HBufC* buffer = HBufC::NewLC(NCentralRepositoryConstants::KMaxUnicodeStringLength);
    TPtr bufferPtr = buffer->Des();

    // try user key first.
    TUint32 key = iKey & KScutBitMaskThemeDefault;
    TInt err = aRepository->Get(key, bufferPtr);

    if (err == KErrNone)
    {
        err = ParseValueL(bufferPtr);
    }

    if (err == KErrNone)
    {
        iKey = key;
    }
    else
    {
        // if no user key try default key then.
        key = iKey | KScutFlagBitThemeDefault;
        err = aRepository->Get(key, bufferPtr);
        if (err == KErrNone)
        {
            err = ParseValueL(bufferPtr);
        }

    }

    if (err != KErrNone ||
        (iType == EAiScutSettingTypeApplication && iModel.IsHidden(iUid)))
    {
        HBufC* buf = HBufC::NewLC(NCentralRepositoryConstants::KMaxUnicodeStringLength);        
        TPtr bufPtr = buf->Des();
        HBufC* caption = NULL;

        // Get the default shortcut uid for key 'key' 
        iType = EAiScutSettingTypeApplication;
        TAiDefaultShortcut::GetDefaultShortcut(key, iUid, bufPtr);

        err = iModel.GetAppCaption(iUid, bufPtr);
        if (err == KErrNone)
        {
            caption = bufPtr.AllocLC();
            CreateListBoxLineL(*caption);
            CleanupStack::PopAndDestroy(caption);
        }

        CleanupStack::PopAndDestroy(buf);

    }

    delete iValue;
    iValue = NULL;
    iValue = bufferPtr.AllocL();

    CleanupStack::PopAndDestroy(buffer);

 }

 // ---------------------------------------------------------------------------
 //
 // ---------------------------------------------------------------------------
 //
 TInt CAiScutSettingsItem::Save(CRepository* aRepository)
 {

    if( !aRepository )
    {
        return KErrGeneral;
    }

    iKey = iKey & KScutBitMaskThemeDefault;

    TInt err = aRepository->Set(iKey, Value());

    return err;
 }


 // ---------------------------------------------------------------------------
 // Constructs a new settings item leaving it on the cleanup stack.
 // ---------------------------------------------------------------------------
 //
 CAiScutSettingsItem* CAiScutSettingsItem::NewLC(
    CAiScutSettingsModel&   aModel,
    TInt                    aIndex,
    TUint32                 aKey)
 {
    CAiScutSettingsItem* self = new (ELeave) CAiScutSettingsItem(
        aModel, aIndex, aKey);

    CleanupStack::PushL(self);
    self->ConstructL();
    return self;
 }

 // ---------------------------------------------------------------------------
 //
 // ---------------------------------------------------------------------------
 //
 CAiScutSettingsItem* CAiScutSettingsItem::NewLC(
    CAiScutSettingsModel&   aModel,
    TInt                    aIndex,
    TUint32                 aKey,
    const TDesC&            aValue)
 {
    CAiScutSettingsItem* self = new (ELeave) CAiScutSettingsItem(
        aModel, aIndex, aKey);

    CleanupStack::PushL(self);
    self->ConstructL(aValue);
    return self;
 }

 // ---------------------------------------------------------------------------
 //
 // ---------------------------------------------------------------------------
 //
 void CAiScutSettingsItem::ConstructL()
 {

 }

 // ---------------------------------------------------------------------------
 //
 // ---------------------------------------------------------------------------
 //
 void CAiScutSettingsItem::ConstructL(const TDesC& aValue)
 {
     ParseValueL(aValue);
     iValue = aValue.AllocL();
 }

 // ---------------------------------------------------------------------------
 //
 // ---------------------------------------------------------------------------
 //
 CAiScutSettingsItem::~CAiScutSettingsItem()
 {
    delete iValue;
    delete iListBoxLine;
 }

 // ---------------------------------------------------------------------------
 //
 // ---------------------------------------------------------------------------
 //
 TInt CAiScutSettingsItem::ParseValueL(const TDesC& aValue)
 {
    HBufC* caption = NULL;
    TInt err = KErrNone;
    HBufC* buf = HBufC::NewLC(KMaxBufSize);
    TPtr bufPtr = buf->Des();

    TAiScutParser parser;
    parser.Parse(aValue);

    TShortcutType type = parser.Type();

    iUid = parser.Uid();
    iType = EAiScutSettingTypeApplication;

    switch (type)
    {
        case EScutApplication:
        case EScutApplicationWithParams:
        case EScutApplicationView:
        case EScutLogsMissedCallsView:
        case EScutLogsDialledCallsView:
        case EScutLogsReceivedCallsView:
        case EScutLogsMainView:
            err = iModel.GetAppCaption(iUid, bufPtr);
            if (err == KErrNone)
            {
                caption = bufPtr.AllocLC();
            }
            break;

        case EScutNewMessage:
            caption = StringLoader::LoadLC(
                R_SCUT_SETTINGS_NEW_MSG, iModel.Env());
            break;

        case EScutNewEmail:
            caption = StringLoader::LoadLC(
                R_SCUT_SETTINGS_NEW_EMAIL, iModel.Env());
            break;

        #ifdef __SYNCML_DS_EMAIL
            case EScutNewSyncMLMail:
                caption = StringLoader::LoadLC(
                    R_SCUT_SETTINGS_NEW_SYNCML_MAIL, iModel.Env());
                break;
        #endif

        case EScutNewPostcard:
            caption = StringLoader::LoadLC(
                R_SCUT_SETTINGS_NEW_POSTCARD, iModel.Env());
            break;

        case EScutNewAudioMsg:
            caption = StringLoader::LoadLC(
                R_SCUT_SETTINGS_NEW_AUDIO_MSG, iModel.Env());
            break;

        case EScutNewMsgType:
            caption = StringLoader::LoadLC(
                R_SCUT_SETTINGS_SELECT_MSG_TYPE, iModel.Env());
            break;

        case EScutChangeTheme:
            caption = StringLoader::LoadLC(
                R_SCUT_SETTINGS_CHANGE_THEME, iModel.Env());
            break;

        case EScutMailbox:
            {
            err = KErrNotFound;
            // Parse the mailbox id from the definition
            TLex lex(parser.Get(EScutDefParamValue));
            TInt mailboxId = KErrNone;
            lex.Val(mailboxId);

            CMsvSession* msvSession = CMsvSession::OpenAsObserverL(*iModel.AppList());
            CleanupStack::PushL(msvSession);

            CMsvEntry* rootEntry = msvSession->GetEntryL(KMsvRootIndexEntryIdValue);
            CleanupStack::PushL(rootEntry);          
            
            // Searching the mailbox name
            for (TInt i = rootEntry->Count() - 1; i >= 0; --i)
            {
                const TMsvEntry& tentry = (*rootEntry)[i];

                if ((tentry.iMtm == KSenduiMtmImap4Uid || tentry.iMtm == KSenduiMtmPop3Uid) &&
                    tentry.Id() == mailboxId)
                {
                    caption = tentry.iDetails.AllocL();
                    err = KErrNone;
                    break;
                }
            }
            CleanupStack::PopAndDestroy(rootEntry);
            CleanupStack::PopAndDestroy(msvSession);
            if ( caption )
                {
                CleanupStack::PushL( caption );
                }
            }
            break;

        case EScutNoEffect:
            caption = StringLoader::LoadLC(
                R_SCUT_SETTINGS_NO_EFFECT, iModel.Env());
            break;

        case EScutConnectivityStatusView:
            caption = StringLoader::LoadLC(
                R_SCUT_SETTINGS_CONNECTIVITY_STATUS, iModel.Env());
            break;

        case EScutApplicationManagerView:
            caption = StringLoader::LoadLC(
                R_SCUT_SETTINGS_APPMNGR, iModel.Env());
            break;

        case EScutBookmark:
            {
            // aValue = "localapp:0x102750fb?bkm=0x12345678"
            iUid = KScutSettingsDllUid;
            iType = EAiScutSettingTypeBookmark;
            TUid uid = parser.ParseUid(parser.Get(EScutDefParamValue));
            TRAP(err, iModel.GetBkmCaptionL(uid, bufPtr));
            if (err == KErrNone)
            {
                caption = bufPtr.AllocLC();

                __PRINT( __DBG_FORMAT( "XAI: CAiScutSettingsItem bkm uid = 0x%x caption = '%S' "),
                uid.iUid, caption);
            }
            }
            break;

        case EScutWebAddress:
        default:
            // treat unknown shortcuts as typed urls.
            iUid.iUid = 0;
            iType = EAiScutSettingTypeUrl;
        HBufC* tmp = HBufC::NewLC( aValue.Length() );
        TPtr tmpPtr = tmp->Des();
        TInt err = parser.CustomTitle( tmpPtr );

        if ( err != KErrNone || tmp->Length() <= 0 )
            {
            CleanupStack::PopAndDestroy( tmp );
            caption = aValue.AllocLC();
            }
        else
            {
            caption = tmp;
            }
            break;
        }

    if (caption)
    {
        CreateListBoxLineL(*caption);
        CleanupStack::PopAndDestroy(caption);
    }

    CleanupStack::PopAndDestroy(buf);
    return err;
 }

 // ---------------------------------------------------------------------------
 // Changes the setting item target application.
 // ---------------------------------------------------------------------------
 //
 void CAiScutSettingsItem::ChangeApplicationL(TUid aUid, const TDesC& aParams,
        const TDesC& aCaption)
 {
    iUid = aUid;
    iType = EAiScutSettingTypeApplication;

    HBufC* newValue = NULL;
    TAiScutParser parser;
    parser.ComposeL(newValue, iUid, aParams);

    delete iValue;
    iValue = NULL;
    iValue = newValue;

    CreateListBoxLineL(aCaption);
 }

 // -----------------------------------------------------------------------------
 // Changes the setting item target bookmark.
 // -----------------------------------------------------------------------------
 //
 void CAiScutSettingsItem::ChangeBookmarkL(const TDesC& aParams, const TDesC& aCaption)
 {
    iUid = KScutSettingsDllUid;
    iType = EAiScutSettingTypeBookmark;

    HBufC* newValue = NULL;
    TAiScutParser parser;
    parser.ComposeL(newValue, iUid, aParams);

    delete iValue;
    iValue = NULL;
    iValue = newValue;

    CreateListBoxLineL(aCaption);
 }

 // -----------------------------------------------------------------------------
 // Changes the setting item target url.
 // -----------------------------------------------------------------------------
 //
 void CAiScutSettingsItem::ChangeUrlL(const TDesC& aUrl)
 {
    iUid.iUid = 0;
    iType = EAiScutSettingTypeUrl;

    delete iValue;
    iValue = NULL;
    iValue = aUrl.AllocL();

    CreateListBoxLineL(*iValue);
 }

 // -----------------------------------------------------------------------------
 // Creates a formatted listbox line.
 // -----------------------------------------------------------------------------
 //
 void CAiScutSettingsItem::CreateListBoxLineL(const TDesC& aCaption)
 {
    HBufC* title = CreateItemTitleLC();

    TPtrC caption;
    caption.Set(aCaption);

    TUriParser parser;
    TInt err = parser.Parse(aCaption);
    if (err == KErrNone)
    {
        // Remove scheme from the url.
        const TDesC& host = parser.Extract(EUriHost);
        if (host.Length())
        {
            caption.Set(host);
        }
    }

    // Format (" \t%S\t\t%S") without %S characters.
    TInt formatLength = KSettingListboxLineFormat().Length();

    HBufC* listBoxLine =
        HBufC::NewLC(title->Length() + caption.Length() + formatLength);

    TPtr ptr = listBoxLine->Des();
    ptr.Format(KSettingListboxLineFormat, title, &caption);

    delete iListBoxLine;
    iListBoxLine = NULL;
    iListBoxLine = listBoxLine;
    CleanupStack::Pop(listBoxLine);

    TInt titlePos = ptr.Find(*title);
    if (titlePos < 0)
    {
        titlePos = 0;
    }
    iTitle.Set(ptr.Mid(titlePos, title->Length()));

    CleanupStack::PopAndDestroy(title);
 }

 // -----------------------------------------------------------------------------
 // Creates a setting item title.
 // -----------------------------------------------------------------------------
 //
 HBufC* CAiScutSettingsItem::CreateItemTitleLC()
 {
     HBufC* title = NULL;
     if (iKey & KScutFlagBitOptionallyVisible)
     {
        // Optionally visible shortcuts are either navigation keys or soft keys.
        title = CreateOptionallyVisibleKeyTitleLC();
     }

     // Make sure something gets loaded and put to cleanup stack.
     if (!title)
     {
        title = StringLoader::LoadLC(
            R_SCUT_SETTINGS_TXT_LINKN, iIndex+1, iModel.Env());
     }

     __PRINT( __DBG_FORMAT( "XAI: CreateItemTitleLC %d key = 0x%x (0x%x) title = '%S' "),
            iIndex+1, iKey, (iKey & 0xFFFF), title);

     return title;
 }

 // -----------------------------------------------------------------------------
 // Creates a key title for an optionally visible shortcut.
 // -----------------------------------------------------------------------------
 //
 HBufC* CAiScutSettingsItem::CreateOptionallyVisibleKeyTitleLC()
 {
    HBufC* title = NULL;
    TInt resourceId = 0;

    switch (iKey & 0xFFFF)
    {
        case EAiScutScrollKeyLeft:
            resourceId = R_SCUT_SETTINGS_SCROLL_LEFT;
            break;

        case EAiScutScrollKeyRight:
            resourceId = R_SCUT_SETTINGS_SCROLL_RIGHT;
            break;

        case EAiScutScrollKeyUp:
            resourceId = R_SCUT_SETTINGS_SCROLL_UP;
            break;

        case EAiScutScrollKeyDown:
            resourceId = R_SCUT_SETTINGS_SCROLL_DOWN;
            break;

        case EAiScutSelectionKey:
            resourceId = R_SCUT_SETTINGS_SELECTION_KEY;
            break;

        case EAiScutSoftKeyLeft:
            resourceId = R_SCUT_SETTINGS_SOFTKEY_LEFT;
            break;

        case EAiScutSoftKeyRight:
            resourceId = R_SCUT_SETTINGS_SOFTKEY_RIGHT;
            break;

        default:
            resourceId = 0;
            break;
        }

    if (resourceId)
    {
        title = StringLoader::LoadLC(resourceId, iModel.Env());
    }
    else
    {
        title = NULL;
    }

    return title;
 }

 // ---------------------------------------------------------------------------
 // Returns the setting item value.
 // ---------------------------------------------------------------------------
 //
 TPtrC CAiScutSettingsItem::Value() const
 {
     if(iValue)
         {
         return TPtrC( *iValue );
         }
     return TPtrC(KNullDesC);
 }

 // ---------------------------------------------------------------------------
 // Returns the formatted listbox line descriptor.
 // ---------------------------------------------------------------------------
 //
 TPtrC CAiScutSettingsItem::ListBoxLine() const
 {
     if(iListBoxLine)
         {
         return TPtrC( *iListBoxLine );
         }
     return TPtrC(KNullDesC);
 }
// End of File.
hs_app_caiscutsettingsmodel.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shrortcut settings plug-in model.
*
*/


#include 
#include 
#include 

#include "hs_app_caiscutsettings.h"
#include "hs_app_caiscutsettingsmodel.h"
#include "hs_app_caiscutsettingscontainer.h"
#include "hs_app_caiscutsettingsitem.h"
#include "hs_app_aiscutpluginprivatecrkeys.h"
#include "aiscutdefs.h"
#include "hs_app_aiscutappuidparser.h"
#include "hs_app_aiscutrepositorywatcher.h"

#include "debug.h"

LOCAL_C TInt CompareKey(const TUint32& aLeft, const TUint32& aRight)
{
    TBool softkey1 = (0 != ((aLeft  & 0xFFFF) >= EAiScutSoftKeyLeft));
    TBool softkey2 = (0 != ((aRight & 0xFFFF) >= EAiScutSoftKeyLeft));
    TUint32 left  = aLeft  & (KScutBitMaskThemeDefault & KScutBitMaskLocked);
    TUint32 right = aRight & (KScutBitMaskThemeDefault & KScutBitMaskLocked);

    // Softkey shortcuts are always sorted to be smallest.
    if (!(softkey1 && softkey2))
    {
        if (softkey1)
        {
            return -1;
        }
        else if (softkey2)
        {
            return 1;
        }
    }

    if (left < right)
    {
        return -1;
    }
    else if (left > right)
    {
        return 1;
    }

    return 0;
}



// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsModel* CAiScutSettingsModel::NewL(CAiScutSettings& aPlugin,
    CCoeEnv* aEnv)
{
    CAiScutSettingsModel* self = new (ELeave) CAiScutSettingsModel(aPlugin, aEnv);

    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);

    return self;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsModel::CAiScutSettingsModel(CAiScutSettings& aPlugin, CCoeEnv* aEnv) 
    : iPlugin(aPlugin), iEnv(aEnv)
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsModel::~CAiScutSettingsModel()
{
    ActivateObservers(EFalse);

    delete iSettingsNotifier;
    delete iRepository;

    delete iHiddenAppsNotifier;
    delete iHiddenAppsRepository;

    iHiddenApps.Close();

    delete iAppList;
    delete iBkmList;

    iSettings.ResetAndDestroy();
    iKeys.Reset();
    delete iFavItemList;
    iBookmarkDb.Close();
    iBookmarkSess.Close();
    iApaSession.Close();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsModel::ConstructL()
{
    User::LeaveIfError(iApaSession.Connect());
    User::LeaveIfError(iBookmarkSess.Connect());
    User::LeaveIfError(iBookmarkDb.Open(iBookmarkSess, KBrowserBookmarks));

    iRepository = CRepository::NewL(KCRUidShortcutItems);

    iHiddenAppsRepository = CRepository::NewL(KCRUidMenu);

    // Create cenrep key observer for monitoring settings changes
    // when theme is changed.
    iSettingsNotifier = CAiScutRepositoryWatcher::NewL(
        KCRUidShortcutItems,
        TCallBack(HandleShortcutsChanged, this),
        iRepository);

    iSettingsNotifier->StartListeningL();

    iHiddenAppsNotifier = CAiScutRepositoryWatcher::NewL(
        KCRUidMenu,
        KMenuHideApplication,
        CCenRepNotifyHandler::EStringKey,
        TCallBack(HandleHiddenAppsChanged, this),
        iHiddenAppsRepository);

    iHiddenAppsNotifier->StartListeningL();

    GetHiddenAppsL();

    iAppList = CAiScutSettingsAppList::NewL(iEnv, *this);
    iAppList->StartL();

    iBkmList = CAiScutSettingsBkmList::NewL(iEnv, this, *this);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsModel::SetSettingsKeys(RArray& aKeys)
    {
    iKeys.Reset();
    
    for( TInt i = 0; i < aKeys.Count(); i++ )
        {
        TUint32 value( aKeys[i] );
        
        iKeys.Append( value );
        }        
    }
    
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsModel::UpdateSettingsL()
{
    if( !iPlugin.Activated() )
        {
        return;
        }
        
    iSettings.ResetAndDestroy();

    TInt keyCount( iKeys.Count() );

    if( keyCount > 0 )
        {
        for( TInt i = 0; i < keyCount; i++ )
            {
            CAiScutSettingsItem* setting = CAiScutSettingsItem::NewLC(
                *this, i, iKeys[i] );

            setting->ReadL( iRepository );

            User::LeaveIfError( iSettings.Append( setting ) );
            CleanupStack::Pop( setting );           
            }
                
        return;
        }
        
    RArray defaultKeys;
    CleanupClosePushL(defaultKeys);
    
    // Find the default keys and user defined keys.
    iRepository->FindL(
        KScutCenRepKeyThemeDefault, KScutCenRepKeyMask, defaultKeys);        

    TInt i;
    TUint32 defaultKey;
    TUint32 userKey;
    TInt count;
    TInt lockedKeys  = 0;
    TInt visibleKeys = 0;

    TLinearOrder order(CompareKey);
    defaultKeys.Sort(order);

    count = defaultKeys.Count();
    for (i = 0; i < count; ++i)
    {
        defaultKey = defaultKeys[i];
        userKey = defaultKey & KScutBitMaskThemeDefault;
        // We show only actual shortcuts
        if ( (! ( defaultKey & KScutFlagBitIconOverride )) && 
             (! ( defaultKey & KScutFlagBitToolbarShortcut )))
            {                               
    		__PRINT( __DBG_FORMAT( "XAI:   %d. key = 0x%x"), i+1, 
    			(defaultKey & (KScutBitMaskThemeDefault & KScutBitMaskLocked)));

            if (!(userKey & KScutFlagBitOptionallyVisible))
            {
                visibleKeys++;
            }

            TBool locked = (0 != (userKey & KScutFlagBitLocked));

            if (locked)
            {
                lockedKeys++;
            }
            else
            {
                CAiScutSettingsItem* setting = CAiScutSettingsItem::NewLC(
                    *this, visibleKeys-1, defaultKey);

                setting->ReadL(iRepository);

                User::LeaveIfError(iSettings.Append(setting));
                CleanupStack::Pop(setting);
            }
        }

    }

	__PRINT( __DBG_FORMAT("XAI:   %d keys, %d locked"), count, lockedKeys);

    CleanupStack::PopAndDestroy(&defaultKeys);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsModel::UpdateSettingsContainerL()
{
    if (iContainer)
    {
        if (iContainer->IsChangeDialogShowing())
        {
            iContainer->CloseChangeDialog();
        }
    }

    UpdateSettingsL();

    if (iContainer)
    {
        iContainer->ResetCurrentListL(0);
    }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsModel::GetHiddenAppsL()
{
    HBufC* buffer = HBufC::NewLC(
        NCentralRepositoryConstants::KMaxUnicodeStringLength);
    TPtr bufferPtr = buffer->Des();

    iHiddenAppsRepository->Get(KMenuHideApplication, bufferPtr);

	__PRINT( __DBG_FORMAT("XAI: CAiScutSettingsModel::GetHiddenAppsL '%S' "), buffer);

    iHiddenApps.Reset();
    TAiScutAppUidParser uidParser(bufferPtr, iHiddenApps);
    uidParser.ParseL();

    CleanupStack::PopAndDestroy(buffer);
}

// ---------------------------------------------------------------------------
// From MDesCArray
// Returns the number of descriptor elements in a descriptor array.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsModel::MdcaCount() const
{
    return iSettings.Count();
}

// ---------------------------------------------------------------------------
// From MDesCArray
// Indexes into a descriptor array.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutSettingsModel::MdcaPoint(TInt aIndex) const
{
    if (aIndex < 0 || aIndex >= iSettings.Count())
    {
        TPtrC ret(KNullDesC);
        return ret;
    }

    return iSettings[aIndex]->ListBoxLine();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsModel::HandleShortcutsChanged(TAny* aPtr)
{
	__PRINTS( "XAI: CAiScutSettingsModel::HandleShortcutsChanged");

    if (aPtr)
        {
        CAiScutSettingsModel* self = static_cast(aPtr);
        TRAP_IGNORE(self->UpdateSettingsContainerL());
        }

    return KErrNone;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsModel::HandleHiddenAppsChanged(TAny* aPtr)
{
	__PRINTS("XAI: CAiScutSettingsModel::HandleHiddenAppsChanged");

    if (aPtr)
        {
        CAiScutSettingsModel* self = static_cast(aPtr);

        TRAP_IGNORE(
            self->iAppList->StartL();
            self->GetHiddenAppsL();
            self->UpdateSettingsContainerL() ) // TRAP_IGNORE
        }

    return KErrNone;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CAiScutSettingsModel::IsHidden(const TUid& aAppUid) const
{
    if (iHiddenApps.Find(aAppUid) == KErrNotFound)
    {
        return EFalse;
    }

	__PRINT( __DBG_FORMAT( "XAI: CAiScutSettingsModel::IsHidden (0x%x) ETrue"), aAppUid);

    return ETrue;
}

// ---------------------------------------------------------------------------
// From MAiScutListObserver
// Callback for application list events.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsModel::HandleScutListEventL(TScutListEvent aEvent,
    TBool /*aAdded*/)
{
    switch (aEvent)
    {
    case MAiScutListObserver::EAppListReady:
        if (iContainer)
        {
            iContainer->HideWaitNoteDialog();
        }
        break;

    case MAiScutListObserver::EAppListUpdated:
    case MAiScutListObserver::EBkmListUpdated:
        UpdateSettingsContainerL();
        break;

    default:
        break;
    }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsModel::ActivateObservers(TBool aActivate)
{
    TRAP_IGNORE(
        if (iAppList)
        {
            iAppList->SetObservingL(aActivate);
        }
        if (iBkmList)
        {
            iBkmList->SetObservingL(aActivate);
        }
    )
}

// ---------------------------------------------------------------------------
// Returns a setting item for the given index.
// ---------------------------------------------------------------------------
//
CAiScutSettingsItem* CAiScutSettingsModel::Item(TInt aIndex) const
{
    if (aIndex >= 0 && aIndex < iSettings.Count())
    {
        return iSettings[aIndex];
    }

    return NULL;
}

// ---------------------------------------------------------------------------
// Utility function to retrieve a bookmark caption from an uid.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsModel::GetBkmCaptionL(const TUid aUid, TDes& aCaption)
{
    CFavouritesItem* favItem = CFavouritesItem::NewLC();
    TInt err = iBookmarkDb.Get(aUid.iUid, *favItem);
    if (err == KErrNone)
    {
        aCaption.Copy(favItem->Name());
    }

    CleanupStack::PopAndDestroy(favItem);

    return err;
}

// ---------------------------------------------------------------------------
// Utility function to retrieve an appliation caption from an uid.
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsModel::GetAppCaption(const TUid aUid, TDes& aCaption)
{
    TInt err = KErrNone;
    TApaAppInfo appInfo;

    err = iApaSession.GetAppInfo(appInfo, aUid);
    if (err == KErrNone)
    {
        aCaption.Copy(appInfo.iCaption);
    }

    return err;
}

// ---------------------------------------------------------------------------
// Returns a pointer to the coe environment.
// ---------------------------------------------------------------------------
//
CCoeEnv* CAiScutSettingsModel::Env()
{
    return iEnv;
}

// ---------------------------------------------------------------------------
// Handles saving a setting item to central repository.
// ---------------------------------------------------------------------------
//
void CAiScutSettingsModel::SaveItemL(CAiScutSettingsItem& aItem)
{
    // Stop monitoring own settings changes.
    iSettingsNotifier->StopListening();

    TInt err = aItem.Save(iRepository);

	__PRINT( __DBG_FORMAT( "XAI: CAiScutSettingsModel::SaveItemL key = 0x%x, err = %d"), 
		aItem.Key(), err);
    UpdateSettingsL();
    iSettingsNotifier->StartListeningL();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutSettingsModel::SetContainer(CAiScutSettingsContainer* aContainer)
{
    iContainer = aContainer;
}

// -----------------------------------------------------------------------------
// Using the Favorites dB, get the bookmarked pages
// -----------------------------------------------------------------------------
//
void CAiScutSettingsModel::ReadBookmarksL()
{
    // Get bookmarks
    delete iFavItemList;
    iFavItemList = NULL;

    iFavItemList = new (ELeave) CFavouritesItemList();
    TInt err = iBookmarkDb.GetAll(
        *iFavItemList, KFavouritesNullUid, CFavouritesItem::EItem);
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TInt CAiScutSettingsModel::BookmarkCount() const
{
    if (iFavItemList)
    {
        return iFavItemList->Count();
    }
    else
    {
        return 0;
    }
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CFavouritesItem* CAiScutSettingsModel::GetBookmark(TInt aIndex)
{
    if (aIndex >= 0 && aIndex < iFavItemList->Count())
    {
    	    
    	if (iFavItemList)
    	{
        	return iFavItemList->At(aIndex);
    	}
    	else
    	{
        	return NULL;
    	}
    }
    else
    {
    	return NULL;	
    }
}

// ---------------------------------------------------------------------------
// Returns reference to the bookmark database owned by the engine.
// ---------------------------------------------------------------------------
//
RFavouritesDb& CAiScutSettingsModel::FavouritesDb()
{
    return iBookmarkDb;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsAppList* CAiScutSettingsModel::AppList()
{
    return iAppList;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutSettingsBkmList* CAiScutSettingsModel::BkmList()
{
    return iBkmList;
}

// End of File.
hs_app_caiscutshortcut.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Implementation for a shortcut.
*
*/


#include 
#include             // For CGulIcon
#include                 // For CFbsBitmap
#include             // For RProperty

#include 
#include "aiscutcontentmodel.h"
#include "hs_app_caiscutshortcut.h"
#include "aiscutdefs.h"
#include "hs_app_caiscuttargetapp.h"
#include "hs_app_caiscuttargetbkm.h"
#include "hs_app_caiscuttargethttp.h"
#include "hs_app_caiscuttargetmessagingview.h"
#include "hs_app_caiscuttargetnewmsg.h"
#include "hs_app_caiscuttargetkeylock.h"
#include "hs_app_caiscuttargetempty.h"
#include "hs_app_aiscutpluginprivatecrkeys.h"

#include "debug.h"


// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcut::CAiScutShortcut(TInt aId, CAiScutEngine& aEngine)
	: CTimer( CActive::EPriorityLow )
	, iId(aId)
    , iEngine(aEngine)
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutShortcut::ConstructL(const TDesC& aTarget)
{
    iDefaultTarget = CreateTargetL(aTarget, EFalse);

    if (!iDefaultTarget)
    {
        iDefaultTarget = CAiScutTargetEmpty::NewL(iEngine, EScutUnknown, aTarget);
    }
    CTimer::ConstructL();
    CActiveScheduler::Add( this );
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcut* CAiScutShortcut::NewLC(TInt aId, const TDesC& aTarget,
    CAiScutEngine& aEngine)
{
    CAiScutShortcut* self = new (ELeave) CAiScutShortcut(aId, aEngine);
    CleanupStack::PushL(self);
    self->ConstructL(aTarget);
    return self;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcut* CAiScutShortcut::NewL(TInt aId, const TDesC& aTarget,
    CAiScutEngine& aEngine)
{
    CAiScutShortcut* self = CAiScutShortcut::NewLC(aId, aTarget, aEngine);
    CleanupStack::Pop(self);
    return self;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcut::~CAiScutShortcut()
{
	Cancel();
    delete iDefaultTarget;
    delete iUserTarget;
    delete iRetiredTarget;
}

// -----------------------------------------------------------------------------
// Returns the shortcut id.
// -----------------------------------------------------------------------------
//
TInt32 CAiScutShortcut::Id() const
{
    return iId;
}

// -----------------------------------------------------------------------------
// Publishes the shortcut content, non leaving version.
// -----------------------------------------------------------------------------
//
void CAiScutShortcut::Publish(
    MAiPropertyExtension& aPlugin, MAiContentObserver& aObserver)
{
    TRAPD(err, PublishL(aPlugin, aObserver));
    //Possible forcing done already so reset the flag
    iForcePublish = EFalse;
    if (err == KErrNone)
    {
        delete iRetiredTarget;
        iRetiredTarget = NULL;
        iLastPublishedTarget = iActiveTarget;
    }
    else
    {
        // Publish failed, roll back to previous content.
        TInt transactionId = reinterpret_cast(this);
        aObserver.CancelTransaction(transactionId);

        // Delete the new target and put the retired one back to work.
        if (iRetiredTarget)
        {
            delete iUserTarget;
            iUserTarget = iRetiredTarget;
            iRetiredTarget = NULL;
        }

        iActiveTarget = iLastPublishedTarget;
    }

    
}

// -----------------------------------------------------------------------------
// Checks if the application or messaging view pointed to can be launched.
// -----------------------------------------------------------------------------
//
TBool CAiScutShortcut::CheckAccessL(TInt aCheckType)
{
    TBool userTargetAccessible = EFalse;

	__PRINT( __DBG_FORMAT( "XAI: CAiScutShortcut::CheckAccessL( %d )"), aCheckType);

    // First try the user setting if it is defined.
    if (iUserTarget && iUserTarget->IsAccessibleL(aCheckType))
    {
        iActiveTarget = iUserTarget;
        userTargetAccessible = ETrue;
    }

    if (!userTargetAccessible)
    {

		__PRINTS("XAI:   *** user target NOT accessible ***");
        // User setting was not accessible or not defined, try the default.
        if (iDefaultTarget->IsAccessibleL(aCheckType))
        {
            iActiveTarget = iDefaultTarget;
        }
        else
        {
            // The default is not accessible either, the shortcut is empty.
            iActiveTarget = NULL;

			__PRINTS( "XAI:   *** default target NOT accessible ***");
        }
    }

    if (iActiveTarget)
	{
		return ETrue;
	}
	else
	{
		return EFalse;
	}    
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
//
TBool CAiScutShortcut::IsTargetChanged() const
{
    // We need to publish if target changed during access checking.
    return (iLastPublishedTarget != iActiveTarget);
}

// -----------------------------------------------------------------------------
// Changes the shortcut target to the user defined setting.
// -----------------------------------------------------------------------------
//
void CAiScutShortcut::SetUserTarget(const TDesC& aNewTarget)
{

	TPtrC defaultTarget(iDefaultTarget->Definition());
	__PRINTS( "XAI: CAiScutShortcut::SetUserTarget");
	__PRINT( __DBG_FORMAT( "XAI:   id             = 0x%x"), iId);
	__PRINT( __DBG_FORMAT( "XAI:   default target = '%S'"),   &defaultTarget);
	__PRINT( __DBG_FORMAT("XAI:   new target     = '%S'"),   &aNewTarget);
	if (iUserTarget)
		{
		TPtrC userTarget(iUserTarget->Definition());
		__PRINT( __DBG_FORMAT("XAI:   user target    = '%S'"),   &userTarget);
		}
		
	
    if (iUserTarget && (aNewTarget.CompareC(iUserTarget->Definition()) == 0))
    {
        return;
    }


    // Creating the new target might leave, so it is done before the old target
    // is deleted to ensure that the shortcut object remains in a consistent state
    // in case of a leave. If target creation leaves, nothing has changed.
    //
    // As a side effect this means that the new target is allocated to a different
    // memory address than the old one, the address of the old target will not be re-used
    // by this target. That doesn't mean anything for the plug-in, but it helps the
    // plug-in tester to notice premature target deletion, since the address will still
    // contain 0xDEDEDEDE instead of the new target.
    CAiScutTarget* tempTarget = NULL;

    TRAPD(err, tempTarget = CreateTargetL(aNewTarget, ETrue));

    if (err == KErrNone)
    {
        DeleteUserTarget();
        iUserTarget = tempTarget;
    }
}

// -----------------------------------------------------------------------------
// Deletes the user target.
// -----------------------------------------------------------------------------
//
void CAiScutShortcut::DeleteUserTarget()
{
    if (iUserTarget)
    {

		__PRINTS("XAI: CAiScutShortcut::DeleteUserTarget");

        if (iLastPublishedTarget == iUserTarget && !(iId & KScutFlagBitNonVisible))
        {
            // Previous user target was the last published target so the Ai framework
            // is still using the icon pointer. Deleting the target now would cause a
            // KERN-EXEC 3 panic when the framework tries to access the deleted icon.
            // The target must be kept alive until the new target has been successfully
            // published and the framework is no longer using its icon.
            // This is unnecessary for non-visible shortcuts because they are not published.
            iRetiredTarget = iUserTarget;
            iUserTarget = NULL;

			__PRINTS("XAI:   iUserTarget = NULL");

        }

        if (iActiveTarget == iUserTarget)
        {
            // Previous user target was the active target. We don't know if the new
            // user target is accessible, so the shortcut is effectively empty until
            // the access check has been run.
            iActiveTarget = NULL;
        }

        delete iUserTarget;
        iUserTarget = NULL;

		__PRINTS( "XAI:   delete iUserTarget");
    }
}

// -----------------------------------------------------------------------------
// Launches the shortcut.
// -----------------------------------------------------------------------------
//
void CAiScutShortcut::LaunchL()
{
	Cancel();
	RProperty::Set( 
        KPSUidAiInformation, 
        KActiveIdleLaunch, 
        EPSAiLaunchIsActive );

    if (iActiveTarget)
    {
    	TRAP_IGNORE( iActiveTarget->BeginEffectL() ); //start a full screen effect
        iActiveTarget->LaunchL();
    }
  
    // When preparing for backup, the plugin is suspended and calling After() would
    // cause a crash
    if ( IsAdded() )
    {	
    	After(1000000);
    }
}

// -----------------------------------------------------------------------------
// Launches the shortcut.
// -----------------------------------------------------------------------------
//
void CAiScutShortcut::LaunchL(const TDesC8& aMessage)
{
	Cancel();
	RProperty::Set( 
        KPSUidAiInformation, 
        KActiveIdleLaunch, 
        EPSAiLaunchIsActive );

    if (iActiveTarget)
    {
    	TRAP_IGNORE( iActiveTarget->BeginEffectL() ); //start a full screen effect
        iActiveTarget->LaunchL(aMessage);
    }
  
    // When preparing for backup, the plugin is suspended and calling After() would
    // cause a crash
    if ( IsAdded() )
    {	
    	After(1000000);
    }
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
//
void CAiScutShortcut::SetToBePublished(TBool aFlag)
{
    if ( !iForcePublish )
        {
        iNeedsToBePublished = aFlag;                
        }
    else
        {
        iNeedsToBePublished = iForcePublish;
        }
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
//
TBool CAiScutShortcut::NeedsToBePublished()
{
    return iNeedsToBePublished;
}

// -----------------------------------------------------------------------------
// Return shortcut type.
// -----------------------------------------------------------------------------
//
TShortcutType CAiScutShortcut::Type() const
{
    if (iUserTarget)
    {
        return iUserTarget->Type();
    }
    else
    {
        return iDefaultTarget->Type();
    }
}

// ---------------------------------------------------------------------------
// Return application uid of this shortcut.
// ---------------------------------------------------------------------------
//
TUid CAiScutShortcut::AppUid() const
{
    if (iUserTarget)
    {
        return iUserTarget->AppUid();
    }
    else
    {
        return iDefaultTarget->AppUid();
    }
}
void CAiScutShortcut::SetIcon(TAiScutIcon aIcon)
    {
    switch(aIcon.iDestination)
        {      
        case EScutDestinationSoftkey:
            SetSoftkeyIcon(aIcon);
            break;
        case EScutDestinationToolbar:
            SetToolbarIcon(aIcon);
            break;
        case EScutDestinationNormal:
            SetOverrideIcon(aIcon);
            break;
        default:
            break;
        }
    }
void CAiScutShortcut::SetOverrideIcon(TAiScutIcon aIcon)
{   
    if (iUserTarget)
    {
        iUserTarget->SetOverrideIcon(aIcon);
    }
    else
    {
        iDefaultTarget->SetOverrideIcon(aIcon);
    }
}

void CAiScutShortcut::SetSoftkeyIcon(TAiScutIcon aIcon)
{   
    if (iUserTarget)
    {
        iUserTarget->SetSoftkeyIcon(aIcon);
    }
    else
    {
        iDefaultTarget->SetSoftkeyIcon(aIcon);
    }
}


void CAiScutShortcut::SetToolbarIcon(TAiScutIcon aIcon)
{   
    if (iUserTarget)
    {
        iUserTarget->SetToolbarIcon(aIcon);
    }
    else
    {
        iDefaultTarget->SetToolbarIcon(aIcon);
    }
}


// -----------------------------------------------------------------------------
// Creates a shortcut target object.
// -----------------------------------------------------------------------------
//
CAiScutTarget* CAiScutShortcut::CreateTargetL(
    const TDesC& aDefinition, TBool aCreateUserTarget)
{

	__PRINTS("XAI: CAiScutShortcut::CreateTargetL");
	__PRINT( __DBG_FORMAT("XAI:   id = 0x%x, target = '%S'"), iId, &aDefinition);

    CAiScutTarget* target = NULL;
    TAiScutParser parser;
    TInt err = parser.Parse(aDefinition);

    if (parser.IsValid())
    {
        TShortcutType type = parser.Type();
        
        switch (type)
        {
        case EScutApplication:
        case EScutChangeTheme:
        case EScutApplicationView:
        case EScutApplicationWithParams:
        case EScutLogsMissedCallsView:
        case EScutLogsDialledCallsView:
        case EScutLogsReceivedCallsView:
        case EScutLogsMainView:
            target = CAiScutTargetApp::NewL(iEngine, type, parser);
            break;

        case EScutNewMsgType:
        case EScutNewMessage:
        case EScutNewEmail:
#ifdef __SYNCML_DS_EMAIL
        case EScutNewSyncMLMail:
#endif
        case EScutNewPostcard:
        case EScutNewAudioMsg:
            target = CAiScutTargetNewMsg::NewL(iEngine, type, parser);
            break;

        case EScutMailbox:
            target = CAiScutTargetMessagingView::NewL(iEngine, type, parser);
            break;

        case EScutWebAddress:
            target = CAiScutTargetHttp::NewL(iEngine, type, parser);
            break;

        case EScutKeylock:
            target = CAiScutTargetKeyLock::NewL(iEngine, type, aDefinition);
            break;

        case EScutNoEffect:
            target = CAiScutTargetEmpty::NewL(iEngine, type, aDefinition);
            break;

        case EScutBookmark:
            target = CAiScutTargetBkm::NewL(iEngine, type, parser);
            break;

        case EScutConnectivityStatusView:
            target = CAiScutTargetApp::NewL(iEngine, EScutApplicationView, parser);
            break;

        case EScutApplicationManagerView:
            target = CAiScutTargetApp::NewL(iEngine, EScutApplicationView, parser);
            break;

        default:
            break;
        }
    }

    if (!target && aCreateUserTarget)
    {
        // treat unknown user targets as web addresses.
        target = CAiScutTargetHttp::NewL(iEngine, EScutWebAddress, parser);
    }

    if (!target)
    {
		__PRINTS( "XAI:   *** empty target ***");
    }
    
    
    return target;
}

// -----------------------------------------------------------------------------
// Publishes the shortcut content, leaving version.
// -----------------------------------------------------------------------------
//
void CAiScutShortcut::PublishL(
    MAiPropertyExtension& aPlugin, MAiContentObserver& aObserver)
    {
    TInt err = KErrNone;
    TBool cbaIconPublished = EFalse;

	__PRINT( __DBG_FORMAT("XAI: CAiScutShortcut::PublishL 0x%x"), iId);

    // Publish caption if the framework can handle it.
    if (!aObserver.CanPublish(
        aPlugin, KAiScutContent[EAiScutContentShortcutCaption].id, iId))
        {
        err = KErrNotSupported;
        }
    else
        {
        err = PublishCaption(
            aPlugin, aObserver, KAiScutContent[EAiScutContentShortcutCaption].id);

        if (err != KErrNone)
        	__PRINT( __DBG_FORMAT( "XAI:   publish caption err = %d"), err);
        }

    // Publish short caption if the framework can handle it.
    if (!aObserver.CanPublish(
        aPlugin, KAiScutContent[EAiScutContentShortcutShortCaption].id, iId))
        {
        err = KErrNotSupported;
        }
    else
        {
        err = PublishCaption(
            aPlugin, aObserver, KAiScutContent[EAiScutContentShortcutShortCaption].id);

        if (err != KErrNone)
	        __PRINT( __DBG_FORMAT( "XAI:   publish short caption err = %d"), err);
        }

    /** softkeys **/
      // Publish short caption if the framework can handle it.
    if (!aObserver.CanPublish(
        aPlugin, KAiScutContent[EAiScutContentShortcutSkIcon].id, iId))
        {
        err = KErrNotSupported;
        }
    else
        {
        err = PublishIcon(
            aPlugin, aObserver, KAiScutContent[EAiScutContentShortcutSkIcon].id);
        
        if ( err == KErrNone )
            {
            cbaIconPublished = ETrue;
            }
        if (err != KErrNone) 
        	__PRINT( __DBG_FORMAT("XAI:   publish icon err = %d"), err);
        }
    
    // No CBA icon published so publish the caption
    if ( !cbaIconPublished )
        {        
        // Publish sk caption if the framework can handle it.
        if (!aObserver.CanPublish(
            aPlugin, KAiScutContent[EAiScutContentShortcutSkCaption].id, iId))
            {
            err = KErrNotSupported;
            }
        else
            {
            err = PublishCaption(
                aPlugin, aObserver, KAiScutContent[EAiScutContentShortcutSkCaption].id);

            if (err != KErrNone)
    	        __PRINT( __DBG_FORMAT( "XAI:   publish short caption err = %d"), err);
            }
        }
    
    /** end of softkeys **/
    
    // Publish MSK caption if the framework can handle it.
    if (!aObserver.CanPublish(
        aPlugin, KAiScutContent[EAiScutContentShortcutMskCaption].id, iId))
        {
        err = KErrNotSupported;
        }
    else
        {
        err = PublishCaption(
            aPlugin, aObserver, KAiScutContent[EAiScutContentShortcutMskCaption].id);

        if (err != KErrNone)
        	__PRINT( __DBG_FORMAT( "XAI:   publish msk caption err = %d"), err);
        }

    // Publish icon if the framework can handle it.
    if (!aObserver.CanPublish(
        aPlugin, KAiScutContent[EAiScutContentShortcutIcon].id, iId))
        {
        err = KErrNotSupported;
        }
    else
        {
        err = PublishIcon(
            aPlugin, aObserver, KAiScutContent[EAiScutContentShortcutIcon].id);

        if (err != KErrNone) 
        	__PRINT( __DBG_FORMAT("XAI:   publish icon err = %d"), err);
        }

    // Publish toolbar caption if the framework can handle it.
    if (!aObserver.CanPublish(
        aPlugin, KAiScutContent[EAiScutContentShortcutToolbarCaption].id, iId))
        {
        err = KErrNotSupported;
        }
    else
        {
        err = PublishCaption(
            aPlugin, aObserver, KAiScutContent[EAiScutContentShortcutToolbarCaption].id);

        if (err != KErrNone)
        	__PRINT( __DBG_FORMAT( "XAI:   publish toolbar caption err = %d"), err);
        }

    // Publish the toolbar icon if the framework can handle it    
    if (!aObserver.CanPublish(
        aPlugin, KAiScutContent[EAiScutContentShortcutToolbarIcon].id, iId))
        {
        err = KErrNotSupported;
        }
    else
        {
        err = PublishIcon(
            aPlugin, aObserver, KAiScutContent[EAiScutContentShortcutToolbarIcon].id);
        
        if (err != KErrNone) 
        	__PRINT( __DBG_FORMAT("XAI:   publish toolbar icon err = %d"), err);
        }
    }

// -----------------------------------------------------------------------------
// Publishes shortcut caption.
// -----------------------------------------------------------------------------
//
TInt CAiScutShortcut::PublishCaption(MAiPropertyExtension& aPlugin,
    MAiContentObserver& aObserver, TInt aCaptionContentId) const
{
    TInt err = KErrNone;

    if (iId == KRightSoftkeyId)
    {
        if (iActiveCall)
        {
            TInt backCaptionResId = KAiScutResources[EAiScutResourceBackCaption].id;
            err = aObserver.Publish(aPlugin, aCaptionContentId, backCaptionResId, iId);
            return err;
        }
    }

    if (!iActiveTarget)
    {
        // Publish the EmptyCaption resource id.
        TInt emptyCaptionResId = KAiScutResources[EAiScutResourceEmptyCaption].id;
        err = aObserver.Publish(aPlugin, aCaptionContentId, emptyCaptionResId, iId);
    }
    else
    {
        TPtrC captionDes;
        TInt captionResId = 0;
        TAiScutAppTitleType titleType = EAiScutLongTitle;
        if (aCaptionContentId == KAiScutContent[EAiScutContentShortcutShortCaption].id ||
            aCaptionContentId == KAiScutContent[EAiScutContentShortcutSkCaption].id || 
            aCaptionContentId == KAiScutContent[EAiScutContentShortcutToolbarCaption].id)
        {
            titleType = EAiScutSkeyTitle;
        }
        else if (aCaptionContentId == KAiScutContent[EAiScutContentShortcutMskCaption].id)
        {
            titleType = EAiScutMskTitle;
        }

        captionResId = iActiveTarget->GetCaption(captionDes, titleType);

        if (captionResId == 0)
        {
            // Publish descriptor.
            err = aObserver.Publish(aPlugin, aCaptionContentId, captionDes, iId);
        }
        else if (captionResId > 0)
        {
            // Publish resource.
            err = aObserver.Publish(aPlugin, aCaptionContentId, captionResId, iId);
            
            __PRINT( __DBG_FORMAT("XAI:   publish resource = %d"), captionResId);
        }
    }

    return err;
}

// -----------------------------------------------------------------------------
// Publishes shortcut icon.
// -----------------------------------------------------------------------------
//
TInt CAiScutShortcut::PublishIcon(MAiPropertyExtension& aPlugin,
    MAiContentObserver& aObserver, TInt aIconContentId )
{
    TInt emptyIconResId = KAiScutResources[EAiScutResourceEmptyIcon].id;
    TInt err = KErrNone;
    // In case of an active call cancel the SK icon publication
    // to RSK
    if ( iActiveCall && iId == KRightSoftkeyId )
        {
        return KErrCancel;
        }
    if (!iActiveTarget)
    {
        // Publish the EmptyIcon resource id.

        __PRINT( __DBG_FORMAT( "XAI: PublishIcon publish empty #1 = %d"), emptyIconResId);

        err = aObserver.Publish(aPlugin, aIconContentId, emptyIconResId, iId);
    }
    else
    {
        CGulIcon* iconPtr = NULL;
        TInt iconResId = 0;
        //  Normal icon
        if (aIconContentId == KAiScutContent[EAiScutContentShortcutIcon].id)
            {
            iconResId = iActiveTarget->GetIcon(iconPtr);
            }
        // Soft key icon
        else if ( aIconContentId == KAiScutContent[EAiScutContentShortcutSkIcon].id )
            {
            iconResId = iActiveTarget->GetSoftkeyIcon(iconPtr);
            }
        else if ( aIconContentId == KAiScutContent[EAiScutContentShortcutToolbarIcon].id )
            {
            iconResId = iActiveTarget->GetToolbarIcon(iconPtr);            
            }

        // No error, continue with the publish
        if (iconResId == 0)
        {
            if (iconPtr)
            {
                // Publish pointer.
                err = aObserver.PublishPtr(aPlugin, aIconContentId, iconPtr, iId);
                    
                if( err != KErrNone )
                    {
                    delete iconPtr;
                    }
            }
            else
            {
                // The target hasn't been able to initialize its icon, publish the empty icon.

                __PRINT( __DBG_FORMAT("XAI: PublishIcon publish empty #2 = %d"), emptyIconResId);

                err = aObserver.Publish(aPlugin, aIconContentId, emptyIconResId, iId);
            }
        }
        // Publish by resource
        else if (iconResId > 0)
        {
            // Publish resource.

            __PRINT( __DBG_FORMAT("XAI: PublishIcon publish resource = %d"), iconResId);

            err = aObserver.Publish(aPlugin, aIconContentId, iconResId, iId);
        }
        // < 0 error occurred, return it
        else
            {
            err = iconResId;
            }
    }

    return err;
}

// -----------------------------------------------------------------------------
// Set call state
// -----------------------------------------------------------------------------
//
void CAiScutShortcut::SetCallState(TBool aStatus)
{
    // Call state changed force the publish of RSK    
    if ( iActiveCall != aStatus )
        {
        if ( iId == KRightSoftkeyId )
            {
            iForcePublish = ETrue;
            }
        }
    iActiveCall = aStatus;
}

TPtrC CAiScutShortcut::ActiveDefinition()
    {
    if( iUserTarget )
        {
        return iUserTarget->Definition();
        }
    if( iDefaultTarget )
        {
        return iDefaultTarget->Definition();
        }
    return TPtrC();
    }
    
// ---------------------------------------------------------------------------
// Return the possible additional id
// ---------------------------------------------------------------------------
//    
TUid CAiScutShortcut::AdditionalUid() const
    {
    if( iUserTarget )
        {
        return iUserTarget->AdditionalUid();
        }
    if( iDefaultTarget )
        {
        return iDefaultTarget->AdditionalUid();
        }
    return TUid::Uid(-1);
    }

// ---------------------------------------------------------------------------
// CActive
// ---------------------------------------------------------------------------
//   
TInt CAiScutShortcut::RunError(TInt /*aError*/)
    {
    return KErrNone;
    }

// ---------------------------------------------------------------------------
// CActive
// ---------------------------------------------------------------------------
//   
void CAiScutShortcut::DoCancel()
    {
    CTimer::DoCancel();
    RProperty::Set( 
        KPSUidAiInformation, 
        KActiveIdleLaunch, 
        EPSAiLaunchNotActive );
    }

// ---------------------------------------------------------------------------
// CActive
// ---------------------------------------------------------------------------
//
void CAiScutShortcut::RunL()
    {
    RProperty::Set( 
        KPSUidAiInformation, 
        KActiveIdleLaunch, 
        EPSAiLaunchNotActive );
    }
// End of File.
hs_app_caiscutshortcutext.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in shortcut extensions
*
*/


#include 
#include 
#include 
#include 

#include "hs_app_caiscutshortcutext.h"
#include "aiscutcontentmodel.h"
#include "hs_app_caiscuttarget.h"
#include "hs_app_caiscutengineext.h"
#include "hs_app_PopupFSM.h"
#include "hs_app_cpopupeventhandler.h"
#include "hs_app_maiscutextdata.h"
#include "activeidle2domainpskeys.h"

#include "debug.h"


// P&S access policies
_LIT_SECURITY_POLICY_C1( KAiScutReadPolicy, ECapabilityReadDeviceData );
_LIT_SECURITY_POLICY_C1( KAiScutWritePolicy, ECapabilityWriteDeviceData );


// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcutExt* CAiScutShortcutExt::NewL(
    TInt aId, const TDesC& aTarget, CAiScutEngine& aEngine )
    {
    CAiScutShortcutExt* self = CAiScutShortcutExt::NewLC(
        aId, aTarget, aEngine );
    CleanupStack::Pop( self );
    return self;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcutExt* CAiScutShortcutExt::NewLC(
    TInt aId, const TDesC& aTarget, CAiScutEngine& aEngine )
    {
    CAiScutShortcutExt* self = new( ELeave ) CAiScutShortcutExt(
        aId, aEngine );
    CleanupStack::PushL( self );
    self->ConstructL( aTarget );
    return self;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcutExt::~CAiScutShortcutExt()
    {
    delete iPopupEventHandler;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcutExt::CAiScutShortcutExt( TInt aId, CAiScutEngine& aEngine )
    : CAiScutShortcut( aId, aEngine )//,
    //iPublishLineArray( EFalse )
    {
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutShortcutExt::ConstructL( const TDesC& aTarget )
    {
    iPopupEventHandler = CPopupEventHandler::NewL( *this );
    CAiScutShortcut::ConstructL( aTarget );

    RProperty::Define(
        KPSUidAiInformation,
        KActiveIdleThemeSupportsXsp,
        RProperty::EInt,
        KAiScutReadPolicy,
        KAiScutWritePolicy );
    RProperty::Set( KPSUidAiInformation, KActiveIdleThemeSupportsXsp, EPSAiXspNotSupported );
    }


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TPtrC CAiScutShortcutExt::ActiveTargetDefinition() const
    {
    if( iActiveTarget )
        {
        return iActiveTarget->Definition();
        }
    return KNullDesC();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutShortcutExt::HandleAIEventL( TInt aEvent )
    {
    switch ( aEvent )
        {
        case EAiScutEventLoseFocus:
            {
            iPopupEventHandler->PopupFSM().HandleLostFocus();
            break;
            }
        case EAiScutEventGainFocus:
            {
            iPopupEventHandler->PopupFSM().HandleGotFocus();
            break;
            }
        default:
            {
            break;
            }
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutShortcutExt::HandleResumed( TAiTransitionReason aResumeReason )
    {
    switch( aResumeReason )
        {
        case EAiIdleBackground:
            {
            iPopupEventHandler->PopupFSM().HandleBackground();
            break;
            }
        case EAiIdleForeground:
            {
            // Handleforeground() calls unnecessary publishes in case nothing
            // has changed. 
            if ( iTextChanged || iIconChanged )
                {
                iPopupEventHandler->PopupFSM().HandleForeground();
                }
            break;
            }
        default:
            {
            break;
            }
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutShortcutExt::SetAiScutExtData(
    const MAiScutExtData* aAiScutExtData )
    {
    iAiScutExtData = aAiScutExtData;

    const MDesCArray* newPopupLineArray =
        aAiScutExtData ? aAiScutExtData->PopupLineArray() : NULL;
    const CGulIcon* newIcon =
        aAiScutExtData ? aAiScutExtData->Icon() : NULL;
        
    if( iPreviousPopupLineArray != newPopupLineArray &&
        newPopupLineArray )
        {
        iTextChanged = ETrue;
        iPopupEventHandler->PopupFSM().HandleUpdate();        
        }
    else if( iPreviousPopupLineArray && !newPopupLineArray )
        {
        iTextChanged = ETrue;
        iPopupEventHandler->PopupFSM().HandleReset();
        }

    if( iPreviousIcon != newIcon )
        {
        iIconChanged = ETrue;
        CAiScutEngineExt& engine = static_cast< CAiScutEngineExt& > ( iEngine );
        engine.CheckAccessAndPublish( *this );
        }

    iPreviousPopupLineArray = newPopupLineArray;
    iPreviousIcon = newIcon;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutShortcutExt::PublishL(
    MAiPropertyExtension& aPlugin, MAiContentObserver& aObserver )
    {
    if( iLastPublishedTarget && iActiveTarget &&
        iLastPublishedTarget->Definition() != iActiveTarget->Definition() )
        {
        iAiScutExtData = NULL;
        iPopupEventHandler->PopupFSM().HandleReset();
        }

    if( aObserver.CanPublish(
        aPlugin, KAiScutContent[EAiScutContentPopupTextFirstLine].id, iId) &&
        aObserver.CanPublish(
        aPlugin, KAiScutContent[EAiScutContentPopupTextSecondLine].id, iId) &&
        aObserver.CanPublish(
        aPlugin, KAiScutContent[EAiScutContentPopupTextThirdLine].id, iId) )
        {
        PublishPopupText( aPlugin, aObserver );
        RProperty::Set( KPSUidAiInformation, KActiveIdleThemeSupportsXsp, EPSAiXspIsSupported );
        }

    CAiScutShortcut::PublishL( aPlugin, aObserver );
    iTextChanged = EFalse;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TInt CAiScutShortcutExt::PublishCaption(
    MAiPropertyExtension& aPlugin, MAiContentObserver& aObserver,
    TInt aCaptionContentId ) const
    {
    if( iPopupEventHandler->PublishCaption() )
        {
        if( !iPopupEventHandler->CaptionVisible() )
            {
            return aObserver.Clean( aPlugin, aCaptionContentId, iId );
            }
        else
            {
            return CAiScutShortcut::PublishCaption(
                aPlugin, aObserver, aCaptionContentId );
            }
        }
    else
        {
        return CAiScutShortcut::PublishCaption(
            aPlugin, aObserver, aCaptionContentId );
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutShortcutExt::PublishPopupText(
    MAiPropertyExtension& aPlugin, MAiContentObserver& aObserver ) const
    {
    if( iPopupEventHandler->PublishPopup() )
        {
        TAiScutContentIds popupTextContentIds[] =
            {
            EAiScutContentPopupTextFirstLine,
            EAiScutContentPopupTextSecondLine,
            EAiScutContentPopupTextThirdLine
            };
        const TInt idCount =
            sizeof( popupTextContentIds ) / sizeof( TAiScutContentIds );

        TInt err = KErrNone;

        //iLineArray is set or reset via xSP API. iPublishLineArray is controlled
        //by state machine in iPopupEventHandler
        if( iAiScutExtData && iAiScutExtData->PopupLineArray() &&
            iPopupEventHandler->PopupVisible() )
            {
            //Publish caption line in popup text box
            TPtrC captionDes;
            TInt captionResId = iActiveTarget->GetCaption( captionDes, EAiScutLongTitle );

            if ( captionResId == 0 )
                {
                // Publish descriptor
                err = aObserver.Publish( aPlugin,
                    KAiScutContent[ EAiScutContentPopupTextCaptionLine ].id,
                    captionDes, iId );
                if( err != KErrNone )
                    {
                    __PRINT( __DBG_FORMAT( "XAI:   publish Popup caption text err = %d" ), err );
                    }
                }
            else if ( captionResId > 0 )
                {
                // Publish resource
                err = aObserver.Publish( aPlugin,
                    KAiScutContent[ EAiScutContentPopupTextCaptionLine ].id,
                    captionResId, iId );
                if( err != KErrNone )
                    {
                    __PRINT( __DBG_FORMAT( "XAI:   publish Popup caption text (resource) err = %d" ), err );
                    }
                }

            const MDesCArray& lineArray = *iAiScutExtData->PopupLineArray();
            TInt numberOfLines = lineArray.MdcaCount();
            //Iterate each popup text content and either publish or clean it
            //depending on the number or lines in iLineArray
            for( TInt i = 0; i < idCount; i++ )
                {
                if( numberOfLines > i )
                    {
                    err = aObserver.Publish( aPlugin,
                        KAiScutContent[ popupTextContentIds[ i ] ].id,
                        lineArray.MdcaPoint( i ), iId );
                    if( err != KErrNone )
                        {
                        __PRINT( __DBG_FORMAT( "XAI:   publish Popup text err = %d" ), err );
                        }
                    }
                else
                    {
                    err = aObserver.Clean( aPlugin,
                        KAiScutContent[ popupTextContentIds[ i ] ].id, iId );
                    if( err != KErrNone )
                        {
                        __PRINT( __DBG_FORMAT( "XAI:   clean Popup text err = %d" ), err );
                        }
                    }
                }
            }
        else
            {
            //Clean each popup text content
            for( TInt i = 0; i < idCount; i++ )
                {
                err = aObserver.Clean( aPlugin,
                    KAiScutContent[ popupTextContentIds[ i ] ].id, iId );
                if ( err != KErrNone )
                    {
                    __PRINT( __DBG_FORMAT( "XAI:   clean Popup text err = %d" ), err );
                    }
                }
            }
        }
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TInt CAiScutShortcutExt::PublishIcon( MAiPropertyExtension& aPlugin,
    MAiContentObserver& aObserver, TInt aIconContentId )
    {
    if( aIconContentId == KAiScutContent[EAiScutContentShortcutIcon].id && 
		iAiScutExtData && iAiScutExtData->Icon() )
        {
        const CGulIcon& icon = *iAiScutExtData->Icon();
        CGulIcon* duplicatedIcon = NULL;
        TRAP_IGNORE(
            CFbsBitmap* bitmap = new( ELeave ) CFbsBitmap();
            CleanupStack::PushL( bitmap );
            CFbsBitmap* mask   = new( ELeave ) CFbsBitmap();
            CleanupStack::PushL( mask );

            User::LeaveIfError( bitmap->Duplicate( icon.Bitmap()->Handle() ) );
            User::LeaveIfError( mask->Duplicate( icon.Mask()->Handle() ) );

            duplicatedIcon = CGulIcon::NewL( bitmap, mask );

            CleanupStack::Pop( 2, bitmap );
            );

        if( duplicatedIcon )
            {
            TInt err = aObserver.PublishPtr( aPlugin,
                aIconContentId, duplicatedIcon, iId );
            if( err != KErrNone )
                {
                delete duplicatedIcon;
                }
            return err;
            }
        }
    
    TInt err = CAiScutShortcut::PublishIcon( aPlugin, aObserver, aIconContentId );
    iIconChanged = EFalse;
    return err;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutShortcutExt::IssuePublishShortcut()
    {
//    iPublishLineArray = aVisiblePopup;
    CAiScutEngineExt& engine = static_cast< CAiScutEngineExt& >( iEngine );
    engine.CheckAccessAndPublish( *this );
    }


// End of File.
hs_app_caiscutshortcutinfo.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Small container for shortcut info.
*
*/


#include "hs_app_caiscutshortcutinfo.h"

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcutInfo::CAiScutShortcutInfo(TInt aId)
    : iId(aId)
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutShortcutInfo::ConstructL(const TDesC& aTarget)
{
    iTarget = aTarget.AllocL();
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcutInfo* CAiScutShortcutInfo::NewL(TInt aId, const TDesC& aTarget)
{
    CAiScutShortcutInfo* self = new(ELeave) CAiScutShortcutInfo(aId);
    CleanupStack::PushL(self);
    self->ConstructL(aTarget);
    CleanupStack::Pop(self);
    return self;
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutShortcutInfo::~CAiScutShortcutInfo()
{
    delete iTarget;
}

// -----------------------------------------------------------------------------
// Returns the shortcut id.
// -----------------------------------------------------------------------------
//
TInt32 CAiScutShortcutInfo::Id() const
{
    return iId;
}

// -----------------------------------------------------------------------------
// Returns the shortcut target string.
// -----------------------------------------------------------------------------
//
const TDesC& CAiScutShortcutInfo::Target()
    {
    if( iTarget )
        return *iTarget;
    else
        return KNullDesC;
    }

// Eof
hs_app_caiscuttarget.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Base class for shortcut target
*
*/


#include "hs_app_caiscutengine.h"
#include "hs_app_caiscuttarget.h"
#include 
#include           // For AknsUtils
#include 
#include 
#include 
#include         // For CAknTaskList
#include            // For CApaWindowGroupName
#include 		// For Transition effect
#include 
#include 

// ======== MEMBER FUNCTIONS ========
_LIT(KFileLoadDir,"z:\\resource\\");
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTarget::CAiScutTarget(CAiScutEngine& aEngine, TShortcutType aType)
    : iEngine(aEngine)
    , iType(aType)
{
}

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTarget::~CAiScutTarget()
{
    
}

// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
TInt CAiScutTarget::GetCaption(TPtrC& /*aDes*/, TAiScutAppTitleType /*aTitleType*/) const
{
    // Default implementation.
    return KErrNotSupported;
}

TUid CAiScutTarget::AdditionalUid() const
    {
    return TUid::Uid(-1);
    }

// ---------------------------------------------------------------------------
// Returns the shortcut target icon.
// ---------------------------------------------------------------------------
//
TInt CAiScutTarget::GetIcon(const TAiScutIcon &aIconToLoad, CGulIcon*& aIcon ) const
{   
    TInt err = KErrNotSupported;
    
    if ( aIconToLoad.iType == EScutIconSkin )
        {
        TRAP(err, LoadIconFromSkinL(aIconToLoad, aIcon));
        }
    else if ( aIconToLoad.iType == EScutIconMif )
        {
        TRAP(err, LoadIconFromFileL(aIconToLoad, aIcon));
        }
    else if ( aIconToLoad.iType == EScutIconMbm )
        {
        TRAP(err, LoadIconFromFileL(aIconToLoad, aIcon));
        }
    
    return err;
}

TInt CAiScutTarget::GetIcon(CGulIcon*& aIcon) const
    {
    return GetIcon(iOverrideIcon, aIcon);
    }

TInt CAiScutTarget::GetSoftkeyIcon(CGulIcon*& aIcon) const
    {
    return GetIcon(iSoftkeyIcon, aIcon);
    }

TInt CAiScutTarget::GetToolbarIcon(CGulIcon*& aIcon) const
    {
    return GetIcon(iToolbarIcon, aIcon);
    }
    
void CAiScutTarget::SetOverrideIcon(TAiScutIcon aIcon)
    {
    iOverrideIcon = aIcon;
    }

void CAiScutTarget::SetSoftkeyIcon(TAiScutIcon aIcon)
    {
    iSoftkeyIcon = aIcon;
    }

void CAiScutTarget::SetToolbarIcon(TAiScutIcon aIcon)
    {
    iToolbarIcon = aIcon;
    }

void CAiScutTarget::LoadIconFromSkinL(const TAiScutIcon &aIconToLoad, CGulIcon*& aIcon) const
    {
    CFbsBitmap* bitmap = NULL;
	CFbsBitmap* bitmapMask = NULL;
	
    // With colour group support
    if ( aIconToLoad.iColourGroup >= EAknsCIQsnTextColorsCG1 &&
           aIconToLoad.iColourGroup <= EAknsCIQsnTextColorsCG62)
        {
        
        AknsUtils::CreateColorIconLC(
            AknsUtils::SkinInstance(),
            aIconToLoad.iSkinId,
            KAknsIIDQsnTextColors,
            aIconToLoad.iColourGroup,
            bitmap,
            bitmapMask,
            KNullDesC,  /* no backup */
            0,          /* no backup */
            0,          /* no backup */
            KRgbBlack );
            
        if ( bitmap )
            {
            aIcon = CGulIcon::NewL( bitmap, bitmapMask );              
            }
        CleanupStack::Pop( 2 ); // bitmap, bitmapMask
        }
    // no colour group support
    else
        {
        aIcon = AknsUtils::CreateGulIconL( AknsUtils::SkinInstance(), aIconToLoad.iSkinId, KNullDesC, 0, 0 );
        }
    if ( !aIcon )
        {
        User::Leave( KErrNotFound );
        }
    }

void CAiScutTarget::LoadIconFromFileL(const TAiScutIcon &aIconToLoad, CGulIcon*& aIcon) const 
    {
    CFbsBitmap* bitmap = NULL;
	CFbsBitmap* bitmapMask = NULL;
    TFileName actualPath;
    TInt iconIndexStart = 0;
    
    if ( aIconToLoad.iType == EScutIconMif )
        {
        iconIndexStart = KMifIdFirst;
        }
    actualPath.Append(KFileLoadDir);
    actualPath.Append(aIconToLoad.iPath);
    
    RFs fs; fs.Connect();
	if ( aIconToLoad.iIconId < 0 || !BaflUtils::FileExists(fs, actualPath))
		{
		fs.Close();
		User::Leave( KErrNotFound );
		}
    fs.Close();
	// Mask is next after bitmap
    AknIconUtils::CreateIconLC(bitmap,bitmapMask, actualPath,
        aIconToLoad.iIconId+iconIndexStart, aIconToLoad.iIconId+iconIndexStart+1);
      

    aIcon = CGulIcon::NewL(bitmap, bitmapMask);

    CleanupStack::Pop(bitmapMask);    
    CleanupStack::Pop(bitmap);
    
    if ( !aIcon )
        {
        User::Leave( KErrNotFound );        
        }
    
    }

// ---------------------------------------------------------------------------
// Returns the shortcut target type.
// ---------------------------------------------------------------------------
//
TShortcutType CAiScutTarget::Type() const
{
    return iType;
}

// ---------------------------------------------------------------------------
// Determines which effect should be shown, and starts it.
// ---------------------------------------------------------------------------
//
void CAiScutTarget::BeginEffectL()
	{
	RWsSession& aWs = iEngine.Env()->WsSession();
	TUid appUid = AppUid();
	TInt effectType = AknTransEffect::EApplicationStart;
	CAknTaskList* taskList = CAknTaskList::NewL( aWs );
	TApaTask task = taskList->FindRootApp( appUid );
	delete taskList;
	
	if ( task.Exists() )
		{
		TBool inHiddenList = iEngine.IsHiddenFromFSW(appUid);
		CApaWindowGroupName* wgName = CApaWindowGroupName::NewL( aWs, task.WgId() );
		wgName->SetAppUid( appUid );
		const TBool isHidden = wgName->Hidden() || inHiddenList;
		delete wgName;
				
		if (!isHidden)
			{
			effectType = AknTransEffect::EApplicationStartSwitchRect;
			}
		
		//start a full screen effect
		GfxTransEffect::BeginFullScreen( effectType,
		TRect(0,0,0,0), 
		AknTransEffect::EParameterType, 
		AknTransEffect::GfxTransParam( appUid, 
		AknTransEffect::TParameter::EActivateExplicitContinue ) );
		}
	}

// End of File.
hs_app_caiscuttargetapp.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for application shortcut target
*
*/


#include             // For CCoeEnv
#include              // For RWsSession
#include 
#include 
#include            // For CApaCommandLine
#include             // For TApaTaskList
#include            // For CApaWindowGroupName
#include             // For CGulIcon
#include           // For AknsUtils
#include         // For CAknTaskList
#include 		// For Transition effect
#include 
#include             // For CVwsSessionWrapper
#include 
#ifdef SYMBIAN_ENABLE_SPLIT_HEADERS
#include 
#endif

#include 
#include 
#include 
#include 
#include 

#include 
//#include 
#include 

#include 

#include "aiscutcontentmodel.h"
#include "hs_app_caiscuttargetapp.h"
#include "hs_app_caiscutengine.h"

#include 
#include "debug.h"

#include 

const TInt KIconSizeArray = 4;

// ======== MEMBER FUNCTIONS =================================================

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetApp::CAiScutTargetApp(
    CAiScutEngine& aEngine, TShortcutType aType, const TUid aUid)
    : CAiScutTarget(aEngine, aType)
    , iAppUid(aUid)
    {
    }


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutTargetApp::ConstructL(const TAiScutParser& aParser)
    {
    iDefinition = aParser.Get(EScutDefComplete).AllocL();

    iViewUid.iUid = -1;

    switch (Type())
        {
    case EScutApplicationView:
    case EScutChangeTheme:
        if (iAppUid == KScutAppShellUid)
            {
            iViewUid.iUid = 1; // activate always appshell main view.
            }
        else
            {
            iViewUid = TAiScutParser::ParseUid(aParser.Get(EScutDefParamValue));
            }
        break;

    case EScutLogsMissedCallsView:
        iMsg = TPtrC8(KLogsMissedCallsView).AllocL();
        break;

    case EScutLogsDialledCallsView:
        iMsg = TPtrC8(KLogsDialledCallsView).AllocL();
        break;

    case EScutLogsReceivedCallsView:
        iMsg = TPtrC8(KLogsReceivedCallsView).AllocL();
        break;

    case EScutLogsMainView:
        iMsg = TPtrC8(KLogsMainView).AllocL();
        break;

    case EScutApplicationWithParams:
        {
        TPtrC ptr = aParser.Get(EScutDefParamNameAndValue);
        iMsg = EscapeUtils::ConvertFromUnicodeToUtf8L(ptr);
        break;
        }

    default:
        break;
        }

    }


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetApp* CAiScutTargetApp::NewL(
    CAiScutEngine& aEngine, TShortcutType aType, const TAiScutParser& aParser)
    {
    CAiScutTargetApp* self =
        new (ELeave) CAiScutTargetApp(aEngine, aType, aParser.Uid());

    CleanupStack::PushL(self);
    self->ConstructL(aParser);

    CleanupStack::Pop(self);

    return self;
    }


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetApp::~CAiScutTargetApp()
    {
    delete iCaption;
    delete iShortCaption;
	delete iMsg;
    delete iDefinition;
    }


// ---------------------------------------------------------------------------
// Returns the shortcut definition string.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutTargetApp::Definition() const
    {
    return iDefinition ? TPtrC(*iDefinition) : TPtrC();
    }


// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetApp::GetCaption(TPtrC& aDes, TAiScutAppTitleType aTitleType) const
    {
    TRAP_IGNORE(GetCaptionL(aTitleType));

    if (aTitleType == EAiScutSkeyTitle)
        {
        aDes.Set(iShortCaption ? *iShortCaption : KNullDesC());
        }
    else
        {
        aDes.Set(iCaption ? *iCaption : KNullDesC());
        }

    return 0;
    }

// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
void CAiScutTargetApp::GetCaptionL(TAiScutAppTitleType aTitleType) const
    {
    TApaAppInfo appInfo;

    // Use lazy evaluation, create the caption only when it is first needed.
    if (aTitleType == EAiScutSkeyTitle)
        {
        if( !iShortCaption )
            {
            iEngine.ApaSession().GetAppInfo(appInfo, iAppUid);
            iShortCaption = appInfo.iShortCaption.AllocL();            
            }
        }
    else
        {
        if (!iCaption)
            {
            iEngine.ApaSession().GetAppInfo(appInfo, iAppUid);
            iCaption = appInfo.iCaption.AllocL();
            }
        }
    }

// ---------------------------------------------------------------------------
// Returns the shortcut target icon.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetApp::GetIcon(CGulIcon*& aIcon) const
    {
    // First try to make the override icon
    // if not successful then do it ourself
    if ( CAiScutTarget::GetIcon(aIcon) != KErrNone )
        {
        TRAP_IGNORE(CreateAppIconL(aIcon));
        }


    return 0;
    }

// ---------------------------------------------------------------------------
// Returns the shortcut target icon for toolbar.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetApp::GetToolbarIcon(CGulIcon*& aIcon) const
    {
    if ( CAiScutTarget::GetToolbarIcon(aIcon) != KErrNone)
        {
        TRAP_IGNORE(CreateAppIconL(aIcon));
        }

    return 0;
    }

// ---------------------------------------------------------------------------
// Creates the application icon.
// ---------------------------------------------------------------------------
//

void CAiScutTargetApp::CreateAppIconL(CGulIcon*& aIcon) const
    {
    // To make sure we won't end up with a partially created icon, we first create
    // a temporary icon and take it into use only when it is propertly initialized.
    CGulIcon* tempIcon = NULL;
    TInt err = KErrNone;

    // If no scalable icon support is available then the icon is constructed the "old way"
    // java icon separately from the native icon. If the support is available then the
    // java icon is constructed the same way the native icon is constructed.

    const TBool isNonNative = iEngine.IsNonNative(iAppUid);

    // First try to create a normal non-native icon
    if (isNonNative)
        {
        TRAP(err,
            tempIcon = CreateNonNativeIconL()
            );
        // Just to be sure
        if (err != KErrNone)
            {
            tempIcon = NULL;
            }
        }
    // No icon yet so either native icon or non-native SVG icon.
    if (!tempIcon)
        {
        MAknsSkinInstance* skin = AknsUtils::SkinInstance();
        if ((iAppUid == KScutPersonalisationUid && iViewUid == KScutChangeThemeViewId)
         || (iAppUid == KScutGeneralSettingsUid && (iViewUid == KScutInstallationViewId
                               ||  iViewUid == KScutConnectivityViewId))
          )
          {
          tempIcon = CreateSubstituteIconL(skin, iAppUid, iViewUid);
          }
    else
      {
          CFbsBitmap* bitmap = NULL;
          CFbsBitmap* mask   = NULL;

        AknsUtils::CreateAppIconLC(skin, iAppUid, EAknsAppIconTypeList, bitmap, mask);
        if (bitmap)
          {
        tempIcon = CGulIcon::NewL(bitmap, mask);
        CleanupStack::Pop(2);   // Bitmap and mask. They have to be popped out by number
                                    // because the order in which they are pushed in is undefined.
        }

          }

    }

    aIcon = tempIcon;
  }


CGulIcon* CAiScutTargetApp::CreateSubstituteIconL( MAknsSkinInstance* aSkin, TUid aAppUid, TUid iViewUid ) const
  {
  CGulIcon* tempIcon = NULL;
  TParse* parse = new (ELeave) TParse;
    CleanupStack::PushL(parse);
    parse->Set(KBitmapFile, &KDC_APP_BITMAP_DIR, NULL);
    HBufC* fileName = parse->FullName().AllocLC();
  TPtr fileNamePtr = fileName->Des();

  //change idle theme
  if (aAppUid == KScutPersonalisationUid && iViewUid == KScutChangeThemeViewId)
      {
      tempIcon = AknsUtils::CreateGulIconL(
          aSkin,
          KAknsIIDQgnPropPslnAiSub,
          fileNamePtr,
            EMbmAiscutpluginQgn_prop_psln_ai_sub,
          EMbmAiscutpluginQgn_prop_psln_ai_sub_mask);
      }
    //appmngr
    else if(aAppUid == KScutGeneralSettingsUid && iViewUid == KScutInstallationViewId)
      {
      CFbsBitmap* bitmap = NULL;
      CFbsBitmap* mask   = NULL;

    AknsUtils::CreateAppIconLC(aSkin, KScutAppMngrUid, EAknsAppIconTypeList, bitmap, mask);
    
    // The icon may reside in cache so we need to exclude in order
    // for updated icons to be loaded properly.
    AknIconUtils::ExcludeFromCache( bitmap );
    if (bitmap)
      {
      tempIcon = CGulIcon::NewL(bitmap, mask);
      CleanupStack::Pop(2);   // Bitmap and mask. They have to be popped out by number
                  // because the order in which they are pushed in is undefined.
      }
      }
    //connectivity view
    else if(aAppUid == KScutGeneralSettingsUid && iViewUid == KScutConnectivityViewId)
      {
      tempIcon = AknsUtils::CreateGulIconL(
          aSkin,
          KAknsIIDQgnPropAiShortcut,
          fileNamePtr,
            EMbmAiscutpluginQgn_prop_cp_conn_shortcut,
          EMbmAiscutpluginQgn_prop_cp_conn_shortcut_mask);
      }
    else
      {
      //never should go here!
      }

      CleanupStack::PopAndDestroy(2, parse); // fileName, parse
      return tempIcon;
  }

// ---------------------------------------------------------------------------
// Creates the NonNative application icon.
// ---------------------------------------------------------------------------
//

CGulIcon* CAiScutTargetApp::CreateNonNativeIconL() const
    {
    CApaMaskedBitmap* maskedbitmap = CApaMaskedBitmap::NewLC();

    CArrayFixFlat* sizesArray = new (ELeave) CArrayFixFlat(KIconSizeArray);
    CleanupStack::PushL(sizesArray);

    TInt err = iEngine.ApaSession().GetAppIconSizes(iAppUid, *sizesArray);

    // If there is no error and there is something in array
    // use first icon size and get an icon.
    if (!err && sizesArray->Count())
        {
        err = iEngine.ApaSession().GetAppIcon(iAppUid, sizesArray->At(0), *maskedbitmap);
        }

    // If there was an error, delete every allocated object and leave.
    if (err)
        {
        CleanupStack::PopAndDestroy(sizesArray);
        CleanupStack::PopAndDestroy(maskedbitmap);
        User::Leave(err);
        }

    CFbsBitmap* bitmap = new (ELeave) CFbsBitmap();
    CleanupStack::PushL(bitmap);
    CFbsBitmap* mask   = new (ELeave) CFbsBitmap();
    CleanupStack::PushL(mask);

    User::LeaveIfError(bitmap->Duplicate(maskedbitmap->Handle()));
    User::LeaveIfError(mask->Duplicate(maskedbitmap->Mask()->Handle()));

    CGulIcon* icon = CGulIcon::NewL(bitmap, mask);
    //icon->SetBitmapsOwnedExternally(ETrue);

    CleanupStack::Pop(mask);
    CleanupStack::Pop(bitmap);

    CleanupStack::PopAndDestroy(sizesArray);
    CleanupStack::PopAndDestroy(maskedbitmap);

    return icon;
    }

// ---------------------------------------------------------------------------
// Checks if the target application is accessible.
// ---------------------------------------------------------------------------
//
TBool CAiScutTargetApp::IsAccessibleL(TInt /*aCheckType*/)
    {
    if (iAppUid == KNullUid || iEngine.IsHidden(iAppUid))
        {
        return EFalse;
        }

    TApaAppInfo appInfo;
    TInt ret = iEngine.ApaSession().GetAppInfo(appInfo, iAppUid);

    if (ret == RApaLsSession::EAppListInvalid)
        {
        // Application list not fully populated yet. Leave with KErrNotReady so
        // the engine can trap it and start the timer to check accessiblity later.
        User::Leave(KErrNotReady);
        }

    return (ret == KErrNone);
    }


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutTargetApp::LaunchL()
    {
    LaunchL( KNullDesC8 );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutTargetApp::LaunchL( const TDesC8& aCustomMessage )
    {
    __PRINTS( "XAI: CAiScutShortcut::LaunchL");
    __PRINT( __DBG_FORMAT("XAI:   type = %d"), Type());

    if (iAppUid != KNullUid)
        {

        // Some special cases
        // ---------------------------------
        if( Type() == EScutApplicationView &&
            iAppUid == KScutGeneralSettingsUid )
            {
            CGSLauncher* l = CGSLauncher::NewLC();
            l->LaunchGSViewL ( iViewUid,
                               KScutActiveIdleUid,
                               aCustomMessage );            
            CleanupStack::PopAndDestroy( l );
            
            return;    
            }
        else if ( ( ( Type() == EScutChangeTheme) && ( iAppUid == KScutPersonalisationUid ) ) ||  // For AI2 Themes
                  ( iAppUid == KScutDiallerUid ) )                                                // Dialer
            {
            const TVwsViewId viewId(iAppUid, iViewUid);
            TUid msgId = KScutGeneralSettingsUid;
            
            if( iAppUid == KScutDiallerUid ) 
                {
                msgId = KScutDiallerViewCommand;
                RProperty::Set(KPSUidAiInformation, KActiveIdleState, EPSAiNumberEntry );
                }

            TInt err = iEngine.VwsSession()->CreateActivateViewEvent( viewId, msgId, aCustomMessage );

            return;
            }

        TBool         exists = EFalse;

        CAknTaskList* taskList = CAknTaskList::NewL(iEngine.Env()->WsSession());
        TApaTask      task(taskList->FindRootApp(iAppUid));
        delete        taskList;

        exists = task.Exists();

        // If not found, try again little harder
        // ----------------------------------------
        if (!exists)
            {
            RWsSession wsSession = iEngine.Env()->WsSession();
            task.SetWgId(0);                // Set task to non-existant task
            TInt wgId=0;
            CApaWindowGroupName::FindByAppUid(iAppUid, wsSession, wgId);

            if (wgId != KErrNotFound)
                {
                exists = ETrue;
            task.SetWgId(wgId);
                }
            }

        // Actual reactivatio / starting
        // -----------------------------
        if (exists)       // Found, reactivate
            {
            if (iMsg && iMsg->Length())
                {
                task.SendMessage(KNullUid, *iMsg);
                }
            if ( iAppUid == KScutAppShellUid ) // AppShell effect is an exception
            	{
            	//start different fullscreen effect when launching appshell
            	GfxTransEffect::BeginFullScreen( AknTransEffect::EApplicationActivate ,
            			TRect(0,0,0,0),
            	        AknTransEffect::EParameterType,
            	        AknTransEffect::GfxTransParam( iAppUid,
            	        AknTransEffect::TParameter::EActivateExplicitContinue ) );        
            	}
            
            if( iAppUid == KScutAppShellUid ) // Appshell starting is an exception
                {
                task.SendMessage( KUidApaMessageSwitchOpenFile , KNullDesC8 );
                }
            else
                {
                // If message was sent, don't try to bring task to foreground as task will do it itself
                if ( !( (iAppUid == KScutLogsUid) && (iMsg && iMsg->Length() > 0)) )
                    {
                    CAknSgcClient::MoveApp(task.WgId(), ESgcMoveAppToForeground);
                    }
                }
            }
        else             // Not exists, starting
            {
            TApaAppInfo appInfo;

            if (iEngine.ApaSession().GetAppInfo(appInfo, iAppUid) == KErrNone)
                {
                if (FeatureManager::FeatureSupported(KFeatureIdCommonVoip) &&
                    (iAppUid == KScutEasyVoIPApplicationUid) )
                    {
                    SetEasyVoIPShortcutStartL();
                    }

                CApaCommandLine* cmdLine = CApaCommandLine::NewLC();
                cmdLine->SetExecutableNameL(appInfo.iFullName);
                if (iMsg && iMsg->Length())
                    {
                    cmdLine->SetCommandL(EApaCommandRun);
                    cmdLine->SetTailEndL(*iMsg);
                    }
                if (iBackground)
                    {
                    cmdLine->SetCommandL(EApaCommandBackground);
                    }
                if ( iAppUid == KScutVoiceDialUid )
                	{
                	cmdLine ->SetCommandL( EApaCommandRunWithoutViews );
                	}

                TInt err = iEngine.ApaSession().StartApp(*cmdLine);


                __PRINT( __DBG_FORMAT("XAI:   StartApp err = %d"), err);

                User::LeaveIfError(err);

                CleanupStack::PopAndDestroy(cmdLine);
                }
            }
        }
    }


// ---------------------------------------------------------------------------
// Return application uid this target launches.
// ---------------------------------------------------------------------------
//
TUid CAiScutTargetApp::AppUid() const
    {

#ifdef __WEB_WIDGETS
    // for widgets return widgetapp uid.
    if (iEngine.IsWidget(iAppUid))
        {
        return KUidWidgetUi;
        }
#endif

    return iAppUid;
    }

// ---------------------------------------------------------------------------
// Return the view id
// ---------------------------------------------------------------------------
//
TUid CAiScutTargetApp::AdditionalUid() const
    {
    return iViewUid;
    }

// ---------------------------------------------------------------------------
// CScShortcutNativeApp::SetEasyVoIPShortcutStartL()
//
// Performs Central Repository shortcut set for EasyVoIP application.
// ---------------------------------------------------------------------------
//
void CAiScutTargetApp::SetEasyVoIPShortcutStartL() const
    {
    CRepository* repository = CRepository::NewL(KUidEasyVoIPRepository);
    CleanupStack::PushL(repository);

    // Set shortcut start for EasyVoIP application.
    TInt error = repository->Set(KEasyVoIPShortcutStartup, 1);
    User::LeaveIfError(error);

    CleanupStack::PopAndDestroy(repository);
    }

// End of File.
hs_app_caiscuttargetbkm.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for bookmark shortcut target
*
*/


#include             // For CCoeEnv
#include              // For RWsSession
#include             // For TApaTaskList
#include             // For CGulIcon
#include           // For AknsUtils
#include 

#include "aiscutcontentmodel.h"
#include "hs_app_caiscuttargetbkm.h"
#include "hs_app_caiscutengine.h"
#include 

#include "debug.h"



_LIT16(KParam, "1 ");
const TInt KTBUF16 = 16;

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetBkm::CAiScutTargetBkm(CAiScutEngine& aEngine, TShortcutType aType)
    : CAiScutTarget(aEngine, aType)
{
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutTargetBkm::ConstructL(const TAiScutParser& aParser)
{
    iDefinition = aParser.Get(EScutDefComplete).AllocL();
    iBkmUid = aParser.ParseUid(aParser.Get(EScutDefParamValue));
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetBkm* CAiScutTargetBkm::NewL(
    CAiScutEngine& aEngine, TShortcutType aType, const TAiScutParser& aParser)
{
    CAiScutTargetBkm* self = new (ELeave) CAiScutTargetBkm(aEngine, aType);

    CleanupStack::PushL(self);
    self->ConstructL(aParser);
    CleanupStack::Pop(self);

    return self;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetBkm::~CAiScutTargetBkm()
{
    delete iCaption;
    delete iDefinition;
}


// ---------------------------------------------------------------------------
// Returns the shortcut definition string.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutTargetBkm::Definition() const
{
    return iDefinition ? TPtrC(*iDefinition) : TPtrC();
}


// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetBkm::GetCaption(TPtrC& aDes, TAiScutAppTitleType /*aTitleType*/) const
{
    // Use lazy evaluation, create the caption only when it is first needed.
    if (!iCaption)
    {
        // Get the caption.
        TRAP_IGNORE(GetCaptionL());
    }

    aDes.Set(iCaption ? *iCaption : KNullDesC());

    return 0;
}

// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
void CAiScutTargetBkm::GetCaptionL() const
{
    RFavouritesDb& db = iEngine.FavouritesDb();

    CFavouritesItem* favItem = CFavouritesItem::NewLC();
    TInt err = db.Get(iBkmUid.iUid, *favItem);
    iCaption = favItem->Name().AllocL();

    CleanupStack::PopAndDestroy(favItem);
}


// ---------------------------------------------------------------------------
// Returns the shortcut target icon.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetBkm::GetIcon(CGulIcon*& aIcon) const
{
     if ( CAiScutTarget::GetIcon(aIcon) != KErrNone )
        {
        
        CGulIcon* tempIcon = NULL;

        TFileName pluginIconFile(KDC_APP_BITMAP_DIR);
        pluginIconFile.Append(KBitmapFile);

        TRAP_IGNORE(
            tempIcon = AknsUtils::CreateGulIconL(
                AknsUtils::SkinInstance(),
                KAknsIIDQgnPropAiShortcut,
                pluginIconFile,
                EMbmAiscutpluginQgn_menu_url,
                EMbmAiscutpluginQgn_menu_url_mask
                )
            );

        aIcon = tempIcon;
        }

    return 0;
}

// -----------------------------------------------------------------------------
// Checks if the target bookmark is accessible.
// -----------------------------------------------------------------------------
//
TBool CAiScutTargetBkm::IsAccessibleL(TInt /*aCheckType*/)
{
    if (iBkmUid == KNullUid)
    {
        return EFalse;
    }

    // Search bookmark from favourites.
    RFavouritesDb& db = iEngine.FavouritesDb();

    TBool exists = EFalse;
    TInt err = db.ItemExists(iBkmUid.iUid, exists);
    if (err != KErrNone)
    {
        exists = EFalse;
    }

    return exists;
}


// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
//
void CAiScutTargetBkm::LaunchL()
{
/*
1. Start/Continue the browser and nothing is specified (the default case)   Parameter = 
2. Start/Continue the browser specifying a Bookmark                         Parameter = "1"+""+""
3. Start/Continue the browser specifying a Saved deck                       Parameter = "2"+""+""
4. Start/Continue the browser specifying a URL                              Parameter = "4"+""+""
5. Start/Continue the browser specifying a URL and an Access Point          Parameter = "4"+""+""+""+""
6. Start/Continue the browser with the start page.
   (Used when starting the browser with a long press of "0" in the
   Idle state of the phone.                                                 Parameter = "5"
7. Start/Continue the browser specifying a Bookmark folder                  Parameter = "6"+""+""
*/

    TApaTaskList taskList(iEngine.Env()->WsSession());
    TApaTask task = taskList.FindApp(KScutBrowserUid);

    
    TBuf param(KParam);
    param.AppendNum(iBkmUid.iUid);

	__PRINT( __DBG_FORMAT("XAI: CAiScutTargetBkm::LaunchL '%S' "), &param);
    
    if (task.Exists())
    {
        HBufC8* param8 = HBufC8::NewLC(param.Length());
        param8->Des().Copy(param);
        task.SendMessage(KNullUid, *param8); // Uid is not used.
        CleanupStack::PopAndDestroy(param8);
    }
    else
    {
        TThreadId id;
        User::LeaveIfError(iEngine.ApaSession().StartDocument(
            param, KScutBrowserUid, id));
    }
}

// ---------------------------------------------------------------------------
// Return application uid this target launches.
// ---------------------------------------------------------------------------
//
TUid CAiScutTargetBkm::AppUid() const
{
    return KScutBrowserUid;
}

// ---------------------------------------------------------------------------
// Return the bkm id
// ---------------------------------------------------------------------------
TUid CAiScutTargetBkm::AdditionalUid() const
    {
    return iBkmUid;
    }

// End of File.
hs_app_caiscuttargetempty.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for empty target.
*
*/


#include "hs_app_caiscuttargetempty.h"

// ----------------------------------------------------------------------------
// CAiScutEmpty::CAiScutEmpty
// ----------------------------------------------------------------------------
//
CAiScutTargetEmpty::CAiScutTargetEmpty(CAiScutEngine& aEngine, TShortcutType aType)
    : CAiScutTarget(aEngine, aType)
{
}

// ----------------------------------------------------------------------------
// CAiScutEmpty::ConstructL
// ----------------------------------------------------------------------------
//
void CAiScutTargetEmpty::ConstructL(const TDesC& aTarget)
{
    iDefinition = aTarget.AllocL();
}

// ----------------------------------------------------------------------------
// CAiScutEmpty::NewL
// ----------------------------------------------------------------------------
//
CAiScutTargetEmpty* CAiScutTargetEmpty::NewL(
    CAiScutEngine& aEngine, TShortcutType aType, const TDesC& aTarget)
{
    CAiScutTargetEmpty* self = new (ELeave) CAiScutTargetEmpty(aEngine, aType);

    CleanupStack::PushL(self);
    self->ConstructL(aTarget);
    CleanupStack::Pop(self);

    return self;
}

// ----------------------------------------------------------------------------
// CAiScutEmpty::~CAiScutEmpty
// ----------------------------------------------------------------------------
//
CAiScutTargetEmpty::~CAiScutTargetEmpty()
{
    delete iDefinition;
}

// ---------------------------------------------------------------------------
// Returns the shortcut definition string
// ---------------------------------------------------------------------------
//
TPtrC CAiScutTargetEmpty::Definition() const
{
    return iDefinition ? TPtrC(*iDefinition) : TPtrC();
}

// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetEmpty::GetCaption(TPtrC& aDes, TAiScutAppTitleType /*aTitleType*/) const
{
    aDes.Set(KNullDesC());
    return 0;
}

// ---------------------------------------------------------------------------
// Returns the shortcut target icon.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetEmpty::GetIcon(CGulIcon*& aIcon) const
{
    aIcon = NULL;
    return 0;
}

// -----------------------------------------------------------------------------
// Checks if the target is accessible
// -----------------------------------------------------------------------------
//
TBool CAiScutTargetEmpty::IsAccessibleL(TInt /*aCheckType*/)
{
    return (iType != EScutUnknown);
}

// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
//
void CAiScutTargetEmpty::LaunchL()
{
}

// ---------------------------------------------------------------------------
// Return application uid this target launches.
// ---------------------------------------------------------------------------
//
TUid CAiScutTargetEmpty::AppUid() const
{
    return KNullUid;
}

//  End of File.
hs_app_caiscuttargethttp.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for http shortcut target
*
*/


#include             // For CCoeEnv
#include              // For RWsSession
#include             // For TApaTaskList
#include             // For CGulIcon
#include           // For AknsUtils
#include 

#include "hs_app_caiscuttargethttp.h"
#include "hs_app_caiscutengine.h"
#include 

#include "debug.h"

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetHttp::CAiScutTargetHttp(CAiScutEngine& aEngine, TShortcutType aType)
    : CAiScutTarget(aEngine, aType)
{
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutTargetHttp::ConstructL(const TAiScutParser& aParser)
{
    iDefinition = aParser.Get( EScutDefComplete ).AllocL();
    iChecksum = TUid::Uid( aParser.ChecksumForString( *iDefinition) );
    
    // Get the possible custom title string from the parser
    iCaption = HBufC::NewL( iDefinition->Length() ); 
    TPtr captionPtr = iCaption->Des();
    TInt err = aParser.CustomTitle( captionPtr );    
    
    if ( err != KErrNone || iCaption->Length() <= 0 )
        {
        delete iCaption;
        iCaption = NULL;
        }
    TPtr defPtr = iDefinition->Des();    
    // we need to strip the possible icon definitions away from 
    // the URL as they are not part of it.
    aParser.RemoveExtraDefinitionsL( defPtr );
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetHttp* CAiScutTargetHttp::NewL(
    CAiScutEngine& aEngine, TShortcutType aType, const TAiScutParser& aParser)
{
    CAiScutTargetHttp* self = new (ELeave) CAiScutTargetHttp(aEngine, aType);

    CleanupStack::PushL(self);
    self->ConstructL(aParser);
    CleanupStack::Pop(self);

    return self;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetHttp::~CAiScutTargetHttp()
{
    delete iDefinition;
    delete iCaption;
}


// ---------------------------------------------------------------------------
// Returns the shortcut definition string.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutTargetHttp::Definition() const
{
    return iDefinition ? TPtrC(*iDefinition) : TPtrC();
}


// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetHttp::GetCaption(TPtrC& aDes, TAiScutAppTitleType /*aTitleType*/) const
{
    // Custom title is fetched when constructing. If no custom
    // title then use part of the URL as title
    if ( !iCaption )
    {        
        TUriParser parser;
        TInt err = parser.Parse(*iDefinition);

        if (err == KErrNone)
            {
            // Remove scheme from the url.
            iCaption = parser.Extract(EUriHost).Alloc();
            }
        else
            {
            iCaption = iDefinition->Alloc();
            }
    }

    aDes.Set(*iCaption);

    return 0;
}


// ---------------------------------------------------------------------------
// Returns the shortcut target icon.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetHttp::GetIcon(CGulIcon*& aIcon) const
{

    if ( CAiScutTarget::GetIcon(aIcon) != KErrNone )
        {
        CGulIcon* tempIcon = NULL;

        TFileName pluginIconFile(KDC_APP_BITMAP_DIR);
        pluginIconFile.Append(KBitmapFile);

        TRAP_IGNORE(
            tempIcon = AknsUtils::CreateGulIconL(
                AknsUtils::SkinInstance(),
                KAknsIIDQgnPropAiShortcut,
                pluginIconFile,
                EMbmAiscutpluginQgn_menu_url,
                EMbmAiscutpluginQgn_menu_url_mask
                )
            );

        aIcon = tempIcon;
        }
    return 0;
}


// ---------------------------------------------------------------------------
// Checks if the shortcut target is accessible.
// ---------------------------------------------------------------------------
//
TBool CAiScutTargetHttp::IsAccessibleL(TInt /*aCheckType*/)
{
    return (iDefinition->Length() > 0);
}


// -----------------------------------------------------------------------------
// Launches the browser
// -----------------------------------------------------------------------------
//
void CAiScutTargetHttp::LaunchL()
{
    // Store the http address directly in the browser parameter format.
    // For example "4 http://www.nokia.com". 4 = open an url.
    HBufC* param = HBufC::NewLC(iDefinition->Length() + KOpenUrlParam().Length());
    param->Des().Copy(KOpenUrlParam());
    param->Des().Append(*iDefinition);

    __PRINT( __DBG_FORMAT("XAI: CAiScutTargetHttp::LaunchL '%S' "), param);

    TApaTaskList taskList(iEngine.Env()->WsSession());
    TApaTask task = taskList.FindApp(KScutBrowserUid);

    if (task.Exists())
    {
        HBufC8* param8 = HBufC8::NewLC(param->Length());
        param8->Des().Copy(*param);
        task.SendMessage(KNullUid, *param8); // Uid is not used.
        CleanupStack::PopAndDestroy(param8);
    }
    else
    {
        TThreadId id;
        User::LeaveIfError(iEngine.ApaSession().StartDocument(
            *param, KScutBrowserUid, id));
    }

    CleanupStack::PopAndDestroy(param);
}

// ---------------------------------------------------------------------------
// Return application uid this target launches.
// ---------------------------------------------------------------------------
//
TUid CAiScutTargetHttp::AppUid() const
{
    return KScutBrowserUid;
}

TUid CAiScutTargetHttp::AdditionalUid() const
{
    return iChecksum;
}

// End of File.
hs_app_caiscuttargetkeylock.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for key lock
*
*/


#include "hs_app_caiscuttargetkeylock.h"
#include 

// Amount of attempts to try to connect to server.
const TInt KTriesToConnectServer(3);

// Delay between retries to connect.
const TInt KTimeBeforeRetryingServerConnection(50000);

// ----------------------------------------------------------------------------
// CAiScutKeyLock::CAiScutKeyLock
// ----------------------------------------------------------------------------
//
CAiScutTargetKeyLock::CAiScutTargetKeyLock(CAiScutEngine& aEngine, TShortcutType aType)
    : CAiScutTarget(aEngine, aType)
{
}

// ----------------------------------------------------------------------------
// CAiScutKeyLock::ConstructL
// ----------------------------------------------------------------------------
//
void CAiScutTargetKeyLock::ConstructL(const TDesC& aTarget)
{
    iDefinition = aTarget.AllocL();

    TInt err(KErrGeneral);
    TInt thisTry(0);

    // Try connect successfully with server limited a number of times
    err = iKeyLock.Connect();
    while ((err != KErrNone) && (thisTry++ < KTriesToConnectServer))
        {
        User::After(KTimeBeforeRetryingServerConnection);
        err = iKeyLock.Connect();
        }
    User::LeaveIfError(err);

}

// ----------------------------------------------------------------------------
// CAiScutKeyLock::NewL
// ----------------------------------------------------------------------------
//
CAiScutTargetKeyLock* CAiScutTargetKeyLock::NewL(
    CAiScutEngine& aEngine, TShortcutType aType, const TDesC& aTarget)
{
    CAiScutTargetKeyLock* self = new (ELeave) CAiScutTargetKeyLock(aEngine, aType);

    CleanupStack::PushL(self);
    self->ConstructL(aTarget);
    CleanupStack::Pop(self);

    return self;
}

// ----------------------------------------------------------------------------
// CAiScutKeyLock::~CAiScutKeyLock
// ----------------------------------------------------------------------------
//
CAiScutTargetKeyLock::~CAiScutTargetKeyLock()
{
    delete iDefinition;
    iKeyLock.Close();
}

// ---------------------------------------------------------------------------
// Returns the shortcut definition string
// ---------------------------------------------------------------------------
//
TPtrC CAiScutTargetKeyLock::Definition() const
{
    return iDefinition ? TPtrC(*iDefinition) : TPtrC();
}


// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetKeyLock::GetCaption(TPtrC& aDes, TAiScutAppTitleType /*aTitleType*/) const
{
    aDes.Set(KNullDesC());
    return 0;
}


// ---------------------------------------------------------------------------
// Returns the shortcut target icon.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetKeyLock::GetIcon(CGulIcon*& aIcon) const
{
    aIcon = NULL;
    return 0;
}


// -----------------------------------------------------------------------------
// Checks if the target is accessible
// -----------------------------------------------------------------------------
//
TBool CAiScutTargetKeyLock::IsAccessibleL(TInt /*aCheckType*/)
{
    return ETrue;
}


// -----------------------------------------------------------------------------
//
// -----------------------------------------------------------------------------
//
void CAiScutTargetKeyLock::LaunchL()
{
    EnableKeyLock();
}

// ---------------------------------------------------------------------------
// Return application uid this target launches.
// ---------------------------------------------------------------------------
//
TUid CAiScutTargetKeyLock::AppUid() const
{
    return KNullUid;
}


// ----------------------------------------------------------------------------
// CAiScutTargetKeyLock::EnableKeyLock
// ----------------------------------------------------------------------------
//
void CAiScutTargetKeyLock::EnableKeyLock()
{
    iKeyLock.EnableKeyLock();
}


// ----------------------------------------------------------------------------
// CAiScutTargetKeyLock::IsKeyLockEnabled
// ----------------------------------------------------------------------------
//
TBool CAiScutTargetKeyLock::IsKeyLockEnabled()
{
    return iKeyLock.IsKeyLockEnabled();
}

//  End of File.
hs_app_caiscuttargetmessagingview.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for messaging view shortcut target
*
*/


#include             // For KMsvRootIndexEntryIdValue
#include             // For CGulIcon
#include 
#include             // For CVwsSessionWrapper
#include           // For AknsUtils
#include 
#ifdef SYMBIAN_ENABLE_SPLIT_HEADERS
#include 
#endif

#include "hs_app_caiscuttargetmessagingview.h"
#include "hs_app_caiscutengine.h"
#include 

#include "debug.h"

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetMessagingView::CAiScutTargetMessagingView(CAiScutEngine& aEngine, TShortcutType aType)
    : CAiScutTarget(aEngine, aType)
{
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutTargetMessagingView::ConstructL(const TAiScutParser& aParser)
{
    iDefinition = aParser.Get(EScutDefComplete).AllocL();
    // Updates the view name also
    FindViewIdL();
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetMessagingView* CAiScutTargetMessagingView::NewL(
    CAiScutEngine& aEngine, TShortcutType aType, const TAiScutParser& aParser)
{
    CAiScutTargetMessagingView* self = new (ELeave) CAiScutTargetMessagingView(aEngine, aType);

    CleanupStack::PushL(self);
    self->ConstructL(aParser);
    CleanupStack::Pop(self);

    return self;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetMessagingView::~CAiScutTargetMessagingView()
{
    delete iDefinition;
    delete iViewName;
}


// ---------------------------------------------------------------------------
// Returns the shortcut definition string.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutTargetMessagingView::Definition() const
{
    return TPtrC(*iDefinition);
}


// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetMessagingView::GetCaption(TPtrC& aDes, TAiScutAppTitleType /*aTitleType*/) const
{
    aDes.Set(*iViewName);
    return 0;
}


// ---------------------------------------------------------------------------
// Returns the shortcut target icon.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetMessagingView::GetIcon(CGulIcon*& aIcon) const
{
    if ( CAiScutTarget::GetIcon(aIcon) != KErrNone )
        {
        TRAP_IGNORE(GetIconL(aIcon));    
        }

    return 0;
}

// ---------------------------------------------------------------------------
// Returns the shortcut target icon.
// ---------------------------------------------------------------------------
//
void CAiScutTargetMessagingView::GetIconL(CGulIcon*& aIcon) const
{
    CGulIcon* tempIcon = NULL;

    CFbsBitmap* bitmap = NULL;
    CFbsBitmap* mask   = NULL;

    MAknsSkinInstance* skin = AknsUtils::SkinInstance();
    AknsUtils::CreateAppIconLC(skin, KScutMessagingUid, EAknsAppIconTypeList, bitmap, mask);

    tempIcon = CGulIcon::NewL(bitmap, mask);

    CleanupStack::Pop(2); // Bitmap and mask. They have to be popped out by number
                          // because the order in which they are pushed in is undefined.

    //Do not need to sets the bitmap and mask to be owned externally
    
    aIcon = tempIcon;
}


// ---------------------------------------------------------------------------
// Checks if the shortcut target is accessible.
// ---------------------------------------------------------------------------
//
TBool CAiScutTargetMessagingView::IsAccessibleL(TInt /*aCheckType*/)
{
	return FindViewIdL() != KErrNotFound;
}


// ---------------------------------------------------------------------------
// Launches a remote mailbox.
// ---------------------------------------------------------------------------
//
void CAiScutTargetMessagingView::LaunchL()
{
    TMsvId id(FindViewIdL());
    if (id != KErrNotFound)
    {
        const TVwsViewId viewId(KScutMessagingUid, KScutRemoteMailboxViewId);
        iEngine.VwsSession()->CreateActivateViewEvent(viewId, TUid::Uid(id), KNullDesC8());
    }
}

// ---------------------------------------------------------------------------
// Return application uid this target launches.
// ---------------------------------------------------------------------------
//
TUid CAiScutTargetMessagingView::AppUid() const
{
    return KScutMessagingUid;
}


// ---------------------------------------------------------------------------
// Tries to find a view id.
// ---------------------------------------------------------------------------
//
TMsvId CAiScutTargetMessagingView::FindViewIdL()
    {
    TMsvId id(KErrNotFound);

    TInt mailboxId = KErrNone;
    TAiScutParser parser;
    parser.Parse(*iDefinition);          		
    TLex lex(parser.Get(EScutDefParamValue));
    lex.Val(mailboxId);

    if (iEngine.MsvSession())
    {
        // KErrNotReady is the only allowed leave code. Engine will trap it and start a timer
        // to check access later. Other possible leaves emitted by the message server are
        // substituted with KErrNotReady.
        CMsvEntry* rootEntry = NULL;
        TRAPD(err, rootEntry = iEngine.MsvSession()->GetEntryL(KMsvRootIndexEntryIdValue));
        if (err != KErrNone)
        {
            User::Leave(KErrNotReady);
        }

		if(rootEntry)
		{
	        // No leaving code here since rootEntry is not in cleanup stack.
    	    for (TInt i = rootEntry->Count(); --i >= 0;)
        	{
            	const TMsvEntry& tentry = (*rootEntry)[i];
	
				__PRINT( __DBG_FORMAT("XAI: CAiScutTargetMessagingView::FindViewIdL id = 0x%x '%S'"),
					 tentry.Id(), &tentry.iDetails);
            	if ((tentry.iMtm == KSenduiMtmImap4Uid || tentry.iMtm == KSenduiMtmPop3Uid) &&
                	tentry.Id() == mailboxId)
	            {
    	            id = tentry.Id();
    	            delete iViewName;
    	            iViewName = NULL;
    	            iViewName = tentry.iDetails.AllocL();
        	        break;
            	}
	        }
	
    	    delete rootEntry;
        	rootEntry = NULL;
			
		}
    }

    return id;
}

// End of File.
hs_app_caiscuttargetnewmsg.cpp
/*
* Copyright (c) 2005-2008 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Class for new message shortcut target
*
*/


#include          // For CSendUi
#include      // For settings not ok - error dialog
#include         // For CGulIcon
#include 
#include  // For finding out available email account counts
#include       // For AknsUtils

#include 

#include 
#include   // For error note
#include 
#include 

#include "aiscutcontentmodel.h"
#include "hs_app_caiscuttargetnewmsg.h"
#include "hs_app_caiscutengine.h"
#include 
#include 
#include 
#include 
#include 

#include "debug.h"

using namespace conn;
const TInt KMaxBufSize = 256;

// Status keys adopted from FileManager to be used when checking file backup status
const TUid KPSUidFileManagerStatus = { 0x101F84EB }; // File Manager SID
const TUint32 KFileManagerBkupStatus = 0x00000001;

enum TFileManagerBkupStatusType
    {
    EFileManagerBkupStatusUnset   = 0x00000000,
    EFileManagerBkupStatusBackup  = 0x00000001,
    EFileManagerBkupStatusRestore = 0x00000002
    };

TBool PhoneIsInBackupOrRestoreMode()
    {
    TBool backupOrRestore = EFalse;
    
    TInt status( EFileManagerBkupStatusUnset );
    TInt err( RProperty::Get( KPSUidFileManagerStatus, KFileManagerBkupStatus, status ) );
    if ( status == EFileManagerBkupStatusBackup )
    {
    	backupOrRestore = ETrue;
    	return backupOrRestore;
    }

    // Get the back-up restore key, return EFalse if we can't get the key
    TInt keyVal = 0;
    const TInt error = RProperty::Get( KUidSystemCategory, conn::KUidBackupRestoreKey, keyVal );
    if( error )
        {
        return backupOrRestore;
        }

    const conn::TBURPartType partType = static_cast< conn::TBURPartType >( keyVal & conn::KBURPartTypeMask );
    if  (keyVal != 0)
        {
        switch(partType)
            {
        case EBURUnset:
        case EBURNormal:
            break;
        case EBURBackupFull:
        case EBURBackupPartial:
        case EBURRestoreFull:
        case EBURRestorePartial:
            backupOrRestore = ETrue;
            break;
            }
        }
    //

    return backupOrRestore;
    }

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetNewMsg::CAiScutTargetNewMsg(CAiScutEngine& aEngine, TShortcutType aType)
    : CAiScutTarget(aEngine, aType)
{
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CAiScutTargetNewMsg::ConstructL(const TAiScutParser& aParser)
{
    iDefinition = aParser.Get(EScutDefComplete).AllocL();

    iAppUid       = KNullUid;
    iViewUid.iUid = -1;

    switch (aParser.Type())
    {
    case EScutNewMessage:
        iMtm          = KSenduiMtmUniMessageUid;
        iAppUid.iUid  = KScutUnifiedEditorUidValue;
        break;

    case EScutNewEmail:
        iMtm          = KSenduiMtmSmtpUid;
        iAppUid.iUid  = KScutEmailEditorUidValue;
        break;

#ifdef __SYNCML_DS_EMAIL
    case EScutNewSyncMLMail:
        iMtm          = KSenduiMtmSyncMLEmailUid;
        iAppUid.iUid  = KScutEmailEditorUidValue; // check that these uids are in sync with aiscuttexts.rss
        iViewUid.iUid = KScutSyncMlEmailUidValue;
        break;
#endif

    case EScutNewPostcard:
        iMtm          = KSenduiMtmPostcardUid;
        iAppUid.iUid  = KScutPostcardEditorUidValue;
        break;

    case EScutNewAudioMsg:
        iMtm          = KSenduiMtmAudioMessageUid;
        iAppUid.iUid  = KScutAmsEditorUidValue;
        break;

    case EScutNewMsgType:
        iAppUid.iUid  = KScutMessagingCenterUidValue; // check that these uids are in sync with aiscuttexts.rss
        iViewUid.iUid = KScutMessagingCenterUidValue;
        // fallthrough
    default:
        iMtm = KNullUid;
        break;
    }
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetNewMsg* CAiScutTargetNewMsg::NewL(
    CAiScutEngine& aEngine, TShortcutType aType, const TAiScutParser& aParser)
{
    CAiScutTargetNewMsg* self = new (ELeave) CAiScutTargetNewMsg(aEngine, aType);

    CleanupStack::PushL(self);
    self->ConstructL(aParser);
    CleanupStack::Pop(self);

    return self;
}


// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CAiScutTargetNewMsg::~CAiScutTargetNewMsg()
{
    delete iCaption;
    delete iShortCaption;
    delete iDefinition;

}


// ---------------------------------------------------------------------------
// Returns the shortcut definition string.
// ---------------------------------------------------------------------------
//
TPtrC CAiScutTargetNewMsg::Definition() const
{
    return TPtrC(*iDefinition);
}


// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetNewMsg::GetCaption(TPtrC& aDes, TAiScutAppTitleType aTitleType) const
{
    TRAP_IGNORE(GetCaptionL(aTitleType));

    if (aTitleType == EAiScutSkeyTitle)
    {
        aDes.Set(iShortCaption ? *iShortCaption : KNullDesC());
    }
    else
    {
        aDes.Set(iCaption ? *iCaption : KNullDesC());
    }

    return 0;
}

// ---------------------------------------------------------------------------
// Returns the shortcut target caption.
// ---------------------------------------------------------------------------
//
void CAiScutTargetNewMsg::GetCaptionL(TAiScutAppTitleType aTitleType) const
{
    HBufC* titlePtr = HBufC::NewLC(KMaxBufSize);
    TPtr titlePtrP = titlePtr->Des();


    // Use lazy evaluation, create the caption only when it is first needed.
    if (aTitleType == EAiScutSkeyTitle)
    {
        if (!iShortCaption)
        {
            if (iEngine.GetAppTitle(iAppUid, iViewUid, titlePtrP, aTitleType))
            {
                iShortCaption = titlePtrP.AllocL();
            }
        }
    }
    else
    {
        if (!iCaption)
        {
            if (iEngine.GetAppTitle(iAppUid, iViewUid, titlePtrP, aTitleType))
            {
                iCaption = titlePtrP.AllocL();
            }
        }
    }

    CleanupStack::PopAndDestroy(titlePtr);
}

// ---------------------------------------------------------------------------
// Returns the shortcut target icon.
// ---------------------------------------------------------------------------
//
TInt CAiScutTargetNewMsg::GetIcon(CGulIcon*& aIcon) const
{
    if ( CAiScutTarget::GetIcon(aIcon) != KErrNone )
        {
        TRAP_IGNORE(GetIconL(aIcon));
        }


    return 0;
}

// ---------------------------------------------------------------------------
// Returns the shortcut target icon.
// ---------------------------------------------------------------------------
//
void CAiScutTargetNewMsg::GetIconL(CGulIcon*& aIcon) const
{

    CGulIcon* tempIcon = NULL;
    TBool useAppIcon = ETrue;
    TInt iconId = 0;
    TInt maskId = 0;

    if (iMtm == KNullUid)
    {
        useAppIcon = EFalse;
        iconId = EMbmAiscutpluginQgn_menu_mce_sel_mes;
        maskId = EMbmAiscutpluginQgn_menu_mce_sel_mes_mask;
    }
#ifdef __SYNCML_DS_EMAIL
    else if (iMtm.iUid == KSenduiMtmSyncMLEmailUidValue)
    {
        useAppIcon = EFalse;
        iconId = EMbmAiscutpluginQgn_menu_mce_syncmail;
        maskId = EMbmAiscutpluginQgn_menu_mce_syncmail_mask;
    }
#endif

    MAknsSkinInstance* skin = AknsUtils::SkinInstance();

    if (useAppIcon)
    {
        CFbsBitmap* bitmap = NULL;
        CFbsBitmap* mask   = NULL;

        AknsUtils::CreateAppIconLC(skin, iAppUid, EAknsAppIconTypeList, bitmap, mask);
        tempIcon = CGulIcon::NewL(bitmap, mask);
        CleanupStack::Pop(2); // Bitmap and mask. They have to be popped out by number
                              // because the order in which they are pushed in is undefined.
    }
    else
    {
        TFileName pluginIconFile(KDC_APP_BITMAP_DIR);
        pluginIconFile.Append(KBitmapFile);

        tempIcon = AknsUtils::CreateGulIconL(
            skin,
            KAknsIIDQgnPropAiShortcut,
            pluginIconFile,
            iconId,
            maskId
            );
    }

    //Do not need to sets the bitmap and mask to be owned externally


    aIcon = tempIcon;
}


// -----------------------------------------------------------------------------
// Checks if the shortcut target is accessible.
// -----------------------------------------------------------------------------
//
TBool CAiScutTargetNewMsg::IsAccessibleL(TInt /*aCheckType*/)
{
    return ETrue;
}


// -----------------------------------------------------------------------------
// Launches the message editor to send an Sms, Mms or Email message.
// -----------------------------------------------------------------------------
//
void CAiScutTargetNewMsg::LaunchL()
    {
    if( PhoneIsInBackupOrRestoreMode() )
        {
        CAknGlobalNote* note = CAknGlobalNote::NewLC();

        HBufC* prompt = StringLoader::LoadLC( R_QTN_AI_SCUT_OPERATION_DISABLED );

        note->SetSoftkeys( R_AVKON_SOFTKEYS_OK_EMPTY );
        note->ShowNoteL( EAknGlobalInformationNote, *prompt );

        CleanupStack::PopAndDestroy( prompt );
        CleanupStack::PopAndDestroy( note );
        return;
        }

  CSendUi* sendUi = CSendUi::NewLC();

    if (iMtm == KNullUid)
        {
        TSendingCapabilities capabs(0, 0, TSendingCapabilities::ESupportsEditor);

        TUid uid = sendUi->ShowTypedQueryL(CSendUi::EWriteMenu, NULL, capabs, NULL, KNullDesC);
        if (uid != KNullUid)
            {
            sendUi->ServiceCapabilitiesL(uid, capabs);
            sendUi->CreateAndSendMessageL(uid, NULL, KNullUid, EFalse); // launch standalone
            }
        }
    else
        {
        if( iMtm == KSenduiMtmSmtpUid ) // pop, imap, smtp
            {
            RArray popAccounts;
            RArray imapAccounts;
            RArray smtpAccounts;
            CEmailAccounts* emailAccounts = CEmailAccounts::NewLC();
            // check that mailbox exists or else display error message
            emailAccounts->GetPopAccountsL(popAccounts);
            emailAccounts->GetImapAccountsL(imapAccounts);
            emailAccounts->GetSmtpAccountsL(smtpAccounts);
            CleanupStack::PopAndDestroy(emailAccounts);

            if( iMtm == KSenduiMtmSmtpUid &&
                (popAccounts.Count() + imapAccounts.Count() + smtpAccounts.Count() ) > 0 )
                {
                sendUi->CreateAndSendMessageL(iMtm, NULL, KNullUid, EFalse); // launch standalone
                }
            else
                {
                ShowErrorNote();
                }
            popAccounts.Reset();
            imapAccounts.Reset();
            smtpAccounts.Reset();
            }
        else if ( iMtm == KSenduiMtmSyncMLEmailUid ) // syncml
            {
            CMsvEntrySelection* sel =
                MsvUiServiceUtilities::GetListOfAccountsWithMTML( *(iEngine.MsvSession()), iMtm );
            TInt accounts = sel->Count();
            delete sel;
            if ( accounts > 0 )
                {
                sendUi->CreateAndSendMessageL(iMtm, NULL, KNullUid, EFalse); // launch standalone
                }
            else
                {
                ShowErrorNote();
                }
            }
        else
            {
            sendUi->CreateAndSendMessageL(iMtm, NULL, KNullUid, EFalse); // launch standalone
            }

    }
    CleanupStack::PopAndDestroy(sendUi);
}

void CAiScutTargetNewMsg::ShowErrorNote()
    {
     TRAP_IGNORE(
        // Display global error note.
        CAknGlobalNote* note = CAknGlobalNote::NewLC();
        HBufC* prompt = StringLoader::LoadLC( R_SENDUI_SETTINGS_NOT_OK );
        note->ShowNoteL( EAknGlobalErrorNote, *prompt );
        CleanupStack::PopAndDestroy( prompt );
        CleanupStack::PopAndDestroy( note );
    ); // end TRAP_IGNORE
    }

// ---------------------------------------------------------------------------
// Return application uid this target launches.
// ---------------------------------------------------------------------------
//
TUid CAiScutTargetNewMsg::AppUid() const
{
    return iAppUid;
}

// End of File.
hs_app_cpopupeventhandler.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut plug-in Popup event handler class
*
*/


#include "hs_app_cpopupeventhandler.h"
#include "hs_app_PopupFSM.h"
#include "hs_app_mpopupeventhandleractions.h"

/**
 * Timeout timer values
 */
const TInt KTimeoutShort = 900000;  //900 ms
const TInt KTimeoutLong = 6000000;  //6 sec


// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CPopupEventHandler* CPopupEventHandler::NewL(
    MPopupEventHandlerActions& aPopupEventHandlerActions )
    {
    CPopupEventHandler* self = CPopupEventHandler::NewLC( aPopupEventHandlerActions );
    CleanupStack::Pop( self );
    return self;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CPopupEventHandler* CPopupEventHandler::NewLC(
    MPopupEventHandlerActions& aPopupEventHandlerActions )
    {
    CPopupEventHandler* self = new( ELeave ) CPopupEventHandler(
        aPopupEventHandlerActions );
    CleanupStack::PushL( self );
    self->ConstructL();
    return self;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CPopupEventHandler::~CPopupEventHandler()
    {
    Cancel();
    iTimer.Close();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
CPopupEventHandler::CPopupEventHandler(
    MPopupEventHandlerActions& aPopupEventHandlerActions )
    : CActive( EPriorityStandard ),
    iPopupEventHandlerActions( aPopupEventHandlerActions ),
    iPopupFSM( *this ),
    iPublishPopup( ETrue ),
    iPublishCaption( ETrue ),
    iCaptionVisible( ETrue )
    {
    }

// ---------------------------------------------------------------------------
// Constructor
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::ConstructL()
    {
    User::LeaveIfError( iTimer.CreateLocal() );
    CActiveScheduler::Add( this );
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TPopupFSM& CPopupEventHandler::PopupFSM()
    {
    return iPopupFSM;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CPopupEventHandler::PublishPopup() const
    {
    return iPublishPopup;
    }

TBool CPopupEventHandler::PopupVisible() const
    {
    return iPopupVisible;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TBool CPopupEventHandler::PublishCaption() const
    {
    return iPublishCaption;
    }

TBool CPopupEventHandler::CaptionVisible() const
    {
    return iCaptionVisible;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::DoCancel()
    {
    iTimer.Cancel();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::RunL()
    {
    iPopupFSM.HandleRequestCompleted();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::CompleteSelf()
    {
    TRequestStatus* status = &iStatus;
    User::RequestComplete( status, KErrNone );
    SetActive();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::CancelRequest()
    {
    Cancel();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::StartShortTimer()
    {
    Cancel();  // Cancel previous request by calling iTimer.Cancel()
    iTimer.After( iStatus, KTimeoutShort );
    SetActive();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::StartLongTimer()
    {
    Cancel();  // Cancel previous request by calling iTimer.Cancel()
    iTimer.After( iStatus, KTimeoutLong );
    SetActive();
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::IssuePublishPopup()
    {
    iPublishPopup = ETrue;
    iPopupVisible = ETrue;
    iPopupEventHandlerActions.IssuePublishShortcut();
    iPublishPopup = EFalse;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::IssueCleanPopup()
    {
    iPublishPopup = ETrue;
    iPopupVisible = EFalse;
    iPopupEventHandlerActions.IssuePublishShortcut();
    iPublishPopup = EFalse;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::IssuePublishCaption()
    {
    iPublishCaption = ETrue;
    iCaptionVisible = ETrue;
    iPopupEventHandlerActions.IssuePublishShortcut();
    iPublishCaption = EFalse;
    }

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
void CPopupEventHandler::IssueCleanCaption()
    {
    iPublishCaption = ETrue;
    iCaptionVisible = EFalse;
    iPopupEventHandlerActions.IssuePublishShortcut();
    iPublishCaption = EFalse;
    }

// End of File.
hs_app_MPopupFSMActions.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/
#ifndef MPOPUPFSMACTIONS_H
#define MPOPUPFSMACTIONS_H

//  EXTERNAL INCLUDES
#include 

//  CLASS DEFINITION
/**
 * MPopupFSMActions actions.
 * Note: This file has been generated automatically. Do not edit!
 */
class MPopupFSMActions
    {
    public:     // Abstract methods
        virtual void StartLongTimer() = 0;
        virtual void IssueCleanPopup() = 0;
        virtual void IssuePublishPopup() = 0;
        virtual void IssuePublishCaption() = 0;
        virtual void IssueCleanCaption() = 0;
        virtual void StartShortTimer() = 0;
        virtual void CompleteSelf() = 0;
        virtual void CancelRequest() = 0;
    };

#endif      //  MPOPUPFSMACTIONS_H

// End of file
hs_app_PopupFSM.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/
#include "hs_app_PopupFSM.h"
#include "hs_app_MPopupFSMActions.h"
#include "hs_app_PopupTrace.h"

#pragma warning( disable:4100 )
#pragma warning( disable:4068 )
#pragma warn_unusedarg off

TPopupFSM::TPopupFSM( MPopupFSMActions& aPopupFSMActions ) : 
    iCurrentState( &iNotSetOffFocus ),
    iPopupFSMActions( aPopupFSMActions )
    {
    }

void TPopupFSM::TPopupStateBase::HandleForeground( TPopupFSM* /*aPopupFSM*/, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TPopupStateBase::HandleForeground()") );
    }

void TPopupFSM::TPopupStateBase::HandleUpdate( TPopupFSM* /*aPopupFSM*/, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TPopupStateBase::HandleUpdate()") );
    }

void TPopupFSM::TPopupStateBase::HandleRequestCompleted( TPopupFSM* /*aPopupFSM*/, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TPopupStateBase::HandleRequestCompleted()") );
    }

void TPopupFSM::TPopupStateBase::HandleReset( TPopupFSM* /*aPopupFSM*/, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TPopupStateBase::HandleReset()") );
    }

void TPopupFSM::TPopupStateBase::HandleBackground( TPopupFSM* /*aPopupFSM*/, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TPopupStateBase::HandleBackground()") );
    }

void TPopupFSM::TPopupStateBase::HandleGotFocus( TPopupFSM* /*aPopupFSM*/, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TPopupStateBase::HandleGotFocus()") );
    }

void TPopupFSM::TPopupStateBase::HandleLostFocus( TPopupFSM* /*aPopupFSM*/, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TPopupStateBase::HandleLostFocus()") );
    }

void TPopupFSM::HandleForeground()
    {
    iCurrentState->HandleForeground( this, iPopupFSMActions );
    }

void TPopupFSM::HandleUpdate()
    {
    iCurrentState->HandleUpdate( this, iPopupFSMActions );
    }

void TPopupFSM::HandleRequestCompleted()
    {
    iCurrentState->HandleRequestCompleted( this, iPopupFSMActions );
    }

void TPopupFSM::HandleReset()
    {
    iCurrentState->HandleReset( this, iPopupFSMActions );
    }

void TPopupFSM::HandleBackground()
    {
    iCurrentState->HandleBackground( this, iPopupFSMActions );
    }

void TPopupFSM::HandleGotFocus()
    {
    iCurrentState->HandleGotFocus( this, iPopupFSMActions );
    }

void TPopupFSM::HandleLostFocus()
    {
    iCurrentState->HandleLostFocus( this, iPopupFSMActions );
    }

void TPopupFSM::SetState( TPopupStateBase* aNewState )
    {
    iCurrentState = aNewState;
    }

void TPopupFSM::TNotSetOffFocus::HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TNotSetOffFocus::HandleUpdate()") );
    aPopupFSM->SetState( &aPopupFSM->iSetOffFocus );
    aPopupFSMActions.IssueCleanCaption();
    }

void TPopupFSM::TNotSetOffFocus::HandleGotFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TNotSetOffFocus::HandleGotFocus()") );
    aPopupFSM->SetState( &aPopupFSM->iNotSetOnFocus );
    }

void TPopupFSM::TNotSetOffFocus::HandleForeground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TNotSetOffFocus::HandleForeground()") );
    aPopupFSM->SetState( &aPopupFSM->iNotSetOffFocus );
    aPopupFSMActions.IssuePublishCaption();
    }

void TPopupFSM::TSetOffFocus::HandleGotFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TSetOffFocus::HandleGotFocus()") );
    aPopupFSM->SetState( &aPopupFSM->iGettingFocus );
    aPopupFSMActions.StartShortTimer();
    }

void TPopupFSM::TSetOffFocus::HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TSetOffFocus::HandleReset()") );
    aPopupFSM->SetState( &aPopupFSM->iNotSetOffFocus );
    aPopupFSMActions.IssuePublishCaption();
    }

void TPopupFSM::TGettingFocus::HandleRequestCompleted( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TGettingFocus::HandleRequestCompleted()") );
    aPopupFSM->SetState( &aPopupFSM->iVisible );
    aPopupFSMActions.IssuePublishPopup();
    aPopupFSMActions.StartLongTimer();
    }

void TPopupFSM::TGettingFocus::HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TGettingFocus::HandleReset()") );
    aPopupFSM->SetState( &aPopupFSM->iNotSetOnFocus );
    aPopupFSMActions.IssuePublishCaption();
    aPopupFSMActions.CancelRequest();
    }

void TPopupFSM::TGettingFocus::HandleLostFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TGettingFocus::HandleLostFocus()") );
    aPopupFSM->SetState( &aPopupFSM->iSetOffFocus );
    aPopupFSMActions.CancelRequest();
    }

void TPopupFSM::TLosingFocus::HandleRequestCompleted( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TLosingFocus::HandleRequestCompleted()") );
    aPopupFSM->SetState( &aPopupFSM->iSetOffFocus );
    aPopupFSMActions.IssueCleanPopup();
    }

void TPopupFSM::TLosingFocus::HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TLosingFocus::HandleReset()") );
    aPopupFSM->SetState( &aPopupFSM->iNotSetOffFocus );
    aPopupFSMActions.IssuePublishCaption();
    aPopupFSMActions.CancelRequest();
    }

void TPopupFSM::TLosingFocus::HandleGotFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TLosingFocus::HandleGotFocus()") );
    aPopupFSM->SetState( &aPopupFSM->iVisible );
    aPopupFSMActions.CancelRequest();
    aPopupFSMActions.StartLongTimer();
    }

void TPopupFSM::TNotSetOnFocus::HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TNotSetOnFocus::HandleUpdate()") );
    aPopupFSM->SetState( &aPopupFSM->iVisible );
    aPopupFSMActions.IssueCleanCaption();
    aPopupFSMActions.IssuePublishPopup();
    aPopupFSMActions.StartLongTimer();
    }

void TPopupFSM::TNotSetOnFocus::HandleLostFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TNotSetOnFocus::HandleLostFocus()") );
    aPopupFSM->SetState( &aPopupFSM->iNotSetOffFocus );
    }

void TPopupFSM::TNotSetOnFocus::HandleBackground( TPopupFSM* aPopupFSM, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TNotSetOnFocus::HandleBackground()") );
    aPopupFSM->SetState( &aPopupFSM->iBackgroundNotSetOnFocus );
    }

void TPopupFSM::TNotSetOnFocus::HandleForeground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TNotSetOnFocus::HandleForeground()") );
    aPopupFSM->SetState( &aPopupFSM->iNotSetOnFocus );
    aPopupFSMActions.IssuePublishCaption();
    }

void TPopupFSM::TVisible::HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TVisible::HandleUpdate()") );
    aPopupFSM->SetState( &aPopupFSM->iVisible );
    aPopupFSMActions.IssueCleanCaption();
    aPopupFSMActions.IssuePublishPopup();
    aPopupFSMActions.StartLongTimer();
    }

void TPopupFSM::TVisible::HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TVisible::HandleReset()") );
    aPopupFSM->SetState( &aPopupFSM->iNotSetOnFocus );
    aPopupFSMActions.IssuePublishCaption();
    aPopupFSMActions.IssueCleanPopup();
    aPopupFSMActions.CancelRequest();
    }

void TPopupFSM::TVisible::HandleLostFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TVisible::HandleLostFocus()") );
    aPopupFSM->SetState( &aPopupFSM->iLosingFocus );
    aPopupFSMActions.CancelRequest();
    aPopupFSMActions.CompleteSelf();
    }

void TPopupFSM::TVisible::HandleRequestCompleted( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TVisible::HandleRequestCompleted()") );
    aPopupFSM->SetState( &aPopupFSM->iNotVisible );
    aPopupFSMActions.IssueCleanPopup();
    }

void TPopupFSM::TVisible::HandleBackground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TVisible::HandleBackground()") );
    aPopupFSM->SetState( &aPopupFSM->iBackgroundSetOnFocus );
    aPopupFSMActions.CancelRequest();
    aPopupFSMActions.IssueCleanPopup();
    }

void TPopupFSM::TNotVisible::HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TNotVisible::HandleUpdate()") );
    aPopupFSM->SetState( &aPopupFSM->iVisible );
    aPopupFSMActions.IssueCleanCaption();
    aPopupFSMActions.IssuePublishPopup();
    aPopupFSMActions.StartLongTimer();
    }

void TPopupFSM::TNotVisible::HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TNotVisible::HandleReset()") );
    aPopupFSM->SetState( &aPopupFSM->iNotSetOnFocus );
    aPopupFSMActions.IssuePublishCaption();
    }

void TPopupFSM::TNotVisible::HandleLostFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& /*aPopupFSMActions*/ )
    {
    TRACE( _L("TNotVisible::HandleLostFocus()") );
    aPopupFSM->SetState( &aPopupFSM->iSetOffFocus );
    }

void TPopupFSM::TBackgroundNotSetOnFocus::HandleForeground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TBackgroundNotSetOnFocus::HandleForeground()") );
    aPopupFSM->SetState( &aPopupFSM->iNotSetOnFocus );
    aPopupFSMActions.IssuePublishCaption();
    }

void TPopupFSM::TBackgroundNotSetOnFocus::HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TBackgroundNotSetOnFocus::HandleUpdate()") );
    aPopupFSM->SetState( &aPopupFSM->iBackgroundSetOnFocus );
    aPopupFSMActions.IssueCleanCaption();
    }

void TPopupFSM::TBackgroundSetOnFocus::HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TBackgroundSetOnFocus::HandleReset()") );
    aPopupFSM->SetState( &aPopupFSM->iBackgroundNotSetOnFocus );
    aPopupFSMActions.IssuePublishCaption();
    }

void TPopupFSM::TBackgroundSetOnFocus::HandleForeground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions )
    {
    TRACE( _L("TBackgroundSetOnFocus::HandleForeground()") );
    aPopupFSM->SetState( &aPopupFSM->iVisible );
    aPopupFSMActions.IssuePublishPopup();
    aPopupFSMActions.StartLongTimer();
    }

// End of file
hs_app_PopupFSM.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/
#ifndef POPUPFSM_H
#define POPUPFSM_H

//  EXTERNAL INCLUDES
#include 

//  FORWARD DECLARATIONS
class TPopupFSM;
class MPopupFSMActions;

//  CLASS DEFINITIONS
/**
 * Popup state machine
 */
class TPopupFSM
    {
    /**
     * Base class for states
     */
    class TPopupStateBase
        {
        public:     // New methods
            virtual void HandleForeground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            virtual void HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            virtual void HandleRequestCompleted( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            virtual void HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            virtual void HandleBackground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            virtual void HandleGotFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            virtual void HandleLostFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
        };

    /**
     * State class TNotSetOffFocus
     */
    class TNotSetOffFocus : public TPopupStateBase
        {
        protected:  // Methods derived from TPopupState
            void HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleGotFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleForeground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
        };

    /**
     * State class TSetOffFocus
     */
    class TSetOffFocus : public TPopupStateBase
        {
        protected:  // Methods derived from TPopupState
            void HandleGotFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
        };

    /**
     * State class TGettingFocus
     */
    class TGettingFocus : public TPopupStateBase
        {
        protected:  // Methods derived from TPopupState
            void HandleRequestCompleted( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleLostFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
        };

    /**
     * State class TLosingFocus
     */
    class TLosingFocus : public TPopupStateBase
        {
        protected:  // Methods derived from TPopupState
            void HandleRequestCompleted( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleGotFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
        };

    /**
     * State class TNotSetOnFocus
     */
    class TNotSetOnFocus : public TPopupStateBase
        {
        protected:  // Methods derived from TPopupState
            void HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleLostFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleBackground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleForeground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
        };

    /**
     * State class TVisible
     */
    class TVisible : public TPopupStateBase
        {
        protected:  // Methods derived from TPopupState
            void HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleLostFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleRequestCompleted( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleBackground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
        };

    /**
     * State class TNotVisible
     */
    class TNotVisible : public TPopupStateBase
        {
        protected:  // Methods derived from TPopupState
            void HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleLostFocus( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
        };

    /**
     * State class TBackgroundNotSetOnFocus
     */
    class TBackgroundNotSetOnFocus : public TPopupStateBase
        {
        protected:  // Methods derived from TPopupState
            void HandleForeground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleUpdate( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
        };

    /**
     * State class TBackgroundSetOnFocus
     */
    class TBackgroundSetOnFocus : public TPopupStateBase
        {
        protected:  // Methods derived from TPopupState
            void HandleReset( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
            void HandleForeground( TPopupFSM* aPopupFSM, MPopupFSMActions& aPopupFSMActions );
        };


    public:    // Constructors
        TPopupFSM( MPopupFSMActions& aPopupFSMActions );

    public:     // New methods
        void HandleForeground();
        void HandleUpdate();
        void HandleRequestCompleted();
        void HandleReset();
        void HandleBackground();
        void HandleGotFocus();
        void HandleLostFocus();

    private:     // New methods
        void SetState( TPopupStateBase* aNewState );

    private:    // Data
        //Ref:
        TPopupStateBase* iCurrentState;
        MPopupFSMActions& iPopupFSMActions;

        //Own:
        TNotSetOffFocus iNotSetOffFocus;
        TSetOffFocus iSetOffFocus;
        TGettingFocus iGettingFocus;
        TLosingFocus iLosingFocus;
        TNotSetOnFocus iNotSetOnFocus;
        TVisible iVisible;
        TNotVisible iNotVisible;
        TBackgroundNotSetOnFocus iBackgroundNotSetOnFocus;
        TBackgroundSetOnFocus iBackgroundSetOnFocus;
    private:    // Friend class definitions
        friend class TNotSetOffFocus;
        friend class TSetOffFocus;
        friend class TGettingFocus;
        friend class TLosingFocus;
        friend class TNotSetOnFocus;
        friend class TVisible;
        friend class TNotVisible;
        friend class TBackgroundNotSetOnFocus;
        friend class TBackgroundSetOnFocus;
    };

#endif      //  POPUPFSM_H

// End of file
hs_app_PopupTrace.h
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/
#ifndef POPUPTRACE_H
#define POPUPTRACE_H

//  MACROS
#define TRACE

#endif      //  POPUPTRACE_H

// End of file
hs_app_taiscutparser.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Shortcut definition parser
*
*/


#include "hs_app_taiscutparser.h"
#include "aiscutdefs.h"

#include "debug.h"


// ======== LOCAL FUNCTIONS ========
/**
 * Extract a value with the given name from a URI query string.
 * For example a query string of ?view=1234&iconid=3;5&foo=bar
 * and we wanted iconid from that string. Function places the 3;5 
 * into aValue and if needed deletes the "iconid=3;5&" string from the
 * query string.
 *
 * @param aQueryString The querystring
 * @param aParameterName The name of the parameter to find
 * @param aValue Where to place the value
 * @param aRemoveNameAndValue ETrue to remove the name=value from the querystring
 * @return KErrNone on succesful extraction. KErrNotFound if the parameter was not found
*/
TInt ExtractValueFromQueryString( TDes &aQueryString, const TDesC &aParameterName,
    TDes &aValue, TBool aRemoveNameAndValue )
    {
    TInt err = KErrNone;
    HBufC *tempBuffer = aQueryString.Alloc();
    if ( !tempBuffer )
        {
        return KErrNoMemory;
        }
    
    TPtr temp = tempBuffer->Des();
    
    TInt foundStartPos = 0;
    TInt foundStopPos = 0;
    foundStartPos =  aQueryString.FindC(aParameterName);
    if ( foundStartPos != KErrNotFound )
        {
        // remove the beginning of the string from temp, so no additional &-marks are found
        // at the start of string
        temp.Delete(0,foundStartPos);

        foundStopPos = temp.Locate(KParamNextSeparator);
        // stop either at the eos or at the next & mark
        foundStopPos = (foundStopPos != KErrNotFound ) ? (foundStopPos): (temp.Length() );
        // start after the = separator and stop either on eos or at & mark
        TInt from = (aParameterName.Length() + 1);
        TInt length = foundStopPos - from;

        // Get just the value part
        if ( aValue.MaxLength() >= length )
            {
            aValue = temp.Mid( from, length );
            }
        else // Can't place the value to aValue string
            {            
            err = KErrNoMemory;
            }

        if ( err == KErrNone && aRemoveNameAndValue )
            {
            // Delete the aParameterName=aValue string from the querystring
            // If eos reached then we need to delete the & before us also
            // Don't try to delete if this is an only parameter
            if ( foundStopPos == temp.Length() && foundStartPos > 0 )
                {
                aQueryString.Delete(foundStartPos - 1, (foundStopPos + 1));
                }
            else
                {
                aQueryString.Delete(foundStartPos, (foundStopPos + 1));
                }
            }        
        }
    else
        {
        err = KErrNotFound;
        }
    
    delete tempBuffer;
    return err;
    }

/**
 * Tests if string ends with given pattern
 * 
 * @param aString input string
 * @param aPattern test pattern
 * @return ETrue if string ends with given pattern.
 */
TBool EndsWith( const TDesC& aString, const TDesC& aPattern )
    {
    TBuf<10> temp(aString.Right(aPattern.Length()));
    return ( aString.Right( aPattern.Length() ) == aPattern );
    }    
    
/**
 * Resolves skin item id from pattern majorId;minorId;colourGroupId.
 * The colourGroupId in the syntax is optional, and if no value found then
 * aColourValue will be -1
 *
 * @param aPath   skin item id string     
 * @param aItemId skin item id to fill
 * @param aColourValue colour value to fill. 
 * 
 * @return ETrue if id was succesfully parsed.
 */
TBool ResolveSkinItemId( const TDesC& aPath, TAknsItemID& aItemId, TInt& aColourValue )
    {
    // Syntax: major;minor;colourgroup    
    aColourValue = -1;
  
    // Initialize lexer
    TLex lex( aPath );
    lex.SkipSpace();

    TInt majorId( 0 );        
    TInt minorId( 0 );
    
    // Resolve major id        
    TInt error = lex.Val( majorId );
    
    // Resolve minor id
    if ( lex.Eos())
        return KErrNotFound;
    
    lex.Inc();
    error |= lex.Val( minorId );
    
    // initilize skin item id object
    aItemId.Set( majorId, minorId );
    
    if ( lex.Eos())
        return KErrNotFound;
    lex.Inc();

    TInt colorError = lex.Val( aColourValue );
    if ( colorError != KErrNone || aColourValue < 0)
        {
        aColourValue = -1;
        }
                
    // Check error
    return ( error == KErrNone );

    }
    
/**
* Resolves filename and id from syntax
* filename.ext;id. If the syntax is incorrect
* aId is -1 and filename zeroed and EFalse is returned
* MIF and MBM supported.
*
* @param aPath The path to extract the data from
* @param aId    Id to fill
* @param aFilename Filename to fill
* @return ETrue if id and path was succesfully parsed.
*/
TBool ResolveFileIdAndPath( const TDesC& aPath, TInt& aId, TDes& aFilename )
{
    // Syntax: filename.ext;index
    // Supported: MIF, MBM
    TInt pos = aPath.FindF( KScutSkinItemSeparator );
    aFilename.Zero();
    if( pos != KErrNotFound )
        {
        aFilename = (aPath.Left(pos));
        
        if ( ( !EndsWith(aFilename, KScutMIFExtension ) ) &&
             ( !EndsWith(aFilename, KScutMBMExtension ) )   )
        	{
        	aFilename.Zero();
        	return EFalse;
        	}
        
        TLex lex(aPath.Mid(pos+1));
        TInt error = lex.Val(aId);
        if ( error != KErrNone )
        	{
        	aId = -1;
        	return EFalse;
        	}
        return ETrue;
        }
    return EFalse;
}     

TInt CreateChecksumFromString( const TDesC& aString )
    {
    TInt checksum = 0;
    
    for ( TInt i = 0; i < aString.Length(); i++ )
        {
        checksum += aString[i] * ( i + 1);
        }
    return checksum;       
    }

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
//
TAiScutParser::TAiScutParser() : iType(EScutUnknown), iUid(KNullUid)
{
}


// -----------------------------------------------------------------------------
// Static utility function to parse an uid from the given descriptor.
// -----------------------------------------------------------------------------
//
TUid TAiScutParser::ParseUid(const TDesC& aDesC)
{
    TRadix radix(EDecimal);

    // Check if the number is in hexadecimal format.
    _LIT(KHexPrefix, "0x");
    const TInt prefixLen = 2;
    TPtrC ptr(aDesC);

    if (ptr.Left(prefixLen).CompareC(KHexPrefix) == 0)
    {
        // Strip the '0x' prefix.
        ptr.Set(ptr.Right(ptr.Length() - prefixLen));

        radix = EHex;
    }

    // Do the actual parsing.
    TUint uint;
    TUid uid(KNullUid);
    TLex lexer(ptr);
    TInt err = lexer.Val(uint, radix);
    if (err == KErrNone)
    {
        uid.iUid = uint;
    }

    return uid;
}


// ---------------------------------------------------------------------------
// Parses a shortcut definition.
// ---------------------------------------------------------------------------
//
TInt TAiScutParser::Parse(const TDesC& aDefinition)
{
    iType = EScutUnknown;
    iDefinition.Set(aDefinition);
    
    // Default values for the icon
    iIcon.iIconId = KErrNotFound;
    iIcon.iPath.Zero();
    iIcon.iSkinId.iMajor = -1;
    iIcon.iSkinId.iMinor = -1;
    iIcon.iColourGroup = -1;
    
    iIcon.iType = EScutIconNone;
    iIcon.iDestination = EScutDestinationNormal;
    iIcon.iShortcutType = EScutUnknown;
    iIcon.iAppUid = TUid::Uid(0);
    iIcon.iViewId = TUid::Uid(0);
    
    TInt err = iUriParser.Parse(aDefinition);
    if (err != KErrNone)
    {
        return err;
    }

    TPtrC scheme(iUriParser.Extract(EUriScheme));

    if (scheme.Length() == 0 ||
        scheme.Compare(KScutURISchemeHttp) == 0 ||
        scheme.Compare(KScutURISchemeHttps) == 0)
    {
        ParseParams();
        iType = EScutWebAddress;
        
        if ( iIcon.iType != EScutIconNone )
            {
            // create a checksum for unique identifying
            TInt checksum = CreateChecksumFromString( aDefinition );
            iIcon.iViewId = TUid::Uid( checksum );
            iIcon.iShortcutType = iType;
            iIcon.iAppUid = KScutBrowserUid;           
            }
        err = KErrNone;
    }
    else if (scheme.Compare(KScutURISchemeLocalApp) == 0)
    {
        iType = EScutApplication;

        if (!ParseAlias())
        {
            iUid = ParseUid(iUriParser.Extract(EUriPath));
        }

        if (iUid == KScutAppShellUid)
        {
            // appshell shortcut is always of type app view.
            iType = EScutApplicationView;
        }

        // ParseParams() parses params from an URL. If it encounters
        // iconid, iconmifpath or cba parameter from the URL, then it
        // places the values to iIcon and removes the parameters from
        // the URL. It also extract the additional viewid if needed.
        // For example bookmarks and apps with views use them. 

        ParseParams();
        // Icon found so apply the appuid and type to icon. 
        if ( iIcon.iType != EScutIconNone )
            {
            iIcon.iShortcutType = iType;
            
            // If we are dealing with messaging icons then the 
            // appuid needs to be changed in order to match it against
            // the shortcuts appuid
            switch( iType )
                { 
                case EScutNewMessage:
                    iIcon.iAppUid.iUid = KScutUnifiedEditorUidValue;
                    break;

                case EScutNewEmail:
                    iIcon.iAppUid.iUid = KScutEmailEditorUidValue;
                    break;

            #ifdef __SYNCML_DS_EMAIL
                case EScutNewSyncMLMail:
                    iIcon.iAppUid.iUid = KScutEmailEditorUidValue; 
                    iIcon.iViewId.iUid = KScutSyncMlEmailUidValue;
                    break;
            #endif

                case EScutNewPostcard:
                    iIcon.iAppUid.iUid = KScutPostcardEditorUidValue;
                    break;

                case EScutNewAudioMsg:
                    iIcon.iAppUid.iUid = KScutAmsEditorUidValue;
                    break;

                case EScutNewMsgType:
                    iIcon.iAppUid.iUid = KScutMessagingCenterUidValue;
                    iIcon.iViewId.iUid = KScutMessagingCenterUidValue;
                    break;
                    
                default:
                    iIcon.iAppUid = iUid;       
                    break;
               
                }
                 
            }
        err = KErrNone;
    }
    else
    {
        err = KErrCorrupt;
    }

	__PRINTS( "XAI: TAiScutParser::Parse");
	__PRINT( __DBG_FORMAT( "XAI:   type = %d, definition = '%S', err = %d"), iType, &aDefinition, err);
    return err;
}


// ---------------------------------------------------------------------------
// Checks if the shortcut definition was valid.
// ---------------------------------------------------------------------------
//
TBool TAiScutParser::IsValid() const
{
    return iType != EScutUnknown;
}


// -----------------------------------------------------------------------------
// Returns the shortcut target type.
// -----------------------------------------------------------------------------
//
TShortcutType TAiScutParser::Type() const
{
    return iType;
}


// -----------------------------------------------------------------------------
// Returns the shortcut target uid. Used for application shortcuts.
// -----------------------------------------------------------------------------
//
TUid TAiScutParser::Uid() const
{
    return iUid;
}


TAiScutIcon TAiScutParser::Icon() const
    {
    return iIcon;
    }
// -----------------------------------------------------------------------------
// Returns a shortcut definition component value.
// -----------------------------------------------------------------------------
//
TPtrC TAiScutParser::Get(TScutDefComponent aComponent) const
{
    TPtrC componentValue;

    switch (aComponent)
    {
    case EScutDefScheme:
        componentValue.Set(iUriParser.Extract(EUriScheme));
        break;

    case EScutDefTarget:
        componentValue.Set(iUriParser.Extract(EUriPath));
        break;

    case EScutDefParamName:
        componentValue.Set(iParamName);
        break;

    case EScutDefParamValue:
        componentValue.Set(iParamValue);
        break;

    case EScutDefParamNameAndValue:
        componentValue.Set(iUriParser.Extract(EUriQuery));
        break;

    case EScutDefComplete:
        componentValue.Set(iDefinition);
        break;

    default:
        break;
    }

    return componentValue;
}


// ---------------------------------------------------------------------------
// Composes a shortcut definition string from given parameters.
// ---------------------------------------------------------------------------
//
void TAiScutParser::ComposeL(HBufC*& aDes, const TUid aUid,
    const TDesC& aParamName, const TDesC& aParamValue)
{
    HBufC* temp = HBufC::NewLC(KMaxDefinitionLength);
    TPtr ptr = temp->Des();

    if (aParamName.Length() && aParamValue.Length())
    {
        ptr.Format(KScutFormatApplicationWithParams, aUid.iUid, &aParamName, &aParamValue);
    }
    else
    {
        ptr.Format(KScutFormatApplication, aUid.iUid);
    }

    aDes = temp->AllocL();
    CleanupStack::PopAndDestroy(temp);
}


// ---------------------------------------------------------------------------
// Composes a shortcut definition string from given parameters.
// ---------------------------------------------------------------------------
//
void TAiScutParser::ComposeL(HBufC*& aDes, const TUid aUid,
    const TDesC& aParamString)
{
    HBufC* temp = HBufC::NewLC(KMaxDefinitionLength);
    TPtr ptr = temp->Des();

    if (aParamString.Length())
    {
        ptr.Format(KScutFormatApplicationWithParamString, aUid.iUid, &aParamString);
    }
    else
    {
        ptr.Format(KScutFormatApplication, aUid.iUid);
    }

    aDes = temp->AllocL();
    CleanupStack::PopAndDestroy(temp);
}


// ---------------------------------------------------------------------------
// Checks if an alias was used in shortcut definition and parses an uid from it.
// ---------------------------------------------------------------------------
//
TBool TAiScutParser::ParseAlias()
{
    TPtrC ptr(iUriParser.Extract(EUriPath));

    // "localapp:msg?..." is an alias for messaging application.
    if (ptr.CompareC(KScutTargetAliasMessaging) == 0)
    {
        iUid = KScutMessagingUid;
        return ETrue;
    }
    // "localapp:keylock?..." is an alias for keylock
    else if (ptr.CompareC(KScutTargetAliasKeylock) == 0)
    {
        iUid = KScutKeyLockUid;
        return ETrue;
    }

    // "localapp:voicedial..." is an alias for voicedial
    else if (ptr.CompareC(KScutTargetAliasVoiceDial) == 0)
    {
        iUid = KScutVoiceDialUid;
        return ETrue;
    }

    // "localapp:logs?..." is an alias for logs
    else if (ptr.CompareC(KScutTargetAliasLogs) == 0)
    {
        iUid = KScutLogsUid;
        return ETrue;
    }
    else
    {
        return EFalse;
    }
}


// ---------------------------------------------------------------------------
// Parses the possible application shortcut parameters.
// ---------------------------------------------------------------------------
//
void TAiScutParser::ParseParams()
{
    TPtrC params(iUriParser.Extract(EUriQuery));
    
    if (params.Length() > 0)
    {        
        HBufC *tempParams = params.Alloc();
        // value can't be longer than the params
        // but in some cases it can be equally long
        HBufC *value = HBufC::New(params.Length());
        
        // low memory or similar situation so cannot do anything
        if ( !value || !tempParams )
            {
            return;
            }
        
        TPtr valuePtr = value->Des();
        TPtr tempParamsPtr = tempParams->Des();
        
        TBool addonFound = EFalse;
        TInt err = KErrNone;
        
        // First extract the CBA
        err = ExtractValueFromQueryString(tempParamsPtr,KScutParamNameCBAIcon,valuePtr, ETrue);               
        if ( err == KErrNone )
            {
            iIcon.iDestination = EScutDestinationSoftkey;
            }
        // Then the toolbar

        err = ExtractValueFromQueryString(tempParamsPtr,KScutParamNameToolbarIcon,valuePtr, ETrue);               

        if ( err == KErrNone )
            {
            iIcon.iDestination = EScutDestinationToolbar;
            }
        
        // then extract the iconskinid
        err = ExtractValueFromQueryString(tempParamsPtr,
                KScutParamNameIconSkinId,valuePtr, ETrue);
        if ( err == KErrNone &&
                ResolveSkinItemId(valuePtr,iIcon.iSkinId,iIcon.iColourGroup))
            {
            iIcon.iType = EScutIconSkin;
            addonFound = ETrue;
            }
        // Then extract the iconmifpath
        // Iconmifpath extraction left here for backward compatibility
        valuePtr.Zero();
        err = ExtractValueFromQueryString(tempParamsPtr,
                KScutParamNameIconMifPath,valuePtr, ETrue);
        if ( err == KErrNone &&
                ResolveFileIdAndPath(valuePtr,iIcon.iIconId,iIcon.iPath) )
            {
            iIcon.iType = EScutIconMif;
            addonFound = ETrue;
            }        

        // Then extract the iconpath.
        valuePtr.Zero();
        err = ExtractValueFromQueryString(tempParamsPtr,
                KScutParamNameIconPath,valuePtr, ETrue);
        if ( err == KErrNone &&
                ResolveFileIdAndPath(valuePtr,iIcon.iIconId,iIcon.iPath) )
            {
            if ( EndsWith(iIcon.iPath, KScutMIFExtension ))
                {
                iIcon.iType = EScutIconMif;                
                }
            else if ( EndsWith(iIcon.iPath, KScutMBMExtension ))
                {
                iIcon.iType = EScutIconMbm;
                } 
            addonFound = ETrue;
            } 
                   
        // Use the new params string where the addons 
        // have been removed
        if( addonFound )
            {
            params.Set(tempParamsPtr);   
            // no need to process anything because there are no
            // parameters left after our addons have been taken out
            if ( params.Length() <= 0)
                {
                delete value;
                delete tempParams;
                return;
                }
            }
        
        delete value;
        
        iType = EScutApplicationWithParams;
        
        const TInt valueSeparatorPos = params.Locate(KParamValueSeparator);

        if (valueSeparatorPos >= 0)
        {
            iParamName.Set(params.Left(valueSeparatorPos));
        }
        if (valueSeparatorPos >= 0)
        {
            iParamValue.Set(params.Mid(valueSeparatorPos + 1));
        }
        if (valueSeparatorPos == -1)
        {
            iParamName.Set(params);
        }

        if (iParamName.CompareC(KScutParamNameView) == 0)
        {
            iType = EScutApplicationView;

            if (iUid == KScutPersonalisationUid)
            {
                TUid uid = ParseUid(iParamValue);
                if (uid == KScutChangeThemeViewId)
                {
                    iType = EScutChangeTheme;
                }
                iIcon.iViewId = uid;
            }

            if (iUid == KScutLogsUid)
            {
                if (iParamValue.CompareC(KScutParamValueMissedCalls) == 0)
                {
                    iType = EScutLogsMissedCallsView;
                }
                else if (iParamValue.CompareC(KScutParamValueDialledCalls) == 0)
                {
                    iType = EScutLogsDialledCallsView;
                }
                else if (iParamValue.CompareC(KScutParamValueReceivedCalls) == 0)
                {
                    iType = EScutLogsReceivedCallsView;
                }
                else if (iParamValue.CompareC(KScutParamValueMainView) == 0)
                {
                    iType = EScutLogsMainView;
                }
            }

            if (iUid == KScutGeneralSettingsUid)
            {
                if (ParseUid(iParamValue) == KScutParamValueConnectivityView)
                {
                    iType = EScutConnectivityStatusView;
                }
                else if (ParseUid(iParamValue) == KScutInstallationViewId)
                {
                    iType = EScutApplicationManagerView;
                }
            }
            
            
        }
        else if (iUid == KScutMessagingUid)
        {
            if (iParamName.CompareC(KScutParamNameNew) == 0)
            {
                if (iParamValue.CompareC(KScutParamValueMsg) == 0)
                {
                    iType = EScutNewMessage;
                }
                else if (iParamValue.CompareC(KScutParamValueEmail) == 0)
                {
                    iType = EScutNewEmail;
                }
#ifdef __SYNCML_DS_EMAIL
                else if (iParamValue.CompareC(KScutParamValueSyncMLMail) == 0)
                {
                    iType = EScutNewSyncMLMail;
                }
#endif
                else if (iParamValue.CompareC(KScutParamValuePostcard) == 0)
                {
                    iType = EScutNewPostcard;
                }
                else if (iParamValue.CompareC(KScutParamValueAudioMsg) == 0)
                {
                    iType = EScutNewAudioMsg;
                }
                else
                {
                    iType = EScutNewMsgType;
                }
            }
            else if (iParamName.CompareC(KScutParamNameMailbox) == 0)
            {
                iType = EScutMailbox;
            }
        }
        else if (iUid == KScutKeyLockUid)
        {
            iType = EScutKeylock;
        }
        else if (iUid == KScutSettingsDllUid || iUid == KScutBrowserUid)
        {
            if (iParamName.CompareC(KScutParamNameBookmark) == 0)
            {
                iType = EScutBookmark;
                iIcon.iViewId = ParseUid(iParamValue);
            }
            else if (iParamName.CompareC(KScutParamNoEffect) == 0)
            {
                iType = EScutNoEffect;
            }
        }
        delete tempParams;
    }
}

TInt TAiScutParser::ChecksumForString( const TDesC& aDefinition) const 
    {
    return CreateChecksumFromString( aDefinition );
    }

TInt TAiScutParser::CustomTitle( TDes& aTarget ) const
    {
    TPtrC params(iUriParser.Extract(EUriQuery));
    HBufC *tempParams = params.Alloc();
    if ( !tempParams )
        {
        return KErrNoMemory;
        }
        
    TPtr tempParamsPtr = tempParams->Des();
    
    TInt err = ExtractValueFromQueryString(tempParamsPtr,
            KScutParamNameCustomTitle, aTarget, EFalse);
    
    delete tempParams;
    return err;
    }

void TAiScutParser::RemoveExtraDefinitionsL( TDes &aString ) const
    {
    HBufC *temp = HBufC::NewL( aString.Length( ));
    TPtr tempPtr = temp->Des();
    ExtractValueFromQueryString(aString,
                    KScutParamNameCBAIcon, tempPtr, ETrue);
    
    ExtractValueFromQueryString(aString,
                KScutParamNameIconSkinId,tempPtr, ETrue);
    
    ExtractValueFromQueryString(aString,
                KScutParamNameIconMifPath,tempPtr, ETrue);
    
    ExtractValueFromQueryString(aString,
                KScutParamNameCustomTitle, tempPtr, ETrue);
    ExtractValueFromQueryString(aString,
                KScutParamNameIconPath, tempPtr, ETrue);
    delete temp;
    }

// End of File.
hs_app_wrtdataplugin.rss
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Registry info
 *
*/


// INCLUDES
#include 
#include "hs_app_wrtdatapluginuids.hrh"

 

// -----------------------------------------------------------------------------
//   
// registry_info
// Registry information required for identifying the ECOM component
//
// -----------------------------------------------------------------------------
//

RESOURCE REGISTRY_INFO registry_info
{
    resource_format_version = RESOURCE_FORMAT_VERSION_2;

    dll_uid = WRTDP_UID_ECOM_DLL_CONTENTPUBLISHER_DATAPLUGIN; 

    // Declare array of interface info
    interfaces = 
    {
        INTERFACE_INFO
        {
            // UID of interface that is implemented
            interface_uid = AI_UID_ECOM_INTERFACE_CONTENTPUBLISHER; 

            implementations = 
            {
                IMPLEMENTATION_INFO
                {
                    implementation_uid = WRTDP_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DATAPLUGIN;
                    version_no         = 1;
                    display_name       = "WRT Data plug-in";
                    default_data       = "";
                    opaque_data        = "";
                }
            };
        }
    };
}


// End of File
bld.inf
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  The build information file of Data Plugin
*
*/


#include 

PRJ_PLATFORMS
DEFAULT

PRJ_EXPORTS


../rom/hs_app_wrtdataplugin.iby                CORE_MW_LAYER_IBY_EXPORT_PATH(hs_app_wrtdataplugin.iby)

PRJ_MMPFILES
wrtdataplugin.mmp



// End of File.
wrtdataplugin.mmp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Project definition file for project wrtdataplugin
*
*/
#include 
#include 

#include "../inc/hs_app_wrtdatapluginuids.hrh"

TARGET          hs_app_wrtdataplugin.dll
TARGETTYPE      PLUGIN
UID             0x10009D8D  WRTDP_UID_ECOM_DLL_CONTENTPUBLISHER_DATAPLUGIN

CAPABILITY      CAP_ECOM_PLUGIN
VENDORID        VID_DEFAULT


USERINCLUDE     ../inc


APP_LAYER_SYSTEMINCLUDE


SOURCEPATH      ../data
START RESOURCE  hs_app_wrtdataplugin.rss
TARGET          hs_app_wrtdataplugin.rsc
END


LIBRARY         euser.lib
LIBRARY         bafl.lib
LIBRARY         efsrv.lib
LIBRARY         liwservicehandler.lib 
LIBRARY         ecom.lib
LIBRARY         hs_app_aiutils.lib
LIBRARY         cone.lib
LIBRARY         avkon.lib
LIBRARY         fbscli.lib
LIBRARY         egul.lib
LIBRARY         aknskins.lib  
LIBRARY         estor.lib
LIBRARY         apgrfx.lib 

// End of File
SOURCEPATH ../src

SOURCE hs_app_wrtdataplugin.cpp
SOURCE hs_app_wrtdata.cpp 
SOURCE hs_app_wrtdataobserver.cpp
hs_app_wrtdata.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#ifndef WRTDATA_H
#define WRTDATA_H

// INCLUDE FILES
#include  
#include 
#include "hs_app_wrtdatapluginconst.h"
#include "aicontentpublisher.h"

// FORWARD DECLARATIONS
class MLiwInterface;
class CLiwServiceHandler;
class CWrtDataObserver;
class CWrtDataPlugin;

// CLASS DECLARATION
/**
 *  @ingroup group_wrtdataplugin
 *
 *  Wrt data
 *
 *  @since S60 v3.2
 */
class CWrtData : public CBase
   {

   public:
        
        /**
        * Part of the two phased construction
        *
        * @param aPlugin refrence of the plugin
        * @return none
        */
        static CWrtData* NewL(CWrtDataPlugin* aPlugin);
        
        /**
        * Destructor
        *
        * @param none
        * @return none
        */
        ~CWrtData();
    
   public : 
    
        /**
        * Configures the subscriber and data to subscribe.
        *  
        * @param aConfigurations  Information about the subscriber 
        *  and the data to subscribe.
        * @return void
        */
        void ConfigureL(RAiSettingsItemArray& aConfigurations);
     
        /**
        * Checks is this menu item is supported by the publisher
        * 
        * @param aMenuItem  menu item name.
        * @return  boolean (ETrue/EFalse) 
        */
        TBool HasMenuItem(const TDesC16& aMenuItem );

        /**
        * Register to CPS for all (add/delete/update/execute) action
        * 
        * @param none
        * @return void
        */
        void RegisterL();
        
       /**
        * Update the publisher status 
        * 
        * @param None
        * @return void
        */
        void UpdatePublisherStatusL();     
              
        /**
        * Publish updated data for all the items in the widget
        *     
        * @param aObserver to publish data
        * @return void
        */
        void PublishDefaultImageL( MAiContentObserver* aObserver );
                
        /**
        * Publish the updated data
        *   
        * @param aObserver to publish data
        * @param aDataMap data map
        * @return void
        */
        void PublishL( MAiContentObserver* aObserver, CLiwDefaultMap* aDataMap );
        
        /**
        * Called by the observer to refresh the changed content
        *   
        * @param aContentId content Id.
        * @param aOperation operation (add/delete/update/execute).
        * @param aDataMap data map.
        * @return void
        */
        void RefreshL( TDesC& aContentId, TDesC& aOperation, CLiwDefaultMap* aDataMap );
                
        /**
        * Tigger for execution of a action for a specific content id.
        * 
        * @param aObjectId object Id.
        * @param aTrigger name of the trigger.
        * @return void
        */
        void ExecuteActionL(const TDesC& aObjectId, const TDesC& aTrigger);

        /**
        * Is the pugin is active to publish the data.
        * 
        * @param None
        * @return boolean (ETrue/EFalse).
        */
        TBool IsPluginActive();

        /**
        * Activate the publisher
        * 
        * @param None
        * @return void
        */
        void ActivateL();
                 
        /**
        * Resume the publisher
        * 
        * @param None
        * @return void
        */
        void ResumeL();
        
        /**
        * Suspend the publisher
        * 
        * @param None
        * @return void
        */
        void SuspendL();
        
        /**
        * Deactivate the publisher
        * 
        * @param None
        * @return void
        */
        void DeActivateL();
        
        /**
        * InActiveL 
        * 
        * @param None
        * @return void
        */
        void InActiveL();        
        
        /**
        * OnLineL 
        * 
        * @param None
        * @return void
        */
        void OnLineL();
        
        /**
        * OffLineL 
        * 
        * @param None
        * @return void
        */
        void OffLineL();

   private :
    
        /**
        * Default Constructor
        *
        */
        CWrtData();
        
        /**
        * Part of the two phased construction
        *
        * @param aPlugin reference of the plugin
        * @return void
        */
        void ConstructL(CWrtDataPlugin* aPlugin);
         
        /**
        * Createts the filter map
        * 
        * @return filter map
        */
        CLiwDefaultMap* CreateFilterLC( );
          
        /**
        * Execute the command to get the data from CPS
        * 
        * @param aInFilter input filter for the command
        * @param aOutDataMap output data map 
        * @param aRegistry type of registry (publisher/cp_data)
        * @return void 
        */
        void ExecuteCommandL(CLiwDefaultMap* aInFilter, 
                CLiwDefaultMap* aOutDataMap, const TDesC16& aRegistry );
       

        /**
        * Change the publisher status
        *
        * @param aStatus new status of the publisher
        * @return void
        */
        void ChangePublisherStatusL(const TDesC& aStatus);
        
        /**
        * Gets the menu item from the publisher
        *
        * @param none
        * @return void
        */
        void GetMenuItemsL();
        
        /**
        * Gets the widgent name and uid 
        *
        * @param aName  - widget name
        * @param aAppUID - widget uid
        * @return void
        */
        void GetWidgetNameAndUidL(TDes& aName, TDes& aAppUID );
        
        /**
        * Resolves the Uid from the string  
        *
        * @param aUidDes  - uid in string
        * @param aUid - uid
        * @return ETure/EFalse
        */ 
        TBool ResolveUid(const TDesC& aUidDes, TUid& aUid );
        
        /**
        * Creates icon from the uid
        *
        * @param aHandle  - icon handle
        * @param aMaskHandle - mask handle
        * @param aAppUid - application uid
        * @return ETure/EFalse
        */   
        void CreateIconFromUidL(TInt& aHandle, TInt& aMaskHandle, const TUid& aAppUid );

    private :   
        
        // Subscriber interface
        // own
        MLiwInterface* iInterface;
          
        // Data Observer to CPS
        // Own
        CWrtDataObserver* iObserver;
       
        // Service handler 
        // Own
        CLiwServiceHandler* iServiceHandler;
    
        // Command name in configuration Array
        HBufC8* iCommandName;
          
        // Reference of the wrt data plugin
        // Not owned
        CWrtDataPlugin* iPlugin;
        
        // Menu item names
        // Own
        RPointerArray iMenuItems; 
        
        // Trigger names for the menu items
        // Own
        RPointerArray iMenuTriggers;
        
        // Widgets content id.
        // Own
        HBufC* iContentId;
 
    };

#endif /*WRTDATA_H*/
hs_app_wrtdataobserver.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#ifndef WRTDATAOBSERVER_H
#define WRTDATAOBSERVER_H

// INCLUDE FILES
#include 

// FORWARD DECLARATIONS
class CWrtData;

// CLASS DECLARATION
/**
 *  @ingroup group_wrtdataplugin
 *
 *  Wrt data observer
 *
 *  @since S60 v3.2
 */
class CWrtDataObserver : public CBase, public MLiwNotifyCallback
    {
    public:

        /**
        * Part of the two phased constuction
        *
        * @param aInterface reference of the interface 
        * @param aData reference of the wrt data object
        * @return none
        */
        static CWrtDataObserver* NewL( MLiwInterface* aInterface, CWrtData* aData );
    
        /**
        * Destructor
        *
        * @param none
        * @return none
        */   
        ~CWrtDataObserver();

    private :
    
        /**
        * Constructor
        *
        * @param none
        * @return none
        */
        CWrtDataObserver();
        
        /**
        * Part of the two phased construction
        *
        * @param aInterface reference of the interface
        * @param aData reference of the wrt data object
        * @return void
        */
        void ConstructL( MLiwInterface* aInterface, CWrtData* aData );
       
    public:  //from MLiwNotifyCallbackc
    
        /**
        * Handles notifications caused by an asynchronous Execute*CmdL call
        * or an event.
        *
        * @param aCmdId The service command associated to the event.
        * @param aEventId occurred event, see LiwCommon.hrh.
        * @param aEventParamList Event parameters, if any, as defined per
        *        each event.
        * @param aInParamList Input parameters, if any, given in the
        *        related HandleCommmandL.
        * @return Error code for the call back.
        */
        virtual TInt HandleNotifyL(
            TInt aCmdId,
            TInt /*aEventId*/,
            CLiwGenericParamList& aEventParamList,
            const CLiwGenericParamList& /*aInParamList*/);

    public:
    
        /**
        * Registers to CPS for add, delete , update and execute notifications
        * @aFilter - filter for input parameter list
        * @return void.
        */
        void RegisterL( CLiwDefaultMap* aFilter );
    
        /**
        * Cancel all the registered notifications. 
        * @return void.
        */
        void ReleaseL();
            
    private:
            
        // Reference of 
        // Not owned
        MLiwInterface* iInterface;
        
        // Reference of the wrt data
        // Not owned
        CWrtData* iData;
        
        // Call back error code
        TInt iError;
        
    };

#endif /*WRTDATAOBSERVER_H*/
hs_app_wrtdataplugin.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plug-in main class
*
*/


#ifndef WRTDATAPLUGIN_H
#define WRTDATAPLUGIN_H

#include 
#include 
#include 
#include 

// FORWARD DECLARATIONS
class MAiContentObserver;
class MAiContentItemIterator;
class MAiPSPropertyObserver;
class CWrtData;
class CDesC16Array;
class CGulIcon;
class CLiwDefaultMap;


// CLASS DECLARATION
/**
 *  @ingroup group_wrtdataplugin
 *
 *  Plug-in main class
 *
 *  @since S60 v3.2
 */
class CWrtDataPlugin : public CAiContentPublisher,
                     	public MAiPropertyExtension,
                     	public MAiEventHandlerExtension
                    
    {
        
    public :
        /**
        * Plugin's network state.
        */
        enum TPluginNetworkStatus 
            {
            EUnknown, 
            EOffline,
            EOnline
            };
        
        /**
         * Plugin's state.
         */
        enum TPluginStates
            {
            ENone,
            EResume,
            ESuspend,
            EInActive,
            };
        
        /**
        * Content Items
        */
        enum TContentItem
         {
         EDefaultImage,
         EDefaultText,
         EImage1
         };

    public:
    
        /**
        * Part of the two phased constuction
        *
        * @param none
        * @return none
        */
        static CWrtDataPlugin* NewL();
        
        /**
        * Destructor
        *
        * @param none
        * @return none
        */
        ~CWrtDataPlugin();

    public: // from base class CAiContentPublisher
        
        /**
        * From CAiContentPublisher
        * The method is called by the framework to request the plug-in free all
        * memory and CPU resources and close all its open files, e.g. the plug-in 
        * should unload its engines due backup operation. The method transits the 
        * plug-in to "Idle" state.
        *
        * @param aReason reason for state change, see TAiTransitionChange.
        * @return void
        */
        void Stop( TAiTransitionReason aReason );
    
        /**
        * From CAiContentPublisher
        * The method is called by the framework to instruct plug-in that it is
        * allowed to consume CPU resources, e.g plug-in is able to run timers,
        * perform asynchronous operations, etc. The method transits the plug-in
        * to "Alive" state.
        *
        * @param aReason reason for state change, see TAiTransitionChange.
        * @return void
        */
        void Resume( TAiTransitionReason aReason );
    
        /**
        * From CAiContentPublisher
        * The method is called by the framework to instruct plug-in that it is
        * not allowed to consume CPU resources, e.g plug-in MUST stop each
        * timers, cancel outstanding asynchronous operations, etc. The method
        * transits the plug-in to "Suspendend" state.
        *
        * @param aReason reason for state change, see TAiTransitionChange.
        * @return void
        */
        void Suspend( TAiTransitionReason aReason );
    
        /**
        * From CAiContentPublisher
        * Adds the content observer / subscriber to plug-in. The plug-in MUST
        * maintain a registry of subscribers and send notification to all them
        * whenever the plug-in changes state or new content available.
        *
        * @param aObserver content observer to register.
        * @return void
        */
        void SubscribeL( MAiContentObserver& aObserver );
        
        /**
        * From CAiContentPublisher
        * Configures the plug-in.
        * Plug-ins take ownership of the settings array, so it must either
        * store it in a member or free it. Framework has put the array in cleanup
        * stack so the plugin shouldn't do that.
        * If this leaves, the plug-in will be destroyed by AI FW.
        * Plug-in must support LaunchByValue-event even if normal shortcuts don't
        * work. The only allowed serious enough leave is KErrNotFound from CenRep.
        *
        * @param aSettings setting items defined in the UI definition.
        * @return void
        */
        void ConfigureL( RAiSettingsItemArray& aSettings );
        
        /**
        * From CAiContentPublisher
        * Returns interface extension. In Series 60 3.1 only event & property
        * extensions are supported. See MAiEventExtension & MAiPropertyExtension
        * interfaces.
        *
        * @param  aUid - UID of the extension interface to access.
        * @return the extension interface. Actual type depends on the passed aUid 
        *         argument.
        */
        TAny* Extension( TUid aUid );  
    
    // from base class MAiPropertyExtension
    
        /**
        * From MAiPropertyExtension.
        * Read property of publisher plug-in.
        *
        * @param aProperty - identification of property.
        * @return pointer to property value.
        */
        TAny* GetPropertyL( TInt aProperty );
    
        /**
        * From MAiPropertyExtension.
        * Write property value.
        *
        * @param aProperty - identification of property.
        * @param aValue - contains pointer to property value.
        */
        void SetPropertyL( TInt aProperty, TAny* aValue );
      
     // from base class MAiEventHandlerExtension
       
         /**
         * From MAiEventHandlerExtension
         * Invoked by the framework when plug-in must handle an event.
         * @param aEvent - unique identifier of event from plug-in content model.
         * @param aParam - parameters associated with event. Each UI Definition
         *        declares events in the format: (),
         *        where  is mapped by the framework to unique
         *        identifier supplied in aEvent,  are provided to
         *        plug-in as-is in the descriptor.
         * @since S60 3.2
         */
         void HandleEvent(TInt aEvent, const TDesC& aParam);
        
         /**
         * From MAiEventHandlerExtension
         * Invoked by the framework when plug-in must handle an event.
         *
         * @param aEventName - name of the event from plug-in content model.
         * @param aParam - parameters associated with event. Each UI Definition
         *        declares events in the format: (),
         *        where   mapping to unique identifier supplied by event 
         *        is failed by the frame work then the   and  
         *          are provided to plug-in as-is in the descriptor.
         */
         void HandleEvent(const TDesC& aEventName, const TDesC& aParam);
    
        /**
        * Invoked by the framework for querying if plugin has menu item
        *
        * @param aMenuItem  menu item name.
        * @return ETrue if plugin has specific menu item, EFalse otherwise 
        */
        TBool HasMenuItem(const TDesC16& aMenuItem);
         
    public : // New functions
    
        /**
        * Gets the id of a content  
        *
        * @param aObjectId image or text id
        * @return id of the content
        */
        TInt GetIdL(TDesC16& aObjectId);
        
        /**
        * Gets the type of a specific content
        *
        * @param aObjectId image or text id
        * @param aType type
        * @return void
        */
        void GetTypeL( TDesC16& aObjectId, TDes16& aType );
        
        /**
        * RefereshL a specific image of text in the widget
        *
        * @param aOperation operation performed
        * @param aDataMap data map
        * @return void
        */
        void RefreshL(TDesC16& aOperation, CLiwDefaultMap* aDataMap );
        
        /**
        * Is plugin active to publish the data 
        *
        * @param void 
        * @return boolean (ETrue/EFalse)
        */
        TBool IsActive();
        
        /**
        * Publish a specific text of the widget  
        *
        * @param aObserver observer
        * @param aContentId content model id
        * @param aContentValue content value
        * @return void
        */
        void PublishTextL(MAiContentObserver* aObserver, 
                TInt aContentId, const TDesC16& aContentValue);
    
        /**
        * Publish a specific image of the widget  
        *
        * @param aObserver observer
        * @param aContentId content model id
        * @param aHandle image handle 
        * @param aMaskHandle handle of the mask image
        * @return void
        */
        void PublishImageL(MAiContentObserver* aObserver, 
                TContentItem aContentId, TInt aHandle, TInt aMaskHandle);
    
        /**
        * Publish a specific image of the widget  
        *
        * @param aObserver observer
        * @param aContentId content model id
        * @param aPath image path / skin id pattern / mif id Pattern 
        * @return void
        */
        void PublishImageL(MAiContentObserver* aObserver,
                TContentItem aContentId, const TDesC16& aPath );
        
        /**
        * Cleans a data from the widget
        *
        * @param aObserver observer
        * @param aContentId content model id
        * @return void
        */
        void Clean(MAiContentObserver* aObserver, 
                TInt aContentId );
        
        /**
        * Shows the loading icon animation 
        *
        * @param aObserver observer
        * @return void
        */
        void ShowLoadingIcon(MAiContentObserver* aObserver);

        /**
        * Hides the loading icon animation 
        *
        * @param aObserver observer
        * @return void
        */
        void HideLoadingIcon(MAiContentObserver* aObserver);

        /**
        * CWrtData getter
        * @return Pointer to CWrtData
        */
        inline CWrtData* Data() const
            {
            return iData;
            }
    
        /*
        * Plugin's network status getter
        * @return Pointer to Harvester status observer
        */
        inline TPluginNetworkStatus NetworkStatus() const
            {
            return iNetworkStatus;
            }
    
    private:
        
        /**
        * Constructor
        *
        * @param none
        * @return none
        */
        CWrtDataPlugin();
        
        /**
        * Part of the two phased construction
        *
        * @param void
        * @return void
        */
        void ConstructL();
        
        /**
        * Publishes widget's texts and images
        *
        * @param void
        * @return void
        */
        void PublishL();

        /**
        * Resume the plug-in.
        *
        * @param aReason reason for state change, see TAiTransitionChange.
        * @return void
        */    
        void DoResumeL(TAiTransitionReason aReason);
        
        /**
        * Resolves skin item id and Mif id from pattern 
        * skin(   () 
        * mif(  )
        * 
        * @param aPath  skin pattern / mif pattern value
        * @param aItemId skin item id  
        * @param aMifId  mif id 
        * @param aMaskId  mask id 
        * @param aFilename mif file name
        * @return boolean (ETrue/EFalse)  
        */
        TBool ResolveSkinIdAndMifId( const TDesC& aPath, TAknsItemID& aItemId,
                TInt& aMifId, TInt& aMaskId, TDes& aFilename );
        
    private: // data
    
        // Iterator for plugin content
        // Own
        MAiContentItemIterator* iContent;
    
        // Array of content observers
        // Own
        RPointerArray iObservers;
        
        // Information about the content publisher (this plug-in)
        TAiPublisherInfo iInfo;
        
        // Number of data in the content model.
        TInt iDataCount;
         
        // Dynamic content model
        // Own
        TAiContentItem* iContentModel;
        
        // Reference array for Published text
        // Own
        RPointerArray iDataArray;
        
        // Service API Data Subscriber.
        // Own
        CWrtData* iData;
        
        // References array for published images 
        // Own
        RArray iIconArray;
        
        // Plugin's network status
        TPluginNetworkStatus iNetworkStatus;
        
        // Is Homescreen foreground.
        TBool iHSForeGround;
        
        // Is KeyLockON.
        TBool iKeyLockOn;
    
        // Plugin state    
        TPluginStates iPluginState;
    };

#endif // WRTDATAPLUGIN_H


hs_app_wrtdatapluginconst.h
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
* Content model for data plug-in.
*
*/


#ifndef WRTDATAPLUGINCONST_H
#define WRTDATAPLUGINCONST_H

#include 
#include "hs_app_wrtdatapluginuids.hrh"

// AI Data Plug-in ECOM implementation UID.
const TInt KImplUidDataPlugin = WRTDP_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DATAPLUGIN;
const TUid KUidDataPlugin = { KImplUidDataPlugin };

// ================================= CONTENT ===================================

/**
 * Content Model type identifier
 */
_LIT(KText ,"text");
_LIT(KImage, "image");
_LIT(KAnimation, "animation");
_LIT(KPlugin, "plugin");

_LIT(KNewsTicker ,"newsticker");


// CPS Constants
_LIT(KService,         "service");
_LIT(KInterface,       "interface");
_LIT(KCommand,         "command");
_LIT8( KType,          "type");
_LIT( KCpData,         "cp_data");
_LIT( KPubData,        "publisher" );
_LIT( KCpData_PubData, "cp_data:publisher");

_LIT8( KFilter,        "filter" );
_LIT8( KDataMap,       "data_map");
_LIT8( KActionTrigger, "action_trigger" );
_LIT8( KGetList ,      "GetList" );
_LIT8( KExecuteAction, "ExecuteAction" );
_LIT8( KRequestNotification, "RequestNotification" );
_LIT8( KChangeInfo, "change_info" );
_LIT8( KListMap, "list_map" );
_LIT8( KPublisherId, "publisher" );
_LIT8( KContentType, "content_type" );
_LIT8( KContentId,   "content_id" );
_LIT8( KResults,      "results");
_LIT8( KMenuItems,     "menuitems");
_LIT( KMenuItem16,     "menuitem");
_LIT( KAll, "all");
_LIT8( KOperation, "operation" );
_LIT8( KFLAG,      "flag");

_LIT( KOperationAdd, "add" );
_LIT( KOperationUpdate, "update" );
_LIT( KOperationDelete, "delete" );
_LIT( KOperationExecute, "execute" );
_LIT( KAddUpdateDelete, "add:update:delete" );

_LIT( KDeActive, "deactive");
_LIT( KActive, "active");
_LIT( KSuspend , "suspend");
_LIT( KResume, "resume");
_LIT( KOnLine, "online");
_LIT( KOffLine, "offline");
_LIT( KInActive, "inactive");

// reserved extension for retrieving mask handle 
_LIT8( KImageMask, "image1_mask");

_LIT( KSkin, 		 "skin" );
_LIT( KMif, 		 "mif" );
_LIT( KMIFExtension, ".mif" );
_LIT( KColon,		 ":");

_LIT( KTemplateWidget,"ai3templatedwidget");
_LIT( KWRTPublisher, "wrt_publisher");
_LIT8(KImage1, "image1");
_LIT8( KWidgetInfo,   "widget_info");
_LIT8( KWidgetName, "widget_name");
_LIT8( KWidgetIcon, "widget_icon");

_LIT( KHexPrefix,     "0x" );
_LIT( KUid,           "uid" );
_LIT8(KElement, "loading");
_LIT8(KDisplay, "display");
_LIT8(KShow, "block");
_LIT8(KHide, "none");

#ifdef __WINS__
_LIT( KDrive, "C:" );
#else
_LIT( KDrive, "Z:" );
#endif

#ifdef WRT_PREDEFINED_IMAGE  
_LIT(KImgFolder, "200286dd\\");
_LIT(KJPEG, ".jpg");
_LIT(KPNG, ".png");
#endif

const TUint KLeftParenthesis = '(';


// WRT Data Plugin Constants
const TUint KPluginNameSeprator =  '/';

/**
 * Maximum length for the content name
 */
const TInt KMaxTypeLength = 8;

/**
 * Maximum length for the content name
 */
const TInt KWRTContentNameMaxLength = 255;

/**
 * Maximum length for the content value
 */
const TInt KWRTContentValueMaxLength = 255;

/**
 * Maximum length for the plugin name
 */
const TInt KAiPluginNameMaxLength = 255;

/**
 * Maximum length for the application uid string
 * uid(0x123456578)
 * 
 */
const TInt KWRTAppUidLenth = 16; 

#endif /* WRTDATAPLUGINCONST_H */
hs_app_wrtdatapluginuids.hrh
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
* {Name} {Company} - {Description of contribution}
*
* Description:
* UIDs for the Active Idle subsystem components.
*
*/

#ifndef WRTDATAPLUGINUIDS_HRH
#define WRTDATAPLUGINUIDS_HRH

#include 

/**
 * Ecom dll uid for AI Data plug-in.
 */
#define WRTDP_UID_ECOM_DLL_CONTENTPUBLISHER_DATAPLUGIN 0x200286DC

/**
 * Ecom implementation uid for AI Data plug-in.
 */     
#define WRTDP_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DATAPLUGIN 0x200286DD

#endif //WRTDATAPLUGINUIDS_HRH
hs_app_wrtdataplugin.iby
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
* IBY file for Data plug-in
*
*/

#ifndef WRTDATAPLUGIN_IBY
#define WRTDATAPLUGIN_IBY
#include 

#ifdef RD_CUSTOMIZABLE_AI

ECOM_PLUGIN(hs_app_wrtdataplugin.dll, hs_app_wrtdataplugin.rsc)

#endif // RD_CUSTOMIZABLE_AI

#endif // WRTDATAPLUGIN_IBY

hs_app_wrtdata.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
* Profile plug-in publisher
*
*/


// INCLUDE FILES
#include 
#include 
#include 
#include 
#include  
#include  

#include "hs_app_wrtdata.h"
#include "hs_app_wrtdatapluginconst.h"
#include "hs_app_wrtdataobserver.h"
#include "hs_app_wrtdataplugin.h"

// ======== MEMBER FUNCTIONS ========
	
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
CWrtData* CWrtData::NewL(CWrtDataPlugin* aPlugin)
    {
    CWrtData* self = new (ELeave) CWrtData();
    CleanupStack::PushL( self );
    self->ConstructL(aPlugin);
    CleanupStack::Pop( self );
    return self;
    }
    
// ---------------------------------------------------------------------------
// Default constructor
// ---------------------------------------------------------------------------
//
CWrtData::CWrtData()
    {
    }
    
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
void CWrtData::ConstructL(CWrtDataPlugin* aPlugin)
    { 
     iPlugin = aPlugin;
     iCommandName = HBufC8::NewL( KWRTContentValueMaxLength );
    }
    
// ---------------------------------------------------------------------------
// Destructor
// Deletes all data created to heap
// ---------------------------------------------------------------------------
//
CWrtData::~CWrtData()
    {
    if( iCommandName )
    	{
    	delete iCommandName;
    	iCommandName = NULL;
    	}
    if(iObserver)
        {
        TRAP_IGNORE(iObserver->ReleaseL() );
        delete iObserver;
        iObserver = NULL;
        }
    if( iInterface )
         {
         iInterface->Close();
         iInterface = NULL;
         }
    if( iServiceHandler )
         {
         iServiceHandler->Reset();
         delete iServiceHandler;
         iServiceHandler = NULL;
         }
    if ( iContentId )
    	{
    	delete iContentId;
    	iContentId = NULL;
    	}
    iMenuItems.ResetAndDestroy();
    iMenuTriggers.ResetAndDestroy();
    // not owned
    iPlugin = NULL;
    }

// ---------------------------------------------------------------------------
// CWrtData::ConfigureL
// ---------------------------------------------------------------------------
//
void CWrtData::ConfigureL(RAiSettingsItemArray& aConfigurations )
    {
    HBufC8* serviceName = HBufC8::NewLC( KWRTContentValueMaxLength );
    HBufC8* interfaceName = HBufC8::NewLC( KWRTContentValueMaxLength );
    
    // Interface name 
    RCriteriaArray criteriaArray;
    
    TInt count = aConfigurations.Count();
   
    for(TInt i = 0;iAiPluginConfigurationItem();
       // if owner is plugin then it (key,value) is for plugin configurations items
       if(confItem.Owner() == KPlugin())
           {
           if(confItem.Name() ==  KService())
               {
               serviceName->Des().Copy(confItem.Value());
               }
           else if( confItem.Name() == KInterface() )
                 {
                 interfaceName->Des().Copy(confItem.Value());
                 }
           else if( confItem.Name() == KCommand() )
                 {
                 iCommandName->Des().Copy(confItem.Value());
                 }
           else if( confItem.Name() == KMenuItem16() )
                 {
                 iMenuItems.AppendL( confItem.Value().AllocL() );
                 }
           else if( confItem.Name() == KPubData() )
				  {
				  iContentId = confItem.Value().AllocL();
				  }
           }
       }
    
    if( !( serviceName->Des().Length() >= 0 && interfaceName->Des().Length() >= 0  
            && iCommandName->Des().Length() >= 0 ) )
        {
        // No service to offer without plugin configurations 
        User::Leave( KErrNotSupported );
        }
    
    iServiceHandler = CLiwServiceHandler::NewL(); 

    // for convenience keep pointers to Service Handler param lists 
    CLiwGenericParamList* inParamList  = &iServiceHandler->InParamListL();
    CLiwGenericParamList* outParamList = &iServiceHandler->OutParamListL();

    CLiwCriteriaItem* criteriaItem = CLiwCriteriaItem::NewLC( KLiwCmdAsStr, *interfaceName , *serviceName );
    criteriaItem->SetServiceClass( TUid::Uid( KLiwClassBase ) );
    criteriaArray.AppendL( criteriaItem );


    // attach Liw criteria
     iServiceHandler->AttachL( criteriaArray );
     iServiceHandler->ExecuteServiceCmdL( *criteriaItem, *inParamList, *outParamList );

     CleanupStack::PopAndDestroy(criteriaItem);
     criteriaArray.Reset();

    // extract CPS interface from output params
    TInt pos( 0 );
    outParamList->FindFirst( pos, *interfaceName );
    if( pos != KErrNotFound )
        {
        //iInterface is MLiwInterface*
        iInterface = (*outParamList)[pos].Value().AsInterface(); 
        User::LeaveIfNull( iInterface );
        }
    else
        {
        User::Leave( KErrNotFound );
        }
    inParamList->Reset();
    outParamList->Reset();
    CleanupStack::PopAndDestroy( interfaceName );
    CleanupStack::PopAndDestroy( serviceName );

	//Gets the menu items from the publisher registry    
    GetMenuItemsL();
 
    iObserver = CWrtDataObserver::NewL( iInterface, this );   
    }

// ---------------------------------------------------------------------------
// CWrtData::HasMenuItem
// ---------------------------------------------------------------------------
//
TBool CWrtData::HasMenuItem(const TDesC16& aMenuItem )
    {
    TBool found = EFalse;
    for (TInt i = 0; i < iMenuItems.Count(); i++ )
        {
        if( aMenuItem == iMenuItems[i] )
            {
            found =  ETrue;
            break;
            }
        }
    return found;
    }

// ---------------------------------------------------------------------------
// CWrtData::RegisterL
// ---------------------------------------------------------------------------
//
void CWrtData::RegisterL()
    {
    CLiwDefaultMap* filter = CreateFilterLC();
    filter->InsertL( KOperation, TLiwVariant( KAddUpdateDelete ) );
    iObserver->RegisterL(filter);
    CleanupStack::PopAndDestroy( filter );
    }

// ---------------------------------------------------------------------------
// CWrtData::UpdatePublisherStatusL
// ---------------------------------------------------------------------------
//
void CWrtData::UpdatePublisherStatusL()
    {
     // Resent the plugin status to publisher
     ActivateL();
     if ( iPlugin->IsActive() )
         {
         ResumeL();
         }
     else
         {
         SuspendL();
         }
      // forward the network status if it uses.
    if ( iPlugin->NetworkStatus() == CWrtDataPlugin::EOnline )
        {
        OnLineL();
        }
    else if ( iPlugin->NetworkStatus() == CWrtDataPlugin::EOffline )
        {
        OffLineL();
        }
    }

// ---------------------------------------------------------------------------
// CWrtData::PublishDefaultImageL
// ---------------------------------------------------------------------------
//
void CWrtData::PublishDefaultImageL( MAiContentObserver* aObserver )
    {
    TBuf appUidStr;
    TBuf appName;
    GetWidgetNameAndUidL( appName, appUidStr );
    
    TUid appUid;
    if ( ResolveUid (appUidStr, appUid ) )
        {
#ifdef WRT_PREDEFINED_IMAGE         
        RFs rfs;
        User::LeaveIfError( rfs.Connect() );

        TFileName privatePath;
        rfs.PrivatePath(privatePath);
        privatePath.Insert(0,KDrive);
        privatePath.Append( KImgFolder );
      
        appUidStr.Copy( appUid.Name());
        appUidStr.Delete(0,1);
        appUidStr.Delete( appUidStr.Length() -1, 1);
        privatePath.Append (appUidStr );
        privatePath.Append ( KJPEG );
        if ( BaflUtils::FileExists(rfs,privatePath) )
            {
            // Publish predefined jpeg image
            iPlugin->PublishImageL( aObserver, CWrtDataPlugin::EImage1,privatePath);
            }
        else
            {
            privatePath.Delete( privatePath.Length() - 4 , 4);
            privatePath.Append( KPNG );
            if ( BaflUtils::FileExists(rfs,privatePath) )
               {
               // Publish predefined image
               iPlugin->PublishImageL( aObserver, CWrtDataPlugin::EImage1,privatePath);
               }
            else
                {
#endif                 
                TInt handle = KErrNotFound;
                TInt mask = KErrNotFound;
                CreateIconFromUidL( handle, mask, appUid );
                // Publish widget apparc image
                iPlugin->PublishImageL( aObserver, CWrtDataPlugin::EDefaultImage,handle,mask);
                if ( appName.Length() > 0)
                   {
                   // Publish Widget Name
                   iPlugin->PublishTextL( aObserver, CWrtDataPlugin::EDefaultText, appName);
                   }
#ifdef WRT_PREDEFINED_IMAGE                
                }
            }
        rfs.Close();
#endif        
        }
    
    // Show loading animation
    iPlugin->ShowLoadingIcon(aObserver);
    }

// ---------------------------------------------------------------------------
// CWrtData::PublishL
// ---------------------------------------------------------------------------
//
void CWrtData::PublishL( MAiContentObserver* aObserver, CLiwDefaultMap* aDataMap ) 
    {
    TLiwVariant variant;
    iPlugin->HideLoadingIcon(aObserver);
    if ( aDataMap->FindL( KImage1, variant ) )
        {
        TInt handle = KErrBadHandle;
        TUint uintHandle = 0;
        TPtrC16 valPtr;
        if ( variant.Get( uintHandle ) )
            {
            handle = uintHandle;
            }
        else if ( !variant.Get( handle ) )
            {
            handle = KErrBadHandle;
            }
        // read as a image handle
        if( handle == KErrBadHandle )
            {
            // no handle, so read as image path
            variant.Get( valPtr );
            iPlugin->PublishImageL(aObserver, CWrtDataPlugin::EImage1, valPtr );
            }
        else
            {
            TInt maskHandle = KErrBadHandle;
            //Look for image mask
            if ( aDataMap->FindL( KImageMask, variant ) )
               {
               variant.Get( maskHandle );                           
               }
            iPlugin->PublishImageL(aObserver, CWrtDataPlugin::EImage1, handle, maskHandle );
            }
        }
    variant.Reset();
    }

// ---------------------------------------------------------------------------
// CWrtData::RefreshL
// ---------------------------------------------------------------------------
//
void CWrtData::RefreshL( TDesC& aContentId, TDesC& aOperation, 
        CLiwDefaultMap* aDataMap )
    {
     if ( aContentId == iContentId )
         {
         iPlugin->RefreshL( aOperation, aDataMap);
         }
    }

// ---------------------------------------------------------------------------
// CWrtData::ExecuteActionL
// ---------------------------------------------------------------------------
//
void CWrtData::ExecuteActionL(const TDesC& aObjectId, const TDesC& aTrigger )
   {
   HBufC8* triggerName = HBufC8::NewLC( KWRTContentNameMaxLength );
  
   CLiwGenericParamList* inParamList  = &iServiceHandler->InParamListL();
   CLiwGenericParamList* outParamList = &iServiceHandler->OutParamListL();
   CLiwDefaultMap* filter = NULL;

   triggerName->Des().Copy(aTrigger);
   if ( aObjectId == KPubData )
       {
       // this trigger belongs to publisher registery.
       // in such case it is assumed that all the items in the widgets
       // belongs to same publisher, type and id.
       TLiwGenericParam cptype( KType, TLiwVariant( KPubData ) );
       inParamList->AppendL( cptype );
       cptype.Reset();
       // use the first item configuration to create the filter
       filter = CreateFilterLC();
       }
   else
       {
       if ( aObjectId == KMenuItem16 )
           {
           TInt pos = KErrNotFound;
           for (TInt i = 0; i < iMenuItems.Count(); i++)
               {
               if ( aTrigger == iMenuItems[i] )
                   {
                   pos = i;
                   break;
                   }
               }
           if( pos == KErrNotFound )
               {
               // No such menu items
               CleanupStack::PopAndDestroy( triggerName );
               return; 
               }
              triggerName->Des().Copy( iMenuTriggers[pos]->Des() );
              filter = CreateFilterLC();
           }
       else
           {
           //Create filter criteria for requested entries in form of LIW map:
           filter = CreateFilterLC();
           }
       //append type to inparam list
       TLiwGenericParam cptype( KType, TLiwVariant( KCpData ) );
       inParamList->AppendL( cptype );
       cptype.Reset();
       }

    filter->InsertL( KActionTrigger, TLiwVariant( triggerName->Des() ) );
   //append filter to input param
    TLiwGenericParam item( KFilter, TLiwVariant( filter ) );
    inParamList->AppendL( item );
    iInterface->ExecuteCmdL( KExecuteAction,  *inParamList, *outParamList );
    
    CleanupStack::PopAndDestroy( filter );
    CleanupStack::PopAndDestroy( triggerName );
    item.Reset();

    inParamList->Reset();
    outParamList->Reset();  
    
    }

// ---------------------------------------------------------------------------
// CWrtData::IsPluginActive
// ---------------------------------------------------------------------------
//
TBool CWrtData::IsPluginActive()
    {
    return iPlugin->IsActive();
    }

// ---------------------------------------------------------------------------
// CWrtData::ActivateL
// ---------------------------------------------------------------------------
//
void CWrtData::ActivateL()
    {
    ChangePublisherStatusL( KActive );
    }

// ---------------------------------------------------------------------------
// CWrtData::ResumeL
// ---------------------------------------------------------------------------
//
void CWrtData::ResumeL()
    {
    ChangePublisherStatusL( KResume );
    }

// ---------------------------------------------------------------------------
// CWrtData::SuspendL
// ---------------------------------------------------------------------------
//
void CWrtData::SuspendL()
    {
    ChangePublisherStatusL( KSuspend );
    }

// ---------------------------------------------------------------------------
// CWrtData::DeActivateL
// ---------------------------------------------------------------------------
//
void CWrtData::DeActivateL()
    {
    ChangePublisherStatusL( KDeActive );
    }

// ---------------------------------------------------------------------------
// CWrtData::InActiveL
// ---------------------------------------------------------------------------
//
void CWrtData::InActiveL()
    {
    ChangePublisherStatusL( KInActive );
    }

// ---------------------------------------------------------------------------
// CWrtData::OnLineL
// ---------------------------------------------------------------------------
//
void CWrtData::OnLineL()
    {
    ChangePublisherStatusL( KOnLine );
    }

// ---------------------------------------------------------------------------
// CWrtData::offLineL
// ---------------------------------------------------------------------------
//
void CWrtData::OffLineL()
    {
    ChangePublisherStatusL( KOffLine );
    }

// ---------------------------------------------------------------------------
// CWrtData::CreateFilterL
// ---------------------------------------------------------------------------
//
CLiwDefaultMap* CWrtData::CreateFilterLC()
    {
    CLiwDefaultMap* filter = CLiwDefaultMap::NewLC();
    filter->InsertL( KPublisherId, TLiwVariant( KWRTPublisher ));
    filter->InsertL( KContentType, TLiwVariant( KTemplateWidget ));
    filter->InsertL( KContentId, TLiwVariant( iContentId ));
    return filter;
    }

// ---------------------------------------------------------------------------
// CWrtData::ExecuteCommandL
// ---------------------------------------------------------------------------
//
void CWrtData::ExecuteCommandL(CLiwDefaultMap* aInFilter, CLiwDefaultMap* aOutDataMap, const TDesC16& aRegistry  )
    {
    CLiwGenericParamList* inParamList  = &iServiceHandler->InParamListL();
    CLiwGenericParamList* outParamList = &iServiceHandler->OutParamListL();
    
    TLiwGenericParam type( KType, TLiwVariant( aRegistry ) );
    inParamList->AppendL( type );
    
    //append filter to input param
     TLiwGenericParam item( KFilter, TLiwVariant( aInFilter ));
     inParamList->AppendL( item );
     
    // execute service.It is assumed that iInterface is already initiatedd
    if(iInterface)
        {
        iInterface->ExecuteCmdL( *iCommandName, *inParamList, *outParamList);
        }
    else
        {
        User::Leave( KErrNotSupported );
        }
    type.Reset();
    item.Reset();
    inParamList->Reset();
    
    //extracts data map
    TInt pos = 0;
    outParamList->FindFirst( pos, KResults );
    if( pos != KErrNotFound )
        // results present
        {
        //extract iterator on results list
        TLiwVariant variant = (*outParamList)[pos].Value();
        CLiwIterable* iterable = variant.AsIterable();
        iterable->Reset();
        
        //get next result
        if( iterable->NextL( variant ) )
            {
            //extract content map
            CLiwDefaultMap *map = CLiwDefaultMap::NewLC();
            variant.Get( *map );
            if( map->FindL( KDataMap, variant) )
                {
                 variant.Get( *aOutDataMap );
                }
            CleanupStack::PopAndDestroy( map );
            }
        iterable->Reset();
        variant.Reset();
        }
    outParamList->Reset();
    }

// ---------------------------------------------------------------------------
// CWrtData::PublisherStatusL
// ---------------------------------------------------------------------------
//
void CWrtData::ChangePublisherStatusL(const TDesC& aStatus)
    {
    if( iContentId == NULL )
       {
       return;
       }
   HBufC8* triggerName = HBufC8::NewLC(KWRTContentNameMaxLength);
   triggerName->Des().Copy(aStatus);
   
   CLiwGenericParamList* inParamList  = &iServiceHandler->InParamListL();
   CLiwGenericParamList* outParamList = &iServiceHandler->OutParamListL();
       
   TLiwGenericParam type( KType, TLiwVariant( KPubData ) );
   inParamList->AppendL( type );
              
   CLiwDefaultMap* filter = CreateFilterLC();
   filter->InsertL(KActionTrigger, TLiwVariant(triggerName->Des()) );
   
   TLiwGenericParam item( KFilter, TLiwVariant( filter ));
   inParamList->AppendL( item );
   
   if(iInterface)
       {
       iInterface->ExecuteCmdL( KExecuteAction, *inParamList, *outParamList);
       }
   else
       {
       User::Leave( KErrNotSupported );
       }
   CleanupStack::PopAndDestroy( filter );
   
   inParamList->Reset();
   outParamList->Reset();
   CleanupStack::PopAndDestroy( triggerName );
   }

// ---------------------------------------------------------------------------
// CWrtData::GetMenuItemsL
// ---------------------------------------------------------------------------
//
void CWrtData::GetMenuItemsL()
	{
	if(iInterface)
		{
		CLiwDefaultMap *outDataMap = CLiwDefaultMap::NewLC();
		CLiwDefaultMap* filter = CreateFilterLC( );
		//append filter to input param
        ExecuteCommandL( filter, outDataMap, KPubData  );
		CleanupStack::PopAndDestroy( filter );
		
		TLiwVariant variant;
		TInt pos = outDataMap->FindL( KMenuItems, variant ) ;
		
		if ( pos  )
			{
			CLiwDefaultMap *menuMap = CLiwDefaultMap::NewLC();
			variant.Get( *menuMap );
			for ( TInt i = 0; i < menuMap->Count(); i++)
				{
				menuMap->FindL(menuMap->AtL(i), variant );
				HBufC8* value = HBufC8::NewL( KWRTContentValueMaxLength );
				CleanupStack::PushL( value );
				TPtr8 valPtr = value->Des();
				variant.Get( valPtr);
				if ( valPtr.Length() > 0 )
					{
					iMenuTriggers.AppendL( value );
					CleanupStack::Pop( value );
					HBufC16* triggerName = HBufC16::NewLC( KWRTContentNameMaxLength );
				    triggerName->Des().Copy( menuMap->AtL(i) );
					iMenuItems.AppendL( triggerName );
					CleanupStack::Pop( triggerName );
					}
				else
					{
					CleanupStack::PopAndDestroy( value );	
					}
				variant.Reset();
				}
			CleanupStack::PopAndDestroy( menuMap );
			}
		variant.Reset();
		CleanupStack::PopAndDestroy( outDataMap );
		}
	}

// ---------------------------------------------------------------------------
// CWrtData::GetWidgetNameAndUidL
// ---------------------------------------------------------------------------
//
void CWrtData::GetWidgetNameAndUidL(TDes& aName, TDes& aAppUID )
    {
    CLiwDefaultMap *outDataMap = CLiwDefaultMap::NewLC();
    //Create filter criteria for requested entries in form of LIW map:
    CLiwDefaultMap* filter = CreateFilterLC();
    ExecuteCommandL( filter, outDataMap, KPubData  );
    CleanupStack::PopAndDestroy( filter );
  
    TLiwVariant variant;
    if ( outDataMap->FindL(KWidgetInfo, variant) )
        {
        CLiwDefaultMap* widgetInfoMap = CLiwDefaultMap::NewLC();
        variant.Get( *widgetInfoMap );
        variant.Reset();
        if ( widgetInfoMap->FindL( KWidgetName, variant ) )
            {
            aName.Copy(variant.AsDes());
            variant.Reset();
            if ( widgetInfoMap->FindL( KWidgetIcon, variant ) )
               {
               aAppUID.Copy(variant.AsDes());
               }
            }
        CleanupStack::PopAndDestroy( widgetInfoMap );
        }
    variant.Reset();
    CleanupStack::PopAndDestroy( outDataMap );
    }

// ---------------------------------------------------------------------------
// CWrtData::ResolveUid
// ---------------------------------------------------------------------------
//
TBool CWrtData::ResolveUid(const TDesC& aUidDes, TUid& aUid )
    {
    // Syntax: uid(0x12345678)
    TInt error = KErrNotFound;
    TInt pos = aUidDes.FindF( KUid );
    if( pos == 0 )
        {
        // Skip skin token
        pos += KUid().Length();

        // Initialize lexer
        TLex lex( aUidDes.Mid( pos ) );

        // Check left parenthesis
        if ( lex.Get() == KLeftParenthesis )
            {
            lex.SkipSpaceAndMark();
            lex.SkipCharacters();
            
            TPtrC mtoken = lex.MarkedToken();
            pos = mtoken.FindF( KHexPrefix );
            if ( pos == 0 )
                {
                TLex lex( mtoken.Mid( KHexPrefix().Length() ) );
                TUint id = 0;
                error = lex.Val( id, EHex );
                aUid = TUid::Uid( (TInt)id );
                }
            else
                {
                TInt id( 0 );
                error = lex.Val( id );
                aUid.iUid = id;
                }
            }
        }
    return (error == KErrNone );
    }

// ---------------------------------------------------------------------------
// CWrtData::CreateIconFromUidL
// ---------------------------------------------------------------------------
//
void CWrtData::CreateIconFromUidL(TInt& aHandle, TInt& aMaskHandle, const TUid& aAppUid ) 
    {
    RApaLsSession lsSession;
    User::LeaveIfError( lsSession.Connect() );
    CleanupClosePushL( lsSession ); // lsSession (1)
    
    CArrayFixFlat* sizeArray = new(ELeave) CArrayFixFlat( 5 );
    CleanupStack::PushL( sizeArray );
    if ( KErrNone == lsSession.GetAppIconSizes(aAppUid, *sizeArray) )
        {
        if ( sizeArray->Count() ) 
            {
            // There are other icon sizes
            TInt idx = 0;
            TInt size( sizeArray->At(idx).iWidth * sizeArray->At(idx).iHeight );
            for ( TInt i = 1; i < sizeArray->Count(); i++ ) 
                {
                if ( ( sizeArray->At(i).iWidth * sizeArray->At(i).iHeight ) > size )
                    {
                    idx = i;
                    size =  sizeArray->At(idx).iWidth * sizeArray->At(idx).iHeight;
                    }
                }

            CApaMaskedBitmap* appBitMap = CApaMaskedBitmap::NewLC();
            if ( KErrNone == lsSession.GetAppIcon( aAppUid, sizeArray->At(idx),
                    *appBitMap ) )
                {
                aHandle = appBitMap->Handle();
                aMaskHandle = appBitMap->Mask()->Handle();
                }
            CleanupStack::PopAndDestroy( appBitMap );
            }
        }
    CleanupStack::PopAndDestroy( sizeArray );
    CleanupStack::PopAndDestroy( &lsSession );
    }

hs_app_wrtdataobserver.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
* Plug-in main class
*
*/


// INCLUDE FILES
#include 
#include 
#include 
#include 
#include "hs_app_wrtdata.h"
#include "hs_app_wrtdataobserver.h"
#include "hs_app_wrtdatapluginconst.h"

// ---------------------------------------------------------------------------
// Factory method construction
// ---------------------------------------------------------------------------
//
CWrtDataObserver * CWrtDataObserver::NewL( MLiwInterface* aInterface, CWrtData* aData )
    {
    CWrtDataObserver * self = new (ELeave) CWrtDataObserver();
    CleanupStack::PushL( self );
    self->ConstructL( aInterface, aData );
    CleanupStack::Pop( self );
    return self;    
    }


// ---------------------------------------------------------------------------
// 2n phase constructor
// ---------------------------------------------------------------------------
//
void CWrtDataObserver::ConstructL( MLiwInterface* aInterface, CWrtData* aData )
    {
    iData = aData;
    iInterface = aInterface;
    }

// ---------------------------------------------------------------------------
// Constructor
// ---------------------------------------------------------------------------
//
CWrtDataObserver::CWrtDataObserver ()
    {

    }
        
// ---------------------------------------------------------------------------
// Destructor
// ---------------------------------------------------------------------------
//
CWrtDataObserver ::~CWrtDataObserver ()
    {
    TRAP_IGNORE( ReleaseL());
    iInterface = NULL;
    iData = NULL;
    }

// ---------------------------------------------------------------------------
// CWrtDataObserver::HandleNotifyL
// Handles Published content notification
// ---------------------------------------------------------------------------
//
TInt CWrtDataObserver::HandleNotifyL(
        TInt aErrorCode,
        TInt /*aEventId*/,
        CLiwGenericParamList& aEventParamList,
        const CLiwGenericParamList& /*aInParamList*/ )
    {
     
    // Is plugin active to refresh the published data
	iError = aErrorCode;        
	TInt count(0);
	TInt pos(0);
	const TLiwGenericParam* param(NULL);
	CLiwDefaultList* listOfMaps = CLiwDefaultList::NewLC();
	param = aEventParamList.FindFirst(pos,KChangeInfo);
	if( param )
		{
		 User::LeaveIfError( param->Value().Get( *listOfMaps ) );
		 count = listOfMaps->Count();
		}
	TLiwVariant variant;
	// Extract the data from the map 
	for(TInt i = 0;i < count; i++)
		{
		listOfMaps->AtL(i,variant);
		HBufC16* operation = NULL;

		CLiwDefaultMap *map = CLiwDefaultMap::NewLC();
		variant.Get( *map );
		if (map->FindL( KOperation, variant ))
		   {
		   operation = variant.AsDes().AllocLC();
	       variant.Reset();
            if( operation->Des() != KOperationExecute )
               {
               // Nothing to update for execute action
               if ( map->FindL( KFLAG, variant ))
                   {
                   // notification from publisher registry
                  if ( operation->Des() !=  KOperationDelete )
                      {
                      iData->UpdatePublisherStatusL();
                      }
                   }
               // ignore update if plugin is in suspend mode
               else if ( iData->IsPluginActive() ) 
                   {
                   HBufC16* contentId = NULL; 
                   CLiwDefaultMap* dataMap = NULL;
                    // Get the data Map if available
                    if ( map->FindL( KDataMap, variant))
                        {
                        TPtrC8 data = variant.AsData();
                        RDesReadStream datastrm ( data );
                        dataMap = CLiwDefaultMap::NewLC(datastrm);
                        }
                    // Get the content Id
                   if ( map->FindL( KContentId, variant ))
                       {
                       contentId = variant.AsDes().AllocLC();
                       // Refresh only if contentId is retrieved
                       iData->RefreshL( *contentId, *operation, dataMap );
                       CleanupStack::PopAndDestroy( contentId );
                       }

                   if ( dataMap )
                        {
                        CleanupStack::PopAndDestroy( dataMap );
                        }
                   }
                 variant.Reset();
               }
            if ( operation )
                {
                CleanupStack::PopAndDestroy( operation );
                }
		     }
		CleanupStack::PopAndDestroy( map );
		}
	CleanupStack::PopAndDestroy( listOfMaps );
	
    return aErrorCode;
    }

// ---------------------------------------------------------------------------
// CWrtDataObserver::RegisterL
// Register for notifications
// ---------------------------------------------------------------------------
//
void CWrtDataObserver::RegisterL( CLiwDefaultMap* aFilter )
    {
    CLiwGenericParamList* inParamList = CLiwGenericParamList::NewL();
    CleanupStack::PushL( inParamList );
    CLiwGenericParamList* outParamList = CLiwGenericParamList::NewL();
    CleanupStack::PushL( outParamList );
        
    // Fill in input list for RequestNotification command
    inParamList->AppendL(TLiwGenericParam(KType,TLiwVariant(KCpData_PubData)));
    inParamList->AppendL(TLiwGenericParam(KFilter ,TLiwVariant(aFilter)));
        
    iError = KErrNone;
    TRAP( iError, iInterface->ExecuteCmdL( 
                KRequestNotification,
                *inParamList,
                *outParamList,
                0,
                this ) );
    
    CleanupStack::PopAndDestroy( outParamList );
    CleanupStack::PopAndDestroy( inParamList ); 
    }

// ---------------------------------------------------------------------------
// CWrtDataObserver ::ReleaseL
// Sing off to notification
// ---------------------------------------------------------------------------
//
void CWrtDataObserver ::ReleaseL()
    {
    if( iInterface )
        {
        CLiwGenericParamList* inParamList = CLiwGenericParamList::NewL();
        CleanupStack::PushL( inParamList );
        CLiwGenericParamList* outParamList = CLiwGenericParamList::NewL();
        CleanupStack::PushL( outParamList );
        
        TInt err(KErrNone);
        TRAP(err, iInterface->ExecuteCmdL( 
                KRequestNotification,
                *inParamList,
                *outParamList,
                KLiwOptCancel,
                this ));
        
        CleanupStack::PopAndDestroy( outParamList );
        CleanupStack::PopAndDestroy( inParamList );
        }
    }
hs_app_wrtdataplugin.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
* Profile plug-in publisher
*
*/



// INCLUDE FILES
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include  
#include  
#include 
#include 
#include 

#include "hs_app_wrtdatapluginconst.h"
#include "hs_app_wrtdatapluginuids.hrh"
#include "hs_app_wrtdataplugin.h"
#include "hs_app_wrtdata.h"

// CONST CLASS VARIABLES
const TImplementationProxy KImplementationTable[] =
    {
    IMPLEMENTATION_PROXY_ENTRY( KImplUidDataPlugin, CWrtDataPlugin::NewL ) 
    };

// ======== MEMBER FUNCTIONS ========
// ---------------------------------------------------------------------------
// Constructs and returns an application object.
// ---------------------------------------------------------------------------
//
EXPORT_C const TImplementationProxy* ImplementationGroupProxy(TInt& aTableCount )
    {
    aTableCount = sizeof( KImplementationTable ) /
        sizeof( TImplementationProxy );
    return KImplementationTable;
    }

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
CWrtDataPlugin* CWrtDataPlugin::NewL()
    {
    CWrtDataPlugin* self = new (ELeave) CWrtDataPlugin;
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }
    
// ---------------------------------------------------------------------------
// Default constructor
// ---------------------------------------------------------------------------
//
CWrtDataPlugin::CWrtDataPlugin()
    {
    }
    
// ---------------------------------------------------------------------------
// Symbian 2nd phase constructor can leave
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::ConstructL()
    { 
    iInfo.iUid.iUid = WRTDP_UID_ECOM_IMPLEMENTATION_CONTENTPUBLISHER_DATAPLUGIN; 
    iPluginState = ENone;
    iHSForeGround = EFalse;
    iKeyLockOn = EFalse;
    iNetworkStatus = EUnknown;
    iData = CWrtData::NewL(this);

    }
    
// ---------------------------------------------------------------------------
// Destructor
// Deletes all data created to heap
// ---------------------------------------------------------------------------
//
CWrtDataPlugin::~CWrtDataPlugin()
    {
    // deactivate the publishers
    if( iData )
        {
        if ( iPluginState != EInActive )
        	{
        	TRAP_IGNORE(iData->DeActivateL());
        	}
        delete iData;
        }
    iObservers.Close();
    Release( iContent );
    iDataArray.ResetAndDestroy();

    if( iContentModel)
        {
        for( TInt i = iDataCount-1;i>=0  ; i-- )
            {
            User::Free((TAny*)iContentModel[i].cid);   
            }
        delete []iContentModel;
        }
    iIconArray.Reset();
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is requested to unload its engines due backup operation
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::Stop( TAiTransitionReason aReason )
    {
    if( iPluginState == EResume )
        {
        Suspend( aReason );
        }
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is instructed that it is allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::Resume( TAiTransitionReason aReason )
    {
    TRAP_IGNORE( DoResumeL( aReason ) ); 
    }
    
// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-in is instructed that it is not allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::Suspend( TAiTransitionReason aReason )
    {
    switch( aReason )
        {
        case EAiKeylockDisabled:
        case EAiKeylockEnabled:
            {
            // handled in resume 
            break;
            }
        default :
            {
            iPluginState = ESuspend;
            TRAP_IGNORE ( iData->SuspendL() );
            }
        }
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// The plug-in MUST maintain a registry of subscribers and send 
// notification to all of them whenever the state changes or new content
// is available
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::SubscribeL( MAiContentObserver& aObserver )
    { 
    iObservers.AppendL( &aObserver );
    }
 
// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Plug-ins take ownership of the settings array, so it must either
// store it in a member or free it.
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::ConfigureL( RAiSettingsItemArray& aSettings )
    {
    if( iDataCount > 0 )
        {
        // We own the array so destroy it
         aSettings.ResetAndDestroy();
         return;
        }
    
    RAiSettingsItemArray contentItemsArr;
    RAiSettingsItemArray configurationItemsArr;
    RAiSettingsItemArray settingItemsArr;
    
    TInt count = aSettings.Count();
    for(TInt i = 0; i < count; i++ )
        {
        MAiPluginSettings* pluginSetting = aSettings[i];
        if( pluginSetting->AiPluginItemType() == EAiPluginContentItem )
            {
            contentItemsArr.Append(pluginSetting);
            }
        else if( pluginSetting->AiPluginItemType() == EAiPluginConfigurationItem )
            {
            configurationItemsArr.Append(pluginSetting);
            }
        else 
            {
            settingItemsArr.Append(pluginSetting);
            }
        }
    
    iDataCount = contentItemsArr.Count();
    if(iDataCount > 0 )
        {
        // Create the content Model
        HBufC16* contentId = HBufC16::NewLC( KAiContentIdMaxLength + KAiPluginNameMaxLength );
        iContentModel = new TAiContentItem[iDataCount];
        for(TInt i = 0; i < iDataCount; i++)
            {
            MAiPluginContentItem& contentItem = (contentItemsArr[i])->AiPluginContentItem();
            iContentModel[i].id = i;
            if( contentItem.Type() == KText() )
                {
                // text
                iContentModel[i].type = KAiContentTypeText;
                }
            if( contentItem.Type() == KImage() || 
                    contentItem.Type() == KAnimation() )
                {
                // image
                iContentModel[i].type = KAiContentTypeBitmap;
                }
            
            contentId->Des().Copy(contentItem.Name());
            contentId->Des().Delete(0, contentId->Des().LocateReverse(KPluginNameSeprator) +1);
  
            TInt sizeOfContentId = contentId->Des().Size()+sizeof(wchar_t);
            iContentModel[i].cid = static_cast( User::Alloc( sizeOfContentId ) );
            Mem::Copy((TAny*)iContentModel[i].cid, contentId->Des().PtrZ(), sizeOfContentId);
            
            contentId->Des().Delete( 0, contentId->Des().Length());
            }    
        
        CleanupStack::PopAndDestroy( contentId );
        iContent = AiUtility::CreateContentItemArrayIteratorL( iContentModel, iDataCount );
        // Configurations 
        iData->ConfigureL(configurationItemsArr);

        iPluginState = ESuspend;
        // Register for notifications
        iData->RegisterL();
        
        // Activate the publisher 
        iData->ActivateL();
        }
    
    settingItemsArr.Reset();
    contentItemsArr.Reset();
    configurationItemsArr.Reset();
       // We own the array so destroy it
    aSettings.ResetAndDestroy();
    // publish the initial data
    PublishL();
    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// Returns the extension interface. Actual type depends on the passed 
// aUid argument.
// ---------------------------------------------------------------------------
//
TAny* CWrtDataPlugin::Extension( TUid aUid )
    {    
    if ( aUid == KExtensionUidProperty )
        {
        return static_cast( this );
        }
    else if (aUid == KExtensionUidEventHandler)
        {
        return static_cast( this );
        }
    else
        {   
        return NULL;
        }
    }

// ---------------------------------------------------------------------------
// From class MAiPropertyExtension
// Read property of publisher plug-in.
// ---------------------------------------------------------------------------
//
TAny* CWrtDataPlugin::GetPropertyL( TInt aProperty )
    {
    TAny* property = NULL;
    
    switch ( aProperty )
        {
    case EAiPublisherInfo:
        {
         property = static_cast( &iInfo );
        break;  
        }       

    case EAiPublisherContent:
        {
        property = static_cast( iContent );
        break;    
        }        
    default:
        break;
        }

    return property;
    }

// ---------------------------------------------------------------------------
// From class MAiPropertyExtension
// Write property value to optimize the content model.
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::SetPropertyL( TInt aProperty, TAny* aValue )
    {  
    switch ( aProperty )
        {
        case EAiPublisherInfo:
            {
            if( aValue )
                {
                const TAiPublisherInfo* info = static_cast( aValue );
                iInfo.iName.Copy( info->iName );
                iInfo.iNamespace.Copy( info->iNamespace );
                }
            break;
            }
        default:
            break;         
        }
    }
 
// ---------------------------------------------------------------------------
// From class MAiEventHandlerExtension.
// Handles an event sent by the AI framework.
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::HandleEvent( TInt /*aEvent*/, const TDesC& /*aParam*/ )
    {
    // This is not as there is no event id to retrieve in this dynamic plugin. 
    } 
    
// ---------------------------------------------------------------------------
// From class MAiEventHandlerExtension.
// Handles an event sent by the AI framework.
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::HandleEvent( const TDesC& aEventName, const TDesC& aParam )
    {
    // We have no way of reporting errors to framework so just ignore them.
    TRAP_IGNORE(iData->ExecuteActionL( aEventName , aParam ) );
    }

// ---------------------------------------------------------------------------
// From class MAiEventHandlerExtension.
// Invoked by the framework for querying if plugin has menu item
// ---------------------------------------------------------------------------
//
TBool CWrtDataPlugin::HasMenuItem( const TDesC16& aMenuItem )
    { 
    return iData->HasMenuItem ( aMenuItem );  
    }

// ---------------------------------------------------------------------------
// Gets the id of a content  
// ---------------------------------------------------------------------------
//
TInt CWrtDataPlugin::GetIdL( TDesC16& aObjectId)
    {
    TInt id = KErrNotFound;
    HBufC16* objectId = HBufC16::NewLC( KAiContentIdMaxLength );
    for( TInt i = 0;i<  iDataCount; i++ )
        {
         objectId->Des().Copy((TUint16*)iContentModel[i].cid);
         if( aObjectId == objectId->Des() )
             {
             id = iContentModel[i].id;
             break;
             }
        }
    CleanupStack::PopAndDestroy( objectId );
    return id;
    }
 

// ---------------------------------------------------------------------------
// Gets type of a content
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::GetTypeL(TDesC16& aObjectId, TDes16& aType )
    {
    HBufC16* objectId = HBufC16::NewLC( KAiContentIdMaxLength );
    for( TInt i = 0;i<  iDataCount; i++ )
        {
        objectId->Des().Copy((TUint16*)iContentModel[i].cid);
         if( aObjectId == objectId->Des() )
             {
             if( iContentModel[i].type ==  KAiContentTypeText)
                 {
                 aType.Copy( KText );
                 }
             else if( iContentModel[i].type == KAiContentTypeBitmap)
                 {
                 aType.Copy( KImage );
                 }
             break;
             }
        }
    CleanupStack::PopAndDestroy( objectId );
    }

// ---------------------------------------------------------------------------
//Refresh a specific image of text in the widget
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::RefreshL( TDesC16& aOperation, CLiwDefaultMap* aDataMap )
    {
    TInt observers( iObservers.Count() );        
    TInt transactionId = reinterpret_cast( this );
    
    for ( TInt obsIndex = 0; obsIndex < observers; obsIndex++ )
        {
        MAiContentObserver* observer = iObservers[obsIndex];
 
        if ( observer->StartTransaction( transactionId ) == KErrNone )       
            {
            if( ( aOperation == KOperationUpdate 
                  || aOperation == KOperationAdd )
                  && aDataMap )
                {
                iData->PublishL( observer, aDataMap );
                }
            else if ( aOperation == KOperationDelete )
                {
                Clean( observer , EImage1 ) ;
                }
            
            observer->Commit( transactionId );
            }
     
        // Relese memory of the published text
        iDataArray.ResetAndDestroy();
        // Release memory of the published icons
        iIconArray.Reset();
        }
    }

// ---------------------------------------------------------------------------
// Is plugin active to publish the data 
// ---------------------------------------------------------------------------
//
TBool CWrtDataPlugin::IsActive()
    {
    return (iPluginState == EResume );
    }

// ---------------------------------------------------------------------------
// Publish a specific text of the widget  
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::PublishTextL(MAiContentObserver* aObserver, 
        TInt aContentId, const TDesC16& aContentValue)
    {
    if ( aObserver->CanPublish( *this,  aContentId  ,  aContentId  ) )
        {
        if( aContentValue.Length() > 0 )
            {
            HBufC* contentText = HBufC::NewLC(aContentValue.Size());
            TPtr16 cDes = contentText->Des();
            cDes.Copy(aContentValue);
            aObserver->Publish( *this, aContentId, cDes, aContentId );  
            iDataArray.AppendL( contentText );
            CleanupStack::Pop( contentText );
            }
        else
            {
            aObserver->Clean( *this, aContentId, aContentId );
            }
        }
    }

// ---------------------------------------------------------------------------
// Publish a specific image of the widget  
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::PublishImageL(MAiContentObserver* aObserver,
		TContentItem aContentId, const TDesC16& aPath )
    {
    TInt err = KErrNone;
    TAknsItemID iconId;
    iconId.iMajor=0;
    iconId.iMinor=0;
    TInt bitmapId(0);
    TInt maskId(0);
    TFileName fileName;
    CGulIcon* icon = NULL;
    CFbsBitmap* bitmap = NULL;
    CFbsBitmap* mask = NULL;
    
    if ( aObserver->CanPublish( *this, aContentId , aContentId ) )
      {
      TBool inSkin = ResolveSkinIdAndMifId( aPath, iconId, bitmapId, maskId, fileName  );
      if ( inSkin )
          {
          // Load from skin 
          MAknsSkinInstance* skin = AknsUtils::SkinInstance();
          if ( iconId.iMajor != 0 && iconId.iMajor!=0 )
              {
              // Create icon with fall back 
              TRAP_IGNORE(AknsUtils::CreateIconL(
                      skin,
                      iconId,
                      bitmap,
                      mask,
                      fileName,  /* backup filename */
                      bitmapId,  /* backup bit map id */
                      maskId));   /* backup mask id */
              }
          else if( bitmapId !=0 )
              {
              if ( maskId!=0 )
                  {
                  // Create icon from Mif filename , bitmap id and mask id
                  TRAP_IGNORE(icon = AknsUtils::CreateGulIconL(
                          skin,
                          iconId,
                          fileName,
                          bitmapId,
                          maskId) );
                  }
              else
                  {
                  TRAP_IGNORE(AknsUtils::CreateIconL(
                          skin,
                          iconId,
                          bitmap,
                          fileName,  /* backup filename */
                          bitmapId)); /* backup bit map id */
                  }
              }
          
          if ( icon == NULL && bitmap !=  NULL )
              {
              icon = CGulIcon::NewL( bitmap, mask );
              }

          if ( icon != NULL ) // Syntax correct but icon not found
              {
              aObserver->PublishPtr( *this, aContentId, icon , aContentId );
              iIconArray.Append(icon);
              } 
          else
              {
              err = KErrNotFound;   
              aObserver->Clean( *this, aContentId, aContentId );
              }
          }
      else  // Interpret as File path
          {
          RFs rfs;
          User::LeaveIfError( rfs.Connect() );
          RFile* iconFile = new (ELeave) RFile();
          err = iconFile->Open( rfs, aPath, EFileShareReadersOnly |  EFileRead );
          if( err == KErrNone )
            {
             aObserver->Publish( *this, aContentId, *iconFile, aContentId );
            }
          else
              {
              aObserver->Clean( *this, aContentId, aContentId );
              }
          iconFile->Close();
          delete iconFile;
          iconFile = NULL;
          rfs.Close();
          }
        }
    }

// ---------------------------------------------------------------------------
// Publish a image of the widget  
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::PublishImageL(MAiContentObserver* aObserver, 
		TContentItem aContentId, TInt aHandle, TInt aMaskHandle )
    {
    if ( aObserver->CanPublish( *this, aContentId , aContentId ) )
        {
        if( aHandle != KErrBadHandle  )
            {
            CFbsBitmap* bitmap = new (ELeave) CFbsBitmap();
            if( KErrNone == bitmap->Duplicate( aHandle) )
                {
                // Take the ownership
                CGulIcon* icon = CGulIcon::NewL(bitmap);
                if( aMaskHandle != KErrBadHandle )
                    {
                    CFbsBitmap* mask = new (ELeave) CFbsBitmap();
                    if (KErrNone == mask->Duplicate( aMaskHandle) )
                        {
                        icon->SetMask( mask );            
                        }
                    }
                aObserver->PublishPtr( *this, aContentId, icon , aContentId );
                iIconArray.Append(icon);
                }
            else
                {
                delete bitmap;
                bitmap = NULL;
                aObserver->Clean( *this, aContentId, aContentId );
                }
            }
          }
    }

// ---------------------------------------------------------------------------
// Cleans a data from the widget
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::Clean(MAiContentObserver* aObserver, 
        TInt aContentId )
    {
     if ( aObserver->CanPublish( *this, aContentId, aContentId ) )
        {
        aObserver->Clean( *this, aContentId, aContentId );      
        }

    }

// ---------------------------------------------------------------------------
// Show the loading icong animation 
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::ShowLoadingIcon(MAiContentObserver* aObserver)
    {
    aObserver->SetProperty( *this, KElement , KDisplay , KShow );
    }

// ---------------------------------------------------------------------------
// Hides the loading icon animation 
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::HideLoadingIcon(MAiContentObserver* aObserver)
    {
    aObserver->SetProperty( *this, KElement , KDisplay , KHide );
    }

// ---------------------------------------------------------------------------
// Publishes widget's texts and images
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::PublishL()
    {
    TInt observers( iObservers.Count() );        
    TInt transactionId = reinterpret_cast( this );

    for ( int i = 0; i < observers; i++ )
        {
        MAiContentObserver* observer = iObservers[i];
                
        if ( observer->StartTransaction( transactionId ) == KErrNone )           
            {// Publish default data
            iData->PublishDefaultImageL(observer);
            observer->Commit( transactionId );
            }

        // Release memory of the published text
        iDataArray.ResetAndDestroy();
        // Release memory of the published icons
        iIconArray.Reset();
        }

    }

// ---------------------------------------------------------------------------
// From class CAiContentPublisher
// framework instructs plug-in that it is allowed to consume CPU resources
// ---------------------------------------------------------------------------
//
void CWrtDataPlugin::DoResumeL( TAiTransitionReason aReason )
    {
    //update in startup phase and idle is on foreground.
    switch ( aReason )
        {
        case EAiIdleOnLine:
            {
            iNetworkStatus = EOnline;
            iData->OnLineL();
            break;
            }
        case EAiIdleOffLine:
            {
            iNetworkStatus = EOffline;
            iData->OffLineL();
            break;
            }
        case EAiIdlePageSwitch:
            {
            if ( iPluginState == EResume )
                {
                iData->SuspendL();
                }
            iPluginState = EInActive;
            iData->InActiveL();
            }
            break;
        case EAiSystemStartup:
        case EAiIdleForeground:
            {
            iHSForeGround = ETrue;
            }
        case EAiBacklightOn:            
            {
            if ( iPluginState == ESuspend  && !iKeyLockOn )
                {
                iPluginState = EResume;
                iData->ResumeL();
                }
            break;
            }
        case EAiKeylockDisabled:
            {
            iKeyLockOn = EFalse;
            // Key lock events considered only if HS is in foreground  
            if ( iHSForeGround && iPluginState == ESuspend )
                {
                iPluginState = EResume;
                iData->ResumeL();
                }
            break;
            }
        case EAiKeylockEnabled:
            {
            iKeyLockOn = ETrue;
            // Key lock events considered only if HS is in foreground
            if ( iHSForeGround && iPluginState == EResume )
                {
                iPluginState = ESuspend ;
                iData->SuspendL();
                }
            break;
            }
        case EAiScreenLayoutChanged:
            {
            // ignore events
            break;
            }
      case EAiGeneralThemeChanged:
          {
          // ignore event
          break;
          }
        case EAiIdleBackground: 
            {
            iHSForeGround = EFalse;
            }
        default :
            {
            if ( iPluginState == EResume )
                {
                iPluginState = ESuspend;
                iData->SuspendL();
                }
            break;
            }
        }
    }

// ---------------------------------------------------------------------------
// ResolveSkinItemId
// ---------------------------------------------------------------------------
//
TBool CWrtDataPlugin::ResolveSkinIdAndMifId( const TDesC& aPath, TAknsItemID& aItemId,
        TInt& abitmapId, TInt& aMaskId, TDes& aFilename )
   {
   // Syntax: skin(   ):mif(filename bimapId maskId) 
   TInt error = KErrNotFound;
   TInt pos = aPath.FindF( KSkin );
   if( pos != KErrNotFound )
       {
       // Skip skin token
       pos += KSkin().Length();
       
       // Initialize lexer
      TLex lex( aPath.Mid( pos ) );
      lex.SkipSpace();
       
       // Check left parenthesis
      if (lex.Get() == KLeftParenthesis )
           {
           //lex.SkipSpace();
           
           TInt majorId( 0 );        
           TInt minorId( 0 );

           // Resolve major id        
           error = lex.Val( majorId );
           
           // Resolve minor id
           lex.SkipSpace();
           error |= lex.Val( minorId );
           
           // initilize skin item id object
           aItemId.Set( majorId, minorId );
           }
       }

   if( (error == KErrNone && aPath.FindF( KColon ) != KErrNotFound ) 
         || ( error == KErrNotFound ) )
       {
       error = KErrNotFound;
       pos = aPath.FindF( KMif );
       if ( pos != KErrNotFound )
           {
           pos += KMif().Length();
           // Initialize lexer
           TLex lex( aPath.Mid( pos ) );
           lex.SkipSpace();
           
           // Check left parenthesis
           if (lex.Get() == KLeftParenthesis )
               {
               lex.SkipSpaceAndMark();
               lex.SkipCharacters();
               // Resolve MifFile name
               aFilename.Copy(lex.MarkedToken());
               if( aFilename.Length()!= 0)
                   {
                   // Resolve bitmap id  
                   lex.SkipSpace();
                   error = lex.Val( abitmapId );
                   
                   // Resolve mask id
                   // dont return error if it is not found, that is ok
                   lex.SkipSpace();
                   lex.Val( aMaskId );
                   }
               else
                   {
                   error = KErrNotFound;
                   }
               }
           }
       }
   return (error == KErrNone );
   }
hs_app_aiwspluginanim.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Active Idle Window Server Plug-in.
*
*/

#ifndef C_AIWSPLUGINANIM_H
#define C_AIWSPLUGINANIM_H

#include 
#include "hs_app_aiwspluginanimdef.h"
#include "hs_app_uistate.h"
#include "hs_app_modifierkeytracker.h"

namespace AiWsPlugin
    {
    class CEventHandler;
    }

typedef MAnimGeneralFunctionsWindowExtension::TWindowGroupInfo TIdPlgWindowGroupInfo;

/**
 *  @ingroup group_wsplugin
 *
 * Active Idle Window Server Plug-in.
 *
 * @since 3.2
 */
class CAiWsPluginAnim : 
        public CWindowAnim, public AiWsPlugin::MUiState
    {
    public: // Constructors and destructors
        
        /** 
        * Constructor. 
        */
        CAiWsPluginAnim();
        
        /** 
        * Destructor.
        */
        ~CAiWsPluginAnim();
        
// From base class CWindowAnim

        TInt CommandReplyL( TInt aOpcode, TAny* aArgs );
        
        void Command( TInt aOpcode, TAny* aArgs );
        
        void Animate( TDateTime* aDateTime );
        
        void ConstructL( TAny* aArgs, TBool aHasFocus );
        
        void Redraw();
        
        void FocusChanged( TBool aState );
        
        TBool OfferRawEvent( const TRawEvent& aRawEvent );

// From base class MUiState

        TUint Modifiers() const;
        
        TBool HasFocus() const;
    
    private:  // Implementation
    
        void AddEventHandlerAndPopL( AiWsPlugin::CEventHandler* aEventHandler );
    
    private:  // Data

        /// Event handlers. Own.
        RPointerArray< AiWsPlugin::CEventHandler > iEventHandlers;

        /// Window group ids passed as construction parameters
        TAiWsPluginAnimInitData iWgInfo;
        
        /// Active Idle Focus status
        TBool iAiFocused;
        
        /// Modifier key tracker
        AiWsPlugin::TModifierKeyTracker iModifierTracker;
    };

#endif // C_AIWSPLUGINANIM_H

hs_app_aiwspluginanimdll.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/


#ifndef AIWSPLUGINANIMDLL_H
#define AIWSPLUGINANIMDLL_H

#include    
#include    

/** 
*  @ingroup group_wsplugin
*
* Active Idle Window Server plug-in.
*
* @since S60 3.2
*/
class CAiWsPluginAnimDll 
    : public CAnimDll
    {
public: // From base classes
    
    /** 
    * From CAnimDll, creates an instance of requested plugin.
    *
    * @param aType type of the plug-in. AI WS implements EAnimKeyForward.
    * @return instance of animation service.
    */
    virtual CAnim* CreateInstanceL( TInt aType );

    };

/** 
* Creates an instance of CPhoneAnimDll. 
* Factory function. 
*
* @since S60 3.2
* @return instance of anim dll.
*/
IMPORT_C CAnimDll* CreateCAnimDllL();

#endif // AIWSPLUGINANIMDLL_H

// End of File
hs_app_eventhandler.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Event handler base class for Active Idle WS Plug-in.
*
*/


#ifndef C_AIWSPLUGIN_EVENTHANDLER_H
#define C_AIWSPLUGIN_EVENTHANDLER_H


#include 

class TRawEvent;

namespace AiWsPlugin {

class MUiState;

/**
 *  @ingroup group_wsplugin
 *
 *  Event handler base class for Active Idle WS Plug-in.
 *
 *  Window server plug-in animation class CAiWsPluginAnim forwards events to 
 * instances of this class for processing.
 *
 *  @since S60 3.2
 */
class CEventHandler : public CBase
    {
public:
    /**
     * Sets the UI State query interface for this event handler.
     */
    virtual void SetUiStateQuery( MUiState& aUiState ) =0;

    /**
     * Calls to CWindowAnim::FocusChanged are forwarded to this function.
     *
     * @param Indicates whether the focus has or has not changed.
     */
    virtual void FocusChanged( TBool aState ) =0;
    
    /**
     * Calls to CWindowAnim::OfferRawEvent are forwarded to this function.
     * Forwarding is stopped if this function returns true.
     *
     * @param aRawEvent The raw event to be processed.
     * @return ETrue if the raw event is handled by this function, EFalse if 
     *         the function chooses not to process it. 
     */
    virtual TBool OfferRawEvent(const TRawEvent& aRawEvent) =0;
    };

} // namespace AiWsPlugin

#endif // C_AIWSPLUGIN_EVENTHANDLER_H
hs_app_keyhandlertimer.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Key handler timer for Active Idle WS Plug-in.
*
*/

#ifndef C_AIWSPLUGIN_KEYHANDLERTIMER_H
#define C_AIWSPLUGIN_KEYHANDLERTIMER_H

#include 

namespace AiWsPlugin {

/**
 * Handler timer interface.
 */
class MHandlerTimer
    {
public:
    virtual void TimerDone() = 0;
    };  

/**
 *  @ingroup group_wsplugin
 *
 *  Logs app launch handler for Active Idle WS Plug-in. 
 */
class CKeyHandlerTimer : 
        public CTimer
    {
public:

// Construction

    static CKeyHandlerTimer* NewL( MHandlerTimer* aHandler );
    
    static CKeyHandlerTimer* NewLC( MHandlerTimer* aHandler );
    
    ~CKeyHandlerTimer();

// new methods

    void StopTimer();

    TBool IsActive();

protected: // From CActive

    void RunL();

    TInt RunError( TInt aError );

private:

// Construction

    CKeyHandlerTimer( MHandlerTimer* aHandler );

    void ConstructL();

private: // data

    /// Pointer to handler timer. Not owned.
    MHandlerTimer* iHandler;
    }; 

} // namespace AiWsPlugin


#endif // C_AIWSPLUGIN_KEYHANDLERTIMER_H
hs_app_keylockcontrol.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Keylock handler settings class and control interface for 
*                Active Idle WS Plug-in.
*
*/


#ifndef M_AIWSPLUGIN_KEYLOCKCONTROL_H
#define M_AIWSPLUGIN_KEYLOCKCONTROL_H

#include 
class TRawEvent;

namespace AiWsPlugin {

class TKeypadSettings;
class TKeylockState;

/**
 *  @ingroup group_wsplugin
 *
 * Callback interface for CKeyLockHandler internal states.
 */
class MKeyLockHandlerControl
    {
public:

    virtual const TKeypadSettings& Settings() const = 0;
    
    virtual void StartTimeoutTimer( TInt aTimeout = -1 ) = 0;
    
    virtual void StopTimeoutTimer() = 0;
    
    virtual void ActivateKeypadLock() = 0;
    
    virtual void CancelKeypadLock() = 0;

    virtual void KeypadLockTimeout() = 0;
    
    virtual void SetNextState( const TKeylockState& aState ) = 0;
    
    virtual void ActivateNextState() = 0;
    
    virtual void SetLastLockKeyScanCode( TInt aScanCode ) = 0;
    
    virtual TInt LastLockKeyScanCode() const = 0;
    
    virtual TBool HasFocus() = 0;
    
    virtual TBool TimeoutTimerActive()  = 0;
    
    virtual TBool IsFirstLockKey( TInt aScanCode ) = 0;
    
    virtual TBool IsSecondLockKey( TInt aScanCode ) = 0;

    
protected:
    /**
     * Protected dtor prevents deletion through this interface.
     */
    ~MKeyLockHandlerControl() { }
    };

} // namespace AiWsPlugin

#endif // M_AIWSPLUGIN_KEYLOCKCONTROL_H
hs_app_keylockhandler.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Keylock handler for Active Idle WS Plug-in.
*
*/


#ifndef C_AIWSPLUGIN_KEYLOCKHANDLER_H
#define C_AIWSPLUGIN_KEYLOCKHANDLER_H

#include "hs_app_eventhandler.h"
#include "hs_app_keylockcontrol.h"
#include "hs_app_keypadsettings.h"
#include "hs_app_keyhandlertimer.h"

class CKeyLockPolicyApi;
namespace AiWsPlugin {

class TKeylockState;

/**
 *  @ingroup group_wsplugin
 *
 *  Keylock handler for Active Idle WS Plug-in. 
 *
 *  Monitors key presses that activate keyboard lock on the device.
 *
 *  @since S60 3.2
 */
class CKeyLockHandler : 
        public CEventHandler, 
        public MKeyLockHandlerControl,
        public MHandlerTimer
    {
public:

    static CKeyLockHandler* NewLC();

    ~CKeyLockHandler();

// from MHandlerTimer

    void TimerDone();    

private:

// from base class CEventHandler

    void SetUiStateQuery( MUiState& aUiState );
    
    void FocusChanged( TBool aState );
    
    TBool OfferRawEvent(const TRawEvent& aRawEvent);

// from base class MKeyLockHandlerControl

    const TKeypadSettings& Settings() const;
    
    void StartTimeoutTimer( TInt aTimeout );
    
    void StopTimeoutTimer();
    
    void ActivateKeypadLock();
    
    void CancelKeypadLock();
    
    void KeypadLockTimeout();
    
    void SetNextState( const TKeylockState& aState );
    
    void ActivateNextState();
    
    void SetLastLockKeyScanCode( TInt aScanCode );
    
    TInt LastLockKeyScanCode() const;
    
    TBool HasFocus();

    TBool TimeoutTimerActive();
    
// construction

    CKeyLockHandler();
    
    void ConstructL();
    
    static TInt TimerElapsed( TAny* aSelf );
    
    TBool IsFirstLockKey( TInt aScanCode );
    
    TBool IsSecondLockKey( TInt aScanCode );

private: // data
    /**
     * Current state of this object.
     * Not owned.
     */
    const TKeylockState* iCurrentState;

    /**
     * Next state of this object.
     * Not owned.
     */
    const TKeylockState* iNextState;
    
    /**
     * Timeout timer for keypad lock.
     * Own.
     */
    CPeriodic* iKeypadLockTimer;

    /**
     * Key lock settings.
     */
    TKeypadSettings iSettings;
    
    /**
     * Last value of SetLastLockKeyScanCode( TInt aScanCode).
     */
    TInt iLastLockKeyScanCode;
    
    /**
     * Pointer to ui state.
     * Not owned.
     */
    MUiState* iUiState;
    
    /**
     * For checking keylock buttons
     * Own
     */
    CKeyLockPolicyApi *iKeylockApi;
    };

} // namespace AiWsPlugin


#endif // C_AIWSPLUGIN_KEYLOCKHANDLER_H
hs_app_keylockstates.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Keylock handler states for Active Idle WS Plug-in.
*
*/


#ifndef T_AIWSPLUGIN_KEYLOCKSTATES_H
#define T_AIWSPLUGIN_KEYLOCKSTATES_H

#include 
class TRawEvent;

namespace AiWsPlugin {

class MKeyLockHandlerControl;

/**
 *  @ingroup group_wsplugin
 *
 * Internal state structure for class CKeyLockHandler.
 * The states are behaviour-only and thus consist of just function pointers.
 */
class TKeylockState
    {
public:
    /**
     * Returns the state machine's initial startup state.
     */
    static const TKeylockState& StartupState();

    /**
     * Returns this state's default succeeding state.
     */
    inline const TKeylockState& DefaultNextState() const
        { return (*iDefaultNextState)(); }

    /**
     * Handles Active Idle focus changes.
     *
     * @param aControl Key lock control interface.
     * @param aState   current focus state. See CWindowAnim::FocusChaned.
     */
    inline void FocusChanged( MKeyLockHandlerControl& aControl, TBool aState ) const
        { (*iFocusChanged)( aControl, aState ); }
        
    /**
     * Handles raw Window Server events.
     *
     * @param aControl  Key lock control interface.
     * @param aRawEvent The event to handle. See MEventHandler::OfferRawEvent.
     * @return true if the event was consumed by the state, false otherwise.
     */
    inline TBool OfferRawEvent
            (  MKeyLockHandlerControl& aControl, const TRawEvent& aRawEvent ) const
        { return (*iOfferRawEvent)( aControl, aRawEvent ); }

    /**
     * Handles key lock timeout timer elapsed event.
     *
     * @param aControl  Key lock control interface.
     */
    inline void TimerElapsed( MKeyLockHandlerControl& aControl ) const
        { (*iTimerElapsed)( aControl ); }

// Public function pointers

    /**
     * Pointer to state function that returns this state's default succeeding state.
     */
    const TKeylockState& (*iDefaultNextState)();
    
    /**
     * Pointer to state function which handles Active Idle focus changes.
     *
     * @param aControl Key lock control interface.
     * @param aState   current focus state. See CWindowAnim::FocusChaned.
     */
    void  (*iFocusChanged)( MKeyLockHandlerControl& aControl, TBool aState );

    /**
     * Pointer to state function which handles raw Window Server events.
     *
     * @param aControl  Key lock control interface.
     * @param aRawEvent The event to handle. See MEventHandler::OfferRawEvent.
     * @return true if the event was consumed by the state, false otherwise.
     */
    TBool (*iOfferRawEvent)( MKeyLockHandlerControl& aControl, const TRawEvent& aRawEvent );
    
    /**
     * Pointer to state function which handles key lock timeout timer elapsed 
     * event.
     *
     * @param aControl  Key lock control interface.
     */
    void  (*iTimerElapsed)( MKeyLockHandlerControl& aControl );
    };

} // namespace AiWsPlugin

#endif // T_AIWSPLUGIN_KEYLOCKSTATES_H

hs_app_keypadsettings.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Keypad settings class for Active Idle WS Plug-in.
*
*/


#ifndef T_AIWSPLUGIN_KEYPADSETTINGS_H
#define T_AIWSPLUGIN_KEYPADSETTINGS_H

#include 
class TRawEvent;

namespace AiWsPlugin {

/**
 *  @ingroup group_wsplugin
 *
 * Internal class for keypad settings.
 */
class TKeypadSettings
    {
public:
    /**
     * Initializes this object from settings repository.
     */
    void ReadFromRepositoryL();
    
    /**
     * Returns true if aScanCode matches the first lock key.
     */
    TBool IsFirstLockKey( TInt aScanCode ) const;

    /**
     * Returns true if aScanCode matches the second lock key.
     */
    TBool IsSecondLockKey( TInt aScanCode ) const;

    /**
     * Returns the key lock timeout in microseconds.
     */
    TTimeIntervalMicroSeconds32 KeylockTimeout() const;
    
    /**
     * Returns true if aScanCode matches the SIND key.
     */
    TBool IsSINDKey( TInt aScanCode ) const;

    /**
     * Returns the key lock timeout in microseconds.
     */
    TTimeIntervalMicroSeconds32 KeySINDTimeout() const;
    
    TInt16 MapNkpScanCodeToChar( TInt aScanCode );    

private:  // data
    /**
     * Scan code of first keypad lock key.
     */
    TInt16 iFirstLockKeyScanCode;
    
    /**
     * Character code (if any) that matches iFirstLockKeyScanCode.
     */
    TInt16 iFirstLockKeyChar;
    
    /**
     * Scan code of second keypad lock key.
     */
    TInt16 iSecondLockKeyScanCode;
    
    /**
     * Character code (if any) that matches iSecondLockKeyChar.
     */
    TInt16 iSecondLockKeyChar;
    
    /**
     * Scan code of optional second keypad lock key.
     */
    TInt16 iSecondLockKeyScanCode2;
    
    /**
     * Character code (if any) that matches iSecondLockKeyChar2.
     */
    TInt16 iSecondLockKeyChar2;
    
    /** 
     * Keypad lock timeout in microseconds.
     */
    TTimeIntervalMicroSeconds32 iKeylockTimeout;

    /**
     * Scan code of SIND keypad key.
     */
    TInt16 iSINDKeyScanCode;
    
    /**
     * Character code (if any) that matches iSINDKeyScanCode.
     */
    TInt16 iSINDKeyScanChar;    
    
    /** 
     * Keypad SIND timeout in microseconds.
     */
    TTimeIntervalMicroSeconds32 iKeySINDTimeout;    
    
    };

} // namespace AiWsPlugin

#endif // T_AIWSPLUGIN_KEYPADETTINGS_H
hs_app_logslaunchhandler.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Logs app launch handler for Active Idle WS Plug-in.
*
*/


#ifndef C_AIWSPLUGIN_LOGSLAUNCHANDLER_H
#define C_AIWSPLUGIN_LOGSLAUNCHANDLER_H

#include "hs_app_eventhandler.h"
#include "hs_app_keyhandlertimer.h"

namespace AiWsPlugin {

/**
 *  @ingroup group_wsplugin
 *
 *  Logs app launch handler for Active Idle WS Plug-in. 
 */
class CLogsLaunchHandler : 
        public CEventHandler,
        public MHandlerTimer        
    {
public:

    static CLogsLaunchHandler* NewLC();
    
    ~CLogsLaunchHandler();

private:

// from base class CEventHandler

    void SetUiStateQuery( MUiState& aUiState );
    
    void FocusChanged( TBool aState );
    
    TBool OfferRawEvent(const TRawEvent& aRawEvent);

// from MHandlerTimer

    void TimerDone();

// Construction

    CLogsLaunchHandler();
    
    void ConstructL();

private: // data

    /// Pointer to state. Not owned.
    MUiState* iUiState;
    
    /// Timer for long key down event. Owned.
    CKeyHandlerTimer* iTimer;
    };

} // namespace AiWsPlugin


#endif // C_AIWSPLUGIN_KEYLOCKHANDLER_H
hs_app_modifierkeytracker.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Modifier key status tracker for Active Idle WS Plug-in.
*
*/


#ifndef T_AIWSPLUGIN_MODIFIERKEYTRACKER_H
#define T_AIWSPLUGIN_MODIFIERKEYTRACKER_H

#include 

class TRawEvent;

namespace AiWsPlugin {

/**
 *  @ingroup group_wsplugin
 *
 * Numeric key forwarding handler for Active Idle WS Plug-in. 
 *
 * Monitors and forwards numeric key presses that should be handled by Phone 
 * application.
 *
 *  @since S60 3.2
 */
class TModifierKeyTracker
    {
public:
    TModifierKeyTracker();

    /**
     * Returns true if modifier key states were updated.
     */
    TBool Update(const TRawEvent& aRawEvent);
    
    /**
     * Returns the current modifier key status as bits, see enum TEventModifier.
     */
    TUint Status() const { return iModifiers; }

private: // data
    TUint iModifiers;
    };

} // namespace AiWsPlugin


#endif // T_AIWSPLUGIN_MODIFIERKEYTRACKER_H
hs_app_numerickeyhandler.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Numeric key forwarding handler for Active Idle WS Plug-in.
*
*/


#ifndef C_AIWSPLUGIN_NUMERICKEYHANDLER_H
#define C_AIWSPLUGIN_NUMERICKEYHANDLER_H

#include "hs_app_eventhandler.h"
#include 
#include 

class MAnimGeneralFunctionsWindowExtension;
class MAiPSPropertyObserver;

namespace AiWsPlugin {

class MUiState;

/**
 *  @ingroup group_wsplugin
 *
 * Numeric key forwarding handler for Active Idle WS Plug-in. 
 *
 * Monitors and forwards numeric key presses that should be handled by Phone 
 * application.
 *
 *  @since S60 3.2
 */
class CNumericKeyHandler : 
        public CEventHandler, 
        private MCenRepNotifyHandlerCallback
    {
public:
    /**
     * Creates a new instance of this class.
     *
     * @param aTargetWgId Window Group id of the target application where 
     *                    numeric key events are forwarded.
     * @return A new object of this class. The returned object is left on the
     *         cleanup stack.
     */
    static CNumericKeyHandler* NewLC
        ( TInt aTargetWgId, MAnimGeneralFunctionsWindowExtension* aWindowExt );

    ~CNumericKeyHandler();

private:
// from base class CEventHandler
    void SetUiStateQuery( MUiState& aUiState );
    
    void FocusChanged( TBool aState );
    
    TBool OfferRawEvent(const TRawEvent& aRawEvent);

// new methods
    CNumericKeyHandler
        ( TInt aTargetWgId, MAnimGeneralFunctionsWindowExtension* aWindowExt );
        
    void ConstructL();

    TBool CheckPostToTarget( const TRawEvent& aRawEvent ) const;
    
    void LoadInputLanguageKeyBindings( TInt aLanguage );
    
    static TInt HandleQwertyModeChanged( TAny *aPtr );
    
    TInt HandleInputLanguageChanged( TInt aNewValue );
    
    void SetQwertyMode( TInt aValue );
    
    void SetInputLanguage( TInt aValue );

// from base class MCenRepNotifyHandlerCallback

    void HandleNotifyGeneric(TUint32 aKey);
    
    void HandleNotifyError(TUint32 aKey, TInt aError, CCenRepNotifyHandler* aHandler);
        
private: // data

    /// Target window group id
    TInt iTargetWgId;
    
    /// Anim extension. Not own.
    MAnimGeneralFunctionsWindowExtension* iWindowExt;
    
    /// Pointer ot state. Not own.
    MUiState* iUiState;
    
    /// Qwerty ps observer. Owned.
    MAiPSPropertyObserver* iQwertyObserver;

    /// Input language observer. Owned.    
	CCenRepNotifyHandler* iInputLanguageObserver;
	
	/// Input language repository. Owned.
    CRepository* iInputLanguageRepository; 
    
    /// Numeric keys array.
    RArray iNumericKeys;
    
    /// Qwerty mode indicator.
    TInt iQwertyMode;
    
    /// Input language indicator.
    TInt iInputLanguage;
    };

} // namespace AiWsPlugin


#endif // C_AIWSPLUGIN_KEYLOCKHANDLER_H
hs_app_panic.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Panic codes and helper function for Active Idle WS Plug-in.
*
*/


#ifndef AIWSPLUGIN_PANIC_H
#define AIWSPLUGIN_PANIC_H

#include "hs_app_panic.h" // Include AI2 panic.h

namespace AiWsPlugin {

#ifndef NDEBUG

/**
 * Panic codes for Active Idle WS Plug-in.
 */
enum TPanicCode
    {
    /**
     * Key lock state machine received an invalid event.
     */
    EPanicInvalidKeylockEvent = 1
    };

void Panic( TPanicCode aPanicCode );

#endif  // !NDEBUG

} // namespace AiWsPlugin 

#endif // AIWSPLUGIN_PANIC_H
hs_app_sindlaunchhandler.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  SIND launch handler for Active Idle WS Plug-in.
*
*/


#ifndef C_AIWSPLUGIN_SINDLAUNCHANDLER_H
#define C_AIWSPLUGIN_SINDLAUNCHANDLER_H

#include "hs_app_eventhandler.h"
#include "hs_app_keyhandlertimer.h"

#include 

namespace AiWsPlugin {

/**
 *  @ingroup group_wsplugin
 *
 *  Logs app launch handler for Active Idle WS Plug-in. 
 */
class CSINDLaunchHandler : 
        public CEventHandler,
        public MHandlerTimer        
    {
public:

// Construction

    static CSINDLaunchHandler* NewLC();
    
    ~CSINDLaunchHandler();

// from base class CEventHandler

    void SetUiStateQuery( MUiState& aUiState );
    
    void FocusChanged( TBool aState );
    
    TBool OfferRawEvent(const TRawEvent& aRawEvent);
    
// from MHandlerTimer

    void TimerDone();

private:

// Construction

    CSINDLaunchHandler();
    
    void ConstructL();
    
// New methods

    void SkipVoiceDial();

private: // data

    /// Pointer to state. Not owned.
    MUiState* iUiState;
    
    /// Timer for long key down event. Owned.
    CKeyHandlerTimer* iTimer;
    
    /// Flag for SIND key down
    TBool iSINDKeyDown;
    
    /// Flag for SIND launched
    TBool iSINDLaunched;
    };

} // namespace AiWsPlugin


#endif // C_AIWSPLUGIN_SINDLAUNCHANDLER_H
hs_app_uistate.h
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  UI State query interface for Active Idle WS Plug-in.
*
*/


#ifndef M_AIWSPLUGIN_UISTATE_H
#define M_AIWSPLUGIN_UISTATE_H


#include 

namespace AiWsPlugin {

/**
 *  @ingroup group_wsplugin
 *
 * UI State query interface for Active Idle WS Plug-in
 */
class MUiState
    {
public:
    /**
     * Returns the current modifier key status.
     * @see TEventModifier
     */
    virtual TUint Modifiers() const =0;

    /**
     * Returns true if Active Idle currently has focus.
     */
    virtual TBool HasFocus() const =0;
    
protected:
    /**
     * Protected destructor to prevent deletion through this interface.
     */
    ~MUiState() { }
    };

} // namespace AiWsPlugin

#endif // M_AIWSPLUGIN_UISTATE_H
hs_app_aiwsplugin.iby
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  IBY file for Active Idle Window Server Plug-in
*
*/


#ifndef AIWSPLUGIN_IBY
#define AIWSPLUGIN_IBY

#ifdef RD_CUSTOMIZABLE_AI

file=ABI_DIR\BUILD_DIR\hs_app_aiwsplugin.dll         SHARED_LIB_DIR\hs_app_aiwsplugin.dll

#endif // RD_CUSTOMIZABLE_AI

#endif // AIWSPLUGIN_IBY

//  End of File
hs_app_aiwspluginanim.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Active Idle Window Server Plug-in implementation.
*
*/


#include "hs_app_aiwspluginanim.h"
#include "hs_app_aiwspluginanimdef.h"
#include "hs_app_keylockhandler.h"
#include "hs_app_numerickeyhandler.h"
#include "hs_app_logslaunchhandler.h"
#include "hs_app_sindlaunchhandler.h"

#include 

using namespace AiWsPlugin;

CAiWsPluginAnim::CAiWsPluginAnim()
    {
    }

CAiWsPluginAnim::~CAiWsPluginAnim()
    {
    iEventHandlers.ResetAndDestroy();
    if ( iFunctions )
        {
        iFunctions->GetRawEvents( EFalse );
        }
    FeatureManager::UnInitializeLib();
    }

TInt CAiWsPluginAnim::CommandReplyL( TInt /*aOpcode*/, TAny* /*aArgs*/ )
    {
    return KErrNone;
    }

void CAiWsPluginAnim::Command( TInt /*aOpcode*/, TAny* /*aArgs*/ )
    {
    }

void CAiWsPluginAnim::Animate( TDateTime* /*aDateTime*/ )
    {
    }

void CAiWsPluginAnim::AddEventHandlerAndPopL( CEventHandler* aEventHandler )
    {
    if( aEventHandler )
        {
        aEventHandler->SetUiStateQuery( *this );
	    iEventHandlers.AppendL( aEventHandler );
	    CleanupStack::Pop( aEventHandler );
        }
    }

void CAiWsPluginAnim::ConstructL( TAny* aArgs, TBool aHasFocus )
    {
    FeatureManager::InitializeLibL();
    
    iFunctions->GetRawEvents( ETrue );
    if( !aArgs )
        {
        User::Leave( KErrArgument );
        }
    iWgInfo = *( static_cast(aArgs) );
    
    AddEventHandlerAndPopL( CKeyLockHandler::NewLC() );

    MAnimGeneralFunctionsWindowExtension* ext = reinterpret_cast
        ( iFunctions->ExtendedInterface( 
         MAnimGeneralFunctions::EWindowExtensionInterface ) );
    AddEventHandlerAndPopL( CNumericKeyHandler::NewLC( iWgInfo.iTargetWgId, ext ) );
	
	AddEventHandlerAndPopL( CLogsLaunchHandler::NewLC() );
	
/* Leave this commented code here for now.. 2.5.2007, unclear if needed still in some config.
	if ( FeatureManager::FeatureSupported( KFeatureIdKeypadNoVoiceKey ) )
	    {
	    AddEventHandlerAndPopL( CSINDLaunchHandler::NewLC() );       
	    }	
*/
    // Update initial focus status
    FocusChanged( aHasFocus );
    }

void CAiWsPluginAnim::Redraw()
    {
    }

void CAiWsPluginAnim::FocusChanged( TBool aState )
    {
    iAiFocused = aState;
    const TInt handlerCount = iEventHandlers.Count();
    for( TInt i = 0; i < handlerCount; ++i )
        {
        iEventHandlers[i]->FocusChanged( aState );
        }
    }

TBool CAiWsPluginAnim::OfferRawEvent( const TRawEvent& aRawEvent )
    {
    // Forward event to all event handlers
    const TInt handlerCount = iEventHandlers.Count();
    for( TInt i = 0; i < handlerCount; ++i )
        {
        // All other are made to return EFalse
        // Except wait for 2ndkeyup and 2ndkeydown of keylock states.
        if( iEventHandlers[i]->OfferRawEvent( aRawEvent ) )
            {
            return ETrue;
            }
        }
    
    // Update modifier key status
    iModifierTracker.Update( aRawEvent );
    
    return EFalse;
    }
	
TUint CAiWsPluginAnim::Modifiers() const
    {
    return iModifierTracker.Status();
    }
    
TBool CAiWsPluginAnim::HasFocus() const
    {
    return iAiFocused;
    }
	
hs_app_aiwspluginanimdll.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:
*
*/


#include    "hs_app_aiwspluginanimdef.h"
#include    "hs_app_aiwspluginanimdll.h"
#include    "hs_app_aiwspluginanim.h"

// Create idle key forwarding plug-in.
CAnim* CAiWsPluginAnimDll::CreateInstanceL( TInt aType )
    {
    switch ( aType )
        {
        case EAnimKeyForward:
            return new ( ELeave ) CAiWsPluginAnim();
        default:
            return NULL;
        }
    }

// Create plug-in. Factory function.
EXPORT_C CAnimDll* CreateCAnimDllL()
    {
    return new ( ELeave ) CAiWsPluginAnimDll();
    }

hs_app_keyhandlertimer.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Key handler timer for Active Idle WS Plug-in.
*
*/


#include 

#include "hs_app_keyhandlertimer.h"
#include "hs_app_sindlaunchhandler.h"

namespace AiWsPlugin {

CKeyHandlerTimer::CKeyHandlerTimer( MHandlerTimer* aHandler )
 :  CTimer( CTimer::EPriorityStandard )
    {
    iHandler = aHandler;
    }
    
void CKeyHandlerTimer::ConstructL()
    {
    CTimer::ConstructL();
    CActiveScheduler::Add( this );        
    }

CKeyHandlerTimer* CKeyHandlerTimer::NewL( MHandlerTimer* aHandler )
    {
    CKeyHandlerTimer* self = CKeyHandlerTimer::NewLC( aHandler );
    CleanupStack::Pop( self );
    return self;
    }


CKeyHandlerTimer* CKeyHandlerTimer::NewLC( MHandlerTimer* aHandler )
    {
    CKeyHandlerTimer* self = new(ELeave) CKeyHandlerTimer( aHandler );
    CleanupStack::PushL( self );
    self->ConstructL();
    return self;
    }
    
CKeyHandlerTimer::~CKeyHandlerTimer()
    {
    Cancel();
    }

void CKeyHandlerTimer::RunL()
    {
    if( iHandler )
        {
        iHandler->TimerDone();
        }
    }
    
TInt CKeyHandlerTimer::RunError( TInt /*aError*/ )
    {
    return 0;
    }

TBool CKeyHandlerTimer::IsActive()
	{
	return CActive::IsActive();
	}

} // namespace AiWsPlugin
hs_app_keylockhandler.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Keylock handler implementation for Active Idle WS Plug-in
*
*/


#include "hs_app_keylockhandler.h"
#include "hs_app_keyhandlertimer.h"
#include "hs_app_keylockstates.h"
#include "hs_app_aiwspluginanimdef.h"
#include "hs_app_uistate.h"

#include 
#include 
#include 

#include "debug.h"

namespace AiWsPlugin {

CKeyLockHandler::CKeyLockHandler() :
    // Initialize to start-up state
    iCurrentState( &TKeylockState::StartupState() ),
    iNextState( &iCurrentState->iDefaultNextState() )
    {
    }
    
void CKeyLockHandler::ConstructL()
    {
    // Read capability: ReadDeviceData.
    _LIT_SECURITY_POLICY_C1( KReadDevicePolicy, ECapabilityReadDeviceData );
    // Write capability: WriteDeviceData.
    _LIT_SECURITY_POLICY_C1( KWriteDevicePolicy, ECapabilityWriteDeviceData );

    // Initialize Shortcut Plug-in command API
    RProperty::Define( 
    	KUidSystemCategory,
    	KPSUidShortcutCmd,  
      	RProperty::EText,
        KReadDevicePolicy,
        KWriteDevicePolicy 
        );

    iSettings.ReadFromRepositoryL();    
    iKeypadLockTimer = CPeriodic::NewL( CActive::EPriorityUserInput );
    iKeylockApi = CKeyLockPolicyApi::NewL( EPolicyActivateKeyguard );
    if ( !iKeylockApi->HasConfiguration() )
        {
        delete iKeylockApi;
        iKeylockApi = NULL;
        }
    }

CKeyLockHandler* CKeyLockHandler::NewLC()
    {
    CKeyLockHandler* self = new( ELeave ) CKeyLockHandler;
    CleanupStack::PushL( self );
    self->ConstructL();
    return self;
    }

CKeyLockHandler::~CKeyLockHandler()
    {
    delete iKeypadLockTimer;
    delete iKeylockApi;
    }

void CKeyLockHandler::SetUiStateQuery( MUiState& aUiState )
    {
    iUiState = &aUiState;
    }

TBool CKeyLockHandler::HasFocus()
    {
    return iUiState->HasFocus();
    }
    
TBool CKeyLockHandler::TimeoutTimerActive()
    {
    return iKeypadLockTimer->IsActive();
    }

void CKeyLockHandler::FocusChanged( TBool aState )
    {
    iCurrentState->FocusChanged( *this, aState );
    }
    
TBool CKeyLockHandler::OfferRawEvent(const TRawEvent& aRawEvent)
    {
    return iCurrentState->OfferRawEvent( *this, aRawEvent );    
    }

TBool CKeyLockHandler::IsFirstLockKey( TInt aScanCode )
    {  
    if ( iKeylockApi )
        {
        TKeyEvent event;
        event.iModifiers = 0;
        event.iCode = 0;
        event.iRepeats = 0;
        event.iScanCode = aScanCode;
        // Keylock API return ETrue on handlekeyeventL only if the whole key
        // sequence has been inputted (1st + 2nd key pressed)
        TRAP_IGNORE(iKeylockApi->HandleKeyEventL( event,EEventKeyDown ));
        return iKeylockApi->PrimaryKeyPressed();
        }
    else
        {
        return Settings().IsFirstLockKey( aScanCode );
        }
    }

TBool CKeyLockHandler::IsSecondLockKey( TInt aScanCode )
    {   
    TBool returnValue = EFalse;
    if ( iKeylockApi )
        {
        TKeyEvent event;
        event.iModifiers = 0;
        event.iCode = 0;
        event.iRepeats = 0;
        event.iScanCode = aScanCode;
        TRAP_IGNORE(returnValue = iKeylockApi->HandleKeyEventL( event,EEventKeyDown ));
        return returnValue;
        }
    else
        {
        return Settings().IsSecondLockKey( aScanCode );
        }
    }

const TKeypadSettings& CKeyLockHandler::Settings() const
    {
    return iSettings;
    }

void CKeyLockHandler::StartTimeoutTimer( TInt aTimeout )
    {
    __PRINTS( "AiWsPlugin: CKeyLockHandler::StartTimeoutTimer()" );
    
    iKeypadLockTimer->Cancel();
    if( aTimeout < 0 )
        {
        iKeypadLockTimer->Start( 
            iSettings.KeylockTimeout(), iSettings.KeylockTimeout(),
            TCallBack( &CKeyLockHandler::TimerElapsed, this ) );
        }
    else
        {
        iKeypadLockTimer->Start( 
            aTimeout, aTimeout,
            TCallBack( &CKeyLockHandler::TimerElapsed, this ) );
        }
    }
    
void CKeyLockHandler::StopTimeoutTimer()
    {
    __PRINTS( "AiWsPlugin: CKeyLockHandler::StopTimeoutTimer()" );
    iKeypadLockTimer->Cancel();
    }

void CKeyLockHandler::ActivateKeypadLock()
	{
    __PRINTS( "AiWsPlugin: CKeyLockHandler::ActivateKeypadLock()" );
	StopTimeoutTimer();
	// Use Shortcut Plug-in API to set the keylock
	RProperty::Set(
		KUidSystemCategory, 
	    KPSUidShortcutCmd,
	    KAiPSEnableKeyLock );
    }

void CKeyLockHandler::CancelKeypadLock()
	{
    __PRINTS( "AiWsPlugin: CKeyLockHandler::CancelKeypadLock()" );
	StopTimeoutTimer();
	RProperty::Set(
		KUidSystemCategory, 
	    KPSUidShortcutCmd,
	    KAiPSSkipKeyLock );
	} 

void CKeyLockHandler::KeypadLockTimeout()
	{
    __PRINTS( "AiWsPlugin: CKeyLockHandler::CancelKeypadLock()" );
	StopTimeoutTimer();
	RProperty::Set(
		KUidSystemCategory, 
	    KPSUidShortcutCmd,
	    KAiPSKeyLockTimeout );
	} 

void CKeyLockHandler::SetNextState( const TKeylockState& aState )
    {
    iNextState = &aState;
    }

void CKeyLockHandler::ActivateNextState()
    {
    iCurrentState = iNextState;
    iNextState = &(*iCurrentState->iDefaultNextState)();
    }

void CKeyLockHandler::SetLastLockKeyScanCode( TInt aScanCode )
    {
    iLastLockKeyScanCode = aScanCode;
    }
    
TInt CKeyLockHandler::LastLockKeyScanCode() const
    {
    return iLastLockKeyScanCode;
    }
    
TInt CKeyLockHandler::TimerElapsed(TAny* aSelf)
    {
    CKeyLockHandler* self = static_cast(aSelf);
    if( self )
        {
        self->iCurrentState->TimerElapsed( *self );
        }
    return KErrNone;
    }
    
void CKeyLockHandler::TimerDone()
    {
        
    }

} // namespace AiWsPlugin
hs_app_keylockstates.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Keylock states implementation for Active Idle WS Plug-in
*
*/


#include "hs_app_keylockstates.h"
#include "hs_app_keylockcontrol.h"
#include "hs_app_keypadsettings.h"
#include "hs_app_panic.h"
#include "activeidle2domainpskeys.h"

#include 
#include 

#include "debug.h"


namespace AiWsPlugin {

const TInt KTenMilliSecondsInu = 10 * 1000;

/**
 * Helper macro for declaring internal state classes for CKeyLockHandler.
 */
#define AI_DECLARE_KEYLOCK_STATE(StateCls) \
    class StateCls { \
    public: \
        static const TKeylockState KState; \
        static const TKeylockState& DefaultNextState(); \
        static void FocusChanged( MKeyLockHandlerControl& aControl, TBool aState ); \
        static TBool OfferRawEvent( MKeyLockHandlerControl& aControl, const TRawEvent& aRawEvent ); \
        static void TimerElapsed( MKeyLockHandlerControl& aControl ); \
        }

/**
 * Inactive state class for CKeyLockHandler.
 */
AI_DECLARE_KEYLOCK_STATE(TKeylockStateInactive);

/**
 * Active state class for CKeyLockHandler.
 */
AI_DECLARE_KEYLOCK_STATE(TKeylockStateWaitForFirstKeyDown);

/**
 * Keylock sequence in progress state class for CKeyLockHandler.
 */
AI_DECLARE_KEYLOCK_STATE(TKeylockStateWaitForSecondKeyDown);

/**
 * Keylock sequence finalizer state class for CKeyLockHandler.
 */
AI_DECLARE_KEYLOCK_STATE(TKeylockStateWaitForSecondKeyUp);

/**
 * Helper macro for defining key lock state function tables.
 */
#define AI_DEFINE_KEYLOCK_STATE_FT(StateCls) \
    const TKeylockState StateCls::KState = {     \
        &StateCls::DefaultNextState,             \
        &StateCls::FocusChanged,                 \
        &StateCls::OfferRawEvent,                \
        &StateCls::TimerElapsed }

/// Defines function table for key lock inactive state
AI_DEFINE_KEYLOCK_STATE_FT(TKeylockStateInactive);

/// Defines function table for key lock active state
AI_DEFINE_KEYLOCK_STATE_FT(TKeylockStateWaitForFirstKeyDown);

/// Defines function table for key lock in progress state
AI_DEFINE_KEYLOCK_STATE_FT(TKeylockStateWaitForSecondKeyDown);

/// Defines function table for key lock finalizing state
AI_DEFINE_KEYLOCK_STATE_FT(TKeylockStateWaitForSecondKeyUp);

// TKeyLockState
const TKeylockState& TKeylockState::StartupState()
    {
    return TKeylockStateInactive::KState;
    }

// TKeylockStateInactive
const TKeylockState& TKeylockStateInactive::DefaultNextState()
    {
    return TKeylockStateWaitForFirstKeyDown::KState;
    }
    
void TKeylockStateInactive::FocusChanged
        ( MKeyLockHandlerControl& aControl, TBool aState )
    {
    __PRINT( __DBG_FORMAT("AiWsPlugin: TKeylockStateInactive::FocusChanged(%d)"), aState );
    if ( aState )
        {
        // Gained focus, switch to active state
        aControl.ActivateNextState();    
        }
    }
    
TBool TKeylockStateInactive::OfferRawEvent
        ( MKeyLockHandlerControl& /*aControl*/, const TRawEvent& /*aRawEvent*/ )
    {
    return EFalse;
    }
    
void TKeylockStateInactive::TimerElapsed
        ( MKeyLockHandlerControl& aControl )
    {
    // Illegal event in this state
    aControl.KeypadLockTimeout();
#ifndef NDEBUG
    //Panic( EPanicInvalidKeylockEvent );
#endif    
    }

// TKeylockStateWaitForFirstLockKeyDown
const TKeylockState& TKeylockStateWaitForFirstKeyDown::DefaultNextState()
    {
    return TKeylockStateWaitForSecondKeyDown::KState;
    }

void TKeylockStateWaitForFirstKeyDown::FocusChanged
        ( MKeyLockHandlerControl& aControl, TBool aState )
    {
    __PRINT( __DBG_FORMAT("AiWsPlugin: TKeylockStateWaitForFirstKeyDown::FocusChanged(%d)"), aState );
    if ( !aState )
        {
        if( !aControl.TimeoutTimerActive() )
            {
            // Lost focus, switch to inactive state
            aControl.SetNextState( TKeylockStateInactive::KState );
            aControl.ActivateNextState();
            }
        }
    }
    
TBool TKeylockStateWaitForFirstKeyDown::OfferRawEvent
        ( MKeyLockHandlerControl& aControl, const TRawEvent& aRawEvent )
    {
    switch ( aRawEvent.Type() )
        {
        case TRawEvent::EKeyDown:
            {
            const TInt scanCode = aRawEvent.ScanCode();
            __PRINT( __DBG_FORMAT("AiWsPlugin: TKeylockStateWaitForFirstKeyDown::OfferRawEvent(EKeyDown,ScanCode=%d)" ), scanCode );
            if ( aControl.IsFirstLockKey( scanCode ) && aControl.HasFocus() )
                {
                // First lock key was pressed down
                aControl.SetLastLockKeyScanCode( scanCode );
                // (Re)activate the keylock timeout timer
                aControl.StartTimeoutTimer(KTenMilliSecondsInu);
                }
            }
        }

    // Never consume the event to enable its processing if keylock
    // is not activated within the timeout
    return EFalse;
    }
    
void TKeylockStateWaitForFirstKeyDown::TimerElapsed
        ( MKeyLockHandlerControl& aControl )
    {
                TInt value = EPSAiNotDisplayingMenuOrDialog;          
                TInt err = RProperty::Get(
                   KPSUidAiInformation, 
                   KActiveIdlePopupState, 
                   value );
                
                if( value == EPSAiNotDisplayingMenuOrDialog && err == KErrNone )
                    {
                    // (Re)activate the keylock timeout timer
                    aControl.StartTimeoutTimer();
                    // Switch to wait for second lock key down (see constructor of this state)
                    aControl.ActivateNextState();
                    }
                else
                    {
                    if( aControl.HasFocus() )
                        {
                        aControl.StopTimeoutTimer();
                        }
                    else
                        {
                        // Lost focus, switch to inactive state
                        aControl.SetNextState( TKeylockStateInactive::KState );
                        aControl.ActivateNextState();
                        }
                    }
    // Illegal event in this state
#ifndef NDEBUG
    //Panic( EPanicInvalidKeylockEvent );
#endif    
    }

// TKeylockStateWaitForSecondKeyDown
const TKeylockState&  TKeylockStateWaitForSecondKeyDown::DefaultNextState()
    {
    // Assume the keylock sequence is cancelled
    return TKeylockStateWaitForFirstKeyDown::KState;
    }

void TKeylockStateWaitForSecondKeyDown::FocusChanged
        ( MKeyLockHandlerControl& aControl, TBool aState )
    {
    __PRINT( __DBG_FORMAT("AiWsPlugin: TKeylockStateWaitForSecondKeyDown::FocusChanged(%d)"), aState );
    if ( aState )
        {
        // Gained focus: return to active state if keylock sequence is cancelled
        aControl.SetNextState( TKeylockStateWaitForFirstKeyDown::KState );
        }
    else
        {
        // Lost focus: return to inactive state if keylock sequence is cancelled
        aControl.SetNextState( TKeylockStateInactive::KState );
        }
    }
    
TBool TKeylockStateWaitForSecondKeyDown::OfferRawEvent
        ( MKeyLockHandlerControl& aControl, const TRawEvent& aRawEvent )
    {
    TBool consumedEvent = EFalse;
    
    switch ( aRawEvent.Type() )
        {
        case TRawEvent::EKeyDown:
            {
            const TInt scanCode = aRawEvent.ScanCode();
            __PRINT( __DBG_FORMAT("AiWsPlugin: TKeylockStateWaitForSecondKeyDown::OfferRawEvent(EKeyDown,ScanCode=%d)" ), scanCode );
            if ( aControl.IsSecondLockKey( scanCode ) )
                {
                // Second lock key was pressed down. Cancel keylock timer
                // and switch to wait for key up event.
                aControl.StopTimeoutTimer();
                aControl.SetLastLockKeyScanCode( scanCode );
                aControl.SetNextState( TKeylockStateWaitForSecondKeyUp::KState );
                aControl.ActivateNextState();
                consumedEvent = ETrue;
                }
            else
                {
                // Some other key than second lock key was pressed while
                // keylock timer was running. Cancel the keylock sequence and
                // switch to previous state. (Depending on focus status,
                // see TKeylockStateWaitForFirstKeyDown::FocusChanged.)
                aControl.CancelKeypadLock();
                aControl.ActivateNextState();
                consumedEvent = EFalse;
                }
            break;
            }
        }
        
    return consumedEvent;
    }
    
void TKeylockStateWaitForSecondKeyDown::TimerElapsed
        ( MKeyLockHandlerControl& aControl )
    {
    __PRINTS( "AiWsPlugin: TKeylockStateWaitForSecondKeyDown::TimerElapsed()" ); 
    aControl.KeypadLockTimeout();
    aControl.ActivateNextState();
    }

// TKeylockStateWaitForSecondKeyUp
const TKeylockState& TKeylockStateWaitForSecondKeyUp::DefaultNextState()
    {
    // Idle must currently have focus so return to active state from this state
    return TKeylockStateWaitForFirstKeyDown::KState;
    }

void TKeylockStateWaitForSecondKeyUp::FocusChanged
        ( MKeyLockHandlerControl& aControl, TBool aState )
    {
    __PRINT( __DBG_FORMAT("AiWsPlugin: TKeylockStateWaitForSecondKeyUp::FocusChanged(%d)"), aState );
    if ( aState )
        {
        // Gained focus: return to active state if keylock sequence is cancelled
        aControl.SetNextState(
            TKeylockStateWaitForFirstKeyDown::KState );
        }
    else
        {
        // Lost focus: return to inactive state if keylock sequence is cancelled
        aControl.SetNextState( TKeylockStateInactive::KState );
        }
    }
    
TBool TKeylockStateWaitForSecondKeyUp::OfferRawEvent
        ( MKeyLockHandlerControl& aControl, const TRawEvent& aRawEvent )
    {
    TBool consumedEvent = EFalse;
    
    switch ( aRawEvent.Type() )
        {
        case TRawEvent::EKeyUp:
            {
            const TInt scanCode = aRawEvent.ScanCode();
            __PRINT( __DBG_FORMAT("AiWsPlugin: TKeylockStateWaitForSecondKeyUp::OfferRawEvent(EKeyUp,ScanCode=%d)" ), scanCode );
            if ( scanCode == aControl.LastLockKeyScanCode() )
                {
                // Second lock key was released. Activate the keypad lock and
                // switch back to initial state. (Depending on focus status,
                // see TKeylockStateWaitForSecondKeyUp::FocusChanged.)
                aControl.ActivateKeypadLock();
                aControl.ActivateNextState();
                }
            // Consume all key events until the keylock sequence is finalized
            consumedEvent = ETrue;
            break;
            }

        case TRawEvent::EKeyDown:
            {
            // Consume all key events until the keylock sequence is finalized
            consumedEvent = ETrue;
            break;
            }
        }
        
    return consumedEvent;
    }
    
void TKeylockStateWaitForSecondKeyUp::TimerElapsed
        ( MKeyLockHandlerControl& /*aControl*/ )
    {
    // Illegal event in this state
#ifndef NDEBUG
    //Panic( EPanicInvalidKeylockEvent );
#endif    
    }

} // namespace AiWsPlugin
hs_app_keypadsettings.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Keypad settings implmentation for Active Idle WS Plug-in.
*
*/


#include "hs_app_keypadsettings.h"

#include 
#include 
#include 

#include 

#include "debug.h"

namespace AiWsPlugin {


/**
 * Maps selected numeric keypad scan codes to character.
 *
 * @param aScanCode scan code for which to find a character mapping.
 * @return character mapping for aScanCode or -1 if no mapping is found.
 */
TInt16 TKeypadSettings::MapNkpScanCodeToChar( TInt aScanCode )
    {
    TInt16 result;
    switch( aScanCode )
        {
        case EStdKeyHash:        result = '#'; break;
        case EStdKeyMinus:       result = '-'; break;
        case EStdKeyNkpAsterisk: result = '*'; break;
        case EStdKeyNkpMinus:    result = '-'; break;
        case EStdKeyNkpPlus:     result = '+'; break;
        case EStdKeyNkp1:        result = '1'; break;
        case EStdKeyNkp2:        result = '2'; break;
        case EStdKeyNkp3:        result = '3'; break;
        case EStdKeyNkp4:        result = '4'; break;
        case EStdKeyNkp5:        result = '5'; break;
        case EStdKeyNkp6:        result = '6'; break;
        case EStdKeyNkp7:        result = '7'; break;
        case EStdKeyNkp8:        result = '8'; break;
        case EStdKeyNkp9:        result = '9'; break;
        case EStdKeyNkp0:        result = '0'; break;
        default:                 result =  -1; break;
        }
    return result;
    }

void TKeypadSettings::ReadFromRepositoryL()
    {
    CRepository* repository = CRepository::NewLC( TUid::Uid( KCRUidActiveIdleLV ) );
    TInt value;
    
    // KAIFirstKeyLockKey
    User::LeaveIfError( repository->Get( KAIFirstKeyLockKey,  value ) );
    iFirstLockKeyScanCode = TInt16( value );
    iFirstLockKeyChar = MapNkpScanCodeToChar( value );
    __PRINT( 
        __DBG_FORMAT("AiWsPlugin: KAIFirstKeyLockKey = %d, ch=%d"), 
        TInt(iFirstLockKeyScanCode), TInt(iFirstLockKeyChar) );
    
    // KAISecondKeyLockKey
	User::LeaveIfError( repository->Get( KAISecondKeyLockKey, value ) );
	iSecondLockKeyScanCode = TInt16( value );
	iSecondLockKeyChar = MapNkpScanCodeToChar( value );
    __PRINT( 
        __DBG_FORMAT("AiWsPlugin: KAISecondKeyLockKey = %d, ch=%d"), 
        TInt(iSecondLockKeyScanCode), TInt(iSecondLockKeyChar) );
    
    // KAISecondKeyLockKey2
	User::LeaveIfError( repository->Get( KAISecondKeyLockKey2, value ) );
	iSecondLockKeyScanCode2 = TInt16( value );
	iSecondLockKeyChar2 = MapNkpScanCodeToChar( value );
    __PRINT( 
        __DBG_FORMAT("AiWsPlugin: KAISecondKeyLockKey2 = %d, ch=%d"), 
        TInt(iSecondLockKeyScanCode2), TInt(iSecondLockKeyChar2) );

    // KAIKeyLockTimeout    
	User::LeaveIfError( repository->Get( KAIKeyLockTimeout, value ) );
    __PRINT( __DBG_FORMAT("AiWsPlugin: KAIKeyLockTimeout=%d ms"), value );
	// Convert timeout from milliseconds to microseconds
    const TInt KUsInMs = 1000;
    iKeylockTimeout = KUsInMs * value;
    
    // KAISINDKey
	User::LeaveIfError( repository->Get( KAIVoiceDialLaunchKey, value ) );
	iSINDKeyScanCode = TInt16( value );
	iSINDKeyScanChar = MapNkpScanCodeToChar( value );
    __PRINT( 
        __DBG_FORMAT("AiWsPlugin: iSINDKey = %d, ch=%d"), 
        TInt(iSINDKeyScanCode), TInt(iSINDKeyScanChar) );

    // KAISINDKeyTimeout    
	User::LeaveIfError( repository->Get( KAIVoiceDialKeyTimeout, value ) );
    __PRINT( __DBG_FORMAT("AiWsPlugin: KAISINDKeyTimeout=%d ms"), value );
	// Convert timeout from milliseconds to microseconds
    iKeySINDTimeout = KUsInMs * value;
	
	CleanupStack::PopAndDestroy( repository );
    }

TBool TKeypadSettings::IsFirstLockKey( TInt aScanCode ) const
    {
    return ( aScanCode == iFirstLockKeyScanCode || aScanCode == iFirstLockKeyChar );
    }
    
TBool TKeypadSettings::IsSecondLockKey( TInt aScanCode ) const
    {
    return (
        ( aScanCode == iSecondLockKeyScanCode || aScanCode == iSecondLockKeyChar ) ||
        ( aScanCode == iSecondLockKeyScanCode2 || aScanCode == iSecondLockKeyChar2 ) );
    }

TTimeIntervalMicroSeconds32 TKeypadSettings::KeylockTimeout() const
    {
    return iKeylockTimeout;
    }

} // namespace AiWsPlugin
hs_app_logslaunchhandler.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Logs app launch handler for Active Idle WS Plug-in.
*
*/


#include "hs_app_logslaunchhandler.h"
#include "hs_app_uistate.h"
#include 
#include 
#include 
#include 
#include 

namespace AiWsPlugin {


CLogsLaunchHandler::CLogsLaunchHandler()
    {
    }

void CLogsLaunchHandler::ConstructL()
    {
    // Read capability: ReadDeviceData.
    _LIT_SECURITY_POLICY_C1( KReadDevicePolicy, ECapabilityReadDeviceData );
    // Write capability: WriteDeviceData.
    _LIT_SECURITY_POLICY_C1( KWriteDevicePolicy, ECapabilityWriteDeviceData );

    // Initialize Shortcut Plug-in command API
    RProperty::Define(
        KUidSystemCategory,
        KPSUidShortcutCmd,
        RProperty::EText,
        KReadDevicePolicy,
        KWriteDevicePolicy
        );

    iTimer = CKeyHandlerTimer::NewL( this );
    }

CLogsLaunchHandler* CLogsLaunchHandler::NewLC()
    {
    CLogsLaunchHandler* self = new(ELeave) CLogsLaunchHandler;
    CleanupStack::PushL( self );
    self->ConstructL();
    return self;
    }

CLogsLaunchHandler::~CLogsLaunchHandler()
    {
     if ( iTimer)
     {
     iTimer->Cancel();
     delete iTimer;
     }
    }

void CLogsLaunchHandler::SetUiStateQuery( MUiState& aUiState )
    {
    iUiState = &aUiState;
    }

void CLogsLaunchHandler::FocusChanged( TBool /*aState*/ )
    {
    // Focus status is queried from iUiState
    }

TBool CLogsLaunchHandler::OfferRawEvent(const TRawEvent& aRawEvent)
    {
    TInt reactOnSendKey = 1;
    TInt err = RProperty::Get( KPSUidAiInformation, KActiveIdleActOnSendKey, reactOnSendKey );
    if ( err != KErrNone )
        {
        reactOnSendKey = 1;
        }

    TBool consumed = EFalse;

    if ( reactOnSendKey )
        {
        switch( aRawEvent.Type() )
            {
            case TRawEvent::EKeyDown:
                {
                if ( iUiState->HasFocus() && aRawEvent.ScanCode() == EStdKeyYes )
                    {
                    const TTimeIntervalMicroSeconds32 KLongKeyPress(600000);
                    iTimer->Cancel();
                    iTimer->After(KLongKeyPress);
                    consumed = ETrue;
                    }
                break;
                }
            case TRawEvent::EKeyUp:
                {
                if ( iUiState->HasFocus() && aRawEvent.ScanCode() == EStdKeyYes && iTimer->IsActive() )
                    {
                    iTimer->Cancel();
                    RProperty::Set(
                        KUidSystemCategory,
                        KPSUidShortcutCmd,
                        KAiPSLaunchLogs );
                    consumed = ETrue;
                    }
                break;
                }
            }
        }

    return consumed;
    }

void CLogsLaunchHandler::TimerDone()
    {
    RProperty::Set(
        KUidSystemCategory,
        KPSUidShortcutCmd,
        KAiPSLaunchNameDialer );
    }

} // namespace AiWsPlugin
hs_app_modifierkeytracker.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Modifier key status tracker for Active Idle WS Plug-in.
*
*/


#include "hs_app_modifierkeytracker.h"
#include 
#include 

//#define AI_ENABLE_RD_LOGGING
#define AI_RD_LOG_TO_DEBUG_OUTPUT
#include "debug.h"

namespace AiWsPlugin {


// LOCAL FUNCTIONS

TUint ModifierKeyToBit( TInt aScanCode )
    {
    switch( aScanCode )
        {
        case EStdKeyLeftShift:
            return EModifierLeftShift;
            
        case EStdKeyRightShift:
            return EModifierRightShift;
            
        case EStdKeyLeftAlt:
            return EModifierLeftAlt;

        case EStdKeyRightAlt:
            return EModifierRightAlt;

        case EStdKeyLeftCtrl:
            return EModifierLeftCtrl;

        case EStdKeyRightCtrl:
            return EModifierRightCtrl;

        case EStdKeyLeftFunc:
            return EModifierLeftFunc;

        case EStdKeyRightFunc:
            return EModifierRightFunc;
            
        default:
            return 0;
        }
    }

TUint UpdateCombinedIndicators(TUint aModifiers)
    {
    TUint result = aModifiers;
    struct TModifierCombinations { TUint iModifiers; TUint iCombinedIndicator; };
    static const TModifierCombinations KModifierCombinations[] =
        {
            { EModifierLeftShift | EModifierRightShift, EModifierShift },
            { EModifierLeftAlt   | EModifierRightAlt,   EModifierAlt   },
            { EModifierLeftCtrl  | EModifierRightCtrl,  EModifierCtrl  },
            { EModifierLeftFunc  | EModifierRightFunc,  EModifierFunc  }
        };
    const TModifierCombinations* KModifierCombinationsEnd = 
        KModifierCombinations + sizeof( KModifierCombinations ) / sizeof( KModifierCombinations[0] );

    for ( const TModifierCombinations* comb = KModifierCombinations;
          comb != KModifierCombinationsEnd;
          ++comb )
        {
        if ( aModifiers & comb->iModifiers )
            {
            result |= comb->iCombinedIndicator;
            }
        else
            {
            result &= ~comb->iCombinedIndicator;
            }
        }
    
    return result;
    }

// MEMBER FUNCTIONS

TModifierKeyTracker::TModifierKeyTracker() :
    iModifiers( 0 )
    {
    }

TBool TModifierKeyTracker::Update(const TRawEvent& aRawEvent)
    {
    TUint modifiers = iModifiers;
    
    switch( aRawEvent.Type() )
        {
        case TRawEvent::EKeyDown:
            {
            modifiers |= ModifierKeyToBit( aRawEvent.ScanCode() );
            modifiers = UpdateCombinedIndicators( modifiers );
            break;
            }
            
        case TRawEvent::EKeyUp:
            {
            modifiers &= ~ModifierKeyToBit( aRawEvent.ScanCode() );
            modifiers = UpdateCombinedIndicators( modifiers );
            break;
            }

        // DEBUG: Compare to what modifer update event would report
        case TRawEvent::EUpdateModifiers:
            {
            __PRINT( 
                __DBG_FORMAT("AiWsPlugin: TModifierKeyTracker::Update(), iModifers=%d, TRawEvent::Modifiers()=%d"), 
                iModifiers, aRawEvent.Modifiers() );
            break;
            }
            
        default:
            {
            // No operations..
            break;
            }
        }

    if( modifiers != iModifiers )
        {
        iModifiers = modifiers;
        return ETrue;
        }
    else
        {
        return EFalse;
        }
    }
    
} // namespace AiWsPlugin
hs_app_numerickeyhandler.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Numeric key forwarding handler implementation for Active Idle 
*                WS Plug-in.
*
*/


#include "hs_app_numerickeyhandler.h"
#include "hs_app_uistate.h"

#include 
#include 
#include 

#include 
#include 
#include 
#include 

#include 
#include 

namespace AiWsPlugin {


CNumericKeyHandler::CNumericKeyHandler
        ( TInt aTargetWgId, MAnimGeneralFunctionsWindowExtension* aWindowExt ) :
    iTargetWgId( aTargetWgId ), 
    iWindowExt( aWindowExt )
    {
    }
    
void CNumericKeyHandler::ConstructL()
    {
    // Read capability: ReadUserData.
    _LIT_SECURITY_POLICY_C1( KReadUserPolicy, ECapabilityReadUserData ); 
    // Write capability: WriteDeviceData.
    _LIT_SECURITY_POLICY_C1( KWriteDevicePolicy, ECapabilityWriteDeviceData );

    RProperty::Define( 
         	KPSUidAiInformation,
         	KActiveIdleState,
         	RProperty::EInt,
            KReadUserPolicy,
            KWriteDevicePolicy );
                    
	iQwertyObserver = AiUtility::CreatePSPropertyObserverL(
			TCallBack( HandleQwertyModeChanged, this ),
        	KCRUidAvkon, KAknQwertyInputModeActive );
	
	iInputLanguageRepository = CRepository::NewL( KCRUidAknFep );
	iInputLanguageObserver = CCenRepNotifyHandler::NewL(*this, *iInputLanguageRepository);
	iInputLanguageObserver->StartListeningL(); 
	
	RProperty::Get(KCRUidAvkon, KAknQwertyInputModeActive, iQwertyMode);
	iInputLanguageRepository->Get( KAknFepInputTxtLang, iInputLanguage );
          
    // Load numeric keys mapping for qwerty 
    if ( iQwertyMode )
        {
        LoadInputLanguageKeyBindings( iInputLanguage );            
        }
    }

CNumericKeyHandler* CNumericKeyHandler::NewLC
        ( TInt aTargetWgId, MAnimGeneralFunctionsWindowExtension* aWindowExt )
    {
    CNumericKeyHandler* self = new(ELeave) CNumericKeyHandler
        ( aTargetWgId, aWindowExt );
    CleanupStack::PushL( self );
    self->ConstructL();
    return self;
    }
    
CNumericKeyHandler::~CNumericKeyHandler()
    {
    if( iInputLanguageObserver )
        {
        iInputLanguageObserver->StopListening();
        }
    delete iInputLanguageObserver;
    delete iInputLanguageRepository;
    Release(iQwertyObserver);
    iNumericKeys.Close();
    }

void CNumericKeyHandler::SetUiStateQuery( MUiState& aUiState )
    {
    iUiState = &aUiState;
    }

void CNumericKeyHandler::FocusChanged( TBool /*aState*/ )
    {
    }
    
TBool CNumericKeyHandler::OfferRawEvent(const TRawEvent& aRawEvent)
    {
    switch( aRawEvent.Type() )
        {
        case TRawEvent::EKeyDown:
            {
            if ( iUiState->HasFocus() && CheckPostToTarget( aRawEvent ) )
                {
                TInt forwardKeys = EPSAiForwardNumericKeysToPhone;       
                
                TInt err = RProperty::Get(
                        KPSUidAiInformation,
                        KActiveIdleForwardNumericKeysToPhone,
                        forwardKeys);
                // Key event forwarding disabled => Ignore the keys
                if ( err == KErrNone && 
                        forwardKeys == EPSAiDontForwardNumericKeysToPhone )
                    {
                    return EFalse;
                    }
    			// Phone app is listening this key and knows that next
                // focus event from window server is becuase key events
                // are coming to it.                        
                RProperty::Set(
                 	KPSUidAiInformation, 
                    KActiveIdleState,
                	EPSAiNumberEntry );

                // Switch focus to Phone app
                if( iWindowExt )
                    {
                    iWindowExt->SetOrdinalPosition( iTargetWgId, 0, 0 );
                    }
                }
            break;
            }
        }
    
    // Never consume the key event as we want target application to process it
    return EFalse;
    }

/**
 * Returns true if event should be forwarded to Phone app.
 */
TBool CNumericKeyHandler::CheckPostToTarget(const TRawEvent& aRawEvent ) const
    {
    const TInt scanCode = aRawEvent.ScanCode();

    if ( iQwertyMode ) 
        {
        // Don't pass the check if shift is pressed.
		const TUint modifiers = iUiState->Modifiers();
        if(( modifiers & EModifierShift ) == 0 )
            {
            TInt numericKeysCount = iNumericKeys.Count();
            while( numericKeysCount-- )
                {
                TPtiNumericKeyBinding numKeyBind = iNumericKeys[numericKeysCount];
                if( numKeyBind.iKey == scanCode )
                    {
                    return ETrue;
                    }
                }
            }
        }
    else
        {
        // Normal check ignore modifiers
        static const TInt KIdPlgScanCodes[] = 
            { '1','2','3','4','5','6','7','8','9','0',
              '*',EStdKeyNkpAsterisk,EStdKeyHash,EStdKeyNkpPlus };
        static const TInt KIdPlgScanCodeCount = 
            sizeof( KIdPlgScanCodes ) / sizeof( KIdPlgScanCodes[0] );
        TInt count = KIdPlgScanCodeCount;
        while( count-- )
            {
            const TInt refCode = KIdPlgScanCodes[ count ];
            // Is one of [0,1,2,3,4,5,6,7,8,9,*,#]?
            if( refCode == scanCode )
                {
                return ETrue;
                }
            }
        }
    return EFalse;
    }


/**
 * Load input locales.
 */
void CNumericKeyHandler::LoadInputLanguageKeyBindings( TInt aLanguage )
    {
    iNumericKeys.Reset();
    
    TRAPD( err, 
        {
        CPtiEngine* ptiEngine = CPtiEngine::NewL();
        CleanupStack::PushL( ptiEngine );
        ptiEngine->GetNumericModeKeysForQwertyL( aLanguage, 
                                                 iNumericKeys );         
        CleanupStack::PopAndDestroy( ptiEngine );                                                 
        } ); // TRAP
        
    if ( err )        
        {
        iNumericKeys.Reset();
        iQwertyMode = 0; // To default mode
        }
    else
        {
        // remove numeric chars that not open number entry
        TInt numericKeysCount = iNumericKeys.Count();
        while ( numericKeysCount-- )
            {
            TPtiNumericKeyBinding numKeyBind = iNumericKeys[numericKeysCount];
            
            if ( numKeyBind.iChar == 'w' ||
                 numKeyBind.iChar == 'p' 
#ifndef RD_INTELLIGENT_TEXT_INPUT
                 /*
                 * The following code is commented because
                 * For GQF requirement Space is mapped to "0"
                 */
                 || numKeyBind.iKey == EPtiKeyQwertySpace  
#endif
               )
                 {
                 iNumericKeys.Remove( numericKeysCount );                    
                 }
            }    
        }
    }
    
/**
 * Handles qwerty mode change.
 */
TInt CNumericKeyHandler::HandleQwertyModeChanged( TAny *aPtr )
    {
    CNumericKeyHandler* self = static_cast( aPtr );
    if( self )
        {
        TInt value = self->iQwertyMode;
        TInt err = self->iQwertyObserver->Get( value );

        if( err == KErrNone )
            {
            self->SetQwertyMode( value );
            }
        // Load key bindings if not already loaded
#ifdef RD_INTELLIGENT_TEXT_INPUT
        if ( self->iQwertyMode )
            {
            self->iNumericKeys.Reset();
#else 
        if ( self->iQwertyMode && !self->iNumericKeys.Count() )
            {
#endif
        	self->LoadInputLanguageKeyBindings( self->iInputLanguage );
            }
        }
    return KErrNone;
    }

/**
 * Handles input language change.
 */
TInt CNumericKeyHandler::HandleInputLanguageChanged( TInt aNewValue )
	{    	
	SetInputLanguage( aNewValue );
	LoadInputLanguageKeyBindings( aNewValue );
    return KErrNone;
	}
    
/**
 * Set qwerty mode.
 */
void CNumericKeyHandler::SetQwertyMode( TInt aValue )
	{
	iQwertyMode = aValue;
	}
    
/**
 * Set input language.
 */
void CNumericKeyHandler::SetInputLanguage( TInt aValue )
    {
    iInputLanguage = aValue;
    }

void CNumericKeyHandler::HandleNotifyGeneric(TUint32 aKey)
	{
	if( aKey == KAknFepInputTxtLang )
		{
		TInt newValue = iInputLanguage;
		iInputLanguageRepository->Get( KAknFepInputTxtLang, newValue );
		HandleInputLanguageChanged( newValue );
		}
	}
    
void CNumericKeyHandler::HandleNotifyError
        (TUint32 /*aKey*/, TInt /*aError*/, CCenRepNotifyHandler* /*aHandler*/)
    {
    }

} // namespace AiWsPlugin
hs_app_panic.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Panic helper function for Active Idle WS Plug-in.
*
*/


#include "hs_app_panic.h"
#include 

namespace AiWsPlugin {


#ifndef NDEBUG

void Panic( TPanicCode aPanicCode )
    {
    _LIT( KPanicText, "AiWsPlugin" );
    User::Panic( KPanicText, aPanicCode );    
    }

#endif  // !NDEBUG

} // namespace AiWsPlugin
hs_app_sindlaunchhandler.cpp
/*
* Copyright (c) 2005-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  SIND app launch handler for Active Idle WS Plug-in.
*
*/


#include "hs_app_sindlaunchhandler.h"
#include "hs_app_keyhandlertimer.h"
#include "hs_app_uistate.h"
#include 
#include 
#include 
#include 

//#define AI_ENABLE_RD_LOGGING
#define AI_RD_LOG_TO_DEBUG_OUTPUT

#include "debug.h"

namespace AiWsPlugin {


CSINDLaunchHandler::CSINDLaunchHandler()
    {
    }
    
void CSINDLaunchHandler::ConstructL()
    {
    // Read capability: ReadDeviceData.
    _LIT_SECURITY_POLICY_C1( KReadDevicePolicy, ECapabilityReadDeviceData );
    // Write capability: WriteDeviceData.
    _LIT_SECURITY_POLICY_C1( KWriteDevicePolicy, ECapabilityWriteDeviceData );

    // Initialize Shortcut Plug-in command API
    RProperty::Define( 
    	KUidSystemCategory,
    	KPSUidShortcutCmd,  
      	RProperty::EText,
        KReadDevicePolicy,
        KWriteDevicePolicy 
        );
        
    iTimer = CKeyHandlerTimer::NewL( this );
    
    iSINDKeyDown = EFalse;
    }

CSINDLaunchHandler* CSINDLaunchHandler::NewLC()
    {
    CSINDLaunchHandler* self = new(ELeave) CSINDLaunchHandler;
    CleanupStack::PushL( self );
    self->ConstructL();
    return self;
    }
    
CSINDLaunchHandler::~CSINDLaunchHandler()
    {
    delete iTimer;
    }

void CSINDLaunchHandler::SetUiStateQuery( MUiState& aUiState )
    {
    iUiState = &aUiState;
    }
    
void CSINDLaunchHandler::FocusChanged( TBool /*aState*/ )
    {
    // Focus status is queried from iUiState
    }
    
TBool CSINDLaunchHandler::OfferRawEvent(const TRawEvent& aRawEvent)
    {
    switch( aRawEvent.Type() )
        {
        case TRawEvent::EKeyDown:
            {
            if ( iUiState->HasFocus() && aRawEvent.ScanCode() == EStdKeyDevice1 )
        		{		
				__PRINTS( "XAI: CSINDLaunchHandler: SIND key down, start timer");
				const TTimeIntervalMicroSeconds32 KLongKeyPress(600000);
				iTimer->Cancel();
				iTimer->After(KLongKeyPress);
                iSINDLaunched = EFalse;
                iSINDKeyDown = ETrue;                
        		}        		
            else if( iUiState->HasFocus() && iSINDKeyDown )
                {
                __PRINTS( "XAI: CSINDLaunchHandler: SIND key down, other key pressed, cancel timer");
                iTimer->Cancel();
                SkipVoiceDial();
                }
            break;
            }
        case TRawEvent::EKeyUp:
            {
            if ( iUiState->HasFocus() && aRawEvent.ScanCode() == EStdKeyDevice1 && !iSINDLaunched && iTimer->IsActive() )
                {                
                __PRINTS( "XAI: SIND key up, cancel timer");
                iTimer->Cancel();
                SkipVoiceDial();
                }
            break;
            }
        }
    return EFalse;
    }

void CSINDLaunchHandler::SkipVoiceDial()
    {
    __PRINTS( "XAI: CSINDLaunchHandler::SkipVoiceDial()");
    // Handle skip scenario only if voice dial ui hasn't been launched
    if( !iSINDLaunched )
        {
        RProperty::Set(
	    	KUidSystemCategory, 
		    KPSUidShortcutCmd,
		    KAiPSSkipNameDialer );  
        }
    iSINDKeyDown = EFalse; 
    }
    
void CSINDLaunchHandler::TimerDone()
    {
    __PRINTS( "XAI: CSINDLaunchHandler::TimerDone()");
    __PRINTS( "XAI: Start Voice Dial UI");
    RProperty::Set(
		KUidSystemCategory, 
		KPSUidShortcutCmd,
		KAiPSLaunchNameDialer );    		
    iSINDLaunched = ETrue;
    iSINDKeyDown = EFalse; 
    }    

} // namespace AiWsPlugin
hs_app_idlefw.iby
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Image description file for project ActiveIdle3
*
*/


#ifndef ACTIVEIDLE3_IBY
#define ACTIVEIDLE3_IBY

// Active Idle application and registration file
S60_APP_EXE( ailaunch )
S60_APP_EXE( homescreen )
S60_APP_AIF_RSC( homescreen )
S60_APP_AIF_ICONS( homescreen )

file=ABI_DIR\BUILD_DIR\hs_app_aiutils.dll    SHARED_LIB_DIR\hs_app_aiutils.dll
file=ABI_DIR\BUILD_DIR\hs_app_aiidleint.dll  SHARED_LIB_DIR\hs_app_aiidleint.dll
file=ABI_DIR\BUILD_DIR\hs_app_aifw.dll       SHARED_LIB_DIR\hs_app_aifw.dll

// Content publishing plug-ins
ECOM_PLUGIN( hs_app_aidevstaplg.dll, hs_app_aidevstaplg.rsc )

#endif // ACTIVEIDLE3_IBY
hs_app_idlefw_resources.iby
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Image description file for ActiveIdle3 localisable resources.
*
*/


#ifndef ACTIVEIDLE3_RESOURCES_IBY
#define ACTIVEIDLE3_RESOURCES_IBY

#ifdef RD_CUSTOMIZABLE_AI

#include 

data=DATAZ_\APP_RESOURCE_DIR\homescreen.rsc		APP_RESOURCE_DIR\homescreen.rsc

// Content publishing plug-in resources
data=DATAZ_\APP_RESOURCE_DIR\hs_app_aidevstaplgres.rsc  APP_RESOURCE_DIR\hs_app_aidevstaplgres.rsc

#endif // RD_CUSTOMIZABLE_AI

#endif // ACTIVEIDLE3_RESOURCES_IBY
hs_app_aifwpanic.cpp
/*
* Copyright (c) 2005-2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Panic utility for AI2
*
*/


#include "hs_app_aifwpanic.h"
#include 

#ifdef _DEBUG

void AiFwPanic::Panic(AiFwPanic::TAiPanicCodes aPanicCode)
    {
    _LIT(KPanicText, "AiFw");
    User::Panic( KPanicText, aPanicCode );
    
    
    }

#endif // _DEBUG

hs_app_aibackuprestorestatusobserver.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Backup/restore status observer for AI2
*
*/


#include 
#include 
#include "hs_app_aistatemanager.h"
#include "hs_app_aibackuprestorestatusobserver.h"
#include "hs_app_aifwpanic.h"
#include "debug.h"

const TUint KAI2BackupMask( conn::KBURPartTypeMask ^ conn::EBURNormal );

CAiBackupRestoreStatusObserver::CAiBackupRestoreStatusObserver()
    {
    }
    
CAiBackupRestoreStatusObserver::~CAiBackupRestoreStatusObserver()
    {
    }

CAiBackupRestoreStatusObserver* CAiBackupRestoreStatusObserver::NewL(
                                        MAiStateManager* aStateManager )
    {
    CAiBackupRestoreStatusObserver* self = new (ELeave) CAiBackupRestoreStatusObserver();
    CleanupStack::PushL(self);
    self->ConstructL( aStateManager );
    CleanupStack::Pop(self);
    return self;
    }

void CAiBackupRestoreStatusObserver::ConstructL( MAiStateManager* aStateManager )
    {
    BaseConstructL( TCallBack( HandleBackupOperationEvent, this ),
                    KUidSystemCategory,
                    conn::KUidBackupRestoreKey,
                    aStateManager );
    }
    
TAiStateChanges CAiBackupRestoreStatusObserver::Status()
    {
    TInt value = 0;
    TInt err = iObserver->Get( value );
    if( ( value & KAI2BackupMask ) &&
        ( err == KErrNone ) ) // any type of backup or restore operation
        {
        return ESMAIBackupOn;
        }
    else
        {
        return ESMAIBackupOff;
        } 
    }

TInt CAiBackupRestoreStatusObserver::HandleBackupOperationEvent( TAny* aPtr )
    {
    // see \epoc32\include\connect\sbdefs.h for enum descriptions
    CAiBackupRestoreStatusObserver* self =
                static_cast( aPtr );
    
    __ASSERT_DEBUG( self, 
                    AiFwPanic::Panic( AiFwPanic::EAiFwPanic_NullPointerReference ) );
    
    TInt value = 0;
    TInt err = self->iObserver->Get( value );

    if( ( value & KAI2BackupMask ) &&
        ( err == KErrNone ) ) // any type of backup or restore operation
        {
        __PRINTS("XAI: Backup = ON");
        self->iStateManager->ReportStateChange( ESMAIBackupOn );
        }
    else // aValue == conn::EBURUnset || aValue & conn::EBURNormal
        {
        // back operation finished -> return to previous state
        __PRINTS("XAI: Backup = OFF");
        self->iStateManager->ReportStateChange( ESMAIBackupOff );
        }
    return KErrNone;
    }

hs_app_aicallstatusobserver.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Call status observer for AI2
*
*/


#include 
#include 
#include "hs_app_aicallstatusobserver.h"
#include "hs_app_aistatemanager.h"
#include "hs_app_aifwpanic.h"
#include "debug.h"

CAiCallStatusObserver::CAiCallStatusObserver()
    {
    }
    
CAiCallStatusObserver::~CAiCallStatusObserver()
    {
    }

CAiCallStatusObserver* CAiCallStatusObserver::NewL( MAiStateManager* aStateManager )
    {
    CAiCallStatusObserver* self = new (ELeave) CAiCallStatusObserver();
    CleanupStack::PushL(self);
    self->ConstructL( aStateManager );
    CleanupStack::Pop(self);
    return self;
    }

void CAiCallStatusObserver::ConstructL( MAiStateManager* aStateManager )
    {
    BaseConstructL( TCallBack( HandleCallStateChange, this ),
                    KPSUidCtsyCallInformation,
                    KCTsyCallState,
                    aStateManager );
    }
    
TAiStateChanges CAiCallStatusObserver::Status()
    {
    TInt value = 0;
    TInt err = iObserver->Get( value );
    if( ( value > EPSCTsyCallStateNone ) &&
        ( err == KErrNone ) )
        {
        return ESMAIInCall;
        }
    else
        {
        return ESMAINoCall;
        } 
    }

TInt CAiCallStatusObserver::HandleCallStateChange( TAny* aPtr )
    {
    CAiCallStatusObserver* self = reinterpret_cast< CAiCallStatusObserver* >( aPtr );

    __ASSERT_DEBUG( self, 
                    AiFwPanic::Panic( AiFwPanic::EAiFwPanic_NullPointerReference ) );

    TInt value = 0;
    TInt err = self->iObserver->Get( value );
                 
    if( ( value > EPSCTsyCallStateNone ) &&
        ( err == KErrNone ) )
        {
        __PRINTS("XAI: Call = ON");
        self->iStateManager->ReportStateChange( ESMAIInCall );
        }
    else
        {
        __PRINTS("XAI: Call = OFF");
        self->iStateManager->ReportStateChange( ESMAINoCall );
        } 
    return KErrNone;
    }

hs_app_aicontentpluginmanager.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Content plugin error manager class
*
*/


#include 
#include 
#include 
#include 

#include 
#include 

#include "hs_app_aicontentpluginmanager.h"
#include "hs_app_aipluginstatemanager.h"
#include "aifweventhandler.h"
#include "aicontentpublisher.h"
#include "aipropertyextension.h"
#include 
#include "aieventhandlerextension.h"
#include "aiuicontroller.h"
#include "aiconsts.h"
#include "debug.h"

// CONSTANTS
const TInt KAILenOfParenthesis( 2 );

// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// CAiContentPluginManager::NewL()
// ----------------------------------------------------------------------------
//
CAiContentPluginManager* CAiContentPluginManager::NewL()
    {
    CAiContentPluginManager* self = new ( ELeave ) CAiContentPluginManager();         
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }
  
// ----------------------------------------------------------------------------
// CAiContentPluginManager::ConstructL()
// ----------------------------------------------------------------------------
//
void CAiContentPluginManager::ConstructL()
    {
    iPluginFactory = CAiPluginFactory::NewL( iPlugins, *this );

    iStateManager = CAiPluginStateManager::NewL();
    
    iPluginFactory->AddLifecycleObserverL( *iStateManager );
        
    iPluginTool = AiUtility::CreatePluginToolL();
    }

// ----------------------------------------------------------------------------
// CAiContentPluginManager::~CAiContentPluginManager()
// ----------------------------------------------------------------------------
//
CAiContentPluginManager::~CAiContentPluginManager()
    {               
    iPlugins.ResetAndDestroy();
    
    delete iPluginFactory;
    delete iStateManager;
    
    Release( iPluginTool );
    }

// ----------------------------------------------------------------------------
// CAiContentPluginManager::CAiContentPluginManager()
// ----------------------------------------------------------------------------
//
CAiContentPluginManager::CAiContentPluginManager() 
    {
    }

// ----------------------------------------------------------------------------
// CAiContentPluginManager::HandlePluginEvent()
// ----------------------------------------------------------------------------
//
void CAiContentPluginManager::HandlePluginEvent( const TDesC& aParam )    
    {
    const TInt separatorPos( aParam.Locate( KPluginEventSeparator ) );
    
    if( separatorPos == KErrNotFound )
        {
        return;
        }

    // Extract plugin name
    TPtrC pluginName( aParam.Left( separatorPos ) );
    
    // Extract event and parameter string
    TPtrC eventNameAndParams( aParam.Mid( separatorPos + 1 ) );

    // Find parameter string position
    const TInt paramsPos( 
            eventNameAndParams.Locate( KEventParameterSeparator  ) );
    
    // Extract event name
    TPtrC eventName( paramsPos < 0 ? eventNameAndParams : 
                                     eventNameAndParams.Left( paramsPos ) );
    
    // Calculate actual parameter string length by ignoring parenthesis 
    TInt paramsLength( 
            eventNameAndParams.Length() - paramsPos - KAILenOfParenthesis );
    
    // Extract paramenters
    TPtrC param( paramsPos < 0 ? KNullDesC()  :             
            eventNameAndParams.Mid( paramsPos + 1, Max( 0, paramsLength ) ) );
    
    // Resolve plugin
    CAiContentPublisher* target = NULL;
    
    __TIME( "FW: Lookup plug-in by name",
            
        TRAP_IGNORE( target = iPluginFactory->PluginByNameL( pluginName ) );  
    
    );

    __PRINT( __DBG_FORMAT( 
            "\t[I]\t Event: %S to plug-in by addr 0x%x" ), &aParam, target );
    
    if( target )
        {
        // Resolve plugin specific event id
        TInt eventId( KErrNotFound );
        
        TRAP_IGNORE( GetIdL( *target, EAiPublisherEvents, eventName, eventId ) );
        
        // Forward event to plugin
        MAiEventHandlerExtension* ext( 
                iPluginTool->EventHandlerExt( *target ) );
        
        if( ext )
            {
            if( eventId != KErrNotFound )
                {
                ext->HandleEvent( eventId, param );
                }
            else
                {
                ext->HandleEvent( eventName, param );
                }
            }
        }
    }

// ----------------------------------------------------------------------------
// CAiContentPluginManager::HandlePluginEventL()
// ----------------------------------------------------------------------------
//
void CAiContentPluginManager::HandlePluginEventL( 
    const TAiPublisherInfo& aPublisherInfo, const TDesC& aParam )
    {
    // Resolve plugin
    CAiContentPublisher* target( 
            iPluginFactory->PluginByInfoL( aPublisherInfo ) );
              
    if( target )    
        {
        const TInt separatorPos( aParam.Locate( KPluginEventSeparator ) );
        
        // Extract event and parameter string
        TPtrC eventNameAndParams( aParam.Mid( separatorPos + 1 ) );

        // Find parameter string position
        const TInt paramsPos( 
                eventNameAndParams.Locate( KEventParameterSeparator  ) );
        
        // Extract event name
        TPtrC eventName( paramsPos < 0 ? 
            eventNameAndParams : eventNameAndParams.Left( paramsPos ) );
        
        // Calculate actual parameter string length by ignoring parenthesis 
        TInt paramsLength( 
                eventNameAndParams.Length() - paramsPos - KAILenOfParenthesis );
        
        // Extract paramenters
        TPtrC param( paramsPos < 0 ? KNullDesC() :
            eventNameAndParams.Mid( paramsPos + 1, Max( 0, paramsLength ) ) );
        
        // Resolve plugin specific event id
        TInt eventId( KErrNotFound );
        
        GetIdL( *target, EAiPublisherEvents, eventName, eventId );
        
        // Forward event to plugin
        MAiEventHandlerExtension* ext( 
                iPluginTool->EventHandlerExt( *target ) );
        
        if( ext )
            {
            if( eventId != KErrNotFound )
                {
                ext->HandleEvent( eventId, param );
                }
            else
                {
                ext->HandleEvent( eventName, param );
                }
            }        
        }
    }

// ----------------------------------------------------------------------------
// CAiContentPluginManager::HasMenuItemL()
// ----------------------------------------------------------------------------
//
TBool CAiContentPluginManager::HasMenuItemL( 
    const TAiPublisherInfo& aPublisherInfo, const TDesC& aMenuItem )
    {          
    // Resolve plugin
    CAiContentPublisher* target( 
            iPluginFactory->PluginByInfoL( aPublisherInfo ) );
              
    if( target )    
        {
        // Forward query to plugin
        MAiEventHandlerExtension* ext( 
                iPluginTool->EventHandlerExt( *target ) );                 
        
        if ( ext )
            {
            return ext->HasMenuItem( aMenuItem );
            }
        }

    return EFalse;
    }

// ----------------------------------------------------------------------------
// CAiContentPluginManager::RefreshContentL()
// ----------------------------------------------------------------------------
//
TBool CAiContentPluginManager::RefreshContent( const TDesC& aContentCid )
    {
    TRAPD( error, RefreshContentL( aContentCid ) );
    
    return ( error == KErrNone );
    }

// ----------------------------------------------------------------------------
// CAiFw::ProcessOnlineState()
// ----------------------------------------------------------------------------
//
void CAiContentPluginManager::ProcessOnlineState( TBool aOnline )    
    {  
    _LIT( KOnlineOffline, "online_offline" );
    
    for( TInt i = 0; i < iPlugins.Count(); i++ )
        {               
        MAiEventHandlerExtension* ext( 
                iPluginTool->EventHandlerExt( *iPlugins[i] ) );
        
        // If plugin understands online/offline run state change
        if( ext && ext->HasMenuItem( KOnlineOffline ) )
            {            
            if( aOnline )
                {
                iStateManager->ProcessOnlineState( *iPlugins[i] );
                }
            else
                {
                iStateManager->ProcessOfflineState( *iPlugins[i] );                     
                }                                                           
            }
        }       
    }

// ----------------------------------------------------------------------------
// CAiContentPluginManager::StateManager()
// ----------------------------------------------------------------------------
//
CAiPluginStateManager& CAiContentPluginManager::StateManager() const
    {
    return *iStateManager;
    }

// ----------------------------------------------------------------------------
// CAiContentPluginManager::PluginFactory()
// ----------------------------------------------------------------------------
//
CAiPluginFactory& CAiContentPluginManager::PluginFactory() const
    {
    return *iPluginFactory;
    }

// ----------------------------------------------------------------------------
// CAiContentPluginManager::GetIdL()
// ----------------------------------------------------------------------------
//
void CAiContentPluginManager::GetIdL( CAiContentPublisher& aContentPublisher,         
    TAiPublisherProperty aProperty, const TDesC& aName, TInt& aId )                 
    {
    MAiContentItemIterator* iterator = 
        iPluginTool->ContentItemIteratorL( aContentPublisher, aProperty );

    if( iterator )
        {
        const TAiContentItem& ci( iterator->ItemL( aName ) );
        aId = ci.id;
        }
    else
        {
        aId = KErrNotFound;
        }
    }

// ----------------------------------------------------------------------------
// CAiContentPluginManager::RefreshContentL()
// ----------------------------------------------------------------------------
//
TInt CAiContentPluginManager::RefreshContentL( const TDesC& aContentCid )
    {
    TInt retval( KErrNotFound );
    
    // Look up plug-in and content item and delegate to plug-in's
    // MAiContentRequest implementation.

    // Find plugin name
    TInt pos( aContentCid.Locate( KPluginEventSeparator ) );

    if( pos == KErrNotFound )
        {
        return retval;        
        }
    
    TPtrC pluginName( aContentCid.Left( pos ) );
           
    CAiContentPublisher* plugin( iPluginFactory->PluginByNameL( pluginName ) );
    
    if( !plugin )
        {
        return retval;
        }
    
    MAiPropertyExtension* ext( iPluginTool->PropertyExt( *plugin ) );
    
    if( !ext )
        {
        return retval;
        }
        
    // Extract content id
    TPtrC cid( aContentCid.Mid( ++pos ) );
    TInt id( 0 );
    
    MAiContentRequest* handler( NULL );
    
    TRAPD( error, GetIdL( *plugin, EAiPublisherContent, cid, id ) );
    
    if ( !error )
        {
        handler = static_cast< MAiContentRequest* >( 
                    ext->GetPropertyL( EAiContentRequest ) );            
        }
    else
        {
        GetIdL( *plugin, EAiPublisherResources, cid, id );
        
        handler = static_cast< MAiContentRequest* >( 
                    ext->GetPropertyL( EAiResourceRequest ) );           
        }

    // Forward event to plugin
    if( handler && handler->RefreshContent( id ) )
        {               
        retval = KErrNone;        
        }
    
    return retval;
    }

// End of File.
hs_app_aienvironmentchangeobserver.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Environment change observer for AI2
*
*/


#include  // for CEnvironmentChangeNotifier
#include 
#include  // for KEikDynamicLayoutVariantSwitch
#include "hs_app_aienvironmentchangeobserver.h"
#include "hs_app_aistatemanager.h"
#include "hs_app_aifwpanic.h"
#include "debug.h"

CAiEnvironmentChangeObserver::CAiEnvironmentChangeObserver()
    {
    }
    
CAiEnvironmentChangeObserver::~CAiEnvironmentChangeObserver()
    {
    if( iEnvironmentChangeNotifier )
        {
        iEnvironmentChangeNotifier->Cancel();
        delete iEnvironmentChangeNotifier;
        }
    }

CAiEnvironmentChangeObserver* CAiEnvironmentChangeObserver::NewL( MAiStateManager* aStateManager )
    {
    CAiEnvironmentChangeObserver* self = new (ELeave) CAiEnvironmentChangeObserver();
    CleanupStack::PushL(self);
    self->ConstructL( aStateManager );
    CleanupStack::Pop(self);
    return self;
    }

void CAiEnvironmentChangeObserver::ConstructL( MAiStateManager* aStateManager )
    {
    iStateManager = aStateManager;
    iEnvironmentChangeNotifier = CEnvironmentChangeNotifier::NewL(
                                    EActivePriorityLogonA,
                                    TCallBack( EnvironmentChangeCallBack, this ) );
    iEnvironmentChangeNotifier->Start();
    }
    
TAiStateChanges CAiEnvironmentChangeObserver::Status()
    {
    // No statuses to report
    return ESMAIUnknownState;
    }

TInt CAiEnvironmentChangeObserver::EnvironmentChangeCallBack(TAny* aPtr)
    {
    CAiEnvironmentChangeObserver* self =
            static_cast( aPtr );
            
    __ASSERT_DEBUG( self, 
                    AiFwPanic::Panic( AiFwPanic::EAiFwPanic_NullPointerReference ) );
                    
    const TInt changes( self->iEnvironmentChangeNotifier->Change() );

    // report environment changes
    if( changes & EChangesMidnightCrossover )
        {
        __PRINTS("XAI: Event: Midnight crossover");
        self->iStateManager->ReportStateChange( ESMAIMidnightCrossover );
        }
    if( changes & EChangesSystemTime )
        {
        __PRINTS("XAI: Event: Time changed");
        self->iStateManager->ReportStateChange( ESMAITimeChanged );
        }
    if( changes & EChangesLocale )
        {
        __PRINTS("XAI: Event: Locale setting changed");
        self->iStateManager->ReportStateChange( ESMAILocaleChanged );
        }

    return EFalse;
    }

hs_app_aifocusobserver.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Focus observer for Active idle 2
*
*/


#include 
#include 
#include "hs_app_aistatemanager.h"
#include "hs_app_aifocusobserver.h"
#include "hs_app_aifwpanic.h"
#include "debug.h"

CAiFocusObserver::CAiFocusObserver()
    {
    }
    
CAiFocusObserver::~CAiFocusObserver()
    {
    }

CAiFocusObserver* CAiFocusObserver::NewL(
                                        MAiStateManager* aStateManager )
    {
    CAiFocusObserver* self = new (ELeave) CAiFocusObserver();
    CleanupStack::PushL(self);
    self->ConstructL( aStateManager );
    CleanupStack::Pop(self);
    return self;
    }

void CAiFocusObserver::ConstructL( MAiStateManager* aStateManager )
    {
 //++HV
    BaseConstructL( TCallBack( StaticHandleFocusChangeEvent, this ),
                    KPSUidAiInformation, 
                    KActiveIdleState, 
                    aStateManager );
//--HV
    }
    
TAiStateChanges CAiFocusObserver::Status()
    {
    TInt value = 0;
    TInt err = iObserver->Get( value );
    if( ( value == EPSAiForeground ) &&
        ( err == KErrNone ) )
        {
        return ESMAIIdleForeground;
        }
    else
        {
        return ESMAIIdleBackground;
        } 
    }

 //++HV
                
 TInt CAiFocusObserver::StaticHandleFocusChangeEvent( TAny* aPtr )
    {
    CAiFocusObserver* self =
                static_cast( aPtr );
    
    __ASSERT_DEBUG( self, 
                    AiFwPanic::Panic( AiFwPanic::EAiFwPanic_NullPointerReference ) );
                    
    return( self->HandleFocusChangeEvent() );                
    }
    
    
TInt CAiFocusObserver::HandleFocusChangeEvent()
    {
    if( iTfxEffectActive )
		{
       	return KErrNone;
        }  
    
    TInt value = 0;
    TInt err = iObserver->Get( value );
    
    // Check the PS keys value and call manager with approriate parameter.
    // Repowrt either "idle foreground" or "idle background"
    if( ( value == EPSAiForeground ) &&
        ( err == KErrNone ) )
        {
       	// Check if the transition effect is active
       	
       	// This has to be called first, otherwise the state might not be valid.
		CAknTransitionUtils::AddObserver( this, CAknTransitionUtils::EEventWsBufferRedirection );

 		TInt redirState = 0;
 		CAknTransitionUtils::GetState( CAknTransitionUtils::EEventWsBufferRedirection, &redirState );
 		if ( (TBool)redirState )
 			{
 			// The effect is on-going. Prevent view refresh until the effect is finished.
			iTfxEffectActive = ETrue; 
 			} 
 		else
 			{			
    		// No effect on-going. Observer is not needed.    
			CAknTransitionUtils::RemoveObserver( this, CAknTransitionUtils::EEventWsBufferRedirection );
        	iStateManager->ReportStateChange( ESMAIIdleForeground );
 			}
        }
    else if( value == EPSAiBackground )
        {
    	// Do not receive callbacks in background. Remove observer if it still exists.
    	CAknTransitionUtils::RemoveObserver( this, CAknTransitionUtils::EEventWsBufferRedirection );
    	iTfxEffectActive = EFalse;
    		
        iStateManager->ReportStateChange( ESMAIIdleBackground );
        } 

    return KErrNone;
    }


TInt CAiFocusObserver::AknTransitionCallback( TInt aEvent, TInt aState, const TDesC8* /*aParams*/ )
	{
	if ( ( aEvent & CAknTransitionUtils::EEventWsBufferRedirection ) && ( !(TBool)aState ) )
		{
		// The effect has been finished
		iTfxEffectActive = EFalse;
   		// Observer is not needed any more.    
    	CAknTransitionUtils::RemoveObserver( this, CAknTransitionUtils::EEventWsBufferRedirection );
    	
    	// Issue one focus change event
    	TInt value = 0;
    	TInt err = iObserver->Get( value );
    	if( ( value == EPSAiForeground ) &&
        	( err == KErrNone ) )
        	{
    	 	iStateManager->ReportStateChange( ESMAIIdleForeground );
        	}
    	else if( value == EPSAiBackground )
        	{
        	iStateManager->ReportStateChange( ESMAIIdleBackground );
        	} 
		}
	
	return 0;	
	}
	

//--HV
hs_app_aifw.cpp
/*
* Copyright (c) 2005-2008 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Main AI framework class
*
*/


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

#include 
#include 
#include 


#include 
#include 

#include "hs_app_aifw.h"
#include "hs_app_aifwpanic.h"
#include "aiutility.h"
#include "hs_app_aiuicontrollermanager.h"
#include "aiuicontroller.h"
#include "aicontentmodel.h"
#include "hs_app_aicontentpluginmanager.h"
#include "hs_app_aiwspluginmanager.h"
#include "hs_app_aipluginstatemanager.h"
#include "hs_app_aiidleappregister.h"
#include "debug.h"

#include 
#include 
#include "hs_app_ainetworklistener.h"


#include 

// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// CAiFw::NewL()
// ----------------------------------------------------------------------------
//
CAiFw::CAiFw()
    {
    }

// ----------------------------------------------------------------------------
// CAiFw::ConstructL()
// ----------------------------------------------------------------------------
//
void CAiFw::ConstructL()
    {
#if 0
    // For AI3_test    
    RProcess proc;
    // 0x102750F0 in AI3, 0x2001CB4F in AI3_Test
    TSecureId secId( proc.SecureId() ); 
                                           
    if( secId == 0x2001CB4F )
        {
        iAIRepository = CRepository::NewL( TUid::Uid( 0x2001952B ) );
        }   
    else
        {
        iAIRepository = CRepository::NewL( TUid::Uid( KCRUidActiveIdleLV ) );
        }
#else
    iAIRepository = CRepository::NewL( TUid::Uid( KCRUidActiveIdleLV ) );
#endif
        
    TInt value( 0 );
    
    iAIRepository->Get( KAiMainUIController, value );
    
    if( !( value == AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_XML ||
           value == AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE ||
           value == AI3_UID_ECOM_IMPLEMENTATION_UICONTROLLER_XML ||
           value == AI3_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE ) )
        {
        // Someone wrote an invalid configuration! Reset repository.
        iAIRepository->Reset( KAiMainUIController );
        iAIRepository->Reset( KAiFirstUIController );
        iAIRepository->Delete( KAiFirstUIController + 1 );
        }
    
    iUiControllerManager = CAiUiControllerManager::NewL();
           
    iPluginManager = CAiContentPluginManager::NewL();
                                                                   
    // Hook framework as UI event observer
    iUiControllerManager->SetEventHandler( *this );    
    }

// ----------------------------------------------------------------------------
// CAiFw::NewLC()
// ----------------------------------------------------------------------------
//
EXPORT_C CAiFw* CAiFw::NewLC()
    {
    CAiFw* self = new ( ELeave ) CAiFw;
    CleanupStack::PushL( self );
    self->ConstructL();

    __TICK( "FW: Core FW constructed" );
    __HEAP( "FW: Core FW constructed" );
    
    return self;
    }

// ----------------------------------------------------------------------------
// CAiFw::~CAiFw()
// ----------------------------------------------------------------------------
//
CAiFw::~CAiFw()
    {
    if( iPluginManager )
        {
        delete iPluginManager;
        iPluginManager = NULL;
        }
        
    if( iIdleRestartObserver )
        {
        Release( iIdleRestartObserver );
        iIdleRestartObserver = NULL;
        }
    
    if( iWsPluginManager )
        {
        delete iWsPluginManager;
        iWsPluginManager = NULL;
        }
        
    if( iUiControllerManager )
        {
        delete iUiControllerManager;
        iUiControllerManager = NULL;
        }
    
    if( iNotifyHandler )
        {
        iNotifyHandler->StopListening();
        delete iNotifyHandler;
        iNotifyHandler = NULL;
        }
    
    if( iNotifyHandlerESS )
        {
        iNotifyHandlerESS->StopListening();
        delete iNotifyHandlerESS;
        iNotifyHandlerESS = NULL;
        }
    
    if( iAIRepository )
        {
        delete iAIRepository;
        iAIRepository = NULL;
        }
    
    iLibrary1.Close();
    iLibrary2.Close();
    iLibrary3.Close();
    }

// ----------------------------------------------------------------------------
// CAiFw::RunL()
// ----------------------------------------------------------------------------
//
EXPORT_C void CAiFw::RunL()
    {
    CAiIdleAppRegister* idleReg = CAiIdleAppRegister::NewLC();
    idleReg->RegisterL();
    CleanupStack::PopAndDestroy( idleReg );

    // Tell UI controller manager to start application framework and event loop.
    // This function returns only when the application is shut down.
    // See in CAiFw::HandleUiReadyEventL how the framework initialization continues.
    iUiControllerManager->RunApplicationL();
    }

// ----------------------------------------------------------------------------
// CAiFw::AppEnvReadyL()
// ----------------------------------------------------------------------------
//
void CAiFw::AppEnvReadyL()
    {
    // Initialize members which need to be connected to the app environment's
    // active scheduler or depend on the app environment being initialized.

    // Create state managers system state observers
    CAiPluginStateManager& stateManager( iPluginManager->StateManager() );
    
    stateManager.CreateSystemStateObserversL();

    // Connect state managers UI observer to UI controllers
    MAiUiFrameworkObserver* fwObserver( stateManager.UiFwObserver() );
    
    if ( fwObserver )
        {
        iUiControllerManager->AddObserverL( *fwObserver );
        }

    // Create WS pluign manager
    iWsPluginManager = CAiWsPluginManager::NewL
        ( iUiControllerManager->CoeEnv() );

    // CenRep notifier to listen key changes in cenrep. Application is restarted
    // if key value is changed.
    iNotifyHandler = CCenRepNotifyHandler::NewL( *this,
                                                 *iAIRepository,
                                                 CCenRepNotifyHandler::EIntKey,
                                                 KAiMainUIController );
    iNotifyHandler->StartListeningL();

    // Cenrep notifier to listen ESS changes in cenrep
    //
    iNotifyHandlerESS = CCenRepNotifyHandler::NewL( *this,
                                                    *iAIRepository,
                                                     CCenRepNotifyHandler::EIntKey,
                                                     KAIExternalStatusScreen );
    iNotifyHandlerESS->StartListeningL();

    iIdleRestartObserver = AiUtility::CreatePSPropertyObserverL(
                        TCallBack( HandleRestartEvent, this ),
                        KPSUidAiInformation,
                        KActiveIdleRestartAI2 );
    
    stateManager.ReportStateChange( ESMAISystemBoot );
    }

// ----------------------------------------------------------------------------
// CAiFw::HandleUiReadyEventL()
// ----------------------------------------------------------------------------
//
void CAiFw::HandleUiReadyEventL( CAiUiController& aUiController )
    {         
    if( iUiControllerManager->IsMainUiController( aUiController ) )
        {
        iUiControllerManager->LoadUIDefinition();
                
        TInt value( EIdlePhase1Ok );
        
        RProperty::Get( KPSUidStartup, 
                        KPSIdlePhase1Ok, 
                        value );
                                                      
        if( value == EIdlePhase1NOK )
            {
            RProperty::Set( KPSUidStartup, 
                            KPSIdlePhase1Ok, 
                            EIdlePhase1Ok );                                                          
            }    
        
        if( !iLibrariesLoaded )
            {
            _LIT( KAIVoiceUIDialer, "VoiceUiNameDialer.dll" );
            _LIT( KAIVoiceUIRecog, "VoiceUiRecognition.dll" );
            _LIT( KAIVCommandHandler, "vcommandhandler.dll" );
            
            iLibrary1.Load( KAIVoiceUIDialer );
            iLibrary2.Load( KAIVoiceUIRecog );
            iLibrary3.Load( KAIVCommandHandler );        
            
            iLibrariesLoaded = ETrue;
            }
        
        }
    }

// ---------------------------------------------------------------------------
// CAiFw::HandleActivateUI()
// ----------------------------------------------------------------------------
//
void CAiFw::HandleActivateUI()
    {
    iUiControllerManager->ActivateUI();         
    }

// ---------------------------------------------------------------------------
// CAiFw::HandleUiShutdown()
// ----------------------------------------------------------------------------
//
void CAiFw::HandleUiShutdown( CAiUiController& aUiController )
    {
    if( iUiControllerManager->IsMainUiController( aUiController ) )
        {
        if( iNotifyHandler )
            {
            iNotifyHandler->StopListening();
            delete iNotifyHandler;
            iNotifyHandler = NULL;
            }

        if( iNotifyHandlerESS )
            {
            iNotifyHandlerESS->StopListening();
            delete iNotifyHandlerESS;
            iNotifyHandlerESS = NULL;
            }
        
        iPluginManager->PluginFactory().DestroyPlugins();

        iPluginManager->StateManager().DestroySystemStateObservers();
                
        iUiControllerManager->DestroySecondaryUiControllers();

        iUiControllerManager->RemoveObserver( 
                *iPluginManager->StateManager().UiFwObserver() );
        
        if( iWsPluginManager )
            {
            delete iWsPluginManager;
            iWsPluginManager = NULL;
            }
        
        if( iIdleRestartObserver )
            {
            Release( iIdleRestartObserver );
            iIdleRestartObserver = NULL;
            } 
        }
    }

// ----------------------------------------------------------------------------
// CAiFw::HandleLoadPluginL()
// ----------------------------------------------------------------------------
//
void CAiFw::HandleLoadPluginL( const TAiPublisherInfo& aPublisherInfo )
    {           
    iPluginManager->PluginFactory().CreatePluginL( 
       aPublisherInfo, iUiControllerManager->UiControllers() );                                                                                                                                                 
    }

// ----------------------------------------------------------------------------
// CAiFw::HandleDestroyPluginL()
// ----------------------------------------------------------------------------
//
void CAiFw::HandleDestroyPluginL( const TAiPublisherInfo& aPublisherInfo )
    {    
    iPluginManager->PluginFactory().DestroyPluginL(
        aPublisherInfo, iUiControllerManager->UiControllers() );                                                                            
    }

// ----------------------------------------------------------------------------
// CAiFw::HandlePluginEvent()
// ----------------------------------------------------------------------------
//
void CAiFw::HandlePluginEvent( const TDesC& aParam )
    {
    iPluginManager->HandlePluginEvent( aParam );
    }

// ----------------------------------------------------------------------------
// CAiFw::HandlePluginEventL()
// ----------------------------------------------------------------------------
//
void CAiFw::HandlePluginEventL( const TAiPublisherInfo& aPublisherInfo, 
    const TDesC& aParam )
    {
    iPluginManager->HandlePluginEventL( aPublisherInfo, aParam );
    }

// ----------------------------------------------------------------------------
// CAiFw::HasMenuItemL()
// ----------------------------------------------------------------------------
//
TBool CAiFw::HasMenuItemL( const TAiPublisherInfo& aPublisherInfo, 
    const TDesC& aMenuItem )
    {            
    return iPluginManager->HasMenuItemL( aPublisherInfo, aMenuItem ); 
    }

// ----------------------------------------------------------------------------
// CAiFw::RefreshContent()
// ----------------------------------------------------------------------------
//
TBool CAiFw::RefreshContent( const TDesC& aContentCid )
    {
    return iPluginManager->RefreshContent( aContentCid );
    }

// ----------------------------------------------------------------------------
// CAiFw::ProcessStateChange()
// ----------------------------------------------------------------------------
//
void CAiFw::ProcessStateChange( TAifwStates aState )     
    {
    switch ( aState )
    	{
    	case EAifwOnline :
    		{
    		iPluginManager->ProcessOnlineState( ETrue );
    		}
    		break;
    	case EAifwOffline :
			{
			iPluginManager->ProcessOnlineState( EFalse );
			}
			break;
    	case EAifwPageSwitch:
    		{
    		iPluginManager->StateManager().ReportStateChange( ESMAIPageSwitch );
    		}
    		break;
    	default : 
    		break;
    	}
    
    }

// ----------------------------------------------------------------------------
// CAiFw::QueryIsMenuOpen()
// ----------------------------------------------------------------------------
//
TBool CAiFw::QueryIsMenuOpen()
    {
    return iUiControllerManager->MainUiController().IsMenuOpen();
    }

// ----------------------------------------------------------------------------
// CAiFw::HandleNotifyInt()
// ----------------------------------------------------------------------------
//
void CAiFw::HandleNotifyInt( TUint32 aId, TInt aNewValue )
    {
    switch( aId )
        {
        case KAiMainUIController:
            if( aNewValue == AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_XML ||
                aNewValue == AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE ||
                aNewValue == AI3_UID_ECOM_IMPLEMENTATION_UICONTROLLER_XML ||
                aNewValue == AI3_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE )
                {
                iUiControllerManager->ExitMainController();
                }
            else
                {
                // Someone wrote an invalid configuration! Reset repository.
                if( iAIRepository )
                    {
                    iAIRepository->Reset( KAiMainUIController );
                    iAIRepository->Reset( KAiFirstUIController );
                    iAIRepository->Delete( KAiFirstUIController + 1 );
                    }
                }
            break;
        case KAIExternalStatusScreen:
            if( ( aNewValue & 0x7FFFFFFF ) != 0 )
                {
                TRAP_IGNORE( SwapUiControllerL( EFalse ) );
                }
            else
                {
                TRAP_IGNORE( SwapUiControllerL( ETrue ) );
                }
            break;
        default:
            break;
        }
    }

// ----------------------------------------------------------------------------
// CAiFw::SwapUiControllerL()
// ----------------------------------------------------------------------------
//
void CAiFw::SwapUiControllerL( TBool aToExtHS )
    {
    TUid uid = { KCRUidActiveIdleLV };
    CRepository* cenRep = CRepository::NewL( uid );

    if( !aToExtHS ) // Switch to XML UI
        {
        cenRep->Create( KAiFirstUIController, 
                AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE );
        
        cenRep->Set( KAiFirstUIController, 
                AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE );
        cenRep->Delete( KAiFirstUIController + 1 );
        
        cenRep->Set( KAiMainUIController, 
                AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_XML );
        }
    else // Switch to ExtHS
        {
        cenRep->Delete( KAiFirstUIController );
        cenRep->Delete( KAiFirstUIController + 1 );
        cenRep->Set( KAiMainUIController, 
                AI_UID_ECOM_IMPLEMENTATION_UICONTROLLER_NATIVE );
        }
    
    delete cenRep;

    // Restart
    iUiControllerManager->ExitMainController();
    }

// ----------------------------------------------------------------------------
// CAiFw::HandleRestartEvent()
// ----------------------------------------------------------------------------
//
TInt CAiFw::HandleRestartEvent( TAny* aSelf )
    {
    CAiFw* self = static_cast( aSelf );
    
    TInt value( 0 );
    
    if( self->iIdleRestartObserver )
        {
        TInt err( self->iIdleRestartObserver->Get( value ) );

        // Check the PS keys value and call manager with approriate parameter.
        // Report either "idle foreground" or "idle background"
        if( value == KActiveIdleRestartCode )
            {
            self->iUiControllerManager->ExitMainController();
            }
        }
    
    return KErrNone;
    }

// End of file
hs_app_aifwstartupscheduler.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  AvtiveIdle2 startup scheduler
*
*/


#include "hs_app_aifwstartupscheduler.h"

CAiFwStartupScheduler::CAiFwStartupScheduler()
    : iResult(KErrNone)
    {
    }

CAiFwStartupScheduler* CAiFwStartupScheduler::NewLC()
    {
    CAiFwStartupScheduler* self = new(ELeave) CAiFwStartupScheduler;
    CleanupStack::PushL(self);
    return self;
    }

CAiFwStartupScheduler::~CAiFwStartupScheduler()
    {
    }

TInt CAiFwStartupScheduler::Result()
    {
    return iResult;
    }

// All RunL leaves from active objects which execute during Active Idle
// Framework startup end up here
void CAiFwStartupScheduler::Error(TInt aError) const
    {
    // Store any error code
    if (aError != KErrNone && iResult == KErrNone)
        {
        iResult = aError;
        }
        
    // Stop the scheduler as all errors during Active Idle Framework startup
    // are fatal
    Stop();
    }

hs_app_aikeylockobserver.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Focus observer for Active idle 2
*
*/


#include 
#include 
#include       // KPSUidAvkonDomain, KAknKeyguardStatus, TAknKeyguardStatus
#include "hs_app_aistatemanager.h"
#include "hs_app_aikeylockobserver.h"
#include "hs_app_aifwpanic.h"
#include "debug.h"

CAiKeylockObserver::CAiKeylockObserver()
    {
    }
    
CAiKeylockObserver::~CAiKeylockObserver()
    {
    }

CAiKeylockObserver* CAiKeylockObserver::NewL(
                                        MAiStateManager* aStateManager )
    {
    CAiKeylockObserver* self = new (ELeave) CAiKeylockObserver();
    CleanupStack::PushL(self);
    self->ConstructL( aStateManager );
    CleanupStack::Pop(self);
    return self;
    }

void CAiKeylockObserver::ConstructL( MAiStateManager* aStateManager )
    {
    BaseConstructL( TCallBack( HandleKeylockStatusEvent, this ),
                    KPSUidAvkonDomain, 
                    KAknKeyguardStatus, 
                    aStateManager );
    }
    
TAiStateChanges CAiKeylockObserver::Status()
    {
	TInt value;
	TInt err = iObserver->Get( value );
	if( err != KErrNone ) 
	    {
	    return ESMAIKeylockDisabled;
	    }
	    
	switch( value ) 
	    {
	    case EKeyguardLocked:
	    case EKeyguardAutolockEmulation: // fallthorugh
	        {
	        return ESMAIKeylockEnabled;
	        }
	    case EKeyguardNotActive:
	    default: // fallthorugh
	        {
	        return ESMAIKeylockDisabled;
	        }
	    }
    }

TInt CAiKeylockObserver::HandleKeylockStatusEvent( TAny* aPtr )
    {
    CAiKeylockObserver* self =
                static_cast( aPtr );
    
    __ASSERT_DEBUG( self, 
                    AiFwPanic::Panic( AiFwPanic::EAiFwPanic_NullPointerReference ) );
    
    TAiStateChanges stateChange = self->Status();
    self->iStateManager->ReportStateChange( stateChange );
    return KErrNone;
    }

hs_app_ailightstatusobserver.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Light status observer for AI2
*
*/


#include 
#include "hs_app_ailightstatusobserver.h"
#include "hs_app_aistatemanager.h"
#include "debug.h"

CAiLightStatusObserver::CAiLightStatusObserver()
    {
    }
    
CAiLightStatusObserver::~CAiLightStatusObserver()
    {
    delete iLight;
    }

CAiLightStatusObserver* CAiLightStatusObserver::NewL( MAiStateManager* aStateManager )
    {
    CAiLightStatusObserver* self = new (ELeave) CAiLightStatusObserver();
    CleanupStack::PushL(self);
    self->ConstructL( aStateManager );
    CleanupStack::Pop(self);
    return self;
    }

void CAiLightStatusObserver::ConstructL( MAiStateManager* aStateManager )
    {
    iStateManager = aStateManager;
    iLight = CHWRMLight::NewL( this );
    }
    
TAiStateChanges CAiLightStatusObserver::Status()
    {
    // In future handle other screen lights here also..
    CHWRMLight::TLightStatus status = iLight->LightStatus( CHWRMLight::EPrimaryDisplay );
    if( status == CHWRMLight::ELightOn )
        {
        return ESMAIBacklightOn;
        }
    else if( status == CHWRMLight::ELightOff )
        {
        return ESMAIBacklightOff;
        }
    return ESMAIBacklightOn;
    }

void CAiLightStatusObserver::LightStatusChanged( TInt aTarget, CHWRMLight::TLightStatus aStatus )
    {
    if( aTarget == CHWRMLight::EPrimaryDisplay ||
        aTarget == CHWRMLight::EPrimaryDisplayAndKeyboard )
        {
        if( aStatus == CHWRMLight::ELightOn )
            {
            __PRINTS("XAI: Light = ON");
            iStateManager->ReportStateChange( ESMAIBacklightOn );
            }
        else if( aStatus == CHWRMLight::ELightOff )
            {
            __PRINTS("XAI: Light = OFF");
            iStateManager->ReportStateChange( ESMAIBacklightOff );
            }
        }
    }

hs_app_ainetworklistener.cpp
/*
* Copyright (c) 2009 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network info listener
*
*/

#include 
#include 
#include "hs_app_ainetworklistener.h"
#include "hs_app_ainetworkobserver.h"

/// ======== MEMBER FUNCTIONS ========

// -----------------------------------------------------------------------------
// Two-phased constructor. Can leave.
// -----------------------------------------------------------------------------
// 
CAiNetworkListener* CAiNetworkListener::NewL(MAiNetworkObserver& aNetworkObserver)
    {
    CAiNetworkListener* self = new (ELeave) CAiNetworkListener(aNetworkObserver);
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop();
    return self;
    }

CAiNetworkListener::CAiNetworkListener(MAiNetworkObserver& aNetworkObserver)
:iObserver(aNetworkObserver)
    {
    }

void CAiNetworkListener::ConstructL()
    {
    //Create network handling engine session.
    iSession = CreateL( *this, iInfo );
    iCurrentNwState = MAiNetworkObserver::ENone;
    }

CAiNetworkListener::~CAiNetworkListener()
    {
    delete iSession;
    }

void CAiNetworkListener::HandleNetworkMessage( const TNWMessages aMessage )
    {
    TBool hasNetInfoChanged = HasNetworkInfoChanged( aMessage );
    if ( !hasNetInfoChanged )
        {
        return;
        }
        
    // Interpret new nw state
    MAiNetworkObserver::TNetworkState newState;
    newState= InterpretNWMessage(aMessage,iInfo);

    // Inform observer of only new nw states (TNetworkState)
    if (newState != iCurrentNwState)
        {
        iObserver.HandleNetworkStateChange(newState);
        }    
    
    // Store new nw state
    iCurrentNwState= newState;
  
    }

MAiNetworkObserver::TNetworkState CAiNetworkListener::InterpretNWMessage(const TNWMessages aMessage, const TNWInfo aNWInfo)
    {
    MAiNetworkObserver::TNetworkState nwstate = MAiNetworkObserver::ENone;
    
    switch (aMessage)
        {
        case MNWMessageObserver::ENWMessageNetworkRegistrationStatusChange:
        case MNWMessageObserver::ENWMessageCurrentHomeZoneMessage:
            {
            switch (aNWInfo.iRegistrationStatus)
                {
                case ENWRegisteredRoaming:
                    nwstate = MAiNetworkObserver::ERoaming;
                    break;
                case ENWRegisteredOnHomeNetwork:
                    nwstate = MAiNetworkObserver::EHomeNetwork;
                    break;  
                    
                default:
                    // unknown state
                    break;
                }
            }
       }
    
    return nwstate;
    }

void CAiNetworkListener::HandleNetworkError( const TNWOperation aOperation, TInt /*aErrorCode*/ )
    {
     switch ( aOperation )
        {
        case MNWMessageObserver::ENWGetNetworkProviderName:
            iReceivedMessageFlags |= ENetworkProviderNameReceived;
            iReceivedMessageFlags &= ~ENetworkProviderNameOk;
            iInfo.iNPName.Zero();
            break;
        case MNWMessageObserver::ENWGetProgrammableOperatorName:
            iReceivedMessageFlags |= EProgrammableOperatorInfoReceived;
            iReceivedMessageFlags &= ~EProgrammableOperatorInfoReceivedOk;
            iInfo.iOperatorNameInfo.iName.Zero();
            break;
        case MNWMessageObserver::ENWGetServiceProviderName:
            iReceivedMessageFlags |= EServiceProviderNameReceived;
            iReceivedMessageFlags &= ~EServiceProviderNameOk;
            iInfo.iServiceProviderNameDisplayReq = RMobilePhone::KDisplaySPNNotRequired;
            iInfo.iSPName.Zero();
            iInfo.iPLMNField.Zero();
            break;
        default:
            break;
        }
    
    HandleNetworkMessage( TNWMessages( KErrGeneral ) );
    }

TBool CAiNetworkListener::HasNetworkInfoChanged( const TNWMessages aMessage )
    {
    TBool result = ETrue;
    
    // pass through
    if ( aMessage == MNWMessageObserver::ENWMessageCurrentHomeZoneMessage   ||
         aMessage == MNWMessageObserver::ENWMessageNetworkConnectionFailure ||
         aMessage == MNWMessageObserver::ENWMessageCurrentCellInfoMessage   ||
         aMessage == MNWMessageObserver::ENWMessageNetworkRegistrationStatusChange )
        {
        return result;
        }
    
    result = ( iReceivedMessageFlags != iOldReceivedMessageFlags );
    
    if ( !result )
        {
         result = 
            iInfo.iRegistrationStatus != iOldInfo.iRegistrationStatus;
        }

    iOldReceivedMessageFlags = iReceivedMessageFlags;
    iOldInfo = iInfo;

    return result;
    }

MAiNetworkObserver::TNetworkState CAiNetworkListener::NetworkState()
    {
    return iCurrentNwState;
    }
    
hs_app_ainwsdlgcontroller.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Network selection dialog controller
*
*/


#include 
#include 
#include 
#include 

#include 
#include 

#include "hs_app_ainwsdlgcontroller.h"
#include "debug.h"


// 1-minute timeout before showing soft notification
const TInt KPhoneNetworkLostTimeout = 60*1000000;

// Offline profile, from ProfileEngineSDKCRKeys.h
const TInt KOfflineProfileId = 5;


CAiNwSDlgController* CAiNwSDlgController::NewL()
    {
    CAiNwSDlgController* self = new(ELeave) CAiNwSDlgController();
    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop();    // self
    return self;
    }

CAiNwSDlgController::CAiNwSDlgController()
    {
    iRegistered = ETrue;
    }

void CAiNwSDlgController::ConstructL()
    {
    __PRINTS( "XAI: CAiNwSDlgController is initializing" );

    iSoftNotifier = CAknSoftNotifier::NewL();
    iSession = CreateL( *this, iInfo );
    iProfileApi = CRepository::NewL( KCRUidProfileEngine );
    iPeriodic = CPeriodic::NewL( CActive::EPriorityStandard );

    HandleStateChange();

    __PRINTS( "XAI: CAiNwSDlgController initialized succesfully" );
    }

CAiNwSDlgController::~CAiNwSDlgController()
    {
    delete iPeriodic;
    delete iProfileApi;
    delete iSession;
    delete iSoftNotifier;
    }

void CAiNwSDlgController::HandleStateChange()
    {
    switch( iInfo.iRegistrationStatus )
        {
        case ENWNotRegisteredNoService:
            // Fall-through
        case ENWNotRegisteredEmergencyOnly:
            // Fall-through
        case ENWNotRegisteredSearching:
            // Fall-through
        case ENWRegistrationDenied:
            HandleNetworkLost();
            break;

        case ENWRegisteredBusy:
            // Fall-through
        case ENWRegisteredOnHomeNetwork:
            // Fall-through
        case ENWRegisteredRoaming:
            HandleNetworkFound();
            break;

        case ENWRegistrationUnknown:
            // Take no action
        default:
            break;
        }
    }

void CAiNwSDlgController::HandleNetworkFound()
    {
    __PRINTS( "XAI: Network found" );
    iRegistered = ETrue;
    iPeriodic->Cancel();
    CancelDialog();
    }

void CAiNwSDlgController::HandleNetworkLost()
    {
    if( iInfo.iSelectionSetting == ENWNetworkSelectionManual )
        {
        // See if we were registered before
        if( iRegistered )
            {
            iRegistered = EFalse;

            if(!IsOffLineMode() && !IsBluetoothSAPConnected())
                {
                __PRINTS( "XAI: Network lost, show dialog in 1 minute" );
                iPeriodic->Start( KPhoneNetworkLostTimeout,
                    KPhoneNetworkLostTimeout, TCallBack( DelayCallBack, this ));
                }
            }
        }
    }

void CAiNwSDlgController::LaunchDialog()
    {
    iPeriodic->Cancel();
    TRAP_IGNORE( iSoftNotifier->AddNotificationL( ESelectNetworkNotification, 1 ); );
    }

void CAiNwSDlgController::CancelDialog()
    {
    TRAP_IGNORE( iSoftNotifier->CancelSoftNotificationL( ESelectNetworkNotification ); );
    }

TInt CAiNwSDlgController::DelayCallBack(TAny* aParam)
    {
    CAiNwSDlgController* self = (CAiNwSDlgController*) aParam;
    self->LaunchDialog();
    return KErrNone;
    }

void CAiNwSDlgController::HandleNetworkMessage( const TNWMessages aMessage )
    {
    switch(aMessage)
        {
        case ENWMessageNetworkRegistrationStatusChange:
            HandleStateChange();
            break;

        default:
            break;
        }
    }

void CAiNwSDlgController::HandleNetworkError( const TNWOperation /*aOperation*/,
                                             TInt /*aErrorCode*/ )
    {
    // Take no action.
    }

TBool CAiNwSDlgController::IsOffLineMode() const
    {
    TInt profileId;
    TInt err = iProfileApi->Get( KProEngActiveProfile, profileId );
    return profileId == KOfflineProfileId && err == KErrNone;
    }

TBool CAiNwSDlgController::IsBluetoothSAPConnected() const
    {
    TInt btSapState( EBTSapNotConnected );
    TInt err = RProperty::Get( KPSUidBluetoothSapConnectionState,
                               KBTSapConnectionState,
                               btSapState );
    return btSapState != EBTSapNotConnected && err == KErrNone;
    }

// End of file.
hs_app_aipluginactivitypstool.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plugin activity PS tool
*
*/


#include "hs_app_aipluginactivitypstool.h"
#include "aipropertyextension.h"
#include 
#include  // for User
#include  // for RProperty
#include 

// Unnamed namespace for local definitions
namespace
    {

    const TInt KStartOrdinal( KAIActivePluginRangeStart );
    
    // All reads are allowed.
    _LIT_SECURITY_POLICY_PASS( KPluginActivityRegistryReadPolicy );

    // Write requires WriteDeviceData capability
    _LIT_SECURITY_POLICY_C1( KPluginActivityRegistryWritePolicy, ECapabilityWriteDeviceData );

    }

CAiPluginActivityRegistry::CAiPluginActivityRegistry()
  : iRegistryOrdinal( KStartOrdinal )
    {
    }

CAiPluginActivityRegistry* CAiPluginActivityRegistry::NewL()
    {
    CAiPluginActivityRegistry* self = 
        new (ELeave) CAiPluginActivityRegistry();
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }
    
void CAiPluginActivityRegistry::ConstructL()
    {
    }
    
CAiPluginActivityRegistry::~CAiPluginActivityRegistry()
    {
    CleanRegistry();
    }
        
TInt CAiPluginActivityRegistry::SetPluginActive( const TAiPublisherInfo& aPubInfo )
    {
    TInt psErr = KErrArgument;
    TInt uid = aPubInfo.iUid.iUid;
    
    // Make sure the keys are within their assigned ranges
    if( uid >= KAIPluginNameRangeStart &&
        uid <= KAIPluginNameRangeEnd &&
        iRegistryOrdinal  >= KAIActivePluginRangeStart &&
        iRegistryOrdinal  <= KAIActivePluginRangeEnd )
        {
        psErr = UpdateOrdinalRegister( uid );

        ++iPluginCount; // now there is partial data in registry for next item
                        // so update count allready here, so that
                        // the data may be cleaned in case on error
             
        psErr |= UpdateNameRegister( uid, aPubInfo.iName );
                        
        psErr |= UpdateCountRegister();
        
        if( psErr != KErrNone )
            {
            CleanLastEntry( uid,
                            iRegistryOrdinal,
                            iPluginCount - 1 );
            // Decrement only after rollback so failures may be cleaned properly
            // in case there is interrupting error situations
            --iPluginCount;
            return psErr;
            }
                        
        ++iRegistryOrdinal;
        }
    
    return psErr;
    }
    
void CAiPluginActivityRegistry::CleanRegistry()
    {
    // The count in p&s might not be updated before
    // we end up here that why we use iPluginCount for count.
    for( TInt i = 0; i < iPluginCount; ++i )
        {
        TInt categoryKey = i + KStartOrdinal;
        TInt pluginUid = 0;
        TInt err = RProperty::Get( 
                    KPSUidActiveIdle2,
                    categoryKey,
                    pluginUid );
        if( err == KErrNone )
            {
            // Delete name
            RProperty::Delete( KPSUidActiveIdle2, pluginUid );
            }
        // Delete ordinal
        RProperty::Delete( KPSUidActiveIdle2, categoryKey );
        }
    // Delete count
    RProperty::Delete( KPSUidActiveIdle2, KAIActivePluginCount );
    iRegistryOrdinal = KStartOrdinal;
    }

TInt CAiPluginActivityRegistry::UpdateCountRegister()
    {
    TInt err = RProperty::Define(
                        KPSUidActiveIdle2,
                        KAIActivePluginCount,
                        RProperty::EInt,
                        KPluginActivityRegistryReadPolicy,
                        KPluginActivityRegistryWritePolicy );
    if( err == KErrAlreadyExists &&
        iRegistryOrdinal == KStartOrdinal )
        {
        // Some error has occured
        CleanRegistry();
        err = RProperty::Define(
                        KPSUidActiveIdle2,
                        KAIActivePluginCount,
                        RProperty::EInt,
                        KPluginActivityRegistryReadPolicy,
                        KPluginActivityRegistryWritePolicy );
        }
    if( err != KErrAlreadyExists &&
        err != KErrNone )
        {
        return err;
        }
        
    // iRegistryOrdinal starts from 1, so it can be used as count, but only
    // before incrementation.
    err = RProperty::Set( 
                    KPSUidActiveIdle2,
                    KAIActivePluginCount,
                    iPluginCount );
    return err;
    }

TInt CAiPluginActivityRegistry::UpdateOrdinalRegister( TInt aPluginUid )
    {
    TInt categoryKey = iRegistryOrdinal;
    TInt err = RProperty::Define(
                KPSUidActiveIdle2,
                categoryKey,
                RProperty::EInt,
                KPluginActivityRegistryReadPolicy,
                KPluginActivityRegistryWritePolicy );
    
    if( err == KErrNone ||
        err == KErrAlreadyExists )
        {
        // Set plugin uid to ordinal key
        err = RProperty::Set( 
                    KPSUidActiveIdle2,
                    categoryKey,
                    aPluginUid );
        }
    return err;
    }

TInt CAiPluginActivityRegistry::UpdateNameRegister( TInt aPluginUid,
                                                    const TDesC& aName )
    {
    TInt err = RProperty::Define(
                    KPSUidActiveIdle2,
                    aPluginUid,
                    RProperty::EText,
                    KPluginActivityRegistryReadPolicy,
                    KPluginActivityRegistryWritePolicy );
                        
    if( err == KErrNone ||
        err == KErrAlreadyExists )
        {
        // Set plugin uid to ordinal key
        err = RProperty::Set( 
                        KPSUidActiveIdle2,
                        aPluginUid,
                        aName );
        }
    return err;
    }

void CAiPluginActivityRegistry::CleanLastEntry( TInt aPluginUid,
                                                TInt aOrdinal,
                                                TInt aLastCount )
    {
    RProperty::Delete( KPSUidActiveIdle2, aOrdinal );
    RProperty::Delete( KPSUidActiveIdle2, aPluginUid );
    if( aLastCount == 0 )
        {
        RProperty::Delete( KPSUidActiveIdle2, KAIActivePluginCount );
        }
    else
        {
        RProperty::Set( 
                    KPSUidActiveIdle2,
                    KAIActivePluginCount,
                    aLastCount );
        }
    }
hs_app_aipluginfactory.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Content plugin manager class for Active idle framework.
*
*/

// System includes
#include 
#include 
#include 
#include 
#include                     // For RProperty

// User includes
#include 
#include 
#include 
#include         // PubSub category
#include       // PubSub category key and values

#include "hs_app_aipluginfactory.h"
#include "hs_app_aicontentpluginmanager.h"
#include "hs_app_aipluginlifecycleobserver.h"

#include "aiuicontroller.h"
#include "hs_app_aifwpanic.h"
#include "debug.h"


// ======== LOCAL FUNCTIONS ========
// ----------------------------------------------------------------------------
// CleanupResetAndDestroy()
// ----------------------------------------------------------------------------
//
template
static void CleanupResetAndDestroy( TAny* aObj )
    {
    if( aObj )
        {
        static_cast( aObj )->ResetAndDestroy();
        }
    }

// ----------------------------------------------------------------------------
// CleanupResetAndDestroyPushL()
// ----------------------------------------------------------------------------
//
template
static void CleanupResetAndDestroyPushL(T& aArray)
    {
    CleanupStack::PushL( TCleanupItem( &CleanupResetAndDestroy, &aArray ) );
    }
    
// ======== MEMBER FUNCTIONS ========    

// ----------------------------------------------------------------------------
// CAiPluginFactory::CAiPluginFactory()
// ----------------------------------------------------------------------------
//
CAiPluginFactory::CAiPluginFactory( 
    RPointerArray& aPlugins,
    CAiContentPluginManager& aManager )
      : iPlugins( aPlugins ), iManager( aManager )    
    {
    }

// ----------------------------------------------------------------------------
// CAiPluginFactory::~CAiPluginFactory()
// ----------------------------------------------------------------------------
//
CAiPluginFactory::~CAiPluginFactory()
    {    
    Release( iPluginTool );
           
    iEComPlugins.ResetAndDestroy();
           
    iLifecycleObservers.Reset();
    }
    
// ----------------------------------------------------------------------------
// CAiPluginFactory::NewL()
// ----------------------------------------------------------------------------
//
CAiPluginFactory* CAiPluginFactory::NewL( 
    RPointerArray& aPlugins,
    CAiContentPluginManager& aManager )
    {
    CAiPluginFactory* self = 
        new ( ELeave ) CAiPluginFactory( aPlugins, aManager );
                                                                      
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }

// ----------------------------------------------------------------------------
// CAiPluginFactory::ConstructL()
// ----------------------------------------------------------------------------
//
void CAiPluginFactory::ConstructL()
    {        
    iPluginTool = AiUtility::CreatePluginToolL();
    }
        
// ----------------------------------------------------------------------------
// CAiPluginFactory::AddLifecycleObserverL()
// ----------------------------------------------------------------------------
//
void CAiPluginFactory::AddLifecycleObserverL(
    MAiPluginLifecycleObserver& aObserver )
    {
    if( iLifecycleObservers.Find( &aObserver ) == KErrNotFound )
        {
        iLifecycleObservers.AppendL( &aObserver );
        }    
    }

// ----------------------------------------------------------------------------
// CAiPluginFactory::CreatePluginL()
// ----------------------------------------------------------------------------
//
void CAiPluginFactory::CreatePluginL(
    const TAiPublisherInfo& aPublisherInfo,
    RPointerArray& aControllerArray )                       
    {           
    iEComPlugins.ResetAndDestroy();
    
    // Discover Plugin implementations.
    __TIME_MARK( ecomOverhead );
    
    REComSession::ListImplementationsL( 
            KInterfaceUidContentPlugin, iEComPlugins );
    
    __TIME_ENDMARK( "FW: ECom Discover plug-ins", ecomOverhead );    
                          
    iPlugins.ReserveL( iPlugins.Count() + 1 );
                       
    TBool implFound( EFalse );
    
    for( TInt i = 0; i < iEComPlugins.Count(); i++ )
        {
        CImplementationInformation* information( iEComPlugins[i] );
                                                                 
        if( information->ImplementationUid().iUid == aPublisherInfo.iUid.iUid )
            {
            implFound = ETrue;
            break;
            }
        }
    
    if( aPublisherInfo.iNamespace == KNullDesC8 || !implFound )
        {
        // No namespace available or no ecom implementation available                               
        User::Leave( KErrNotSupported );
        }
           
    CAiContentPublisher* plugin( PluginByInfoL( aPublisherInfo ) );
    
    if( plugin )
        {                             
        User::Leave( KErrAlreadyExists );
        }
           
    __PRINT( __DBG_FORMAT( "\t[I]\t Loading plug-in uid=%x name=%S"), 
                            aPublisherInfo.iUid, &(aPublisherInfo.iName) );
           
    __TIME( "FW: Create plug-in:",
        plugin = CreatePluginLC( aPublisherInfo );
        ) // __TIME
       
    __TIME( "FW: Subscribe content observers",    
        SubscribeContentObserversL( *plugin, 
            aPublisherInfo, aControllerArray );
        ) // __TIME
                                              
    // Plug-in settings
    __TIME( "FW: Configure Plugin",
        ConfigurePluginL( aControllerArray, *plugin, aPublisherInfo );
        ) // __TIME
                                  
    __PRINTS( "*** FW: Done - Load Plug-in ***" );                          
    
    // This might fail and the plugin ends up destroyed
    for( TInt i = 0; i < iLifecycleObservers.Count(); ++i )
        {
        iLifecycleObservers[i]->PluginCreatedL( *plugin );
        }
                
    for( TInt i = 0; i < iLifecycleObservers.Count(); ++i )
        {
        iLifecycleObservers[i]->AllPluginsCreated();
        }
                   
    // Move plugins to manager
    iPlugins.Append( plugin );
    CleanupStack::Pop( plugin );
    
    iEComPlugins.ResetAndDestroy();       
    }
        
// ----------------------------------------------------------------------------
// CAiPluginFactory::DestroyPluginL()
// ----------------------------------------------------------------------------
//
void CAiPluginFactory::DestroyPluginL(
    const TAiPublisherInfo& aPublisherInfo,
    RPointerArray< CAiUiController >& /*aControllerArray*/ )                       
    {
    // TODO: check is there need to call 
    // iUiControllerManager->RemovePluginFromUI( aPlugin );
    // it will clean the published content.     
    
    if( iPlugins.Count() == 0 )
        {
        return;
        }
               
    CAiContentPublisher* plugin( PluginByInfoL( aPublisherInfo ) );
    
    TInt index( iPlugins.Find( plugin ) );
    
    if( plugin && index != KErrNotFound )
        {               
        for( TInt i = 0; i < iLifecycleObservers.Count(); i++ )
            {                
            iLifecycleObservers[i]->PluginDestroyed( *plugin );
            }
        
        iPlugins.Remove( index );
        
        delete plugin;
        plugin = NULL;
        }
        
    if( iPlugins.Count() == 0 )
        {
        for( TInt i = 0; i < iLifecycleObservers.Count(); i++ )
            {                
            iLifecycleObservers[i]->AllPluginsDestroyed();
            }        
        }
    }

// ----------------------------------------------------------------------------
// CAiPluginFactory::DestroyPlugins()
// ----------------------------------------------------------------------------
//
void CAiPluginFactory::DestroyPlugins()
    {
    for( TInt i = 0; i < iPlugins.Count(); i++ )
        {
        CAiContentPublisher* plugin( iPlugins[i] );
        
        for( TInt i = 0; i < iLifecycleObservers.Count(); i++ )
            {                
            iLifecycleObservers[i]->PluginDestroyed( *plugin );
            }        
        }

    iPlugins.ResetAndDestroy();
    
    for( TInt i = 0; i < iLifecycleObservers.Count(); i++ )
        {                
        iLifecycleObservers[i]->AllPluginsDestroyed();
        }           
    }
        
// ----------------------------------------------------------------------------
// CAiPluginFactory::CreatePluginLC()
// ----------------------------------------------------------------------------
//
CAiContentPublisher* CAiPluginFactory::CreatePluginLC(
    const TAiPublisherInfo& aPluginInfo )
    {
    CAiContentPublisher* plugin = 
            CAiContentPublisher::NewL( aPluginInfo.iUid );
    
    CleanupStack::PushL( plugin );
        
    MAiPropertyExtension* ext( iPluginTool->PropertyExt( *plugin ) );
    
    if( !ext )
        {
        User::Leave( KErrNotFound );
        }
    
    ext->SetPropertyL( EAiPublisherInfo, (TAny*)&aPluginInfo );
    
    const TAiPublisherInfo* info( ext->PublisherInfoL() );
    
    if( info->iNamespace != aPluginInfo.iNamespace )
        {
        // SetPropertyL is not implemented correctly
        User::Leave( KErrNotSupported );
        }
    
    return plugin;
    }

// ----------------------------------------------------------------------------
// CAiPluginFactory::SubscribeContentObserversL()
// ----------------------------------------------------------------------------
//
void CAiPluginFactory::SubscribeContentObserversL(
    CAiContentPublisher& aContentPublisher,        
    const TAiPublisherInfo& aPublisherInfo,
    RPointerArray& aControllerArray )
    {       
    
    for( TInt i = 0; i < aControllerArray.Count(); i++ )
        {
        MAiContentObserver& observer( 
            aControllerArray[i]->GetContentObserver() );
        
        if ( observer.RequiresSubscription( aPublisherInfo ) )
            {
			// Subscribe observer only if it understands the plugin
            aContentPublisher.SubscribeL( observer );
            }                   
        }
    }

// ----------------------------------------------------------------------------
// CAiPluginFactory::ConfigurePluginL()
// ----------------------------------------------------------------------------
//
void CAiPluginFactory::ConfigurePluginL( 
    RPointerArray& aControllerArray,
    CAiContentPublisher& aContentPublisher,
    const TAiPublisherInfo& aPubInfo )
    {    
    RAiSettingsItemArray pluginSettings;
    CleanupResetAndDestroyPushL( pluginSettings );
    
    for( TInt i = 0; i < aControllerArray.Count(); i++ )
        {
        // Get settings for plug-in        
        aControllerArray[i]->GetSettingsL( aPubInfo, pluginSettings );
        }
    
    // Configure plug-in with its settings
    aContentPublisher.ConfigureL( pluginSettings );
    
    CleanupStack::PopAndDestroy( &pluginSettings );    
    }
        
// ----------------------------------------------------------------------------
// CAiPluginFactory::PluginByInfoL()
// ----------------------------------------------------------------------------
//
CAiContentPublisher* CAiPluginFactory::PluginByInfoL( 
    const TAiPublisherInfo& aInfo ) const
    {       
    for( TInt i = 0; i < iPlugins.Count(); i++ )
        {         
        const TAiPublisherInfo* info( NULL );
                                                  
        info = iPluginTool->PublisherInfoL( *iPlugins[i] );
        
        if( info && ( aInfo == *info ) ) 
            {
            return iPlugins[i];
            }
        }
    
    return NULL;
    }

// ----------------------------------------------------------------------------
// CAiPluginFactory::PluginByNameL()
// ----------------------------------------------------------------------------
//
CAiContentPublisher* CAiPluginFactory::PluginByNameL( 
    const TDesC& aName ) const
    {
    for( TInt i = 0; i < iPlugins.Count(); i++ )
        {
        const TAiPublisherInfo* info( NULL );
        
        TRAP_IGNORE( info = iPluginTool->PublisherInfoL( *iPlugins[i] ) );
                        
        if( info && info->iName == aName )
            {
            return iPlugins[i];            
            }
        }
    
    return NULL;    
    }

// End of file
hs_app_aipluginstatemachineimpl.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Plugin state machine impl
*
*/


#include "hs_app_aipluginstatemachineimpl.h"
#include "hs_app_aipluginstatemachine.h"
#include "hs_app_aipluginlifecycleobserver.h"
#include "hs_app_aipluginstate.h"
#include "hs_app_aifwpanic.h"

// ======== MEMBER FUNCTIONS ========

// ---------------------------------------------------------------------------
// CAiPluginStateMachine::CAiPluginStateMachine()
// ----------------------------------------------------------------------------
//
CAiPluginStateMachine::CAiPluginStateMachine(
    MAiPluginStateResources& aPluginStateResource,    
    CAiContentPublisher& aPlugin )
      : iAlive( *this ),
        iCurrentState( NULL ),
        iPluginStateResource( aPluginStateResource ),        
        iPlugin( aPlugin )
    {
    }

// ---------------------------------------------------------------------------
// CAiPluginStateMachine::SwitchToState()
// ----------------------------------------------------------------------------
//
void CAiPluginStateMachine::SwitchToState( TAiState aState,
    TAiStateChanges aStateChange )
    {
    // Store previous state
    MAiPluginState* previousState( iCurrentState );
    
    // Determine new current state
    switch( aState )
        {
        case EAiAlive:
            {
            iCurrentState = &iAlive;
            break;
            }
        case EAiSuspended:
            {
            iCurrentState = &iSuspended;
            break;
            }
        case EAiIdle:
            {
            iCurrentState = &iIdle;
            break;
            }
        default:
            {
#ifdef _DEBUG
            AiFwPanic::Panic( AiFwPanic::EAiFwPanic_IllegalPluginStateChange );
#endif
            break;
            }
        }
    
    if( previousState != iCurrentState )
        {
        if( previousState )
            {
            // Exit the previous state
            previousState->Exit( *this, aStateChange );            
            }
        
        if( iCurrentState )
            {
            // Enter the new state
            iCurrentState->Enter( *this, aStateChange );                    
            }
        }
    }

// ---------------------------------------------------------------------------
// CAiPluginStateMachine::StateVariable()
// ----------------------------------------------------------------------------
//
TBool CAiPluginStateMachine::StateVariable( TAiStateVariable aStateVariable )
    {
    return iPluginStateResource.StateVariable( aStateVariable );
    }

// ---------------------------------------------------------------------------
// CAiPluginStateMachine::Plugin()
// ----------------------------------------------------------------------------
//
CAiContentPublisher& CAiPluginStateMachine::Plugin() const
    {
    return iPlugin;
    }

// ---------------------------------------------------------------------------
// CAiPluginStateMachine::HandleEvent()
// ----------------------------------------------------------------------------
//
TBool CAiPluginStateMachine::HandleEvent( TAiStateChanges aStateChange )
    {
    // State machine handles some state changes directly.
    switch( aStateChange )
        {
        case ESMAISystemBoot:
            {
            // State machine handles startup event(boot/theme change).
            // Check if backup is ongoing
            if( iPluginStateResource.StateVariable( ESMAIBackupRestoreStatus ) )
                {
                SwitchToState( EAiIdle, aStateChange );
                }
            else
                {
                SwitchToState( EAiAlive, aStateChange );
                }
            break;
            }
        case ESMAIBackupOn:
            {
            // Backup/restore directs straight to idle state.
            SwitchToState( EAiIdle, aStateChange );
            break;
            }
        case ESMAIReportThemeChangeStarted:
        case ESMAISystemShutdown:
            {
            // Shutdown drives directly to idle state.
            ChangePluginState( iPluginStateResource.TranslateReason( aStateChange ),
                               CAiContentPublisher::Stop );
            break;
            }
        case ESMAIOnLine:
            {
            if( !iOnline && iCurrentState )
                {
                iOnline = ETrue;
                
                return iCurrentState->HandleEvent( *this, aStateChange );
                }                
            break;
            }
        case ESMAIOffLine:
            {
            if( iCurrentState )
                {
                iOnline = EFalse;
                
                return iCurrentState->HandleEvent( *this, aStateChange );                
                }            
            break;
            }
        default:
            {
            if( ( aStateChange == ESMAIBacklightOn ) &&
                !iPluginStateResource.StateVariable( ESMAIIdleFocusStatus ) )
                {
                // Ignore lights on when on background
                return ETrue;
                }
            
            if( iCurrentState )
                {
                // Other events are handled by the current set state.
                // Current state determines return value.
                return iCurrentState->HandleEvent( *this, aStateChange );                
                }
            }
        }
    
    // Return event handled.
    return ETrue;
    }

// ---------------------------------------------------------------------------
// CAiPluginStateMachine::TranslateReason()
// ----------------------------------------------------------------------------
//    
TAiTransitionReason CAiPluginStateMachine::TranslateReason( 
    TAiStateChanges aStateChange )
    {
    return iPluginStateResource.TranslateReason( aStateChange );
    }

// ---------------------------------------------------------------------------
// CAiPluginStateMachine::RestartSuspendTimer()
// ----------------------------------------------------------------------------
//
void CAiPluginStateMachine::RestartSuspendTimer()
    {
    iPluginStateResource.RestartSuspendTimer();
    }

// ---------------------------------------------------------------------------
// CAiPluginStateMachine::ChangePluginState()
// ----------------------------------------------------------------------------
//
void CAiPluginStateMachine::ChangePluginState( TAiTransitionReason aReason,         
    void (CAiContentPublisher::*aStateChangeMethod)( TAiTransitionReason ) )
    {       
	TRAP_IGNORE( ( iPlugin.*aStateChangeMethod)( aReason ) );	
    }

// End of file.
hs_app_aipluginstatemanager.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  System state observer and notifier
*
*/


#include 
#include 
#include  // for KSettingsScreenSaverPeriod
#include 
#include 
#include 
#include 
#include 
#include "hs_app_aifwpanic.h"
#include "hs_app_aipluginstatemanager.h"
#include "hs_app_aipluginstatemachineimpl.h"
#include "hs_app_ailightstatusobserver.h"
#include "hs_app_aicallstatusobserver.h"
#include "hs_app_aifocusobserver.h"
#include "hs_app_aikeylockobserver.h"
#include "hs_app_aibackuprestorestatusobserver.h"
#include "hs_app_aienvironmentchangeobserver.h"
#include "hs_app_aiuiframeworkobserverimpl.h"

#include  // this include needs to be last

#include "debug.h"

const TInt KMinuteInSeconds( 60 );
const TInt KSecondInMikroSeconds( 1000*1000 );
const TInt KAIFadeOutEstimateMikroSeconds( 10 * KSecondInMikroSeconds );
const TInt KTwoMinutesInMikroSeconds( 2 * KMinuteInSeconds * KSecondInMikroSeconds );

#define AI2_OPTION_RESUME_AT_CREATION

// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// CAiPluginStateManager::NewL()
// ----------------------------------------------------------------------------
//
CAiPluginStateManager* CAiPluginStateManager::NewL()
    {
    CAiPluginStateManager* self = new (ELeave) CAiPluginStateManager;
    
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    
    return self;
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::~CAiPluginStateManager()
// ----------------------------------------------------------------------------
//
CAiPluginStateManager::~CAiPluginStateManager()
    {       
    iStateMachines.ResetAndDestroy();
    
    DestroySystemStateObservers();
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::CAiPluginStateManager()
// ----------------------------------------------------------------------------
//
CAiPluginStateManager::CAiPluginStateManager()
    {
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::ConstructL()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::ConstructL()
    {
    TInt value( 0 );
    
    TInt err( RProperty::Get( KCRUidPersonalizationSettings, 
                              KSettingsScreenSaverPeriod, value ) );
                               
    if( err == KErrNone )
        {
        iT1Delay = ( value * KMinuteInSeconds * KSecondInMikroSeconds )
                   + KAIFadeOutEstimateMikroSeconds;
        }
    else
        {
        // default when error to 2 minutes
        iT1Delay = KTwoMinutesInMikroSeconds;
        }    
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::CreateSystemStateObserversL()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::CreateSystemStateObserversL()
    {
    iT1Timer = CPeriodic::NewL( CActive::EPriorityStandard );

    iBackupOperationObserver = CAiBackupRestoreStatusObserver::NewL( this );

    iCallStateObserver = CAiCallStatusObserver::NewL( this );

    iLightStateObserver = CAiLightStatusObserver::NewL( this );

    iFocusObserver = CAiFocusObserver::NewL( this );

    iKeylockObserver = CAiKeylockObserver::NewL( this );

    // Environment change observer notifies time/date/midnight/language
    // changes
    iEnvironmentObserver = CAiEnvironmentChangeObserver::NewL( this );

    // Ui framework observer notifies currently general theme changes
    iFrameworkObserver = CAiUiFrameworkObserverImpl::NewL( *this );
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::DestroySystemStateObservers()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::DestroySystemStateObservers()
    {
    if( iT1Timer )
        {
        iT1Timer->Cancel();
        
        delete iT1Timer;       
        iT1Timer = NULL;
        }

    delete iBackupOperationObserver;
    iBackupOperationObserver = NULL;

    delete iCallStateObserver;
    iCallStateObserver = NULL;

    delete iLightStateObserver;
    iLightStateObserver = NULL;

    delete iFocusObserver;
    iFocusObserver = NULL;

    delete iKeylockObserver;
    iKeylockObserver = NULL;

    delete iEnvironmentObserver;
    iEnvironmentObserver = NULL;

    delete iFrameworkObserver;
    iFrameworkObserver = NULL;
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::UiFwObserver()
// ----------------------------------------------------------------------------
//
MAiUiFrameworkObserver* CAiPluginStateManager::UiFwObserver() const
    {
    return iFrameworkObserver;
    }
    
// ----------------------------------------------------------------------------
// CAiPluginStateManager::ReportStateChange()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::ReportStateChange( TAiStateChanges aState )
    {
    if( !iIsDeviceStarted ) 
        {
        if( aState == ESMAISystemBoot )
            {
            iIsDeviceStarted = ETrue;
            }               
        }
    
    if( aState == ESMAISystemBoot )
        {
        return;
        }
        
    ProcessStateChangeForAll( aState );
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::StateVariable()
// ----------------------------------------------------------------------------
//
TBool CAiPluginStateManager::StateVariable( TAiStateVariable aStateChange )
    {
    switch ( aStateChange )
        {
        case ESMAICallStatus:
            {
            return CallOngoing();
            }
        case ESMAILightStatus:
            {
            return LightsOn();
            }
        case ESMAIBackupRestoreStatus:
            {
            return BackupOngoing();
            }
        case ESMAIIdleFocusStatus:
            {
            return IdleFocused();
            }
        default:
            {
            return EFalse;
            }
        }
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::RestartSuspendTimer()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::RestartSuspendTimer()
    {
    if( iT1Timer )
        {
        iT1Timer->Cancel();
        
        iT1Timer->Start( iT1Delay, iT1Delay,                         
                         TCallBack( T1TimerCallback, this ) );
        }
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::PluginCreatedL()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::PluginCreatedL( CAiContentPublisher& aPlugin )
    {
    // Create a new state machine for the plugin from the heap
    // and append the machine to our local array.
    CAiPluginStateMachine* machine = 
        new ( ELeave ) CAiPluginStateMachine( *this, aPlugin );                                                                                                                                              

    // Important to append first so failure will be handled properly
    CleanupStack::PushL( machine );
    iStateMachines.AppendL( machine );
    CleanupStack::Pop( machine );
              
    // This will effectively resume the plugin NOW.
    ProcessStateChange( ESMAISystemBoot, *machine );
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::PluginDestroyed()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::PluginDestroyed( CAiContentPublisher& aPlugin )
    {
    // plugin has beed destroyed, remove the state machine also
    for( TInt i = 0; i < iStateMachines.Count(); i++ )
        {
        if( &iStateMachines[i]->Plugin() == &aPlugin )
            {
            iStateMachines[i]->HandleEvent( ESMAISystemShutdown );
            delete iStateMachines[i];
          
            iStateMachines.Remove( i );                                    
            break;
            }
        }
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::AllPluginsCreated()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::AllPluginsCreated()
    {
    // Currently we get this event via pluginmanager -> aifw -> EAISMSystemBoot event
    // so no implementation required. We might want to handle this locally in the 
    // future though. Current impl is such because RefreshUI for ui controller
    // needs to after the plugins are resumed -> If we handle this here it is not
    // garanteed.
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::AllPluginsDestroyed()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::AllPluginsDestroyed()
    {
    // Plugins have been destroyed, so destroy the state machines also.
    iStateMachines.ResetAndDestroy();
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::TranslateReason()
// ----------------------------------------------------------------------------
//
TAiTransitionReason CAiPluginStateManager::TranslateReason( 
    TAiStateChanges aStateChange )
    {
    switch ( aStateChange )
        {
        case ESMAIBacklightOn:
            {
            return EAiBacklightOn;
            }
        case ESMAIBacklightOff:
            {
            return EAiBacklightOff;
            }
        case ESMAIBackupOn:
            {
            return EAiBackupRestoreStarted;
            }
        case ESMAIBackupOff:
            {
            return EAiBackupRestoreEnded;
            }
        case ESMAIInCall:
            {
            return EAiPhoneCallStarted;
            }
        case ESMAINoCall:
            {
            return EAiPhoneCallEnded;
            }
        case ESMAISystemBoot:
            {
            return EAiSystemStartup;
            }
        case ESMAILocaleChanged:
            {
            return EAiLanguageChanged;
            }
        case ESMAIIdleForeground:
            {
            return EAiIdleForeground;
            }
        case ESMAIIdleBackground:
            {
            return EAiIdleBackground;
            }
        case ESMAITimeChanged:
            {
            return EAiTimeChanged;
            }
        case ESMAIMidnightCrossover:
            {
            return EAiMidnightPassed;
            }
        case ESMAIRelayoutScreen:
            {
            return EAiScreenLayoutChanged;
            }
        case ESMAIReportThemeChangeStarted:
            {
            return EAiUiDefinitionChangeStarted;
            }
        case ESMAIReportThemeChangeReady:
            {
            return EAiUiDefinitionChangeEnded;
            }
        case ESMAIGeneralThemeChanged:
            {
            return EAiGeneralThemeChanged;
            }
        case ESMAISystemShutdown:
            {
            return EAiSystemShutdown;
            }
        case ESMAIT1Timeout:
            {
            return EAiSuspendPlugins;
            }
        case ESMAIKeylockEnabled:
            {
            return EAiKeylockEnabled;
            }
        case ESMAIKeylockDisabled:
            {
            return EAiKeylockDisabled;
            }
        case ESMAIOffLine:
            {
            return EAiIdleOffLine;
            }
        case ESMAIOnLine:
            {
            return EAiIdleOnLine;
            }   
        case ESMAIPageSwitch:
        	{
        	return EAiIdlePageSwitch;
        	}
        case ESMAIUnknownState: // fallthrough
        default:
            {
            return EAiUnknownTransitionReason;
            }
        }
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::ProcessStateChange()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::ProcessStateChange( TAiStateChanges aState,
    CAiPluginStateMachine& aMachine )
    {
    aMachine.HandleEvent( aState );    
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::ProcessOnlineState()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::ProcessOnlineState( CAiContentPublisher& aPlugin ) 
    {
    for ( TInt i = 0; i < iStateMachines.Count(); i++ )
        {
        if( &iStateMachines[i]->Plugin() == &aPlugin )
            {
            iStateMachines[i]->HandleEvent( ESMAIOnLine );            
            break;
            }
        }
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::ProcessOfflineState()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::ProcessOfflineState( CAiContentPublisher& aPlugin )
    {
    for ( TInt i = 0; i < iStateMachines.Count(); i++ )
        {
        if( &iStateMachines[i]->Plugin() == &aPlugin )
            {
            iStateMachines[i]->HandleEvent( ESMAIOffLine );            
            break;
            }        
        }
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::ProcessStateChangeForAll()
// ----------------------------------------------------------------------------
//
void CAiPluginStateManager::ProcessStateChangeForAll( TAiStateChanges aState )
    {
    for ( TInt i = 0; i < iStateMachines.Count(); ++i )
        {
        iStateMachines[i]->HandleEvent( aState );
        }
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::IdleFocused()
// ----------------------------------------------------------------------------
//
TBool CAiPluginStateManager::IdleFocused() const
    {
    if ( iFocusObserver )
        {
        return ( iFocusObserver->Status() == ESMAIIdleForeground );
        }

    return EFalse;
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::BackupOngoing()
// ----------------------------------------------------------------------------
//
TBool CAiPluginStateManager::BackupOngoing() const
    {
    if ( iBackupOperationObserver )
        {
        return ( iBackupOperationObserver->Status() == ESMAIBackupOn );
        }
    
    return EFalse;    
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::LightsOn()
// ----------------------------------------------------------------------------
//
TBool CAiPluginStateManager::LightsOn() const
    {
    if ( iLightStateObserver )
        {
        return ( iLightStateObserver->Status() == ESMAIBacklightOn );
        }
    
    return EFalse;
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::CallOngoing()
// ----------------------------------------------------------------------------
//
TBool CAiPluginStateManager::CallOngoing() const
    {
    if ( iCallStateObserver )
        {
        return ( iCallStateObserver->Status() == ESMAIInCall );
        }
        
    return EFalse;    
    }

// ----------------------------------------------------------------------------
// CAiPluginStateManager::T1TimerCallback()
// ----------------------------------------------------------------------------
//
TInt CAiPluginStateManager::T1TimerCallback( TAny* aPtr )
    {
    CAiPluginStateManager* self =
        static_cast< CAiPluginStateManager* >( aPtr );

    __ASSERT_DEBUG( self, 
        AiFwPanic::Panic( AiFwPanic::EAiFwPanic_NullPointerReference ) );

    self->iT1Timer->Cancel();
    
//    self->ProcessStateChangeForAll( ESMAIT1Timeout );
    
    return KErrNone;
    }

// End of file

hs_app_aipsstatusobserver.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Generic PS observer base class
*
*/


#include 
#include 
#include "hs_app_aipsstatusobserver.h"

CAiPSStatusObserver::~CAiPSStatusObserver()
    {
    if( iObserver )
        iObserver->Release();
    }

TAiStateChanges CAiPSStatusObserver::Status()
    {
    return ESMAIUnknownState;
    }

CAiPSStatusObserver::CAiPSStatusObserver()
    {
    }
    
void CAiPSStatusObserver::BaseConstructL( TCallBack aCallBack,
                                              TUid aCategory,
                                              TInt aKey,
                                              MAiStateManager* aStateManager )
    {
    iStateManager = aStateManager;
    iObserver = AiUtility::CreatePSPropertyObserverL( aCallBack, aCategory, aKey );
    }

// End of File.
hs_app_aissaverstatusobserver.cpp
/*
* Copyright (c) 2005-2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#include 
#include "hs_app_aissaverstatusobserver.h"
#include  // this include needs to be last
#include "hs_app_aifwpanic.h"
#include "debug.h"

CAiSSaverStatusObserver::CAiSSaverStatusObserver()
    {
    }
    
CAiSSaverStatusObserver::~CAiSSaverStatusObserver()
    {
    }

CAiSSaverStatusObserver* CAiSSaverStatusObserver::NewL( MAiStateManager* aStateManager )
    {
    CAiSSaverStatusObserver* self = new (ELeave) CAiSSaverStatusObserver();
    CleanupStack::PushL(self);
    self->ConstructL( aStateManager );
    CleanupStack::Pop(self);
    return self;
    }

void CAiSSaverStatusObserver::ConstructL( MAiStateManager* aStateManager )
    {
    BaseConstructL( TCallBack( HandleScreenSaverStateChanged, this ),
                    KPSUidScreenSaver,
                    KScreenSaverOn,
		            aStateManager );
    }
    
TAiStateChanges CAiSSaverStatusObserver::Status()
    {
    TInt value = 0;
    Tint err = iObserver->Get( value );
    if( ( value == 0 ) ||
        ( err != KErrNone ) )
    	{
    	return ESMAIScreensaverInactive;
    	}
    else
    	{
    	return ESMAIScreensaverActive;
    	} 
    }

TInt CAiSSaverStatusObserver::HandleScreenSaverStateChanged( TAny* aPtr )
    {
    CAiSSaverStatusObserver* self =
                static_cast( aPtr );

    __ASSERT_DEBUG( self, 
                    AiFwPanic::Panic( AiFwPanic::EAiFwPanic_NullPointerReference ) );

    TInt value = 0;
    TInt err = self->iObserver->Get( value );
	
    if ( ( value == 0 ) ||
         ( err != KErrNone ) )
		{
        // screensaver off
        __PRINTS("XAI: Screen saver = OFF");
        self->iStateManager->ReportStateChange( ESMAIScreensaverInactive );
		}
    else
		{
        // screensaver on
        __PRINTS("XAI: Screen saver = ON");
        self->iStateManager->ReportStateChange( ESMAIScreensaverActive );
		}
	
    return KErrNone;
    }

hs_app_aistatealive.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  State class for alive states
*
*/


#include "hs_app_aistatealive.h"
#include "hs_app_aipluginstatemachine.h"
#include "debug.h"


// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// TAiStateAliveActive::TAiStateAliveActive()
// ----------------------------------------------------------------------------
//
TAiStateAliveActive::TAiStateAliveActive()
    {
    }

// ----------------------------------------------------------------------------
// TAiStateAliveActive::Enter()
// ----------------------------------------------------------------------------
//
void TAiStateAliveActive::Enter( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Enter Alive active" );
    
    const TAiTransitionReason reason( 
            aStateMachine.TranslateReason( aStateChange ) );
    
    aStateMachine.ChangePluginState( reason, CAiContentPublisher::Resume );                                    
    }
    
// ----------------------------------------------------------------------------
// TAiStateAliveActive::HandleEvent()
// ----------------------------------------------------------------------------
//
TBool TAiStateAliveActive::HandleEvent( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Alive active handles event" );
    switch( aStateChange )
        {
        case ESMAIBacklightOff:
            {
            aStateMachine.SwitchToState( EAiAliveInactive, aStateChange );
            return ETrue;
            }
        default:
            {
            return EFalse;
            }
        }
    }
    
// ----------------------------------------------------------------------------
// TAiStateAliveActive::Exit()
// ----------------------------------------------------------------------------
//
void TAiStateAliveActive::Exit( MAiPluginStateMachine& /*aStateMachine*/,
    TAiStateChanges /*aStateChange*/ )
    {
    __PRINTS( "XAI: Exit alive active" );
    }

// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// TAiStateAliveInactive::TAiStateAliveInactive()
// ----------------------------------------------------------------------------
//
TAiStateAliveInactive::TAiStateAliveInactive()
    {
    }

// ----------------------------------------------------------------------------
// TAiStateAliveInactive::Enter()
// ----------------------------------------------------------------------------
//
void TAiStateAliveInactive::Enter( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Enter alive inactive" );
    const TAiTransitionReason reason( 
            aStateMachine.TranslateReason( aStateChange ) );
    
    aStateMachine.ChangePluginState( reason, CAiContentPublisher::Resume );
                                         
    aStateMachine.RestartSuspendTimer();
    }

// ----------------------------------------------------------------------------
// TAiStateAliveInactive::HandleEvent()
// ----------------------------------------------------------------------------
//
TBool TAiStateAliveInactive::HandleEvent( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: alive inactive handles event" );
    switch( aStateChange )
        {
        case ESMAIIdleForeground:
        case ESMAIBacklightOn:
            {
            aStateMachine.SwitchToState( EAiAliveActive, aStateChange );
            return ETrue;
            }
        case ESMAIT1Timeout:
            {
            aStateMachine.SwitchToState( EAiSuspended, aStateChange );
            return ETrue;
            }
        default:
            {
            return EFalse;
            }
        }
    }

// ----------------------------------------------------------------------------
// TAiStateAliveInactive::Exit()
// ----------------------------------------------------------------------------
//
void TAiStateAliveInactive::Exit( MAiPluginStateMachine& /*aStateMachine*/,
    TAiStateChanges /*aStateChange*/ )
    {
    __PRINTS( "XAI: Exit alive inactive" );
    }


// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// TAiStateAliveIncall::TAiStateAliveIncall()
// ----------------------------------------------------------------------------
//
TAiStateAliveIncall::TAiStateAliveIncall()
    {
    }

// ----------------------------------------------------------------------------
// TAiStateAliveIncall::Enter()
// ----------------------------------------------------------------------------
//
void TAiStateAliveIncall::Enter( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Enter alive incall" );
    
    const TAiTransitionReason reason( 
            aStateMachine.TranslateReason( aStateChange ) );
    
    aStateMachine.ChangePluginState( reason, CAiContentPublisher::Resume );                                    
    }

// ----------------------------------------------------------------------------
// TAiStateAliveIncall::HandleEvent()
// ----------------------------------------------------------------------------
//
TBool TAiStateAliveIncall::HandleEvent( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: alive incall handles event" );
    switch( aStateChange )
        {
        case ESMAINoCall:
            {
            // To alive switch
            aStateMachine.SwitchToState( EAiAlive, aStateChange );
            return ETrue;
            }
        case ESMAIInCall:
            {
            // prevent master state from handling this
            return ETrue;
            }
        default:
            {
            return EFalse;
            }
        }
    }

// ----------------------------------------------------------------------------
// TAiStateAliveIncall::Exit()
// ----------------------------------------------------------------------------
//
void TAiStateAliveIncall::Exit( MAiPluginStateMachine& /*aStateMachine*/,
    TAiStateChanges /*aStateChange*/ )
    {
    __PRINTS( "XAI: Exit alive incall" );
    }
   
// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// TAiStateAlive::TAiStateAlive()
// ----------------------------------------------------------------------------
//
TAiStateAlive::TAiStateAlive( MAiPluginStateMachine& aParentStateMachine )
  : iCurrentState( &iStateAliveInactive ),
    iParentStateMachine( &aParentStateMachine )
    {
    }

// ----------------------------------------------------------------------------
// TAiStateAlive::SwitchToState()
// ----------------------------------------------------------------------------
//
void TAiStateAlive::SwitchToState( TAiState aState,
    TAiStateChanges aStateChange )
    {
    switch( aState )
        {
        case EAiAliveInactive:
            {
            iCurrentState = &iStateAliveInactive;
            break;
            }
        case EAiAliveActive:
            {
            iCurrentState = &iStateAliveActive;
            break;
            }
        case EAiAliveIncall:
            {
            iCurrentState = &iStateAliveIncall;
            break;
            }
        default:
            {
            iParentStateMachine->SwitchToState( aState, aStateChange );
            return;
            }
        }   
    iCurrentState->Enter( *this, aStateChange );
    }

// ----------------------------------------------------------------------------
// TAiStateAlive::StateVariable()
// ----------------------------------------------------------------------------
//
TBool TAiStateAlive::StateVariable( TAiStateVariable aStateVariable )
    {
    return iParentStateMachine->StateVariable( aStateVariable );
    }

// ----------------------------------------------------------------------------
// TAiStateAlive::Plugin()
// ----------------------------------------------------------------------------
//
CAiContentPublisher& TAiStateAlive::Plugin() const
    {
    return iParentStateMachine->Plugin();
    }

// ----------------------------------------------------------------------------
// TAiStateAlive::TranslateReason()
// ----------------------------------------------------------------------------
//
TAiTransitionReason TAiStateAlive::TranslateReason( 
    TAiStateChanges aStateChange )
    {
    return iParentStateMachine->TranslateReason( aStateChange );
    }

// ----------------------------------------------------------------------------
// TAiStateAlive::RestartSuspendTimer()
// ----------------------------------------------------------------------------
//
void TAiStateAlive::RestartSuspendTimer()
    {
    iParentStateMachine->RestartSuspendTimer();
    }

// ----------------------------------------------------------------------------
// TAiStateAlive::Enter()
// ----------------------------------------------------------------------------
//
void TAiStateAlive::Enter( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Alive switch - enter" );
    if( aStateMachine.StateVariable( ESMAICallStatus ) )
        {
        // If call is ongoing enter alive in call
        iCurrentState = &iStateAliveIncall;
        }
    else if( !aStateMachine.StateVariable( ESMAILightStatus ) )
        {
        // If light is off enter alive inactive
        iCurrentState = &iStateAliveInactive;
        }
    else
        {
        // Otherwise alive active
        iCurrentState = &iStateAliveActive;
        }
    // finally call the Enter() method
    iCurrentState->Enter( *this, aStateChange );
    }
 
// ----------------------------------------------------------------------------
// TAiStateAlive::HandleEvent()
// ----------------------------------------------------------------------------
//
TBool TAiStateAlive::HandleEvent( MAiPluginStateMachine& /*aStateMachine*/,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Alive switch handle event" );

    if( !iCurrentState->HandleEvent( *this, aStateChange ) )
        {
        // Only master state machine handles the "backup/restore on" and
        // screen layout changed cases.
        // Other event are forwarded to the currently active sub state.
        // Other common events may be added here in the future also.
        switch( aStateChange )
            {
            case ESMAIOffLine:
            case ESMAIOnLine:
            case ESMAIKeylockEnabled:
            case ESMAIKeylockDisabled:
            case ESMAIRelayoutScreen:
            case ESMAIIdleForeground:
            case ESMAIIdleBackground:
            case ESMAIPageSwitch:
            case ESMAIGeneralThemeChanged: // fallthrough
                {
                iCurrentState->Enter( *this, aStateChange );
                // Handled the event ok
                break;
                }
            case ESMAIInCall:
                {
                SwitchToState( EAiAliveIncall, aStateChange );
                // Handled the event ok
                break;
                }
            default:
                {
                // Neither current state or master handled this event
                return EFalse;
                }
            }
        }
    // Current state handled the event
    return ETrue;
    }

// ----------------------------------------------------------------------------
// TAiStateAlive::Exit()
// ----------------------------------------------------------------------------
//
void TAiStateAlive::Exit( MAiPluginStateMachine& /*aStateMachine*/,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Alive switch exit" );
    iCurrentState->Exit( *this, aStateChange );
    }

// ----------------------------------------------------------------------------
// TAiStateAlive::ChangePluginState()
// ----------------------------------------------------------------------------
//
void TAiStateAlive::ChangePluginState( TAiTransitionReason aReason,       
    void (CAiContentPublisher::*aStateChangeMethod)(TAiTransitionReason) )
    {
    iParentStateMachine->ChangePluginState( aReason, aStateChangeMethod );
    }
   
// End of file
hs_app_aistateidle.cpp
/*
* Copyright (c) 2005-2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  State class for idle state
*
*/


#include "hs_app_aistateidle.h"
#include "hs_app_aipluginstatemachine.h"
#include "debug.h"

// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// TAiStateIdle::TAiStateIdle()
// ----------------------------------------------------------------------------
//
TAiStateIdle::TAiStateIdle()
    {
    }

// ----------------------------------------------------------------------------
// TAiStateIdle::Enter()
// ----------------------------------------------------------------------------
//
void TAiStateIdle::Enter( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Enter idle backup restore" );
    const TAiTransitionReason reason( 
            aStateMachine.TranslateReason( aStateChange ) );
    
    aStateMachine.ChangePluginState( reason, CAiContentPublisher::Stop );                                    
    }
    
// ----------------------------------------------------------------------------
// TAiStateIdle::HandleEvent()
// ----------------------------------------------------------------------------
//
TBool TAiStateIdle::HandleEvent( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Idle backup restore handle event" );
    switch( aStateChange )
        {
        case ESMAIBackupOff:
            {
            aStateMachine.SwitchToState( EAiAlive, aStateChange );
            return ETrue;
            }
        case ESMAIKeylockEnabled:
        case ESMAIKeylockDisabled: // fallthrough
            {
            Enter( aStateMachine, aStateChange );
            return ETrue;
            }
        default:
            {
            return EFalse;
            }
        }
    }

// ----------------------------------------------------------------------------
// TAiStateIdle::Exit()
// ----------------------------------------------------------------------------
//
void TAiStateIdle::Exit( MAiPluginStateMachine& /*aStateMachine*/,
    TAiStateChanges /*aStateChange*/ )
    {
    __PRINTS( "XAI: Exit idle backup restore" );
    }

// End of file
hs_app_aistatesuspended.cpp
/*
* Copyright (c) 2005-2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  State class for suspended state
*
*/


#include "hs_app_aistatesuspended.h"
#include "hs_app_aipluginstatemachine.h"
#include "debug.h"

// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// TAiStateSuspended::TAiStateSuspended()
// ----------------------------------------------------------------------------
//
TAiStateSuspended::TAiStateSuspended()
    {
    }

// ----------------------------------------------------------------------------
// TAiStateSuspended::Enter()
// ----------------------------------------------------------------------------
//
void TAiStateSuspended::Enter( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Enter Suspended" );
    const TAiTransitionReason reason( 
            aStateMachine.TranslateReason( aStateChange ) );

    aStateMachine.ChangePluginState( reason, &CAiContentPublisher::Suspend );                                    
    }
    
// ----------------------------------------------------------------------------
// TAiStateSuspended::HandleEvent()
// ----------------------------------------------------------------------------
//
TBool TAiStateSuspended::HandleEvent( MAiPluginStateMachine& aStateMachine,
    TAiStateChanges aStateChange )
    {
    __PRINTS( "XAI: Suspended handle event" );
    switch( aStateChange )
        {
        case ESMAIIdleForeground:
        case ESMAIBacklightOn:
        case ESMAILocaleChanged:
        case ESMAITimeChanged:
        case ESMAIMidnightCrossover:
        case ESMAIRelayoutScreen:
        case ESMAIGeneralThemeChanged:
        case ESMAIInCall: // fallthrough
            {
            aStateMachine.SwitchToState( EAiAlive, aStateChange );
            return ETrue;
            }
        case ESMAIKeylockEnabled:
        case ESMAIKeylockDisabled:
            {
            Enter( aStateMachine, aStateChange );
            return ETrue;
            }
        default:
            {
            return EFalse;
            }
        }
    }

// ----------------------------------------------------------------------------
// TAiStateSuspended::Exit()
// ----------------------------------------------------------------------------
//
void TAiStateSuspended::Exit( MAiPluginStateMachine& /*aStateMachine*/,
    TAiStateChanges /*aStateChange*/ )
    {
    __PRINTS( "XAI: Exit Suspended" );
    }
   
hs_app_aiuicontrollermanager.cpp
/*
* Copyright (c) 2005-2008 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  UI controller manager class
*
*/


#include "hs_app_aiuicontrollermanager.h"
#include "aiuicontroller.h"
#include "aicontentpublisher.h"
#include "aicontentobserver.h"
#include "activeidle2domaincrkeys.h"
#include "hs_app_aifwpanic.h"
#include 
#include 
#include 

#include 

#include "debug.h"

// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// CAiUiControllerManager::CAiUiControllerManager()
// ----------------------------------------------------------------------------
//
CAiUiControllerManager::CAiUiControllerManager()
    {
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::LoadMainControllerL()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::LoadMainControllerL(
    CRepository& aCenRepConfig )
    {
    TInt value( 0 );
    
    // Main UI Controller must be configured correctly
    User::LeaveIfError( aCenRepConfig.Get( KAiMainUIController, value ) );
    
    CAiUiController* controller = CAiUiController::NewL( TUid::Uid( value ) );
    
    iCreatedUICList.Append( value );
    CleanupStack::PushL( controller );
    
    iMainUiController = controller->MainInterface();
    
    // Main UI controller must be configured correctly
    if( !iMainUiController )
        {
        __PRINT( __DBG_FORMAT("Main UI controller interface not found from controller 0x%x"), value );
        User::Leave( KErrNotFound );
        }
    
    iUiControllerArray.AppendL( controller );
    CleanupStack::Pop( controller );
    
    // Register this as a UI framework observer of the main UI controller
    iMainUiController->SetUiFrameworkObserver( *this );
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::LoadSecondaryControllersL()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::LoadSecondaryControllersL(
    CRepository& aCenRepConfig )
    {
    TInt value( 0 );
    
    // Instantiate rest of the UI controllers.
    for( TInt key = KAiFirstUIController; 
         key <= KAiLastUIController && aCenRepConfig.Get( key, value ) == KErrNone;
        ++key )
        {
        // skip empty entries
        if( value == 0 )
            {
            continue;
            }
        
        if( iCreatedUICList.Find( value ) != KErrNotFound )
            {
            continue;
            }
        
        iCreatedUICList.Append( value );
        
        CAiUiController* controller = 
            CAiUiController::NewL( TUid::Uid( value ) );
        
        CleanupStack::PushL( controller );
        
        iUiControllerArray.AppendL( controller );
        CleanupStack::Pop( controller );
        
        // Get the secondary interface
        MAiSecondaryUiController* secController( 
                    controller->SecondaryInterface() ); 
                        
        if( secController )
            {
            MAiUiFrameworkObserver* uiFwObserver(
                    secController->UiFrameworkObserver() );
        
            if( uiFwObserver )
                {
                // Add secondary controller as UI framework event observer. 
                User::LeaveIfError( 
                        iUiFrameworkObservers.InsertInAddressOrder( uiFwObserver ) );
                }
            }
        }
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::ConstructL()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::ConstructL()
    {
    __HEAP("FW: Init - Create UI Ctrls");
    __TIME_MARK(t);

    CRepository* cenRep( NULL );

#if 0
    // For AI3_test    
    RProcess proc;
    // 0x102750F0 in AI3, 0x2001CB4F in AI3_Test
    TSecureId secId( proc.SecureId() ); 
                                           
    if( secId == 0x2001CB4F )
        {
        cenRep = CRepository::NewL( TUid::Uid( 0x2001952B ) );
        }   
    else
        {
        cenRep = CRepository::NewL( TUid::Uid( KCRUidActiveIdleLV ) );
        }
#else
    cenRep = CRepository::NewLC( TUid::Uid( KCRUidActiveIdleLV ) );
#endif

    LoadMainControllerL( *cenRep );
    
    // Failing on secondary is not fatal. Ignore leaves.
    TRAP_IGNORE( LoadSecondaryControllersL( *cenRep ) );
                       
    CleanupStack::PopAndDestroy( cenRep );
    
    __TIME_ENDMARK("FW: Create UI Ctrls", t);
    __HEAP("FW: Done - Create UI Ctrls");
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::NewL()
// ----------------------------------------------------------------------------
//
CAiUiControllerManager* CAiUiControllerManager::NewL()
    {
    CAiUiControllerManager* self = new (ELeave) CAiUiControllerManager;
    
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self ); // self
    
    return self;
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::~CAiUiControllerManager()
// ----------------------------------------------------------------------------
//
CAiUiControllerManager::~CAiUiControllerManager()
    {
    iUiControllerArray.ResetAndDestroy();
    
    iUiFrameworkObservers.Reset();
    
    iCreatedUICList.Reset();
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::UiControllers() 
// ----------------------------------------------------------------------------
//
RPointerArray< CAiUiController >& CAiUiControllerManager::UiControllers() const
    {
    return iUiControllerArray;
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::IsMainUiController()
// ----------------------------------------------------------------------------
//
TBool CAiUiControllerManager::IsMainUiController(
    CAiUiController& aUiController ) const
    {
    return ( aUiController.MainInterface() == iMainUiController );
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::SetEventHandler()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::SetEventHandler(
    MAiFwEventHandler& aEventHandler )
    {
    for ( TInt i = 0; i < iUiControllerArray.Count(); i++ )
        {
        iUiControllerArray[i]->SetEventHandler( aEventHandler );
        }
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::RunApplicationL()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::RunApplicationL()
    {
    iMainUiController->RunApplicationL();
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::ActivateUI()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::ActivateUI()
    {
    for( TInt i = 0; i < iUiControllerArray.Count(); i++ )
        {
        iUiControllerArray[i]->ActivateUI();
        }
    }
    
// ----------------------------------------------------------------------------
// CAiUiControllerManager::LoadUIDefinition()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::LoadUIDefinition()
    {       
    for( TInt i = 0; i < iUiControllerArray.Count(); i++ )
        {
        CAiUiController* uiCtl( iUiControllerArray[i] );
        
        MAiSecondaryUiController* secIntr( uiCtl->SecondaryInterface() );
        
        if( secIntr )
            {
            secIntr->SetCoeEnv( CoeEnv() );
            }
        
        TRAPD( err, uiCtl->LoadUIDefinitionL() );
        
        if( err != KErrNone )            
            {
            if( IsMainUiController( *uiCtl ) )
                {
                // Main ui controller failing is fatal
                _LIT(KAIFWStartupFailed, "FW startup failed.");
                
                User::Panic( KAIFWStartupFailed, 0 );                
                }
            else
                {
                // Secondary UI controller failed, delete it
                delete uiCtl;
                uiCtl = NULL;
                
                iUiControllerArray.Remove( i );               
                }
            }
        }
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::CoeEnv()
// ----------------------------------------------------------------------------
//
CCoeEnv& CAiUiControllerManager::CoeEnv() const
    {
    return iMainUiController->CoeEnv();
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::MainUiController()
// ----------------------------------------------------------------------------
//
MAiMainUiController& CAiUiControllerManager::MainUiController() const
    {
    return *iMainUiController;
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::DestroySecondaryUiControllers()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::DestroySecondaryUiControllers()
    {
    for( TInt i = iUiControllerArray.Count() - 1; i >= 0; --i )
        {
        CAiUiController* uiController = iUiControllerArray[i];
        
        if( !IsMainUiController( *uiController ) )
            {
            delete uiController;
            uiController = NULL;
            
            iUiControllerArray.Remove(i);
            }
        }
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::ExitMainController()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::ExitMainController()
    {
    iMainUiController->Exit();
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::AddObserverL()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::AddObserverL( 
    MAiUiFrameworkObserver& aUiFwObserver )
    {
    User::LeaveIfError( 
            iUiFrameworkObservers.InsertInAddressOrder( &aUiFwObserver ) );
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::RemoveObserver()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::RemoveObserver( 
    MAiUiFrameworkObserver& aUiFwObserver )
    {
    TInt index( iUiFrameworkObservers.FindInAddressOrder( &aUiFwObserver ) );
    
    if( index != KErrNotFound )
        {
        iUiFrameworkObservers.Remove( index );
        }
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::RemovePluginFromUI()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::RemovePluginFromUI( CAiContentPublisher& aPlugin )
    {
    // Get MAiPropertyExtension from plugin
    MAiPropertyExtension* plugin =
        static_cast< MAiPropertyExtension* >( 
                aPlugin.Extension( KExtensionUidProperty ) );
    
    // Inform all UI controller that this plugin need to be removed from UI.
    if( plugin )
        {
        for ( TInt i = 0; i < iUiControllerArray.Count(); i++ )
            {
            iUiControllerArray[i]->RemovePluginFromUI( *plugin );
            }
        }
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::HandleResourceChange()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::HandleResourceChange( TInt aType )
    {
    for( TInt i = 0; i < iUiFrameworkObservers.Count(); i++ )
        {
        iUiFrameworkObservers[i]->HandleResourceChange( aType );
        }
    }

// ----------------------------------------------------------------------------
// CAiUiControllerManager::HandleForegroundEvent()
// ----------------------------------------------------------------------------
//
void CAiUiControllerManager::HandleForegroundEvent( TBool aForeground )
    {
    for( TInt i = 0; i < iUiFrameworkObservers.Count(); i++ )
        {
        iUiFrameworkObservers[i]->HandleForegroundEvent( aForeground );
        }
    }
    
// End of file
hs_app_aiuiframeworkobserverimpl.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  UI framework observer for Active Idle framework
*
*/


#include  // for KAknsMessageSkinChange equal general theme changed
#include "hs_app_aiuiframeworkobserverimpl.h"
#include "debug.h"

CAiUiFrameworkObserverImpl::CAiUiFrameworkObserverImpl( MAiStateManager& aManager )
  : iManager( aManager )
    {
    }

void CAiUiFrameworkObserverImpl::ConstructL()
    {
    }

CAiUiFrameworkObserverImpl* CAiUiFrameworkObserverImpl::NewL( MAiStateManager& aManager )
                                                              
    {
    CAiUiFrameworkObserverImpl* self = 
                        new(ELeave) CAiUiFrameworkObserverImpl( aManager );
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }

CAiUiFrameworkObserverImpl::~CAiUiFrameworkObserverImpl()
    {
    }

// ---------------------------------------------------------------------------
// From class MAiUiFrameworkObserver.
// 
// ---------------------------------------------------------------------------
//
void CAiUiFrameworkObserverImpl::HandleResourceChange( TInt aType )
    {
    switch( aType )
        {
        case KAknsMessageSkinChange:
            {
            iManager.ReportStateChange( ESMAIGeneralThemeChanged );
            break;
            }
        default:
            {
            // Do nothing
            break;
            }
        }
    }

// ---------------------------------------------------------------------------
// From class MAiUiFrameworkObserver.
// 
// ---------------------------------------------------------------------------
//    
void CAiUiFrameworkObserverImpl::HandleForegroundEvent( TBool /*aForeground*/ )
    {
    // Focus observer disabled from this location
    }
    
// ---------------------------------------------------------------------------
// From class MAiDeviceStatusObserver.
// 
// ---------------------------------------------------------------------------
//
TAiStateChanges CAiUiFrameworkObserverImpl::Status()
    {
    // Resource change event are by nature single shot, so no status can 
    // be defined for them.
    return ESMAIUnknownState;
    }
hs_app_homescreen.rss
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Resource definitions for project homescreen
*
*/


NAME AIFW

#include    
#include    
#include    

#include    
#include    
#include    
#include    
#include    

#include    

RESOURCE RSS_SIGNATURE { }

RESOURCE TBUF { buf=""; }

// ---------------------------------------------------------------------------
// r_homescreen_localisable_app_info
// It defines localisable app info of Active Idle 3
// ---------------------------------------------------------------------------
//
RESOURCE LOCALISABLE_APP_INFO r_homescreen_localisable_app_info
    {
    short_caption = qtn_apps_idle_grid;
    caption_and_icon = 
    CAPTION_AND_ICON_INFO
        {
        caption = qtn_apps_idle_grid;
        
#ifdef __SCALABLE_ICONS

        number_of_icons = 1;
        icon_file = APP_RESOURCE_DIR"\\homescreen_aif.mif";

#else

        number_of_icons = 1;
        icon_file = APP_RESOURCE_DIR"\\homescreen_aif.mbm";

#endif // __SCALABLE_ICONS
        };
    }
hs_app_homescreen_reg.rss
/*
* Copyright (c) 2002-2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description: 
*
*/


// ========== INCLUDE FILES ===================================================

#include 
#include 
#include 
#include 

// ========== CONSTANTS =======================================================

UID2 KUidAppRegistrationResourceFile
UID3 AI_UID3_AIFW_EXE // Define your application UID here

// ========== RESOURCE DEFINITIONS ============================================

// ----------------------------------------------------------------------------
//
//
// ----------------------------------------------------------------------------
//
RESOURCE APP_REGISTRATION_INFO
    {
    app_file = "homescreen";
    localisable_resource_file = APP_RESOURCE_DIR"\\homescreen";
    localisable_resource_id = R_HOMESCREEN_LOCALISABLE_APP_INFO;
    
#ifdef RD_BOOT_CUSTOMIZABLE_AI
    // When Active Idle starts in boot, hide the app icon from Application Shell
    hidden = KAppIsHidden;
#endif    
    }

// End of File.
hs_app_main.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Entry point of Active Idle process.
*
*/


#include "ecom/ecom.h"
#include "hs_app_aifw.h"
#include "debug.h"

GLDEF_C TInt E32Main()
    {
    __TICK("FW: Entry point");
    __UHEAP_MARK;
#ifdef _DEBUG
    // Check heap and handle count balance in debug builds
    TInt initPhc, initThc;
    RThread().HandleCount(initPhc, initThc);
#endif

    // Create cleaup stack
    CTrapCleanup* cleanupStack = CTrapCleanup::New();
    if (!cleanupStack)
        {
        return KErrNoMemory;
        }
        
    // Create and run the Active Idle Framework
    TInt aiFwResult = KErrNone;
    TRAP( aiFwResult, 
        CAiFw* fw = CAiFw::NewLC();
        fw->RunL();
        CleanupStack::PopAndDestroy( fw );
        );

    // Clean up before exit
    delete cleanupStack;
    REComSession::FinalClose();

#ifdef _DEBUG
    // Check heap and handle count balance in debug builds
    TInt exitPhc, exitThc;
    RThread().HandleCount(exitPhc, exitThc);
    if ( exitThc != initThc )
        {
        __PRINT(__DBG_FORMAT("FW: Handle count mismatch %d at exit"), exitThc - initThc);
        }
#endif

    __UHEAP_MARKEND;
    __PRINT_IF_ERROR(aiFwResult, "FW: Framework exit with error %d");
    return aiFwResult;
    }

hs_app_aiidleappregister.cpp
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Active Idle <-> Phone app synchronizer implementation.
*
*/


#include "hs_app_aiidleappregisterimpl.h"
#include 
#include 
#include 

namespace 
	{
    _LIT_SECURITY_POLICY_C1( KTelephonyInformationReadPolicy, ECapabilityReadDeviceData );
    _LIT_SECURITY_POLICY_C1( KTelephonyInformationWritePolicy, ECapabilityWriteDeviceData );
    _LIT_SECURITY_POLICY_PASS( KTelephonyInformationPolicyAlwaysPass );

    const TInt KActOnSendKey = 1;
    
     TInt SetIdleAppPS()
        {
        return RProperty::Set( 
        	KPSUidAiInformation, 
            KActiveIdleUid, 
            AI_UID3_AIFW_EXE );
        }
        
     TInt DefineIdleAppPS()
        {
        return RProperty::Define( 
        	KPSUidAiInformation,
            KActiveIdleUid,
          	RProperty::EInt,
            KTelephonyInformationReadPolicy,
            KTelephonyInformationWritePolicy );
        }
     
     TInt DefineIdleStatePS()
     	{
        RProperty::Define( 
         	KPSUidAiInformation,
         	KActiveIdlePopupState,
         	RProperty::EInt,
         	KTelephonyInformationPolicyAlwaysPass,
         	KTelephonyInformationWritePolicy );
        return RProperty::Define( 
         	KPSUidAiInformation,
         	KActiveIdleState,
         	RProperty::EInt,
         	KTelephonyInformationPolicyAlwaysPass,
         	KTelephonyInformationWritePolicy );
     	}
     	
      TInt DefineIdleSendKeyPS()
        {
        return RProperty::Define( 
        	KPSUidAiInformation,
            KActiveIdleActOnSendKey,
          	RProperty::EInt,
            KTelephonyInformationReadPolicy,
            KTelephonyInformationWritePolicy );
        }
    TInt SetIdleSendKeyPS()
        {
        return RProperty::Set( 
        	KPSUidAiInformation, 
            KActiveIdleActOnSendKey, 
            KActOnSendKey );
        }    
        
      TInt DefineIdleSimRegFailedReceivedPS()
        {
        return RProperty::Define( 
        	KPSUidAiInformation,
            KActiveIdleSimRegFailedReceived,
          	RProperty::EInt,
            KTelephonyInformationReadPolicy,
            KTelephonyInformationWritePolicy );
        }

    TInt DefineIdleAI2RestartPS()
        {
        return RProperty::Define( 
        	KPSUidAiInformation,
            KActiveIdleRestartAI2,
          	RProperty::EInt,
            KTelephonyInformationReadPolicy,
            KTelephonyInformationWritePolicy );
        }
	TInt SetIdleAI2RestartPS()
        {
        return RProperty::Set( 
        	KPSUidAiInformation, 
            KActiveIdleRestartAI2, 
            0 );
        }
        
      TInt DefineIdleLaunchPS()
      	{
      	return RProperty::Define( 
        	KPSUidAiInformation,
        	KActiveIdleLaunch,
        	RProperty::EInt,
        	ECapabilityReadDeviceData,
        	ECapabilityWriteDeviceData );
      	}
      
      TInt DefineIdleSendNumKeysToPhonePS()
          {
          return RProperty::Define( 
              KPSUidAiInformation,
              KActiveIdleForwardNumericKeysToPhone,
              RProperty::EInt,
              ECapabilityReadDeviceData,
              ECapabilityWriteDeviceData );
          
          }
      
      TInt SetIdleSendNumKeysToPhonePS()
          {
          return RProperty::Set(KPSUidAiInformation,
                  KActiveIdleForwardNumericKeysToPhone,
                  EPSAiForwardNumericKeysToPhone);
          }
	}

CAiIdleAppRegisterImpl* CAiIdleAppRegisterImpl::NewLC()
    {
    CAiIdleAppRegisterImpl* self = new(ELeave) CAiIdleAppRegisterImpl;
    CleanupStack::PushL( self );
    return self;
    }

CAiIdleAppRegisterImpl::~CAiIdleAppRegisterImpl()
    {
    }

void CAiIdleAppRegisterImpl::RegisterL()
    {
    // Give own uid for phone.
    TInt setPSResult = SetIdleAppPS();
    if ( setPSResult == KErrNotFound )
        {
        // Key not defined yet -> try to define
        const TInt err = DefineIdleAppPS();
        if( err == KErrNone || err == KErrAlreadyExists )
            {
            // Try setting again
            setPSResult = SetIdleAppPS();
            }
        }
    
    DefineIdleSendKeyPS();
    
    DefineIdleSimRegFailedReceivedPS();
    
    DefineIdleLaunchPS();
    
    // Set the default value to 1 so the send key press is reacted
    SetIdleSendKeyPS();
    
    // Failure to set the telephony P&S key is fatal
    User::LeaveIfError( setPSResult );
    
    // Define idle state key
    DefineIdleStatePS();
    
    DefineIdleAI2RestartPS();
    
    SetIdleAI2RestartPS();
    
    DefineIdleSendNumKeysToPhonePS();
    
    SetIdleSendNumKeysToPhonePS();
    }

CAiIdleAppRegisterImpl::CAiIdleAppRegisterImpl()
    {
    }

EXPORT_C CAiIdleAppRegister* CAiIdleAppRegister::NewLC()
    {
    return CAiIdleAppRegisterImpl::NewLC();
    }
    
hs_app_aiidleappregisterimpl.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Active Idle <-> Phone app synchronizer implementation.
*
*/


#ifndef C_AIIDLEAPPREGISTERIMPL_H
#define C_AIIDLEAPPREGISTERIMPL_H

#include "hs_app_aiidleappregister.h"

/**
 * Idle application registration interface.
 */
NONSHARABLE_CLASS( CAiIdleAppRegisterImpl ) : public CAiIdleAppRegister
    {
public:
    static CAiIdleAppRegisterImpl* NewLC();
    ~CAiIdleAppRegisterImpl();

// from CAiIdleAppRegister
    void RegisterL();

private:    
// Construction
    CAiIdleAppRegisterImpl();
    };


#endif // C_AIIDLEAPPREGISTERIMPL_H

hs_app_aistate.cpp
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#include    "hs_app_aistate.h"
#include    "hs_app_aifwpanic.h"
#include    
#include    
#include    "debug.h"

CActiveIdleState::CActiveIdleState()
    {
    }

void CActiveIdleState::ConstructL()
    {
    iUpdater = 
        CIdle::NewL( CActive::EPriorityStandard );

    //for the sake of safe, this function is called here
    UpdateStateAsync();
    }

CActiveIdleState* CActiveIdleState::NewL()
    {
    CActiveIdleState* self = 
        new (ELeave) CActiveIdleState();
    
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop(self);

    return self;
    }

CActiveIdleState::~CActiveIdleState()
    {
    delete iUpdater;
    }

// -----------------------------------------------------------------------------
// CActiveIdleState::UpdateState
// -----------------------------------------------------------------------------
//
void CActiveIdleState::SetIsIdleForeground(
        TBool aIsForeground )
    {
    __PRINT( __DBG_FORMAT("XAI: CActiveIdleState::SetIsIdleForeground(%d), iIsIdleForeground=%d"), 
        aIsForeground, iIsIdleForeground );
    if ( iIsIdleForeground != aIsForeground )
        {
        iIsIdleForeground = aIsForeground;
        UpdateStateAsync();
        }
    }

// -----------------------------------------------------------------------------
// CActiveIdleState::UpdateStateAsync
// -----------------------------------------------------------------------------
//
void CActiveIdleState::UpdateStateAsync()
    {
    // Asynchronous change is done only when going to idle state.
    if ( iIsIdleForeground )
        {
        if ( !iUpdater->IsActive() )
            {
            iUpdater->Start( 
                TCallBack( DoUpdateState, this ) );
            }
        }
    else
        {
        iUpdater->Cancel();
        UpdateActiveIdleState();
        }
    }

// -----------------------------------------------------------------------------
// CActiveIdleState::UpdateActiveIdleState
// -----------------------------------------------------------------------------
//
void CActiveIdleState::UpdateActiveIdleState()
    {
    const EPSActiveIdleState state =
        iIsIdleForeground ? EPSAiForeground : EPSAiBackground;

    TInt setResult = 
        RProperty::Set(
            KPSUidAiInformation, 
            KActiveIdleState, 
            state );

    __PRINT( __DBG_FORMAT( "XAI: Set CActiveIdleState::UpdateActiveIdleState: KTelephonyIdleStatus=%d, P&S result=%d" ),
        TInt(state), setResult );
    }

// -----------------------------------------------------------------------------
// CActiveIdleState::DoUpdateSaSetting
// -----------------------------------------------------------------------------
//
TInt CActiveIdleState::DoUpdateState( TAny* aAny )
    {
    __ASSERT_DEBUG( aAny, AiFwPanic::Panic(AiFwPanic::EAiFwPanic_NullPointerReference ) );
    static_cast< CActiveIdleState* >( aAny )->UpdateActiveIdleState();
    return KErrNone;
    }

hs_app_aistate.h
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#ifndef C_ACTIVEIDLESTATE_H
#define C_ACTIVEIDLESTATE_H

#include 

/**
* @ingroup group_aiidleint
*
*  Update idle state flag in system agent
*
*  @since Series 60 2.8
*/
NONSHARABLE_CLASS(CActiveIdleState) : public CBase
    {
    public:  // Constructors and destructor

        /**
        * Two-phased constructor.
        * @param aSystemAgentProxy System Agent object.
        * @return Idle state monitor object.
        */
        static CActiveIdleState* NewL();

        /**
        * Destructor.
        */
        ~CActiveIdleState();
       
    public: // new function

        /**
        * Update the Idle state 
        */
        void SetIsIdleForeground( TBool aIsForeground );

    private:

        /**
        * C++ default constructor.
        */
        CActiveIdleState( );

        /**
        * Symbian OS constructor.
        */
        void ConstructL( );

        /**
        * Update setting asynchronously.
        */
        void UpdateStateAsync();

        /**
        * Update settings in System Agent.
        */
        void UpdateActiveIdleState();

        /**
        * Callback method, updates system agent setting.
        */
        static TInt DoUpdateState( TAny* aAny );
        
    private:    // Data
        // ETrue if system is in Idle state
        TBool iIsIdleForeground;

        // Owned idle callback to update.
        CIdle* iUpdater;

    };

#endif      // C_ACTIVEIDLESTATE_H

hs_app_aiuiidleintegration.cpp
/*
* Copyright (c) 2006-2007 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Window server plug-in manager.
*
*/


#include "hs_app_aiuiidleintegrationimpl.h"
#include "aifweventhandler.h"

#include 
#include 
#include 
#include 
#include 
#include 
#include  
#include 
#include  
#include 
#include 
#include 
#include 

#include "hs_app_aistate.h"
#include "hs_app_aifwpanic.h"
#include "activeidle2domainpskeys.h"

#include 

#include 

// ======== MEMBER FUNCTIONS ========

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::NewL()
// ----------------------------------------------------------------------------
//
CAiUiIdleIntegrationImpl* CAiUiIdleIntegrationImpl::NewL( CEikonEnv& aEikEnv,         
    const TAiIdleKeySoundConfig& aKeySoundConfig,
    MAiFwEventHandler* aAiFwEventHandler )
    {
    CAiUiIdleIntegrationImpl* self = 
        new ( ELeave ) CAiUiIdleIntegrationImpl( aEikEnv, aAiFwEventHandler );
                                              
    CleanupStack::PushL( self );
    self->ConstructL( aKeySoundConfig );
    CleanupStack::Pop( self );
    return self;
    }

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::~CAiUiIdleIntegrationImpl()
// ----------------------------------------------------------------------------
//
CAiUiIdleIntegrationImpl::~CAiUiIdleIntegrationImpl()
    {
    delete iActiveIdleState;
    
    delete iIncallBubble;
    
    Release( iSystemStateObserver );
    
    Release( iUiStartupStateObserver );
    
    Release( iCallStatusObserver );
    }

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::CAiUiIdleIntegrationImpl()
// ----------------------------------------------------------------------------
//
CAiUiIdleIntegrationImpl::CAiUiIdleIntegrationImpl( CEikonEnv& aEikEnv,
    MAiFwEventHandler* aAiFwEventHandler )
    : iEikEnv( aEikEnv ),
      iAiFwEventHandler( aAiFwEventHandler )
    {
    }

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::ConstructL()
// ----------------------------------------------------------------------------
//
void CAiUiIdleIntegrationImpl::ConstructL(
    const TAiIdleKeySoundConfig& aKeySoundConfig )       
    {   
	iIncallBubble = CAknIncallBubble::NewL();
	
    iActiveIdleState = CActiveIdleState::NewL();
           
    // Set up keysounds
    if( aKeySoundConfig.iKeySounds )
        {
        aKeySoundConfig.iKeySounds
            ->PushContextL( aKeySoundConfig.iContextResId );            
        }
    
    // Set Active Idle application to be system application and disable
    // priority switching performed by window server.
    iEikEnv.SetSystem( ETrue );
    iEikEnv.WsSession().ComputeMode( RWsSession::EPriorityControlDisabled ); 
             
    // Eikon server window group
    iThisApplicationWgId = iEikEnv.RootWin().Identifier();

    iEikEnv.RootWin().EnableFocusChangeEvents(); 
    iEikEnv.RootWin().EnableGroupChangeEvents();
    
    CApaWindowGroupName::FindByAppUid( KAknCapServerUid, 
                                       iEikEnv.WsSession(), 
                                       iEikonServerWgId );
	           
    iActiveIdleState->SetIsIdleForeground( iThisApplicationForeground );
      
    iSystemStateObserver = AiUtility::CreatePSPropertyObserverL(                      
                            TCallBack( HandleSystemStateChange, this ),            
                                       KPSUidStartup, 
                                       KPSGlobalSystemState );
              
    iUiStartupStateObserver = AiUtility::CreatePSPropertyObserverL(                           
                                TCallBack( HandleUiStartupStateChange, this ),            
                                           KPSUidStartup, 
                                           KPSStartupUiPhase );        
                 
    iCallStatusObserver = AiUtility::CreatePSPropertyObserverL(          
                            TCallBack( HandleCallEvent, this ),  
                                       KPSUidCtsyCallInformation, 
                                       KCTsyCallState );  
    
    // Update state flags.    
    CAiUiIdleIntegrationImpl::HandleSystemStateChange( this );
    CAiUiIdleIntegrationImpl::HandleUiStartupStateChange( this );
    }

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::ActivateUI()
// ----------------------------------------------------------------------------
//
void CAiUiIdleIntegrationImpl::ActivateUI()
    {       
    if( iUiStartupPhaseOk && iSystemStateOk )
        {      
        RWsSession& wsSession( iEikEnv.WsSession() );
        
        TInt focusWgId( wsSession.GetFocusWindowGroup() );
        
        if( iThisApplicationWgId != focusWgId )
            {                       
            TApaTaskList taskList( wsSession );
            
            TApaTask task( taskList.FindApp( TUid::Uid( AI_UID3_AIFW_EXE ) ) );
            
            task.SendSystemEvent( EApaSystemEventBroughtToForeground );            
            }

        iAiFwEventHandler->HandleActivateUI();
        }    
    }

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::HandleWsEventL()
// ----------------------------------------------------------------------------
//
void CAiUiIdleIntegrationImpl::HandleWsEventL( const TWsEvent& aEvent, 
    CCoeControl* /*aDestination*/ )
    {
    if( !iSystemStateOk || !iUiStartupPhaseOk )
        {                
        return;
        }
      
    switch ( aEvent.Type() )
    	{
    	case KAknFullOrPartialForegroundGained:	
        	{
            if ( !iThisApplicationForeground )
            	{
                iThisApplicationForeground = ETrue;
                iActiveIdleState->SetIsIdleForeground( ETrue );
               	SetCallBubbleIfNeededL();
                }
          	break;
        	}
                
        case KAknFullOrPartialForegroundLost:
        	{
        	if ( iThisApplicationForeground )
            	{
            	iThisApplicationForeground = EFalse;
                iActiveIdleState->SetIsIdleForeground( EFalse );
                ClearCallBubbleL();
                }
        	break;
        	}
        
    	case EEventKeyDown:
    	    {
            if( aEvent.Key()->iScanCode == EStdKeyDevice0 )
            	{
            	TBool isDialog( iEikEnv.AppUi()->IsDisplayingMenuOrDialog() );
            	
            	if( isDialog || iAiFwEventHandler->QueryIsMenuOpen() )
            	    {
                    RProperty::Set(
                        KPSUidAiInformation, 
                        KActiveIdlePopupState, 
                        EPSAiDisplayingMenuOrDialog );
            	    }
            	else
            	    {
                    RProperty::Set(
                        KPSUidAiInformation, 
                        KActiveIdlePopupState, 
                        EPSAiNotDisplayingMenuOrDialog );
            	    }
            	} 
    	    break;
    	    }
                
    	default:
    	    {
    		break;
    	    }
    	}
    }

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::SetCallBubbleIfNeededL()
// ----------------------------------------------------------------------------
//
void CAiUiIdleIntegrationImpl::SetCallBubbleIfNeededL()
	{
    if( !iIncallBubbleAllowed )
    	{
        TInt callStatus( 0 );
            	
        TInt err( RProperty::Get( KPSUidCtsyCallInformation,
                                  KCTsyCallState,
                                  callStatus ) );
        
        // Call ongoing => show bubble
	  	if( err == KErrNone && callStatus > EPSCTsyCallStateNone )
	      	{
	       	iIncallBubble->SetIncallBubbleAllowedInIdleL( ETrue );                	
	       	iIncallBubbleAllowed = ETrue;
	       	}    
    	}
	}

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::ClearCallBubbleL()
// ----------------------------------------------------------------------------
//
void CAiUiIdleIntegrationImpl::ClearCallBubbleL()
	{
	 if( iIncallBubbleAllowed )
    	{
    	iIncallBubble->SetIncallBubbleAllowedInIdleL( EFalse );
    	iIncallBubbleAllowed = EFalse;
    	}        
	}
    
// ----------------------------------------------------------------------------
// CAiUiIdleIntegration::NewL()
// ----------------------------------------------------------------------------
//
EXPORT_C CAiUiIdleIntegration* CAiUiIdleIntegration::NewL( CEikonEnv& aEikEnv, 
    const TAiIdleKeySoundConfig& aKeySoundConfig,
    MAiFwEventHandler* aAiFwEventHandler )
    {
    return CAiUiIdleIntegrationImpl::NewL( aEikEnv, aKeySoundConfig,                                             
                                           aAiFwEventHandler );
    }

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::HandleSystemStateChange()
// ----------------------------------------------------------------------------
//
TInt CAiUiIdleIntegrationImpl::HandleSystemStateChange( TAny* aPtr )
    {
    __ASSERT_DEBUG( aPtr, 
            AiFwPanic::Panic( AiFwPanic::EAiFwPanic_NullPointerReference ) );
    
    CAiUiIdleIntegrationImpl* self = 
        static_cast( aPtr );
           
    if( !self->iSystemStateOk )
        {
        TInt state( 0 );
        
        self->iSystemStateObserver->Get( state );               

        if ( state == ESwStateCriticalPhaseOK ||
             state == ESwStateNormalRfOn || 
             state == ESwStateNormalRfOff ||
             state == ESwStateNormalBTSap )        
            {
            self->iSystemStateOk = ETrue;            
            self->ActivateUI();
            }        
        }
              
    return KErrNone;
    }

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::HandleUiStartupStateChange()
// ----------------------------------------------------------------------------
//
TInt CAiUiIdleIntegrationImpl::HandleUiStartupStateChange( TAny *aPtr )
    {
    __ASSERT_DEBUG( aPtr, 
            AiFwPanic::Panic( AiFwPanic::EAiFwPanic_NullPointerReference ) );
    
    CAiUiIdleIntegrationImpl* self = 
        static_cast( aPtr );

    if( !self->iUiStartupPhaseOk )
        {
        TInt state( 0 );
        
        self->iUiStartupStateObserver->Get( state );
        
        if( state == EStartupUiPhaseAllDone )
            {
            self->iUiStartupPhaseOk = ETrue;
            
            self->ActivateUI();
            }
        }
    
    return KErrNone;
    }

// ----------------------------------------------------------------------------
// CAiUiIdleIntegrationImpl::HandleCallEvent()
// ----------------------------------------------------------------------------
//
TInt CAiUiIdleIntegrationImpl::HandleCallEvent( TAny* aPtr )
	{
	__ASSERT_DEBUG( aPtr, 
	        AiFwPanic::Panic( AiFwPanic::EAiFwPanic_NullPointerReference ) );
    
	CAiUiIdleIntegrationImpl* self = 
        static_cast( aPtr );
        
	TInt callStatus( EPSCTsyCallStateNone );
	
	TInt err( self->iCallStatusObserver->Get( callStatus ) );
	
	if( err == KErrNone )
		{
		// Call ongoing => show bubble if not showing already
		TBool allowed = EFalse;
		
		if( !self->iIncallBubbleAllowed &&
		     self->iThisApplicationForeground &&
		    ( callStatus > EPSCTsyCallStateNone ) )
			{
			allowed = ETrue;
    		
			TRAP( err, 
                self->iIncallBubble->SetIncallBubbleAllowedInIdleL( allowed ) );
			        
    		
			if( err == KErrNone )
    		    {
    			self->iIncallBubbleAllowed = allowed;
    		    }
			}
		// No call ongoing => hide if bubble is visible			
		else if( self->iIncallBubbleAllowed && callStatus <= EPSCTsyCallStateNone )
			{
			allowed = EFalse;
			
    		TRAP( err, 
                self->iIncallBubble->SetIncallBubbleAllowedInIdleL( allowed ) );
    		
    		if( err == KErrNone )
    		    {
    			self->iIncallBubbleAllowed = allowed;
    		    }
			}
		}
	
	return err;
	}

// End of file.

hs_app_aiuiidleintegrationimpl.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Active Idle main UI Controller idle integration.
*
*/


#ifndef C_AIUIIDLEINTEGRATIONIMPL_H
#define C_AIUIIDLEINTEGRATIONIMPL_H

#include "aiuiidleintegration.h"
#include 

class CActiveIdleState;
class CAknIncallBubble;
class MAiPSPropertyObserver;
class MAiFwEventHandler;

/**
 * CAiUiIdleIntegration implementation.
 */
NONSHARABLE_CLASS( CAiUiIdleIntegrationImpl ) : public CAiUiIdleIntegration
    {
public: // constructor and destructor
    
    static CAiUiIdleIntegrationImpl* NewL( CEikonEnv& aEikEnv,         
                const TAiIdleKeySoundConfig& aKeySoundConfig,
                MAiFwEventHandler* aAiFwEventHandler );

    ~CAiUiIdleIntegrationImpl();

public: // new functions
        
    void HandleWsEventL( const TWsEvent& aEvent, 
                         CCoeControl* aDestination );

private: // constructors
    
    CAiUiIdleIntegrationImpl(CEikonEnv& aEikEnv,
                             MAiFwEventHandler* aAiFwEventHandler);
    void ConstructL(const TAiIdleKeySoundConfig& aKeySoundConfig);

private: // new functions
    
    void ActivateUI();
    
    void SetCallBubbleIfNeededL();
    void ClearCallBubbleL();
           
    static TInt HandleSystemStateChange( TAny *aPtr );
    static TInt HandleUiStartupStateChange( TAny *aPtr );
    static TInt HandleCallEvent( TAny *aPtr );
    
private: // data  

    CEikonEnv& iEikEnv;  
    CActiveIdleState* iActiveIdleState;
    TBool iThisApplicationForeground;
    TBool iIncallBubbleAllowed;
    TInt iThisApplicationWgId;
    TInt iEikonServerWgId;
    CAknIncallBubble* iIncallBubble;

    /**
     * Observer for system state Publish&Subscribe key.
     * Owned.
     */
    MAiPSPropertyObserver* iSystemStateObserver;

    /**
     * Observer for system state Publish&Subscribe key.
     * Owned.
     */
    MAiPSPropertyObserver* iUiStartupStateObserver;

    /**
    * Observer telephony state
    * Owned
    */
    MAiPSPropertyObserver* iCallStatusObserver;
    /**
     * Framework event handler. For notifying critical startup over.
     * Not owned.
     */
    MAiFwEventHandler* iAiFwEventHandler;
    
    TBool iSystemStateOk;
    TBool iUiStartupPhaseOk;
    };


#endif // C_AIUIIDLEINTEGRATION_H

hs_app_aiwspluginanim.inl
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Inline implementation for Window server plug-in manager.
*
*/



#ifndef AIWSPLUGINANIM_H
#define AIWSPLUGINANIM_H

#include    
#include    "hs_app_aiwspluginanimdef.h"

class RAiWsPluginAnim : public RAnim
    {
    public: // constructor
    
        /**
        * c++ constructor
        * @param aDll
        */
        inline RAiWsPluginAnim( RAnimDll &aDll ) : RAnim( aDll ) {}
        
        
        /**
        * Constructor
        * @param aDevice a window device
        * @param aIdleWg window group id of idle application
        * @param aConsumerWg window group id of the application handling
        *        numeric keys on behalf of idle.
        */
        inline TInt Construct( 
        	const RWindowBase& aDevice, 
            TInt aIdleWg, 
            TInt aConsumerWg )
        	{
        	TPckgBuf init;
		    init().iAiWgId = aIdleWg;
		    init().iTargetWgId = aConsumerWg;
		 
		    return RAnim::Construct( aDevice, EAnimKeyForward, init );
        	}

    };

#endif // AIWSPLUGINANIM_H
hs_app_aiwspluginmanager.cpp
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Window server plug-in manager.
*
*/


#include "hs_app_aiwspluginmanagerimpl.h"
#include 
#include 
#include 
#include 
#include 

CAiWsPluginManagerImpl::CAiWsPluginManagerImpl(RWsSession& aWsSession) :
    iAnimDll( aWsSession ),
    iWnd( aWsSession ),
    iAnim( iAnimDll )
    {
    }

void CAiWsPluginManagerImpl::ConstructL(CCoeEnv& aCoeEnv)
    {
    User::LeaveIfError( iAnimDll.Load( KAiWsPluginAnimDllName ) );
    iCoeEnv = &aCoeEnv;
    iPhoneStatusObserver = AiUtility::CreatePSPropertyObserverL
        ( TCallBack( HandlePhoneEvent, this ),
            KPSUidTelInformation, KTelPhoneUid );
    TryLoadWsPluginL();
    }

CAiWsPluginManagerImpl* CAiWsPluginManagerImpl::NewL( CCoeEnv& aCoeEnv )
    {
    CAiWsPluginManagerImpl* self = 
        new(ELeave) CAiWsPluginManagerImpl( aCoeEnv.WsSession() );
    CleanupStack::PushL( self );
    self->ConstructL( aCoeEnv );
    CleanupStack::Pop( self );
    return self;
    }

CAiWsPluginManagerImpl::~CAiWsPluginManagerImpl()
    {
    iAnim.Close();
    iWnd.Close();
    Release( iPhoneStatusObserver );
    iAnimDll.Close();
    }

EXPORT_C CAiWsPluginManager* CAiWsPluginManager::NewL
        (CCoeEnv& aCoeEnv)
    {
    return CAiWsPluginManagerImpl::NewL(aCoeEnv);
    }

TInt CAiWsPluginManagerImpl::HandlePhoneEvent( TAny* aPtr )
	{
    CAiWsPluginManagerImpl* self = 
        static_cast( aPtr );
    TInt err = KErrNone;
    if( self )
        {
        TRAP( err, self->TryLoadWsPluginL() );
        }
    return err;
	}
	
void CAiWsPluginManagerImpl::TryLoadWsPluginL()
    {
    TInt phoneUidVal;
    iPhoneStatusObserver->Get( phoneUidVal );
    const TUid phoneUid = TUid::Uid( phoneUidVal );
    
    if ( phoneUid != KNullUid )
        {
	    RWsSession& wsSession = iCoeEnv->WsSession();
		TApaTaskList taskList( wsSession );
		TApaTask phoneTask( taskList.FindApp( phoneUid ) );
		if ( phoneTask.Exists() )
			{
            iAnim.Close();
            iWnd.Close();
        
         	RWindowGroup& aiRootWg = iCoeEnv->RootWin();
    	    // RWindow::Construct requires a unique non-null handle. Active Idle
    	    // does not care about the handle value and just uses this pointer to have
    	    // something non-null.
    	    const TUint32 dummyHandle = reinterpret_cast(this);
  	        User::LeaveIfError( iWnd.Construct(aiRootWg, dummyHandle ) );

    	    const TInt aiWgId = aiRootWg.Identifier();
    	    const TInt phoneWgId = phoneTask.WgId();
    	    User::LeaveIfError( iAnim.Construct( iWnd, aiWgId, phoneWgId ) );
    	    
    	    // No need to monitor Phone app status anymore
    	    Release( iPhoneStatusObserver );
    	    iPhoneStatusObserver = NULL;
			}
	    }
    }
    
hs_app_aiwspluginmanagerimpl.h
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Window server plug-in manager.
*
*/


#ifndef C_AIWSPLUGINMANAGERIMPL_H
#define C_AIWSPLUGINMANAGERIMPL_H

#include "hs_app_aiwspluginmanager.h"
#include "hs_app_aiwspluginanimdef.h"
#include "hs_app_aiwspluginanim.inl"

class CCoeEnv;
class RWsSession;
class MAiPSPropertyObserver;

/**
 * Attaches Active Idle as the default idle app for Phone application.
 */
NONSHARABLE_CLASS( CAiWsPluginManagerImpl ) : public CAiWsPluginManager
    {
public:
    static CAiWsPluginManagerImpl* NewL(CCoeEnv& aCoeEnv);
    ~CAiWsPluginManagerImpl();

private:    
// Construction
    CAiWsPluginManagerImpl(RWsSession& aWsSession);
    void ConstructL(CCoeEnv& aCoeEnv);
    
private:
    void TryLoadWsPluginL();
	static TInt HandlePhoneEvent( TAny* aPtr );

private: // data
    RAnimDll        iAnimDll;
    RWindow         iWnd;
    RAiWsPluginAnim iAnim;
    CCoeEnv* 				iCoeEnv;  					
    MAiPSPropertyObserver* 	iPhoneStatusObserver;
    };


#endif // C_AIWSPLUGINMANAGERIMPL_H

hs_app_aipluginsettingsimpl.cpp
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#include "hs_app_aipluginsettingsimpl.h"
#include "hs_app_aipluginsettingsitemimpl.h"

// ============================================================================
// Class CAiPluginSettings
// ============================================================================

CAiPluginSettings* CAiPluginSettings::NewL()
    {
    CAiPluginSettings* self = new (ELeave) CAiPluginSettings();

    CleanupStack::PushL(self);
    self->ConstructL();
    CleanupStack::Pop(self);

    return self;
    }

MAiPluginSettingsItem& CAiPluginSettings::AiPluginSettingsItem()
    {
    iItemType = 0;
    return *iSettingsItem;
    }

void CAiPluginSettings::ConstructL()
    {
    iSettingsItem = new (ELeave) CAiPluginSettingsItem();
    iSettingsItem->ConstructL();
    }

CAiPluginSettings::CAiPluginSettings(): iItemType( 0 )
    {
    }

CAiPluginSettings::~CAiPluginSettings()
    {
    delete iSettingsItem;
    }

TInt CAiPluginSettings::AiPluginItemType()
    {
    return iItemType;
    }

MAiPluginContentItem& CAiPluginSettings::AiPluginContentItem()
    {
    iItemType = 1;
    return *iSettingsItem;
    }

MAiPluginConfigurationItem& CAiPluginSettings::AiPluginConfigurationItem()
    {
    iItemType = 2;
    return *iSettingsItem;
    }

// ============================================================================
// Class CAiPluginSettingsItem
// ============================================================================

CAiPluginSettingsItem::CAiPluginSettingsItem()
  : iKey( KErrNotFound )
    {
    }

void CAiPluginSettingsItem::ConstructL()
    {
    iValue = HBufC::NewL(KMaxSettingsValueStringLength);
    }

CAiPluginSettingsItem::~CAiPluginSettingsItem()
    {
    delete iValue;
    delete iName;
    delete iType;
    delete iOwner;
    }

TPtrC CAiPluginSettingsItem::Value()
    {
    if (iValue)
        {
        return TPtrC(*iValue);
        }
    else
        {
        return TPtrC();
        }
    }

void CAiPluginSettingsItem::SetValueL(const TDesC& aValue, TBool /*aSaveToStore*/)
    {
  
    delete iValue;
    iValue = NULL;
    iValue = aValue.AllocL();
    }

const TUid& CAiPluginSettingsItem::PublisherId() const
    {
    return iPublisherId;
    }

void CAiPluginSettingsItem::SetPublisherId(const TUid& aUid)
    {
    iPublisherId = aUid;
    }

TInt32 CAiPluginSettingsItem::Key() const
    {
    return iKey;
    }

void CAiPluginSettingsItem::SetKey(TInt32 aKey)
    {
    iKey = aKey;
    }

void CAiPluginSettingsItem::SetStorer(MAiPluginSettingsStorer* aStorer)
    {
    iStorer = aStorer;
    }

void CAiPluginSettingsItem::ReadFromStoreL()
    {
    if (iStorer)
        {
        TPtr ptr = iValue->Des();
        iStorer->ReadL(iKey, ptr);
        }
    }

void CAiPluginSettingsItem::SaveToStoreL()
    {
    if (iStorer)
        {
        iStorer->SaveL(iKey, *iValue);
        }
    }


void CAiPluginSettingsItem::SetValueL( const TDesC& aValue )
    {
    delete iValue;
    iValue = NULL;
    iValue = aValue.AllocL();
    }

void CAiPluginSettingsItem::SetNameL( const TDesC& aName )
    {
    delete iName;
    iName = NULL;
    iName = aName.AllocL();
    }

void CAiPluginSettingsItem::SetTypeL( const TDesC& aType )
    {
    delete iType;
    iType = NULL;
    iType = aType.AllocL();
    }

TPtrC CAiPluginSettingsItem::Name()
    {
    if ( iName )
        {
        return TPtrC( *iName );
        }
    else
        {
        return TPtrC();
        }
    }

TPtrC CAiPluginSettingsItem::Type()
    {
    if ( iType )
        {
        return TPtrC( *iType );
        }
    else
        {
        return TPtrC();
        }
    }

TPtrC CAiPluginSettingsItem::Owner()
    {
    if ( iOwner )
        {
        return TPtrC( *iOwner );
        }
    else
        {
        return TPtrC();
        }
    }
    
void CAiPluginSettingsItem::SetOwnerL( const TDesC& aOwner )
    {
    delete iOwner;
    iOwner = NULL;
    iOwner = aOwner.AllocL();
    }
hs_app_aiutility.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#include "aiutility.h"
#include "hs_app_caipspropertyobserver.h"
#include "hs_app_caistrparser.h"
#include "hs_app_caicontentitemarrayiterator.h"
#include "hs_app_aipluginsettingsimpl.h"
#include "hs_app_caiplugintool.h"

EXPORT_C MAiPSPropertyObserver* AiUtility::CreatePSPropertyObserverL(
                                            TCallBack aCallBack,
                                            TUid aCategory,
                                            TInt aKey )
	{	
	return CPSPropertyObserver::NewL( aCallBack, aCategory, aKey );	
	}
	
EXPORT_C MAiStrParser* AiUtility::CreateStrParserL()
	{	
	return CStrParser::NewL();	
	}
	
EXPORT_C MAiContentItemIterator* AiUtility::CreateContentItemArrayIteratorL(
                                            const TAiContentItem* aArray,
                                            TInt aCount )
	{
	return CAiContentItemArrayIterator::NewL( aArray, aCount );
	}

EXPORT_C MAiPluginSettings* AiUtility::CreatePluginSettingsL()
	{
	return CAiPluginSettings::NewL();
	}

EXPORT_C MAiPluginTool* AiUtility::CreatePluginToolL()
	{
	return CAiPluginTool::NewL();
	}
	
   
	
// End of File.
hs_app_caicontentitemarrayiterator.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#include "hs_app_caicontentitemarrayiterator.h"

CAiContentItemArrayIterator::CAiContentItemArrayIterator(
                                        const TAiContentItem* aArray,
                                        TInt aCount )
  : iArray( aArray ),
    iCount( aCount ),
    iIndex( 0 )
    {
    }

CAiContentItemArrayIterator* CAiContentItemArrayIterator::NewL(
                                        const TAiContentItem* aArray,
                                        TInt aCount )
	{
    CAiContentItemArrayIterator* self =
                        new( ELeave ) CAiContentItemArrayIterator( aArray, aCount );
    return self;
    }

CAiContentItemArrayIterator::~CAiContentItemArrayIterator()
    {
    }

void CAiContentItemArrayIterator::Release()
	{
	delete this;
	}

TBool CAiContentItemArrayIterator::HasNext() const
    {
    return ( iIndex < iCount );
    }

const TAiContentItem& CAiContentItemArrayIterator::NextL()
    {
    if ( iIndex >= iCount )
        {
        User::Leave( KErrOverflow );
        }
        
    return iArray[iIndex++];      
    }


const TAiContentItem& CAiContentItemArrayIterator::ItemL( TInt aId ) const
    {
    TInt i;
    
    for ( i = 0; i < iCount; ++i )
        {
        if ( iArray[i].id == aId )
            {
            break;
            }
        }

    if ( i >= iCount )
    	{
    	User::Leave( KErrNotFound );
    	}
    
    return iArray[i];
    }

const TAiContentItem& CAiContentItemArrayIterator::ItemL( const TDesC& aCid ) const
    {
    TInt i;
    
    for ( i = 0; i < iCount; ++i )
        {
        if ( ContentCid( iArray[i] ) == aCid )
            {
            break;
            }
        }
	
	if ( i >= iCount )
    	{
    	User::Leave( KErrNotFound );
    	}

	return iArray[i];
    }


void CAiContentItemArrayIterator::Reset()
    {
    iIndex = 0;
    }

hs_app_caiplugintool.cpp
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Collection of content plugin helper functions
*
*/


#include 
#include "hs_app_caiplugintool.h"

CAiPluginTool::CAiPluginTool()
    {
    }

CAiPluginTool* CAiPluginTool::NewL()
    { 
    CAiPluginTool* self = new ( ELeave ) CAiPluginTool();
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }

void CAiPluginTool::ConstructL()
    {
    }

void CAiPluginTool::Release()
    {
    delete this;
    }
    
const TAiPublisherInfo* CAiPluginTool::PublisherInfoL(
                                        CAiContentPublisher& aContentPublisher )
    {
    const TAiPublisherInfo* result = NULL;
    MAiPropertyExtension* propExt = PropertyExt( aContentPublisher );
    if ( propExt )
        {
        result = propExt->PublisherInfoL();
        }
    return result;
    }
    
MAiContentItemIterator* CAiPluginTool::ContentItemIteratorL(
                                        CAiContentPublisher& aContentPublisher,
                                        TInt aContentType )
    {
    MAiContentItemIterator* result = NULL;
    MAiPropertyExtension* propExt = PropertyExt( aContentPublisher );
    if ( propExt )
        {
        TAny* prop = NULL;
        prop = propExt->GetPropertyL( aContentType );
        if ( prop )
            {
            result = static_cast( prop );
            }
        }
    return result;
    }
    
MAiPropertyExtension* CAiPluginTool::PropertyExt(
                                        CAiContentPublisher& aContentPublisher )
    {
    return static_cast(
                        aContentPublisher.Extension( KExtensionUidProperty ) );
    }

MAiEventHandlerExtension* CAiPluginTool::EventHandlerExt(
                                        CAiContentPublisher& aContentPublisher )
    {
    return static_cast(
                        aContentPublisher.Extension( KExtensionUidEventHandler ) );
    }

 // End of File.


hs_app_caipspropertyobserver.cpp
/*
* Copyright (c) 2005-2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Publish and subscribe parameter observer implementation.
*
*/


#include "hs_app_caipspropertyobserver.h"

// ---------------------------------------------------------------------------
// void ConstructL( TCallBack aCallBack, TUid aCategory, TInt aKey )
// ---------------------------------------------------------------------------
//
void CPSPropertyObserver::ConstructL()
    {
    User::LeaveIfError( iProperty.Attach( iCategory, iKey ) );
    CActiveScheduler::Add( this );

    iProperty.Subscribe( iStatus );
    SetActive();
    }

// ---------------------------------------------------------------------------
// CPSPropertyObserver()
// ---------------------------------------------------------------------------
//
CPSPropertyObserver::CPSPropertyObserver( TCallBack aCallBack,
                                          TUid aCategory,
                                          TInt aKey )
  : CActive( EPriorityStandard ),
    iCallBack( aCallBack ),
    iCategory( aCategory ),
    iKey( aKey )
    {
    }
    
// ---------------------------------------------------------------------------
// CPSPropertyObserver* NewL( TCallBack aCallBack, TUid aCategory, TInt aKey )
// ---------------------------------------------------------------------------
//
CPSPropertyObserver* CPSPropertyObserver::NewL( TCallBack aCallBack,
                                                TUid aCategory,
                                                TInt aKey )
    { 
    CPSPropertyObserver* self = new ( ELeave ) CPSPropertyObserver( aCallBack,
                                                                    aCategory,
                                                                    aKey );
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }
    
// ---------------------------------------------------------------------------
// ~CPSPropertyObserver()
// ---------------------------------------------------------------------------
//
CPSPropertyObserver::~CPSPropertyObserver()
    {
    if( IsAdded() )
        {
        Deque();
        }
    iProperty.Close();
    }
    
// ---------------------------------------------------------------------------
// void Release()
// ---------------------------------------------------------------------------
//
void CPSPropertyObserver::Release()
    {
    delete this;
    }
    
// ---------------------------------------------------------------------------
// void RunL()
// ---------------------------------------------------------------------------
//
void CPSPropertyObserver::RunL()
    {
    // resubscribe before processing new value to prevent missing updates.
    iProperty.Subscribe( iStatus );
    SetActive();

    // property updated, get new value.
    TInt propval;
    if ( iProperty.Get( iCategory, iKey, propval ) != KErrNotFound )
        {
        iCallBack.CallBack();
        }
    }

// ---------------------------------------------------------------------------
// void DoCancel()
// ---------------------------------------------------------------------------
//
void CPSPropertyObserver::DoCancel()
    {
    iProperty.Cancel();
    }

// ---------------------------------------------------------------------------
// TInt Get( TInt& aValue )
// ---------------------------------------------------------------------------
//
TInt CPSPropertyObserver::Get( TInt& aValue )
    { 
	TInt error = iProperty.Get( iCategory, iKey, aValue );

    return error;
    }
    
// ---------------------------------------------------------------------------
// TInt Get( TDes8& aString )
// ---------------------------------------------------------------------------
//
TInt CPSPropertyObserver::Get( TDes8& aString )
	{ 
	TInt error = iProperty.Get( iCategory, iKey, aString );
    return error;
    }

// ---------------------------------------------------------------------------
// TInt Get( TDes16& aString )
// ---------------------------------------------------------------------------
//
TInt CPSPropertyObserver::Get( TDes16& aString )
    { 
	TInt error = iProperty.Get( iCategory, iKey, aString );
    return error;
    }

// ========== OTHER EXPORTED FUNCTIONS ========================================

// End of File.
hs_app_caistrparser.cpp
/*
* Copyright (c) 2005 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  Collection of string parsing methods.
*
*/


#include "hs_app_caistrparser.h"
#include "aistrcnv.h"

// CONSTANTS

const TInt KThreeOctets = 3;
const TInt KTwoOctets = 2;

namespace
    {
    
    _LIT8( KHexPrefix8, "0x" );
    _LIT16( KHexPrefix16, "0x" );
    
    const TInt KMaxOneOctetValue = 0x007F;
    const TInt KMaxTwoOctetValue = 0x07FF;
    
    TInt Utf8OctetCount( const TDesC16& aString )
    	{
        TInt numOctets(0);
        TInt length(aString.Length());
        const TUint16* stringData = aString.Ptr();
            
       	for ( TInt i = 0; i < length; ++i)
        	{
            if (stringData[i] > KMaxOneOctetValue)
            	{
                if (stringData[i] > KMaxTwoOctetValue)
                	{
                    numOctets += KThreeOctets;
                    }
               	else
                    {
                    numOctets += KTwoOctets;
                    }
                }
           	else
               	{
                ++numOctets;
                }
            }
                
      	return numOctets;
       	}
    
    TPtr8 EnsureBufMaxLengthL(HBufC8*& aBuffer, TInt aMaxLength )
        {
        if ( !aBuffer )
            {
            aBuffer = HBufC8::NewL( aMaxLength );
            }
        else if ( aBuffer->Des().MaxLength() < aMaxLength )
            {
            aBuffer = aBuffer->ReAllocL( aMaxLength );
            }
            
        return aBuffer->Des();
        }
    
    }

namespace AiUtility
    {
    
template< class DescType, class LexType > inline
TInt ParseIntImpl
        ( TInt32& aValue, const DescType& aStringValue, 
        const DescType& aHexPrefix )
    {
    const TInt pos = aStringValue.FindF( aHexPrefix );
    if (pos != KErrNotFound)
        {
        LexType lex( aStringValue.Mid( pos + aHexPrefix.Length() ) );
        // Hex parsing needs unsigned int
        TUint32 value = 0;
        const TInt parseResult = lex.Val( value, EHex );
        if ( parseResult == KErrNone )
            {
            aValue = value;
            }
        return parseResult;
        }
    else
        {
        LexType lex( aStringValue );
        return lex.Val(aValue);
        }
    }

EXPORT_C TInt ParseInt( TInt32& aResult, const TDesC8& aSourceString )
    {
    return ParseIntImpl< TDesC8, TLex8 >
        ( aResult, aSourceString, KHexPrefix8 );
    }
	
EXPORT_C TInt ParseInt( TInt32& aResult, const TDesC16& aSourceString )
    {
    return ParseIntImpl< TDesC16, TLex16 >
        ( aResult, aSourceString, KHexPrefix16 );
    }
	
EXPORT_C HBufC16* CopyToBufferL(HBufC16* aTargetBuffer, const TDesC16& aSourceText)
    {
    EnsureBufMaxLengthL( aTargetBuffer, aSourceText.Length() ).Copy( aSourceText );
    
    return aTargetBuffer;
    }
    
EXPORT_C HBufC16* CopyToBufferL(HBufC16* aTargetBuffer, const TDesC8& aSourceText)
    {
    if (!aTargetBuffer)
        {
        return CnvUtfConverter::ConvertToUnicodeFromUtf8L( aSourceText );
        }
        
    TPtr16 des( EnsureBufMaxLengthL( aTargetBuffer, aSourceText.Length() ) );
    
    CnvUtfConverter::ConvertToUnicodeFromUtf8( des, aSourceText );
    
    return aTargetBuffer;
    }
    
EXPORT_C HBufC8* CopyToBufferL(HBufC8* aTargetBuffer, const TDesC8& aSourceText)
    {
    ::EnsureBufMaxLengthL( aTargetBuffer, aSourceText.Length() ).Copy( aSourceText );
    return aTargetBuffer;
    }

EXPORT_C HBufC8* CopyToBufferL(HBufC8* aTargetBuffer, const TDesC16& aSourceText)
    {
    if ( !aTargetBuffer )
        {
        return CnvUtfConverter::ConvertFromUnicodeToUtf8L( aSourceText );
        }
    
    TInt length = Utf8OctetCount( aSourceText );
    
    TPtr8 des( ::EnsureBufMaxLengthL( aTargetBuffer, length ) );    
    CnvUtfConverter::ConvertFromUnicodeToUtf8( des, aSourceText );
    return aTargetBuffer;
    }
    
EXPORT_C TPtr16 EnsureBufMaxLengthL(HBufC16*& aTargetBuffer, TInt aMaxLength )
    {
    if ( !aTargetBuffer )
        {
        aTargetBuffer = HBufC16::NewL( aMaxLength );
        }
    else
        {
        if ( aTargetBuffer->Des().MaxLength() < aMaxLength )
            {
            aTargetBuffer = aTargetBuffer->ReAllocL( aMaxLength );
            }
        }
        
    return aTargetBuffer->Des();
    }

    }


// ---------------------------------------------------------------------------
// CStrParser()
// ---------------------------------------------------------------------------
//
CStrParser::CStrParser()
    {
    }

// ---------------------------------------------------------------------------
// CStrParser* NewL()
// ---------------------------------------------------------------------------
//
CStrParser* CStrParser::NewL()
    { 
    CStrParser* self = new ( ELeave ) CStrParser();
    CleanupStack::PushL( self );
    self->ConstructL();
    CleanupStack::Pop( self );
    return self;
    }

// ---------------------------------------------------------------------------
// void ConstructL()
// ---------------------------------------------------------------------------
//
void CStrParser::ConstructL()
    {
    }

// ---------------------------------------------------------------------------
// void Release()
// ---------------------------------------------------------------------------
//
void CStrParser::Release()
    {
    delete this;
    }
    
// ---------------------------------------------------------------------------
// TInt ParseInt( TInt32& aValue, const TDesC8& aStringValue )
// ---------------------------------------------------------------------------
//
TInt CStrParser::ParseInt( TInt32& aResult, const TDesC8& aSourceString )
    {
    return AiUtility::ParseInt( aResult, aSourceString );
    }

// ---------------------------------------------------------------------------
// HBufC16* CopyToBufferL( HBufC16* aTargetBuffer, const TDesC16& aSourceText )
// ---------------------------------------------------------------------------
//    
HBufC16* CStrParser::CopyToBufferL( HBufC16* aTargetBuffer, const TDesC16& aSourceText )
    {
    return AiUtility::CopyToBufferL( aTargetBuffer, aSourceText );
    }

// ---------------------------------------------------------------------------
// HBufC16* CopyToBufferL( HBufC16* aTargetBuffer, const TDesC8& aSourceText )
// ---------------------------------------------------------------------------
//
HBufC16* CStrParser::CopyToBufferL( HBufC16* aTargetBuffer, const TDesC8& aSourceText )
    {
    return AiUtility::CopyToBufferL( aTargetBuffer, aSourceText );
    }

// ---------------------------------------------------------------------------
// HBufC8* CopyToBufferL( HBufC8* aTargetBuffer, const TDesC8& aSourceText )
// ---------------------------------------------------------------------------
//    
HBufC8* CStrParser::CopyToBufferL( HBufC8* aTargetBuffer, const TDesC8& aSourceText )
    {
    return AiUtility::CopyToBufferL( aTargetBuffer, aSourceText );
    }

// ---------------------------------------------------------------------------
// HBufC8* CopyToBufferL( HBufC8* aTargetBuffer, const TDesC16& aSourceText )
// ---------------------------------------------------------------------------
//
HBufC8* CStrParser::CopyToBufferL( HBufC8* aTargetBuffer, const TDesC16& aSourceText )
    {
    return AiUtility::CopyToBufferL( aTargetBuffer, aSourceText );
    }
    
// End of File.


hs_app_contentprioritymap.cpp
/*
* Copyright (c) 2006 Nokia Corporation and/or its subsidiary(-ies).
* All rights reserved.
* This component and the accompanying materials are made available
* under the terms of "Eclipse Public License v1.0"
* which accompanies this distribution, and is available
* at the URL "http://www.eclipse.org/legal/epl-v10.html".
*
* Initial Contributors:
* Nokia Corporation - initial contribution.
*
* Contributors:
*
* Description:  
*
*/


#include "contentprioritymap.h"

using namespace AiUtility;


// ======== MEMBER FUNCTIONS ========

CContentPriorityMap::CContentPriorityMap()
    {
    }

EXPORT_C CContentPriorityMap* CContentPriorityMap::NewL()
    {
    CContentPriorityMap* self = new( ELeave ) CContentPriorityMap;
    return self;
    }

CContentPriorityMap::~CContentPriorityMap()
    {
    iPriorityMap.ResetAndDestroy();
    }


EXPORT_C TInt CContentPriorityMap::CurrentPriority( const TDesC8& aUiElementId ) const
    {
    // Find current priority value for aUiElementId
    const TInt* currentPriority = iPriorityMap.Find( aUiElementId );
    
    // Return current priority value or KErrNotFound if it has not been set
    return currentPriority ? *currentPriority : KErrNotFound;
    }

EXPORT_C TInt CContentPriorityMap::SetCurrentPriority( const TDesC8& aUiElementId,
                                                       TInt aPriority )
    {
    TInt error = KErrNone;
    TInt* currentPriority = iPriorityMap.Find( aUiElementId );
    
    if ( currentPriority )
        {
        // Update old value
        *currentPriority = aPriority;
        }
    else
        {
        // Insert new  pair
        TRAP( error,
            {
            HBufC8* key = aUiElementId.AllocLC();
            TInt* value = new( ELeave ) TInt( aPriority );
            CleanupStack::PushL( value );
            iPriorityMap.InsertL( key, value );
            CleanupStack::Pop( 2, key );
            } );
        }
    
    return error;
    }

EXPORT_C void CContentPriorityMap::ClearPriority( const TDesC8& aUiElementId )
    {
    TInt* currentPriority = iPriorityMap.Find( aUiElementId );
    
    if ( currentPriority )
        {
        // Clear old value. Use KErrNotFound to avoid future reallocations of
        // the same key.
        *currentPriority = KErrNotFound;
        }
    }

EXPORT_C void CContentPriorityMap::Reset()
    {
    iPriorityMap.ResetAndDestroy();
    }

EXPORT_C TBool CContentPriorityMap::OverrideContent( const TDesC8& aUiElementId,
                                                     TInt aNewPriority ) const
    {
    return ( aNewPriority >= CurrentPriority( aUiElementId ) );
    }
